id: Kong/deck-1841
repo: Kong/deck
base_commit: 7a17e1877c6f2acd639e25049d60c891606e11a4
merge_commit: 04f90cb662ecb540f1014fda9a2e05ba07e9607e
language: go
difficulty_score: 2
created_at: 2026-02-17T17:23:02.779164297Z
patch: "diff --git a/cmd/common.go b/cmd/common.go\nindex 2ce8a3528..6f4f9d342 100644\n--- a/cmd/common.go\n+++ b/cmd/common.go\n@@ -146,9 +146,12 @@ func syncMain(ctx context.Context, filenames []string, dry bool, parallelism,\n \t\tjsonOutput.Errors = []string{}\n \t\tjsonOutput.Warnings = []string{}\n \t\tjsonOutput.Changes = diff.EntityChanges{\n-\t\t\tCreating: []diff.EntityState{},\n-\t\t\tUpdating: []diff.EntityState{},\n-\t\t\tDeleting: []diff.EntityState{},\n+\t\t\tCreating:         []diff.EntityState{},\n+\t\t\tUpdating:         []diff.EntityState{},\n+\t\t\tDeleting:         []diff.EntityState{},\n+\t\t\tDroppedCreations: []diff.EntityState{},\n+\t\t\tDroppedUpdates:   []diff.EntityState{},\n+\t\t\tDroppedDeletions: []diff.EntityState{},\n \t\t}\n \t}\n \ttargetContent, err := file.GetContentFromFiles(filenames, false)\n@@ -706,20 +709,18 @@ func performDiff(ctx context.Context, currentState, targetState *state.KongState\n \t}\n \n \tstats, errs, changes := s.Solve(ctx, parallelism, dry, enableJSONOutput)\n+\ttotalOps := stats.CreateOps.Count() + stats.UpdateOps.Count() + stats.DeleteOps.Count()\n \t// print stats before error to report completed operations\n \tif !enableJSONOutput {\n \t\tprintStats(stats)\n-\t}\n-\tif errs != nil {\n-\t\treturn 0, reconcilerUtils.ErrArray{Errors: errs}\n-\t}\n-\ttotalOps := stats.CreateOps.Count() + stats.UpdateOps.Count() + stats.DeleteOps.Count()\n-\n-\tif enableJSONOutput {\n+\t} else {\n \t\tjsonOutput.Changes = diff.EntityChanges{\n-\t\t\tCreating: append(jsonOutput.Changes.Creating, changes.Creating...),\n-\t\t\tUpdating: append(jsonOutput.Changes.Updating, changes.Updating...),\n-\t\t\tDeleting: append(jsonOutput.Changes.Deleting, changes.Deleting...),\n+\t\t\tCreating:         append(jsonOutput.Changes.Creating, changes.Creating...),\n+\t\t\tUpdating:         append(jsonOutput.Changes.Updating, changes.Updating...),\n+\t\t\tDeleting:         append(jsonOutput.Changes.Deleting, changes.Deleting...),\n+\t\t\tDroppedCreations: append(jsonOutput.Changes.DroppedCreations, changes.DroppedCreations...),\n+\t\t\tDroppedUpdates:   append(jsonOutput.Changes.DroppedUpdates, changes.DroppedUpdates...),\n+\t\t\tDroppedDeletions: append(jsonOutput.Changes.DroppedDeletions, changes.DroppedDeletions...),\n \t\t}\n \t\tjsonOutput.Summary = diff.Summary{\n \t\t\tCreating: stats.CreateOps.Count(),\n@@ -728,6 +729,10 @@ func performDiff(ctx context.Context, currentState, targetState *state.KongState\n \t\t\tTotal:    totalOps,\n \t\t}\n \t}\n+\tif errs != nil {\n+\t\treturn 0, reconcilerUtils.ErrArray{Errors: errs}\n+\t}\n+\n \treturn int(totalOps), nil\n }\n \ndiff --git a/cmd/common_test.go b/cmd/common_test.go\nindex 8ca32f25c..2e1f5461d 100644\n--- a/cmd/common_test.go\n+++ b/cmd/common_test.go\n@@ -1,11 +1,17 @@\n package cmd\n \n import (\n+\t\"context\"\n \t\"reflect\"\n \t\"testing\"\n \n+\t\"github.com/kong/go-database-reconciler/pkg/diff\"\n \t\"github.com/kong/go-database-reconciler/pkg/dump\"\n \t\"github.com/kong/go-database-reconciler/pkg/file\"\n+\t\"github.com/kong/go-database-reconciler/pkg/state\"\n+\t\"github.com/kong/go-kong/kong\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func TestDetermineSelectorTag(t *testing.T) {\n@@ -96,3 +102,64 @@ func TestDetermineSelectorTag(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestPerformDiff_JSONOutput(t *testing.T) {\n+\t// Reset global jsonOutput to a known state\n+\tjsonOutput = diff.JSONOutputObject{}\n+\t// This is initialized in syncMain() in the actual application,\n+\t// but we need to set it up here for testing\n+\tjsonOutput.Changes = diff.EntityChanges{\n+\t\tCreating:         []diff.EntityState{},\n+\t\tUpdating:         []diff.EntityState{},\n+\t\tDeleting:         []diff.EntityState{},\n+\t\tDroppedCreations: []diff.EntityState{},\n+\t\tDroppedUpdates:   []diff.EntityState{},\n+\t\tDroppedDeletions: []diff.EntityState{},\n+\t}\n+\n+\tcurrentState, err := state.NewKongState()\n+\trequire.NoError(t, err)\n+\n+\t// mock target state\n+\ttargetState, err := state.NewKongState()\n+\trequire.NoError(t, err)\n+\tservice := state.Service{\n+\t\tService: kong.Service{\n+\t\t\tID:   kong.String(\"service-1\"),\n+\t\t\tName: kong.String(\"Service 1\"),\n+\t\t},\n+\t}\n+\terr = targetState.Services.Add(service)\n+\trequire.NoError(t, err)\n+\n+\t// Calling performDiff with dry=true to avoid actual API calls\n+\ttotalOps, err := performDiff(\n+\t\tcontext.Background(),\n+\t\tcurrentState,\n+\t\ttargetState,\n+\t\ttrue,  // dry mode\n+\t\t1,     // parallelism\n+\t\t0,     // delay\n+\t\tnil,   // client (not used in dry mode)\n+\t\tfalse, // isKonnect\n+\t\ttrue,  // enabled Json output\n+\t\tApplyTypeFull,\n+\t)\n+\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, totalOps)\n+\n+\t// Verify jsonOutput is populated correctly\n+\tassert.Equal(t, int32(1), jsonOutput.Summary.Creating)\n+\tassert.Equal(t, int32(0), jsonOutput.Summary.Updating)\n+\tassert.Equal(t, int32(0), jsonOutput.Summary.Deleting)\n+\tassert.Equal(t, int32(1), jsonOutput.Summary.Total)\n+\n+\t// Verify changes are populated\n+\tassert.Len(t, jsonOutput.Changes.Creating, 1)\n+\tassert.Empty(t, jsonOutput.Changes.Updating)\n+\tassert.Empty(t, jsonOutput.Changes.Deleting)\n+\tassert.Empty(t, jsonOutput.Changes.DroppedCreations)\n+\tassert.Empty(t, jsonOutput.Changes.DroppedUpdates)\n+\tassert.Empty(t, jsonOutput.Changes.DroppedDeletions)\n+}\n"
test_patch: ''
fail_to_pass:
- cd /repo && GOTOOLCHAIN=go1.25.6 go test -v ./cmd -run "TestJSONOutput_DroppedOperationsInitialization"
- cd /repo && GOTOOLCHAIN=go1.25.6 go test -v ./cmd -run "TestJSONOutput_EntityChangesWithDroppedOperations"
- cd /repo && GOTOOLCHAIN=go1.25.6 go test -v ./cmd -run "TestJSONOutput_AppendDroppedOperations"
- cd /repo && GOTOOLCHAIN=go1.25.6 go test -v ./cmd -run "TestJSONOutput_JSONMarshalingWithDroppedOperations"
pass_to_pass:
- cd /repo && GOTOOLCHAIN=go1.25.6 go test -v ./cmd -run "TestDetermineSelectorTag"
- cd /repo && GOTOOLCHAIN=go1.25.6 go build ./...
install_config:
  go: '1.22'
  install: go mod download
  test_cmd: go test ./...
meta:
  added_lines: '85'
  difficulty: medium
  files_changed: '2'
  pr_title: 'fix: json summary output and dropped events addition'
  removed_lines: '13'
  source: gh-archive-pr
  test_files: '[{"path":"cmd/json_output_test.go","content":"package cmd\n\nimport (\n\t\"testing\"\n\n\t\"github.com/kong/go-database-reconciler/pkg/diff\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestJSONOutput_DroppedOperationsInitialization(t *testing.T) {\n\t// Reset jsonOutput to simulate syncMain behavior\n\tjsonOutput = diff.JSONOutputObject{}\n\n\t// Initialize the Changes struct as syncMain would with the fix\n\tjsonOutput.Changes = diff.EntityChanges{\n\t\tCreating:         []diff.EntityState{},\n\t\tUpdating:         []diff.EntityState{},\n\t\tDeleting:         []diff.EntityState{},\n\t\tDroppedCreations: []diff.EntityState{},\n\t\tDroppedUpdates:   []diff.EntityState{},\n\t\tDroppedDeletions: []diff.EntityState{},\n\t}\n\n\t// Verify that all fields including dropped operations are properly initialized\n\tassert.NotNil(t, jsonOutput.Changes.Creating, \"Creating should be initialized\")\n\tassert.NotNil(t, jsonOutput.Changes.Updating, \"Updating should be initialized\")\n\tassert.NotNil(t, jsonOutput.Changes.Deleting, \"Deleting should be initialized\")\n\tassert.NotNil(t, jsonOutput.Changes.DroppedCreations, \"DroppedCreations should be initialized\")\n\tassert.NotNil(t, jsonOutput.Changes.DroppedUpdates, \"DroppedUpdates should be initialized\")\n\tassert.NotNil(t, jsonOutput.Changes.DroppedDeletions, \"DroppedDeletions should be initialized\")\n\n\t// Verify all slices are empty (not nil)\n\tassert.Empty(t, jsonOutput.Changes.Creating, \"Creating should be an empty slice\")\n\tassert.Empty(t, jsonOutput.Changes.Updating, \"Updating should be an empty slice\")\n\tassert.Empty(t, jsonOutput.Changes.Deleting, \"Deleting should be an empty slice\")\n\tassert.Empty(t, jsonOutput.Changes.DroppedCreations, \"DroppedCreations should be an empty slice\")\n\tassert.Empty(t, jsonOutput.Changes.DroppedUpdates, \"DroppedUpdates should be an empty slice\")\n\tassert.Empty(t, jsonOutput.Changes.DroppedDeletions, \"DroppedDeletions should be an empty slice\")\n}\n\nfunc TestJSONOutput_EntityChangesWithDroppedOperations(t *testing.T) {\n\t// Create EntityChanges with dropped operations\n\tchanges := diff.EntityChanges{\n\t\tCreating: []diff.EntityState{\n\t\t\t{Name: \"service-1\", Kind: \"service\"},\n\t\t},\n\t\tUpdating: []diff.EntityState{\n\t\t\t{Name: \"route-1\", Kind: \"route\"},\n\t\t},\n\t\tDeleting:         []diff.EntityState{},\n\t\tDroppedCreations: []diff.EntityState{\n\t\t\t{Name: \"failed-service\", Kind: \"service\"},\n\t\t},\n\t\tDroppedUpdates: []diff.EntityState{\n\t\t\t{Name: \"failed-route\", Kind: \"route\"},\n\t\t},\n\t\tDroppedDeletions: []diff.EntityState{},\n\t}\n\n\t// Verify all fields are accessible and have correct values\n\tassert.Len(t, changes.Creating, 1, \"Should have 1 creating operation\")\n\tassert.Len(t, changes.Updating, 1, \"Should have 1 updating operation\")\n\tassert.Len(t, changes.Deleting, 0, \"Should have 0 deleting operations\")\n\tassert.Len(t, changes.DroppedCreations, 1, \"Should have 1 dropped creation\")\n\tassert.Len(t, changes.DroppedUpdates, 1, \"Should have 1 dropped update\")\n\tassert.Len(t, changes.DroppedDeletions, 0, \"Should have 0 dropped deletions\")\n\n\t// Verify individual items\n\tassert.Equal(t, \"service-1\", changes.Creating[0].Name)\n\tassert.Equal(t, \"failed-service\", changes.DroppedCreations[0].Name)\n\tassert.Equal(t, \"failed-route\", changes.DroppedUpdates[0].Name)\n}\n\nfunc TestJSONOutput_SummaryWithOperations(t *testing.T) {\n\t// Create a summary as would be done in performDiff\n\tsummary := diff.Summary{\n\t\tCreating: 5,\n\t\tUpdating: 3,\n\t\tDeleting: 2,\n\t\tTotal:    10,\n\t}\n\n\t// Verify summary values\n\tassert.Equal(t, int32(5), summary.Creating, \"Creating count should be 5\")\n\tassert.Equal(t, int32(3), summary.Updating, \"Updating count should be 3\")\n\tassert.Equal(t, int32(2), summary.Deleting, \"Deleting count should be 2\")\n\tassert.Equal(t, int32(10), summary.Total, \"Total count should be 10\")\n}\n\nfunc TestJSONOutput_TotalOpsCalculation(t *testing.T) {\n\t// Simulate the stats that would be returned from Solve()\n\t// Test the totalOps calculation: totalOps = CreateOps + UpdateOps + DeleteOps\n\tcreateOps := int32(7)\n\tupdateOps := int32(4)\n\tdeleteOps := int32(2)\n\n\ttotalOps := createOps + updateOps + deleteOps\n\n\tassert.Equal(t, int32(13), totalOps, \"Total operations should be sum of create, update, and delete\")\n\n\t// Verify calculation order - totalOps should be calculated before error check\n\t// This ensures JSON output shows correct counts even when errors occur\n\tsummary := diff.Summary{\n\t\tCreating: createOps,\n\t\tUpdating: updateOps,\n\t\tDeleting: deleteOps,\n\t\tTotal:    totalOps,\n\t}\n\n\tassert.Equal(t, createOps, summary.Creating)\n\tassert.Equal(t, updateOps, summary.Updating)\n\tassert.Equal(t, deleteOps, summary.Deleting)\n\tassert.Equal(t, totalOps, summary.Total)\n}\n\nfunc TestJSONOutput_AppendDroppedOperations(t *testing.T) {\n\t// Reset and initialize jsonOutput\n\tjsonOutput = diff.JSONOutputObject{\n\t\tChanges: diff.EntityChanges{\n\t\t\tCreating:         []diff.EntityState{},\n\t\t\tUpdating:         []diff.EntityState{},\n\t\t\tDeleting:         []diff.EntityState{},\n\t\t\tDroppedCreations: []diff.EntityState{},\n\t\t\tDroppedUpdates:   []diff.EntityState{},\n\t\t\tDroppedDeletions: []diff.EntityState{},\n\t\t},\n\t}\n\n\t// Simulate changes from Solve()\n\tnewChanges := diff.EntityChanges{\n\t\tCreating: []diff.EntityState{\n\t\t\t{Name: \"new-service\", Kind: \"service\"},\n\t\t},\n\t\tDroppedCreations: []diff.EntityState{\n\t\t\t{Name: \"dropped-service\", Kind: \"service\"},\n\t\t},\n\t}\n\n\t// Append changes as performDiff would do\n\tjsonOutput.Changes = diff.EntityChanges{\n\t\tCreating:         append(jsonOutput.Changes.Creating, newChanges.Creating...),\n\t\tUpdating:         append(jsonOutput.Changes.Updating, newChanges.Updating...),\n\t\tDeleting:         append(jsonOutput.Changes.Deleting, newChanges.Deleting...),\n\t\tDroppedCreations: append(jsonOutput.Changes.DroppedCreations, newChanges.DroppedCreations...),\n\t\tDroppedUpdates:   append(jsonOutput.Changes.DroppedUpdates, newChanges.DroppedUpdates...),\n\t\tDroppedDeletions: append(jsonOutput.Changes.DroppedDeletions, newChanges.DroppedDeletions...),\n\t}\n\n\t// Verify appending works correctly\n\tassert.Len(t, jsonOutput.Changes.Creating, 1, \"Should have 1 creating operation\")\n\tassert.Len(t, jsonOutput.Changes.DroppedCreations, 1, \"Should have 1 dropped creation\")\n\tassert.Equal(t, \"new-service\", jsonOutput.Changes.Creating[0].Name)\n\tassert.Equal(t, \"dropped-service\", jsonOutput.Changes.DroppedCreations[0].Name)\n}\n\nfunc TestJSONOutput_JSONMarshalingWithDroppedOperations(t *testing.T) {\n\t// Test that EntityChanges with dropped operations can be marshaled to JSON correctly\n\tchanges := diff.EntityChanges{\n\t\tCreating: []diff.EntityState{\n\t\t\t{Name: \"created-service\", Kind: \"service\"},\n\t\t},\n\t\tUpdating: []diff.EntityState{\n\t\t\t{Name: \"updated-route\", Kind: \"route\"},\n\t\t},\n\t\tDeleting: []diff.EntityState{},\n\t\tDroppedCreations: []diff.EntityState{\n\t\t\t{Name: \"dropped-create\", Kind: \"service\"},\n\t\t},\n\t\tDroppedUpdates: []diff.EntityState{\n\t\t\t{Name: \"dropped-update\", Kind: \"plugin\"},\n\t\t},\n\t\tDroppedDeletions: []diff.EntityState{\n\t\t\t{Name: \"dropped-delete\", Kind: \"consumer\"},\n\t\t},\n\t}\n\n\t// Create JSONOutputObject\n\toutput := diff.JSONOutputObject{\n\t\tChanges: changes,\n\t\tSummary: diff.Summary{\n\t\t\tCreating: 1,\n\t\t\tUpdating: 1,\n\t\t\tDeleting: 0,\n\t\t\tTotal:    2,\n\t\t},\n\t\tWarnings: []string{\"test warning\"},\n\t\tErrors:   []string{},\n\t}\n\n\t// Verify the structure is correctly formed\n\tassert.Equal(t, int32(1), output.Summary.Creating)\n\tassert.Equal(t, int32(1), output.Summary.Updating)\n\tassert.Equal(t, int32(2), output.Summary.Total)\n\tassert.Len(t, output.Changes.Creating, 1)\n\tassert.Len(t, output.Changes.DroppedCreations, 1)\n\tassert.Len(t, output.Changes.DroppedUpdates, 1)\n\tassert.Len(t, output.Changes.DroppedDeletions, 1)\n\tassert.Len(t, output.Warnings, 1)\n}\n\nfunc TestJSONOutput_EmptyDroppedOperationsOmitted(t *testing.T) {\n\t// Test that empty dropped operation slices are handled correctly\n\t// (They should be empty slices, not nil, when explicitly initialized)\n\tchanges := diff.EntityChanges{\n\t\tCreating:         []diff.EntityState{},\n\t\tUpdating:         []diff.EntityState{},\n\t\tDeleting:         []diff.EntityState{},\n\t\tDroppedCreations: []diff.EntityState{},\n\t\tDroppedUpdates:   []diff.EntityState{},\n\t\tDroppedDeletions: []diff.EntityState{},\n\t}\n\n\t// All should be empty but initialized\n\tassert.NotNil(t, changes.Creating)\n\tassert.NotNil(t, changes.Updating)\n\tassert.NotNil(t, changes.Deleting)\n\tassert.NotNil(t, changes.DroppedCreations)\n\tassert.NotNil(t, changes.DroppedUpdates)\n\tassert.NotNil(t, changes.DroppedDeletions)\n\n\tassert.Empty(t, changes.Creating)\n\tassert.Empty(t, changes.Updating)\n\tassert.Empty(t, changes.Deleting)\n\tassert.Empty(t, changes.DroppedCreations)\n\tassert.Empty(t, changes.DroppedUpdates)\n\tassert.Empty(t, changes.DroppedDeletions)\n}\n\nfunc TestJSONOutput_MultipleDroppedOperations(t *testing.T) {\n\t// Test with multiple dropped operations of different types\n\tchanges := diff.EntityChanges{\n\t\tCreating: []diff.EntityState{\n\t\t\t{Name: \"svc1\", Kind: \"service\"},\n\t\t\t{Name: \"svc2\", Kind: \"service\"},\n\t\t},\n\t\tDroppedCreations: []diff.EntityState{\n\t\t\t{Name: \"failed-svc1\", Kind: \"service\"},\n\t\t\t{Name: \"failed-svc2\", Kind: \"service\"},\n\t\t\t{Name: \"failed-svc3\", Kind: \"service\"},\n\t\t},\n\t\tDroppedUpdates: []diff.EntityState{\n\t\t\t{Name: \"failed-route1\", Kind: \"route\"},\n\t\t\t{Name: \"failed-route2\", Kind: \"route\"},\n\t\t},\n\t\tDroppedDeletions: []diff.EntityState{\n\t\t\t{Name: \"failed-consumer\", Kind: \"consumer\"},\n\t\t},\n\t}\n\n\t// Verify counts\n\tassert.Len(t, changes.Creating, 2, \"Should have 2 successful creations\")\n\tassert.Len(t, changes.DroppedCreations, 3, \"Should have 3 dropped creations\")\n\tassert.Len(t, changes.DroppedUpdates, 2, \"Should have 2 dropped updates\")\n\tassert.Len(t, changes.DroppedDeletions, 1, \"Should have 1 dropped deletion\")\n\n\t// Verify specific items\n\tassert.Equal(t, \"svc1\", changes.Creating[0].Name)\n\tassert.Equal(t, \"failed-svc2\", changes.DroppedCreations[1].Name)\n\tassert.Equal(t, \"route\", changes.DroppedUpdates[0].Kind)\n\tassert.Equal(t, \"consumer\", changes.DroppedDeletions[0].Kind)\n}\n"}]'
  test_generation: agentic-docker
prompt: |-
  Fix the JSON summary output to accurately reflect operations performed on the gateway when upstream errors occur. Currently, the JSON summary incorrectly shows zero operations for all fields when an error happens, hiding what was actually done.

  Ensure JSON output displays operation counts consistently with YAML output behavior, correctly showing created, updated, and deleted counts even in error scenarios.

  Add support for dropped operations in the summary output, displaying when operations are dropped due to errors or other conditions.

  Include unit tests for JSON output formatting and summary generation.
original_pr_body: "Kong/deck (#1841): fix: json summary output and dropped events addition\n\nDue to the way we were handling json output earlier, it showed false summary output if an\r\nupstream error occurred. The user didn't see what operations were performed on the gateway\r\nas the summary showed 0 for all ops.\r\nThis is fixed in this PR. Now, json output is similar to yaml output in terms of summary printing.\r\n\r\nFurther, we have added the new fields added in GDR for dropped operations.\r\nhttps://github.com/Kong/go-database-reconciler/pull/362\r\n\r\nAdded a unit test for json output. At the moment, we can't simulate error in\r\nperformDiff that can fill Dropped operations. \r\nOne way was to set a negative parallelism to trigger this [error](https://github.com/Kong/go-database-reconciler/blob/main/pkg/diff/diff.go#L463).\r\nHowever, there's a bug in go-database-reconciler where Run() returns early on\r\nparallelism < 1 without closing channels, causing Solve() to hang when\r\nit tries to range over sc.eventChan.\r\nCaptured the bug here: https://github.com/Kong/go-database-reconciler/issues/375\r\nNot prioritising this or the error test yet as this is not a burning issue.\r\n\r\nFor https://github.com/Kong/deck/issues/1854"
quality_score: 0.55
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
