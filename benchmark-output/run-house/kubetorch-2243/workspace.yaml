id: run-house/kubetorch-2243
repo: run-house/kubetorch
base_commit: 2b3ff017aec0e573dbb82c8695f0e7cd6668b5bf
merge_commit: 2e14986a5f4a3f46b15aba2b82b39d8dcd380b1a
language: python
difficulty_score: 2
created_at: 2026-02-17T18:05:59.532334034Z
patch: "diff --git a/python_client/kubetorch/resources/callables/cls/cls.py b/python_client/kubetorch/resources/callables/cls/cls.py\nindex cb0e8c0f5..a6ee83d90 100644\n--- a/python_client/kubetorch/resources/callables/cls/cls.py\n+++ b/python_client/kubetorch/resources/callables/cls/cls.py\n@@ -17,6 +17,8 @@ def __init__(\n         pointers: tuple = None,\n         init_args: dict = None,\n         sync_dir: Union[str, Path, bool] = None,\n+        remote_dir: Union[str, Path] = None,\n+        remote_import_path: str = None,\n     ):\n         \"\"\"\n         Initialize a Cls object for remote class execution.\n@@ -31,14 +33,23 @@ def __init__(\n                 the information needed to locate and import the class.\n             init_args (dict, optional): Dictionary of arguments to pass to the class constructor.\n                 Defaults to None.\n-            sync_dir (str, Path, or bool): Controls which module directory to sync to compute.\n+            sync_dir (str, Path, or bool, optional): Controls which local class directory to sync to compute.\n+            remote_dir (str or Path, optional): Path on container where class already exists. Can not be used with sync_dir.\n+            remote_import_path (str, optional): Override the computed import path for the class.\n+                Only used when remote_dir is specified.\n         \"\"\"\n         self._init_args = init_args\n         if not pointers:\n             # local to the class definition\n             pointers = extract_pointers(self.__class__)\n \n-        super().__init__(name=name, pointers=pointers, sync_dir=sync_dir)\n+        super().__init__(\n+            name=name,\n+            pointers=pointers,\n+            sync_dir=sync_dir,\n+            remote_dir=remote_dir,\n+            remote_import_path=remote_import_path,\n+        )\n \n     def __getattr__(self, attr_name) -> Any:\n         if attr_name in SHELL_COMMANDS:\n@@ -139,6 +150,8 @@ def cls(\n     get_if_exists=True,\n     reload_prefixes=None,\n     sync_dir: Union[str, Path, bool] = None,\n+    remote_dir: Union[str, Path] = None,\n+    remote_import_path: str = None,\n ) -> Cls:\n     \"\"\"\n     Builds an instance of :class:`Cls`.\n@@ -160,10 +173,14 @@ def cls(\n         reload_prefixes (Union[str, List[str]], optional):\n             A list of prefixes to use when reloading the class (e.g., [\"qa\", \"prod\", \"git-branch-name\"]).\n             If not provided, will use the current username, git branch, and prod.\n-        sync_dir (str, Path, bool, or None): Controls which directory to sync to compute.\n+        sync_dir (str, Path, or bool, optional): Controls which directory to sync to compute.\n             If None (default), auto-detect and sync package directory.\n-            If False, skip syncing files (this assumes files are already on compute).\n-            If str/Path, sync the specified directory. Must contain the module.\n+            If False, skip syncing files (assumes files are already on compute).\n+            If str/Path, sync the specified directory. Must contain the class.\n+        remote_dir (str or Path, optional): Path on container where class already exists.\n+            When specified, class files are not synced. This path is added to the remote sys.path.\n+        remote_import_path (str, optional): Override the computed import path for the class.\n+            Only used when remote_dir is specified.\n \n     Example:\n \n@@ -181,6 +198,8 @@ def cls(\n             name=name,\n             pointers=cls_pointers,\n             sync_dir=sync_dir,\n+            remote_dir=remote_dir,\n+            remote_import_path=remote_import_path,\n         )\n         new_cls.get_if_exists = get_if_exists\n         new_cls.reload_prefixes = reload_prefixes or []\ndiff --git a/python_client/kubetorch/resources/callables/fn/fn.py b/python_client/kubetorch/resources/callables/fn/fn.py\nindex 790a2fb48..e7a8a6519 100644\n--- a/python_client/kubetorch/resources/callables/fn/fn.py\n+++ b/python_client/kubetorch/resources/callables/fn/fn.py\n@@ -16,6 +16,8 @@ def __init__(\n         name: str,\n         pointers: tuple = None,\n         sync_dir: Union[str, Path, bool] = None,\n+        remote_dir: Union[str, Path] = None,\n+        remote_import_path: str = None,\n     ):\n         \"\"\"\n         Initialize a Fn object for remote function execution.\n@@ -28,9 +30,18 @@ def __init__(\n             name (str): The name of the function to be executed remotely.\n             pointers (tuple): A tuple of (root_path, import_path, callable_name) containing\n                 the information needed to locate and import the function.\n-            sync_dir (str, Path, or bool): Controls which module directory to sync to compute.\n+            sync_dir (str, Path, or bool): Controls which local function directory to sync to compute.\n+            remote_dir (str or Path): Path on container where function already exists. Can not be used with sync_dir.\n+            remote_import_path (str, optional): Override the computed import path for the function.\n+                Only used when remote_dir is specified.\n         \"\"\"\n-        super().__init__(name=name, pointers=pointers, sync_dir=sync_dir)\n+        super().__init__(\n+            name=name,\n+            pointers=pointers,\n+            sync_dir=sync_dir,\n+            remote_dir=remote_dir,\n+            remote_import_path=remote_import_path,\n+        )\n \n     def __call__(self, *args, **kwargs):\n         async_ = kwargs.pop(\"async_\", self.async_)\n@@ -114,6 +125,8 @@ def fn(\n     get_if_exists=True,\n     reload_prefixes=None,\n     sync_dir: Union[str, Path, bool] = None,\n+    remote_dir: Union[str, Path] = None,\n+    remote_import_path: str = None,\n ) -> Fn:\n     \"\"\"\n     Builds an instance of :class:`Fn`.\n@@ -135,10 +148,14 @@ def fn(\n         reload_prefixes (Union[str, List[str]], optional):\n             A list of prefixes to use when reloading the function (e.g., [\"qa\", \"prod\", \"git-branch-name\"]).\n             If not provided, will use the current username, git branch, and prod.\n-        sync_dir (str, Path, or bool): Controls which directory to sync to compute.\n+        sync_dir (str, Path, or bool, optional): Controls which directory to sync to compute.\n             If None (default), auto-detect and sync package directory.\n-            If False, skip syncing files (this assumes files are already on compute).\n-            If str/Path, sync the specified directory. Must contain the module.\n+            If False, skip syncing files (assumes files are already on compute).\n+            If str/Path, sync the specified directory. Must contain the function.\n+        remote_dir (str or Path, optional): Path on container where function already exists.\n+            When specified, files are not synced. This path is added to the remote sys.path.\n+        remote_import_path (str, optional): Override the computed import path for the function.\n+            Only used when remote_dir is specified.\n \n     Example:\n \n@@ -159,6 +176,8 @@ def fn(\n             name=name,\n             pointers=fn_pointers,\n             sync_dir=sync_dir,\n+            remote_dir=remote_dir,\n+            remote_import_path=remote_import_path,\n         )\n         new_fn.get_if_exists = get_if_exists\n         new_fn.reload_prefixes = reload_prefixes or []\ndiff --git a/python_client/kubetorch/resources/callables/module.py b/python_client/kubetorch/resources/callables/module.py\nindex 4ff299e7d..beccf6e1e 100644\n--- a/python_client/kubetorch/resources/callables/module.py\n+++ b/python_client/kubetorch/resources/callables/module.py\n@@ -45,6 +45,8 @@ def __init__(\n         name: str,\n         pointers: tuple,\n         sync_dir: Union[str, Path, bool] = None,\n+        remote_dir: Union[str, Path] = None,\n+        remote_import_path: str = None,\n     ):\n         \"\"\"\n         Initialize a Module object.\n@@ -57,10 +59,16 @@ def __init__(\n                     This is where the module can be imported from (added to sys.path).\n                 - import_path: The dotted Python import path (e.g., \"mypackage.mymodule\").\n                 - callable_name: The name of the class or function within the module.\n-            sync_dir (str, Path, or bool): Controls which module directory to sync to compute:\n-                If None (default), auto-detect and sync package directory.\n-                If False, skip syncing files (this assumes files are already on compute).\n+            sync_dir (str, Path, or bool, optional): Controls which module directory to sync\n+                to compute: If None (default), auto-detect and sync package directory.\n+                If False, skip syncing files (assumes files are already on compute).\n                 If str/Path, sync the specified directory. Must contain the module.\n+            remote_dir (str or Path, optional): Path on the container where the module exists.\n+                When specified, files are not synced (assumes files are already on compute,\n+                e.g., via image.copy()). This path is added to the remote sys.path for imports,\n+                and can not be used with sync_dir.\n+            remote_import_path (str, optional): Override the computed import path for the module.\n+                Only used when remote_dir is specified.\n         \"\"\"\n         self._compute = None\n         self._service_config = None\n@@ -79,10 +87,26 @@ def __init__(\n \n         self.name = clean_and_validate_k8s_name(name, allow_full_length=False) if name else None\n \n+        if sync_dir and remote_dir:\n+            raise ValueError(\n+                \"sync_dir and remote_dir can not both be set. \"\n+                \"Use sync_dir to sync a local directory, or remote_dir to specify \"\n+                \"where files already exist on the container.\"\n+            )\n+        if remote_import_path and not remote_dir:\n+            raise ValueError(\n+                \"remote_import_path can only be set when remote_dir is also set. \"\n+                \"Use remote_dir to specify where files already exist on the container, \"\n+                \"and remote_import_path to override the computed import path.\"\n+            )\n+\n         if sync_dir:\n             self._validate_module_in_sync_dir(sync_dir)\n         self.sync_dir = sync_dir\n \n+        self._remote_root_path = str(remote_dir) if remote_dir else None\n+        self._remote_import_path = remote_import_path\n+\n     @property\n     def callable_name(self):\n         return self._callable_name\n@@ -146,8 +170,7 @@ def remote_root_path(self):\n             return self._remote_root_path\n \n         if self.sync_dir is False:\n-            # Files already on compute, user is responsible for PYTHONPATH\n-            self._remote_root_path = None\n+            # Files already on compute and no remote_dir specified, user responsible for PYTHONPATH imports\n             self._container_project_root = None\n             return self._remote_root_path\n \n@@ -205,23 +228,28 @@ def _validate_module_in_sync_dir(self, sync_dir: str):\n \n     @property\n     def remote_import_path(self):\n-        \"\"\"Returns the import_path adjusted for the container based on sync_dir.\"\"\"\n+        \"\"\"Returns the import_path adjusted for the container based on sync_dir or import_path override.\"\"\"\n+        if self._remote_import_path is not None:\n+            return self._remote_import_path\n+\n         if self.sync_dir is False or self.sync_dir is None:\n-            return self._import_path\n+            self._remote_import_path = self._import_path\n+        else:\n+            root_path = Path(self._root_path).expanduser().resolve()\n+            sync_dir = Path(self.sync_dir).expanduser().resolve()\n \n-        root_path = Path(self._root_path).expanduser().resolve()\n-        sync_dir = Path(self.sync_dir).expanduser().resolve()\n+            try:\n+                # sync_dir is parent/equal to _root_path: import path unchanged\n+                root_path.relative_to(sync_dir)\n+                self._remote_import_path = self._import_path\n+            except ValueError:\n+                # sync_dir is child of _root_path: compute adjusted import path relative to sync_dir\n+                module_file = root_path / (self._import_path.replace(\".\", \"/\") + \".py\")\n+                relative_module_file = module_file.relative_to(sync_dir)\n+                parts = list(relative_module_file.with_suffix(\"\").parts)\n+                self._remote_import_path = \".\".join(parts)\n \n-        try:\n-            # sync_dir is parent/equal to _root_path: import path unchanged\n-            root_path.relative_to(sync_dir)\n-            return self._import_path\n-        except ValueError:\n-            # sync_dir is child of _root_path: compute adjusted import path relative to sync_dir\n-            module_file = root_path / (self._import_path.replace(\".\", \"/\") + \".py\")\n-            relative_module_file = module_file.relative_to(sync_dir)\n-            parts = list(relative_module_file.with_suffix(\"\").parts)\n-            return \".\".join(parts)\n+        return self._remote_import_path\n \n     @property\n     def container_project_root(self):\ndiff --git a/python_client/tests/test_imperative.py b/python_client/tests/test_imperative.py\nindex 6a102f2f2..6fbfd2a18 100644\n--- a/python_client/tests/test_imperative.py\n+++ b/python_client/tests/test_imperative.py\n@@ -1059,16 +1059,28 @@ def test_sync_dir_parent():\n \n @pytest.mark.level(\"minimal\")\n def test_sync_dir_false():\n+    \"\"\"Test sync_dir=False with remote_dir and import_path to specify where files exist on container.\"\"\"\n     import kubetorch as kt\n     from kubetorch.resources.callables.utils import extract_pointers\n \n     from .utils import summer\n \n-    default_root_path = extract_pointers(summer)[0]\n-\n-    # Set KT_PROJECT_ROOT to the name of the package directory for import to work.\n-    # This is a workaround because of how summer is being imported in the test function,\n-    # Generally the user is responsible for having set up PYTHONPATH on the computeto include the right directories.\n-    image = kt.Image().copy(default_root_path).set_env_vars({\"KT_PROJECT_ROOT\": Path(default_root_path).name})\n-    remote_fn = kt.fn(summer, name=get_test_fn_name(), sync_dir=False).to(kt.Compute(cpus=\".1\", image=image))\n+    extracted_pointers = extract_pointers(summer)\n+    default_root_path = extracted_pointers[0]\n+    import_path = extracted_pointers[1]\n+\n+    # compute sync_dir, remote_dir, and import_path based on subdirectory of extracted_root_path\n+    subdirectory = \"tests\"\n+    sync_dir = Path(default_root_path) / subdirectory\n+    remote_dir = subdirectory\n+    remote_import_path = \".\".join(import_path.split(\".\")[1:])\n+\n+    image = kt.Image().copy(sync_dir)\n+    remote_fn = kt.fn(\n+        summer,\n+        name=get_test_fn_name(),\n+        sync_dir=False,\n+        remote_dir=remote_dir,\n+        remote_import_path=remote_import_path,\n+    ).to(kt.Compute(cpus=\".1\", image=image))\n     assert remote_fn(4, 5) == 9\n"
test_patch: ''
fail_to_pass:
- cd /repo/python_client && python -c "from tests.test_remote_dir import TestModuleRemoteDir, TestClsRemoteDir, TestFnRemoteDir; t = TestModuleRemoteDir(); t.test_module_accepts_remote_dir_parameter(); print('PASS')"
pass_to_pass:
- cd /repo/python_client && python -c "import kubetorch; print('kubetorch imported successfully')"
install_config:
  install: pip install -e .
  python: '3.11'
  test_cmd: pytest
meta:
  added_lines: '114'
  difficulty: medium
  files_changed: '4'
  pr_title: Add option to specify remote_dir and remote_import_path in module
  removed_lines: '36'
  source: gh-archive-pr
  test_files: '[{"path":"/repo/python_client/tests/test_remote_dir.py","content":"\"\"\"Tests for remote_dir and remote_import_path configuration options in modules.\"\"\"\nimport pytest\nfrom pathlib import Path\n\n\ndef simple_add(a, b):\n    \"\"\"Simple function for testing.\"\"\"\n    return a + b\n\n\nclass SimpleClass:\n    \"\"\"Simple class for testing.\"\"\"\n    \n    def add(self, a, b):\n        return a + b\n\n\nclass TestModuleRemoteDir:\n    \"\"\"Test Module class remote_dir and remote_import_path options.\"\"\"\n    \n    def test_module_accepts_remote_dir_parameter(self):\n        \"\"\"Test that Module.__init__ accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        import inspect\n        \n        sig = inspect.signature(Module.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"Module.__init__ should accept remote_dir parameter\"\n    \n    def test_module_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that Module.__init__ accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        import inspect\n        \n        sig = inspect.signature(Module.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"Module.__init__ should accept remote_import_path parameter\"\n    \n    def test_module_rejects_sync_dir_and_remote_dir_together(self):\n        \"\"\"Test that Module raises ValueError when both sync_dir and remote_dir are specified.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        with pytest.raises(ValueError, match=\"sync_dir and remote_dir can not both be set\"):\n            Module(\n                name=\"test-module\",\n                pointers=pointers,\n                sync_dir=\"/some/local/path\",\n                remote_dir=\"/some/remote/path\"\n            )\n    \n    def test_module_rejects_remote_import_path_without_remote_dir(self):\n        \"\"\"Test that Module raises ValueError when remote_import_path is set without remote_dir.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        with pytest.raises(ValueError, match=\"remote_import_path can only be set when remote_dir is also set\"):\n            Module(\n                name=\"test-module\",\n                pointers=pointers,\n                remote_import_path=\"custom.import.path\"\n            )\n    \n    def test_module_accepts_only_remote_dir(self):\n        \"\"\"Test that Module accepts remote_dir without remote_import_path.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=\"/app/custom/path\"\n        )\n        \n        assert module._remote_root_path == \"/app/custom/path\"\n    \n    def test_module_accepts_remote_dir_and_remote_import_path(self):\n        \"\"\"Test that Module accepts both remote_dir and remote_import_path together.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=\"/app/custom/path\",\n            remote_import_path=\"custom.import.path\"\n        )\n        \n        assert module._remote_root_path == \"/app/custom/path\"\n        assert module._import_path == \"custom.import.path\"\n\n\nclass TestClsRemoteDir:\n    \"\"\"Test Cls class remote_dir and remote_import_path options.\"\"\"\n    \n    def test_cls_accepts_remote_dir_parameter(self):\n        \"\"\"Test that Cls.__init__ accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import Cls\n        import inspect\n        \n        sig = inspect.signature(Cls.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"Cls.__init__ should accept remote_dir parameter\"\n    \n    def test_cls_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that Cls.__init__ accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import Cls\n        import inspect\n        \n        sig = inspect.signature(Cls.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"Cls.__init__ should accept remote_import_path parameter\"\n    \n    def test_cls_factory_accepts_remote_dir_parameter(self):\n        \"\"\"Test that cls() factory function accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import cls as cls_factory\n        import inspect\n        \n        sig = inspect.signature(cls_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"cls() factory should accept remote_dir parameter\"\n    \n    def test_cls_factory_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that cls() factory function accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import cls as cls_factory\n        import inspect\n        \n        sig = inspect.signature(cls_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"cls() factory should accept remote_import_path parameter\"\n    \n    def test_cls_factory_rejects_sync_dir_and_remote_dir_together(self):\n        \"\"\"Test that cls() factory raises error when both sync_dir and remote_dir are specified.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"sync_dir and remote_dir can not both be set\"):\n            kt.cls(SimpleClass, sync_dir=\"/local/path\", remote_dir=\"/remote/path\")\n    \n    def test_cls_factory_rejects_remote_import_path_without_remote_dir(self):\n        \"\"\"Test that cls() factory raises error when remote_import_path is set without remote_dir.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"remote_import_path can only be set when remote_dir is also set\"):\n            kt.cls(SimpleClass, remote_import_path=\"custom.import.path\")\n    \n    def test_cls_factory_accepts_only_remote_dir(self):\n        \"\"\"Test that cls() factory accepts remote_dir without remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_cls = kt.cls(SimpleClass, remote_dir=\"/app/custom/path\")\n        assert remote_cls._remote_root_path == \"/app/custom/path\"\n    \n    def test_cls_factory_accepts_remote_dir_and_remote_import_path(self):\n        \"\"\"Test that cls() factory accepts both remote_dir and remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_cls = kt.cls(SimpleClass, remote_dir=\"/app/custom/path\", remote_import_path=\"custom.module.path\")\n        assert remote_cls._remote_root_path == \"/app/custom/path\"\n        assert remote_cls._import_path == \"custom.module.path\"\n\n\nclass TestFnRemoteDir:\n    \"\"\"Test Fn class remote_dir and remote_import_path options.\"\"\"\n    \n    def test_fn_accepts_remote_dir_parameter(self):\n        \"\"\"Test that Fn.__init__ accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import Fn\n        import inspect\n        \n        sig = inspect.signature(Fn.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"Fn.__init__ should accept remote_dir parameter\"\n    \n    def test_fn_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that Fn.__init__ accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import Fn\n        import inspect\n        \n        sig = inspect.signature(Fn.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"Fn.__init__ should accept remote_import_path parameter\"\n    \n    def test_fn_factory_accepts_remote_dir_parameter(self):\n        \"\"\"Test that fn() factory function accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import fn as fn_factory\n        import inspect\n        \n        sig = inspect.signature(fn_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"fn() factory should accept remote_dir parameter\"\n    \n    def test_fn_factory_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that fn() factory function accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import fn as fn_factory\n        import inspect\n        \n        sig = inspect.signature(fn_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"fn() factory should accept remote_import_path parameter\"\n    \n    def test_fn_factory_rejects_sync_dir_and_remote_dir_together(self):\n        \"\"\"Test that fn() factory raises error when both sync_dir and remote_dir are specified.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"sync_dir and remote_dir can not both be set\"):\n            kt.fn(simple_add, sync_dir=\"/local/path\", remote_dir=\"/remote/path\")\n    \n    def test_fn_factory_rejects_remote_import_path_without_remote_dir(self):\n        \"\"\"Test that fn() factory raises error when remote_import_path is set without remote_dir.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"remote_import_path can only be set when remote_dir is also set\"):\n            kt.fn(simple_add, remote_import_path=\"custom.import.path\")\n    \n    def test_fn_factory_accepts_only_remote_dir(self):\n        \"\"\"Test that fn() factory accepts remote_dir without remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn = kt.fn(simple_add, remote_dir=\"/app/custom/path\")\n        assert remote_fn._remote_root_path == \"/app/custom/path\"\n    \n    def test_fn_factory_accepts_remote_dir_and_remote_import_path(self):\n        \"\"\"Test that fn() factory accepts both remote_dir and remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn = kt.fn(simple_add, remote_dir=\"/app/custom/path\", remote_import_path=\"custom.module.path\")\n        assert remote_fn._remote_root_path == \"/app/custom/path\"\n        assert remote_fn._import_path == \"custom.module.path\"\n\n\nclass TestRemoteDirValidation:\n    \"\"\"Test validation logic for remote_dir and remote_import_path combinations.\"\"\"\n    \n    def test_path_object_accepted_as_remote_dir(self):\n        \"\"\"Test that Path objects are accepted for remote_dir.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        remote_dir_path = Path(\"/app/custom/path\")\n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=remote_dir_path\n        )\n        \n        assert module._remote_root_path == \"/app/custom/path\"\n    \n    def test_different_path_formats_accepted(self):\n        \"\"\"Test various path formats for remote_dir.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn1 = kt.fn(simple_add, remote_dir=\"/absolute/path/to/module\")\n        assert remote_fn1._remote_root_path == \"/absolute/path/to/module\"\n        \n        remote_fn2 = kt.fn(simple_add, remote_dir=\"~/relative/path\")\n        assert \"relative/path\" in remote_fn2._remote_root_path\n    \n    def test_empty_remote_import_path_allowed(self):\n        \"\"\"Test that empty string for remote_import_path is allowed.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=\"/app/path\",\n            remote_import_path=\"\"\n        )\n        assert module._import_path == \"test_remote_dir\"\n\n\nclass TestRemoteDirEdgeCases:\n    \"\"\"Test edge cases for remote_dir and remote_import_path.\"\"\"\n    \n    def test_none_remote_dir_does_not_set_remote_root_path(self):\n        \"\"\"Test that when remote_dir is None, _remote_root_path is not set at init.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=None\n        )\n        \n        assert module._remote_root_path is None\n    \n    def test_remote_dir_with_special_characters(self):\n        \"\"\"Test that remote_dir handles special path characters correctly.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn = kt.fn(simple_add, remote_dir=\"/path with spaces/module\")\n        assert \"/path with spaces/module\" in remote_fn._remote_root_path\n        \n        remote_fn2 = kt.fn(simple_add, remote_dir=\"/my-app_v2/module-dir\")\n        assert remote_fn2._remote_root_path == \"/my-app_v2/module-dir\"\n"},{"path":"python_client/tests/test_remote_dir.py","content":"\"\"\"Tests for remote_dir and remote_import_path configuration options in modules.\"\"\"\nimport pytest\nfrom pathlib import Path\n\n\ndef simple_add(a, b):\n    \"\"\"Simple function for testing.\"\"\"\n    return a + b\n\n\nclass SimpleClass:\n    \"\"\"Simple class for testing.\"\"\"\n    \n    def add(self, a, b):\n        return a + b\n\n\nclass TestModuleRemoteDir:\n    \"\"\"Test Module class remote_dir and remote_import_path options.\"\"\"\n    \n    def test_module_accepts_remote_dir_parameter(self):\n        \"\"\"Test that Module.__init__ accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        import inspect\n        \n        sig = inspect.signature(Module.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"Module.__init__ should accept remote_dir parameter\"\n    \n    def test_module_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that Module.__init__ accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        import inspect\n        \n        sig = inspect.signature(Module.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"Module.__init__ should accept remote_import_path parameter\"\n    \n    def test_module_rejects_sync_dir_and_remote_dir_together(self):\n        \"\"\"Test that Module raises ValueError when both sync_dir and remote_dir are specified.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        with pytest.raises(ValueError, match=\"sync_dir and remote_dir can not both be set\"):\n            Module(\n                name=\"test-module\",\n                pointers=pointers,\n                sync_dir=\"/some/local/path\",\n                remote_dir=\"/some/remote/path\"\n            )\n    \n    def test_module_rejects_remote_import_path_without_remote_dir(self):\n        \"\"\"Test that Module raises ValueError when remote_import_path is set without remote_dir.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        with pytest.raises(ValueError, match=\"remote_import_path can only be set when remote_dir is also set\"):\n            Module(\n                name=\"test-module\",\n                pointers=pointers,\n                remote_import_path=\"custom.import.path\"\n            )\n    \n    def test_module_accepts_only_remote_dir(self):\n        \"\"\"Test that Module accepts remote_dir without remote_import_path.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=\"/app/custom/path\"\n        )\n        \n        assert module._remote_root_path == \"/app/custom/path\"\n    \n    def test_module_accepts_remote_dir_and_remote_import_path(self):\n        \"\"\"Test that Module accepts both remote_dir and remote_import_path together.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=\"/app/custom/path\",\n            remote_import_path=\"custom.import.path\"\n        )\n        \n        assert module._remote_root_path == \"/app/custom/path\"\n        assert module._remote_import_path == \"custom.import.path\"\n\n\nclass TestClsRemoteDir:\n    \"\"\"Test Cls class remote_dir and remote_import_path options.\"\"\"\n    \n    def test_cls_accepts_remote_dir_parameter(self):\n        \"\"\"Test that Cls.__init__ accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import Cls\n        import inspect\n        \n        sig = inspect.signature(Cls.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"Cls.__init__ should accept remote_dir parameter\"\n    \n    def test_cls_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that Cls.__init__ accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import Cls\n        import inspect\n        \n        sig = inspect.signature(Cls.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"Cls.__init__ should accept remote_import_path parameter\"\n    \n    def test_cls_factory_accepts_remote_dir_parameter(self):\n        \"\"\"Test that cls() factory function accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import cls as cls_factory\n        import inspect\n        \n        sig = inspect.signature(cls_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"cls() factory should accept remote_dir parameter\"\n    \n    def test_cls_factory_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that cls() factory function accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.cls.cls import cls as cls_factory\n        import inspect\n        \n        sig = inspect.signature(cls_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"cls() factory should accept remote_import_path parameter\"\n    \n    def test_cls_factory_rejects_sync_dir_and_remote_dir_together(self):\n        \"\"\"Test that cls() factory raises error when both sync_dir and remote_dir are specified.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"sync_dir and remote_dir can not both be set\"):\n            kt.cls(SimpleClass, sync_dir=\"/local/path\", remote_dir=\"/remote/path\")\n    \n    def test_cls_factory_rejects_remote_import_path_without_remote_dir(self):\n        \"\"\"Test that cls() factory raises error when remote_import_path is set without remote_dir.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"remote_import_path can only be set when remote_dir is also set\"):\n            kt.cls(SimpleClass, remote_import_path=\"custom.import.path\")\n    \n    def test_cls_factory_accepts_only_remote_dir(self):\n        \"\"\"Test that cls() factory accepts remote_dir without remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_cls = kt.cls(SimpleClass, remote_dir=\"/app/custom/path\")\n        assert remote_cls._remote_root_path == \"/app/custom/path\"\n    \n    def test_cls_factory_accepts_remote_dir_and_remote_import_path(self):\n        \"\"\"Test that cls() factory accepts both remote_dir and remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_cls = kt.cls(SimpleClass, remote_dir=\"/app/custom/path\", remote_import_path=\"custom.module.path\")\n        assert remote_cls._remote_root_path == \"/app/custom/path\"\n        assert remote_cls._remote_import_path == \"custom.module.path\"\n\n\nclass TestFnRemoteDir:\n    \"\"\"Test Fn class remote_dir and remote_import_path options.\"\"\"\n    \n    def test_fn_accepts_remote_dir_parameter(self):\n        \"\"\"Test that Fn.__init__ accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import Fn\n        import inspect\n        \n        sig = inspect.signature(Fn.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"Fn.__init__ should accept remote_dir parameter\"\n    \n    def test_fn_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that Fn.__init__ accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import Fn\n        import inspect\n        \n        sig = inspect.signature(Fn.__init__)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"Fn.__init__ should accept remote_import_path parameter\"\n    \n    def test_fn_factory_accepts_remote_dir_parameter(self):\n        \"\"\"Test that fn() factory function accepts remote_dir parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import fn as fn_factory\n        import inspect\n        \n        sig = inspect.signature(fn_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_dir'' in params, \"fn() factory should accept remote_dir parameter\"\n    \n    def test_fn_factory_accepts_remote_import_path_parameter(self):\n        \"\"\"Test that fn() factory function accepts remote_import_path parameter.\"\"\"\n        from kubetorch.resources.callables.fn.fn import fn as fn_factory\n        import inspect\n        \n        sig = inspect.signature(fn_factory)\n        params = list(sig.parameters.keys())\n        \n        assert ''remote_import_path'' in params, \"fn() factory should accept remote_import_path parameter\"\n    \n    def test_fn_factory_rejects_sync_dir_and_remote_dir_together(self):\n        \"\"\"Test that fn() factory raises error when both sync_dir and remote_dir are specified.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"sync_dir and remote_dir can not both be set\"):\n            kt.fn(simple_add, sync_dir=\"/local/path\", remote_dir=\"/remote/path\")\n    \n    def test_fn_factory_rejects_remote_import_path_without_remote_dir(self):\n        \"\"\"Test that fn() factory raises error when remote_import_path is set without remote_dir.\"\"\"\n        import kubetorch as kt\n        \n        with pytest.raises(ValueError, match=\"remote_import_path can only be set when remote_dir is also set\"):\n            kt.fn(simple_add, remote_import_path=\"custom.import.path\")\n    \n    def test_fn_factory_accepts_only_remote_dir(self):\n        \"\"\"Test that fn() factory accepts remote_dir without remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn = kt.fn(simple_add, remote_dir=\"/app/custom/path\")\n        assert remote_fn._remote_root_path == \"/app/custom/path\"\n    \n    def test_fn_factory_accepts_remote_dir_and_remote_import_path(self):\n        \"\"\"Test that fn() factory accepts both remote_dir and remote_import_path.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn = kt.fn(simple_add, remote_dir=\"/app/custom/path\", remote_import_path=\"custom.module.path\")\n        assert remote_fn._remote_root_path == \"/app/custom/path\"\n        assert remote_fn._remote_import_path == \"custom.module.path\"\n\n\nclass TestRemoteDirValidation:\n    \"\"\"Test validation logic for remote_dir and remote_import_path combinations.\"\"\"\n    \n    def test_path_object_accepted_as_remote_dir(self):\n        \"\"\"Test that Path objects are accepted for remote_dir.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        remote_dir_path = Path(\"/app/custom/path\")\n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=remote_dir_path\n        )\n        \n        assert module._remote_root_path == \"/app/custom/path\"\n    \n    def test_different_path_formats_accepted(self):\n        \"\"\"Test various path formats for remote_dir.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn1 = kt.fn(simple_add, remote_dir=\"/absolute/path/to/module\")\n        assert remote_fn1._remote_root_path == \"/absolute/path/to/module\"\n        \n        remote_fn2 = kt.fn(simple_add, remote_dir=\"~/relative/path\")\n        assert \"relative/path\" in remote_fn2._remote_root_path\n    \n    def test_empty_remote_import_path_allowed(self):\n        \"\"\"Test that empty string for remote_import_path is allowed.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=\"/app/path\",\n            remote_import_path=\"\"\n        )\n        assert module._import_path == \"test_remote_dir\"  # Original import path preserved\n\n\nclass TestRemoteDirEdgeCases:\n    \"\"\"Test edge cases for remote_dir and remote_import_path.\"\"\"\n    \n    def test_none_remote_dir_does_not_set_remote_root_path(self):\n        \"\"\"Test that when remote_dir is None, _remote_root_path is not set at init.\"\"\"\n        from kubetorch.resources.callables.module import Module\n        \n        test_file = Path(__file__).resolve()\n        pointers = (str(test_file.parent), \"test_remote_dir\", \"simple_add\")\n        \n        module = Module(\n            name=\"test-module\",\n            pointers=pointers,\n            remote_dir=None\n        )\n        \n        assert module._remote_root_path is None\n    \n    def test_remote_dir_with_special_characters(self):\n        \"\"\"Test that remote_dir handles special path characters correctly.\"\"\"\n        import kubetorch as kt\n        \n        remote_fn = kt.fn(simple_add, remote_dir=\"/path with spaces/module\")\n        assert \"/path with spaces/module\" in remote_fn._remote_root_path\n        \n        remote_fn2 = kt.fn(simple_add, remote_dir=\"/my-app_v2/module-dir\")\n        assert remote_fn2._remote_root_path == \"/my-app_v2/module-dir\"\n"}]'
  test_generation: agentic-docker
prompt: |-
  Add configuration options to specify custom remote directory paths and import paths for modules. When running modules on remote clusters, users should be able to:

  1. Specify a custom `remote_dir` to control where module code is placed on the remote filesystem
  2. Specify a `remote_import_path` to control how the module is added to the Python path for imports on the remote side

  These options should allow users to override default behaviors and have full control over module placement and import resolution when code is executed remotely.
original_pr_body: |-
  run-house/kubetorch (#2243): Add option to specify remote_dir and remote_import_path in module

  (no description)
quality_score: 0.5
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
