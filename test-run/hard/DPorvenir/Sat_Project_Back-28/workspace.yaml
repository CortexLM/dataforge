id: DPorvenir/Sat_Project_Back-28
repo: DPorvenir/Sat_Project_Back
base_commit: 6780d7c5d08589059048eadd9601358c82c0ec02
merge_commit: 5f2db8566b4b250c92be152abd2381fda8f77670
language: javascript
difficulty_score: 3
created_at: 2026-02-17T09:46:38.316913699Z
patch: "diff --git a/src/app.mjs b/src/app.mjs\nindex 4f35dfc..cb98274 100644\n--- a/src/app.mjs\n+++ b/src/app.mjs\n@@ -34,8 +34,8 @@ io.on('connection', (socket) => {\n   });\n });\n \n-import './cronJob/satCronJob.js';\n-import './cronJob/scrapingJob.js';\n+// import './cronJob/satCronJob.js';\n+// import './cronJob/scrapingJob.js';\n // import './cronJob/descargaMasivaCron.js';\n // import './cronJob/lista69bCronJob.js';\n // import './cronJob/checkCfdiStatusCron.mjs';\ndiff --git a/src/controllers/LogsController.mjs b/src/controllers/LogsController.mjs\nnew file mode 100644\nindex 0000000..efbe662\n--- /dev/null\n+++ b/src/controllers/LogsController.mjs\n@@ -0,0 +1,30 @@\n+import { poolPromise, sql } from '../config/DbConfig.mjs';\n+\n+export async function listarLogsController(req, res) {\n+  try {\n+    const usuarioId = req.usuario?.usuarioId;\n+    if (!usuarioId) {\n+      return res.status(401).json({ error: 'Usuario no autenticado' });\n+    }\n+\n+    const rawLimit = Number(req.query.limit ?? 10);\n+    const limit = Number.isFinite(rawLimit) ? Math.min(Math.max(rawLimit, 1), 200) : 10;\n+\n+    const pool = await poolPromise;\n+    const result = await pool.request()\n+      .input('UsuarioId', sql.Int, usuarioId)\n+      .input('Limit', sql.Int, limit)\n+      .query(`\n+        SELECT TOP (@Limit)\n+          LogId, Nivel, Contexto, Mensaje, UsuarioId, ClienteFinalId, SolicitudId, EjecucionId, Meta, CreatedAt\n+        FROM AppLogs\n+        WHERE UsuarioId = @UsuarioId\n+        ORDER BY CreatedAt DESC\n+      `);\n+\n+    return res.json({ ok: true, limit, logs: result.recordset });\n+  } catch (error) {\n+    console.error('Error listando logs:', error);\n+    return res.status(500).json({ error: 'Error al listar logs' });\n+  }\n+}\ndiff --git a/src/controllers/SatController.js b/src/controllers/SatController.js\nindex 50e23de..0f38573 100644\n--- a/src/controllers/SatController.js\n+++ b/src/controllers/SatController.js\n@@ -1,5 +1,5 @@\n import fs from 'fs';\n-import { descargarCfdiPorRango, verificarSolicitudSat, descargarPaqueteSatYExtraerXMLs } from '../services/SatDescargaService.mjs';\n+import { verificarSolicitudSat, descargarPaqueteSatYExtraerXMLs } from '../services/SatDescargaService.mjs';\n import { CountCfdiCliente, guardarCfdi } from '../models/Cfdi.mjs';\n import { parseCfdiXml } from '../utils/ParseCfdiXml.mjs';\n import { crearFiel, buscarFielPorRfcYCliente, buscarFielPorId } from '../models/Fiel.mjs';\n@@ -15,9 +15,10 @@ import { buildServiceFromFiel, queryMetadataByUuid, extractMetadataFromVerify, d\n import { actualizarEstadoCfdiPorUuid, obtenerUuidsCfdiVersion40PorCliente, countCfdisPorUsuarioYRangoEmision, obtenerDescargasPorMesDelAnioEmision, obtenerConteosTipoComprobantePorMes, obtenerConteosMetodoPagoPorMes, obtenerTotalesTipoDescargaAnio, countCfdiClientePorAnio, obtenerAniosDisponiblesPorUsuario } from '../models/Cfdi.mjs';\n import { XMLParser, XMLBuilder } from 'fast-xml-parser';\n import { buscarCiecPorRfcYCliente } from '../models/Ciec.mjs';\n-import { scrapingCiecService } from '../services/CiecService.mjs';\n-import { scrapingFielService } from '../services/FielService.mjs';\n-import { crearSolicitudScraping } from '../models/SolicitudScraping.mjs';\n+import { solicitarYDescargarEmitidosCiec, solicitarYDescargarRecibidosCiec } from '../services/CiecService.mjs';\n+import { solicitarYDescargarEmitidosFiel, solicitarYDescargarRecibidosFiel } from '../services/FielService.mjs';\n+import { crearSolicitudScraping, actualizarStatusSolicitudScraping } from '../models/SolicitudScraping.mjs';\n+import { logInfo, logWarn, logError } from '../utils/logger.mjs';\n import { ejecutarDescargaManualDirecta } from '../services/DescargaMasivaService.mjs';\n \n /**\n@@ -84,7 +85,7 @@ export async function descargarCfdi(req, res) {\n \n     let credentials = null;\n     let typeCredential = 'FIEL';\n-    let resultado = null;\n+    const usuarioId = req.usuario?.usuarioId;\n \n     credentials = await buscarFielPorRfcYCliente(rfc, parseInt(clienteFinalId, 10));\n     \n@@ -96,214 +97,290 @@ export async function descargarCfdi(req, res) {\n       }\n     }\n \n-    if(typeCredential === 'FIEL'){\n-      const cerBuffer = Buffer.from(credentials.CerBase64, 'base64');\n-      const keyBuffer = Buffer.from(credentials.KeyBase64, 'base64');\n-      const passwordFiel = decrypt(credentials.Password);\n-  \n-      resultado = await descargarCfdiPorRango({\n-        cerBuffer,\n-        keyBuffer,\n-        password: passwordFiel,\n-        fechaInicio,\n-        fechaFin,\n-        tipoSolicitud,\n-        tipoComprobante,\n-        tipoDescarga,\n-        rfcEmisor,\n-        rfcReceptor\n-      });\n+    const tiposSolicitados = [];\n+    if (tipoDescarga === 'both' || tipoDescarga === 'all') {\n+      tiposSolicitados.push('issued', 'received');\n+    } else if (tipoDescarga === 'issued' || tipoDescarga === 'received') {\n+      tiposSolicitados.push(tipoDescarga);\n+    } else {\n+      tiposSolicitados.push('issued', 'received');\n+    }\n \n-      if(resultado.tipo === 'error_solicitud_soap'){\n-\n-        const startFull = new Date(fechaInicio);\n-        const endFull = new Date(fechaFin);\n-        let current = new Date(startFull);\n-        let jobsEncolados = 0;\n-\n-        // L√≥gica diferenciada para received (meses) vs issued (a√±os)\n-        if (tipoDescarga === 'received') {\n-          // Normalizar al d√≠a 1 del mes inicial si no lo est√°\n-          current.setDate(1);\n-\n-          while (current <= endFull) {\n-            // Calcular fin de mes\n-            let nextMonth = new Date(current);\n-            nextMonth.setMonth(nextMonth.getMonth() + 1);\n-            nextMonth.setDate(0); // √öltimo d√≠a del mes actual\n-\n-            // Si el rango pedido termina antes de fin de mes, usamos la fecha fin real?\n-            // \"solo se debe mandar el 1 de cada mes\" -> API recibe start_date.\n-            // Para consistencia en DB, guardamos el mes completo o el fragmento.\n-            // Guardamos el mes completo para que el job mande el 1 del mes.\n-            \n-            const segmentEnd = nextMonth; \n-            const fInicioSegmento = current.toISOString().split('T')[0];\n-            const fFinSegmento = segmentEnd.toISOString().split('T')[0];\n-\n-            await crearSolicitudScraping({\n-                ClienteFinalId: parseInt(clienteFinalId, 10),\n-                FielId: typeCredential === 'FIEL' ? credentials.FielId : null,\n-                CiecId: typeCredential === 'CIEC' ? credentials.CiecId : null,\n-                TypeCredential: typeCredential,\n-                FechaInicio: fInicioSegmento,\n-                FechaFin: fFinSegmento,\n-                RfcReceptor: rfcReceptor,\n-                RfcEmisor: rfcEmisor,\n-                TipoComprobante: tipoComprobante,\n-                TipoDescarga: tipoDescarga,\n-                EstadoComprobante: estadoComprobante\n-            });\n+    const startFull = new Date(fechaInicio);\n+    const endFull = new Date(fechaFin);\n+    let jobsEncolados = 0;\n+    let totalProcesados = 0;\n+    let totalPendientes = 0;\n+    let totalNoEncontrados = 0;\n+    let totalErrores = 0;\n+    let totalGuardados = 0;\n+    let resultadoSegmento;\n+\n+    await logInfo({\n+      contexto: 'SOLICITUD_CFDI',\n+      mensaje: 'Inicio de descarga',\n+      usuarioId,\n+      clienteFinalId: parseInt(clienteFinalId, 10),\n+      meta: { tipoDescarga, fechaInicio, fechaFin, tipoSolicitud, tipoComprobante }\n+    });\n \n-            jobsEncolados++;\n-            // Avanzar al mes siguiente (el d√≠a 1)\n-            current = new Date(segmentEnd); \n-            current.setDate(current.getDate() + 1); // Del √∫ltimo d√≠a pasa al 1 del sig mes\n-          }\n+    for (const tipo of tiposSolicitados) {\n+      const segmentos = [];\n+      let current = new Date(startFull);\n+      if (tipo === 'received') {\n+        current.setDate(1);\n+      }\n \n+      while (current <= endFull) {\n+        let segmentEnd;\n+        if (tipo === 'received') {\n+          const nextMonth = new Date(current);\n+          nextMonth.setMonth(nextMonth.getMonth() + 1);\n+          nextMonth.setDate(0);\n+          segmentEnd = nextMonth;\n         } else {\n-             // L√≥gica original para issued (por a√±os)\n-             while (current <= endFull) {\n-              let nextYear = new Date(current);\n-              nextYear.setFullYear(nextYear.getFullYear() + 1);\n-    \n-              let segmentEnd = nextYear > endFull ? new Date(endFull) : new Date(nextYear);\n-              const fInicioSegmento = current.toISOString().split('T')[0];\n-              const fFinSegmento = segmentEnd.toISOString().split('T')[0];\n-    \n-              await crearSolicitudScraping({\n-                ClienteFinalId: parseInt(clienteFinalId, 10),\n-                FielId: typeCredential === 'FIEL' ? credentials.FielId : null,\n-                CiecId: typeCredential === 'CIEC' ? credentials.CiecId : null,\n-                TypeCredential: typeCredential,\n-                FechaInicio: fInicioSegmento,\n-                FechaFin: fFinSegmento,\n-                RfcReceptor: rfcReceptor,\n-                RfcEmisor: rfcEmisor,\n-                TipoComprobante: tipoComprobante,\n-                TipoDescarga: tipoDescarga,\n-                EstadoComprobante: estadoComprobante\n-              });\n-    \n-              jobsEncolados++;\n-              current = new Date(segmentEnd);\n-              current.setDate(current.getDate() + 1);\n-            }\n+          const nextYear = new Date(current);\n+          nextYear.setFullYear(nextYear.getFullYear() + 1);\n+          segmentEnd = nextYear > endFull ? new Date(endFull) : new Date(nextYear);\n         }\n \n-        // Devolvemos respuesta inmediata al cliente\n-        return res.json({\n-          ok: true,\n-          status: 202,\n-          message: 'La solicitud v√≠a Web Service fall√≥ o no est√° disponible. Se ha iniciado el proceso de descarga v√≠a Scraping en segundo plano.',\n-          details: {\n-            jobsCreated: jobsEncolados,\n-            note: tipoDescarga === 'received' \n-               ? 'El sistema procesar√° la descarga segmentada por meses para recibidos.'\n-               : 'El sistema procesar√° la descarga segmentada por a√±os para emitidos.'\n-          }\n+        segmentos.push({\n+          fechaInicio: current.toISOString().split('T')[0],\n+          fechaFin: segmentEnd.toISOString().split('T')[0]\n         });\n+\n+        current = new Date(segmentEnd);\n+        current.setDate(current.getDate() + 1);\n       }\n-    } else if(typeCredential === 'CIEC'){\n \n-      const startFull = new Date(fechaInicio);\n-      const endFull = new Date(fechaFin);\n-      \n-      let current = new Date(startFull);\n-      let jobsEncolados = 0;\n-\n-      if (tipoDescarga === 'received') {\n-          // Normalizar al d√≠a 1\n-          current.setDate(1);\n-\n-          while (current <= endFull) {\n-            let nextMonth = new Date(current);\n-            nextMonth.setMonth(nextMonth.getMonth() + 1);\n-            nextMonth.setDate(0); \n-            \n-            const segmentEnd = nextMonth;\n-            const fInicioSegmento = current.toISOString().split('T')[0];\n-            const fFinSegmento = segmentEnd.toISOString().split('T')[0];\n-\n-            await crearSolicitudScraping({\n-                ClienteFinalId: parseInt(clienteFinalId, 10),\n-                FielId: null,\n-                CiecId: credentials.CiecId,\n-                TypeCredential: 'CIEC',\n-                FechaInicio: fInicioSegmento,\n-                FechaFin: fFinSegmento,\n-                RfcReceptor: rfcReceptor,\n-                RfcEmisor: rfcEmisor,\n-                TipoComprobante: tipoComprobante,\n-                TipoDescarga: tipoDescarga,\n-                EstadoComprobante: estadoComprobante\n-            });\n+      segmentos.reverse();\n+\n+      for (let idx = 0; idx < segmentos.length; idx++) {\n+        const segmento = segmentos[idx];\n+        const fInicioSegmento = segmento.fechaInicio;\n+        const fFinSegmento = segmento.fechaFin;\n+\n+        if (idx > 0) {\n+          jobsEncolados++;\n+          await crearSolicitudScraping({\n+            ClienteFinalId: parseInt(clienteFinalId, 10),\n+            FielId: typeCredential === 'FIEL' ? credentials.FielId : null,\n+            CiecId: typeCredential === 'CIEC' ? credentials.CiecId : null,\n+            TypeCredential: typeCredential,\n+            FechaInicio: fInicioSegmento,\n+            FechaFin: fFinSegmento,\n+            RfcReceptor: rfcReceptor,\n+            RfcEmisor: rfcEmisor,\n+            TipoComprobante: tipoComprobante,\n+            TipoDescarga: tipo,\n+            EstadoComprobante: estadoComprobante\n+          });\n+          await logInfo({\n+            contexto: 'SOLICITUD_CFDI',\n+            mensaje: 'Segmento encolado para procesamiento posterior',\n+            usuarioId,\n+            clienteFinalId: parseInt(clienteFinalId, 10),\n+            meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento }\n+          });\n+          continue;\n+        }\n \n-            jobsEncolados++;\n-            current = new Date(segmentEnd);\n-            current.setDate(current.getDate() + 1);\n+        \n+        const solicitudScrapingId = await crearSolicitudScraping({\n+          ClienteFinalId: parseInt(clienteFinalId, 10),\n+          FielId: typeCredential === 'FIEL' ? credentials.FielId : null,\n+          CiecId: typeCredential === 'CIEC' ? credentials.CiecId : null,\n+          TypeCredential: typeCredential,\n+          FechaInicio: fInicioSegmento,\n+          FechaFin: fFinSegmento,\n+          RfcReceptor: rfcReceptor,\n+          RfcEmisor: rfcEmisor,\n+          TipoComprobante: tipoComprobante,\n+          TipoDescarga: tipo,\n+          EstadoComprobante: estadoComprobante\n+        });\n+        if (solicitudScrapingId) {\n+          await actualizarStatusSolicitudScraping(solicitudScrapingId, 'PROCESANDO');\n+        }\n+        await logInfo({\n+          contexto: 'SOLICITUD_CFDI',\n+          mensaje: 'Segmento en proceso',\n+          usuarioId,\n+          clienteFinalId: parseInt(clienteFinalId, 10),\n+          meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento }\n+        });\n+        if (typeCredential === 'FIEL') {\n+          const passwordFiel = decrypt(credentials.Password);\n+          if (tipo === 'issued') {\n+            resultadoSegmento = await solicitarYDescargarEmitidosFiel({\n+              key_base64: credentials.KeyBase64,\n+              cer_base64: credentials.CerBase64,\n+              password: passwordFiel,\n+              start_date: fInicioSegmento,\n+              end_date: fFinSegmento,\n+              rfc_receptor: rfcReceptor,\n+              estado_comprobante: estadoComprobante,\n+              complemento: tipoComprobante,\n+              clienteFinalId: parseInt(clienteFinalId, 10),\n+              fielId: credentials.FielId,\n+              tipoDescarga: tipo\n+            });\n+          } else {\n+            resultadoSegmento = await solicitarYDescargarRecibidosFiel({\n+              key_base64: credentials.KeyBase64,\n+              cer_base64: credentials.CerBase64,\n+              password: passwordFiel,\n+              start_date: fInicioSegmento,\n+              rfc_emisor: rfcEmisor,\n+              estado_comprobante: estadoComprobante,\n+              complemento: tipoComprobante,\n+              clienteFinalId: parseInt(clienteFinalId, 10),\n+              fielId: credentials.FielId,\n+              tipoDescarga: tipo\n+            });\n           }\n-      } else {\n-          // Issued por a√±os\n-          while (current <= endFull) {\n-            let nextYear = new Date(current);\n-            nextYear.setFullYear(nextYear.getFullYear() + 1);\n-            let segmentEnd = nextYear > endFull ? new Date(endFull) : new Date(nextYear);\n-    \n-            const fInicioSegmento = current.toISOString().split('T')[0];\n-            const fFinSegmento = segmentEnd.toISOString().split('T')[0];\n-    \n-            await crearSolicitudScraping({\n-              ClienteFinalId: parseInt(clienteFinalId, 10),\n-              FielId: null,\n-              CiecId: credentials.CiecId,\n-              TypeCredential: 'CIEC',\n-              FechaInicio: fInicioSegmento,\n-              FechaFin: fFinSegmento,\n-              RfcReceptor: rfcReceptor,\n-              RfcEmisor: rfcEmisor,\n-              TipoComprobante: tipoComprobante,\n-              TipoDescarga: tipoDescarga,\n-              EstadoComprobante: estadoComprobante\n+        } else {\n+          const passwordCiec = decrypt(credentials.Password);\n+          if (tipo === 'issued') {\n+            resultadoSegmento = await solicitarYDescargarEmitidosCiec({\n+              rfc: credentials.RFC,\n+              password: passwordCiec,\n+              start_date: fInicioSegmento,\n+              end_date: fFinSegmento,\n+              rfc_receptor: rfcReceptor,\n+              estado_comprobante: estadoComprobante,\n+              complemento: tipoComprobante,\n+              clienteFinalId: parseInt(clienteFinalId, 10),\n+              ciecId: credentials.CiecId,\n+              tipoDescarga: tipo\n+            });\n+          } else {\n+            resultadoSegmento = await solicitarYDescargarRecibidosCiec({\n+              rfc: credentials.RFC,\n+              password: passwordCiec,\n+              start_date: fInicioSegmento,\n+              rfc_emisor: rfcEmisor,\n+              estado_comprobante: estadoComprobante,\n+              complemento: tipoComprobante,\n+              clienteFinalId: parseInt(clienteFinalId, 10),\n+              ciecId: credentials.CiecId,\n+              tipoDescarga: tipo\n             });\n-    \n-            jobsEncolados++;\n-            current = new Date(segmentEnd);\n-            current.setDate(current.getDate() + 1);\n           }\n-      }\n+        }\n \n-      return res.json({\n-        ok: true,\n-        status: 202,\n-        message: 'Se ha iniciado el proceso de descarga v√≠a Scraping (CIEC) en segundo plano.',\n-        details: {\n-          jobsCreated: jobsEncolados,\n-          note: tipoDescarga === 'received' \n-            ? 'El sistema procesar√° la descarga segmentada por meses para recibidos.'\n-            : 'El sistema procesar√° la descarga segmentada por a√±os para emitidos.'\n+        totalProcesados++;\n+\n+        if (resultadoSegmento?.status === 'completed') {\n+          totalGuardados += resultadoSegmento.guardados || 0;\n+          if (solicitudScrapingId) {\n+            await actualizarStatusSolicitudScraping(solicitudScrapingId, 'COMPLETADO', resultadoSegmento.message || 'Paquete descargado y guardado');\n+          }\n+          await logInfo({\n+            contexto: 'SOLICITUD_CFDI',\n+            mensaje: 'Segmento completado',\n+            usuarioId,\n+            clienteFinalId: parseInt(clienteFinalId, 10),\n+            meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento, guardados: resultadoSegmento.guardados || 0 }\n+          });\n+        } else if (resultadoSegmento?.status === 'not_found') {\n+          totalNoEncontrados++;\n+          if (solicitudScrapingId) {\n+            await actualizarStatusSolicitudScraping(solicitudScrapingId, 'COMPLETADO', resultadoSegmento.message || 'No se encontraron CFDIs');\n+          }\n+          await logInfo({\n+            contexto: 'SOLICITUD_CFDI',\n+            mensaje: resultadoSegmento.message,\n+            usuarioId,\n+            clienteFinalId: parseInt(clienteFinalId, 10),\n+            meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento }\n+          });\n+        } else if (resultadoSegmento?.status === 'pending') {\n+          totalPendientes++;\n+          if (solicitudScrapingId) {\n+            await actualizarStatusSolicitudScraping(solicitudScrapingId, 'COMPLETADO', 'Solicitud pendiente, se descargara en cron');\n+          }\n+          await crearSolicitudSat({\n+            ClienteFinalId: clienteFinalId,\n+            FielId: typeCredential === 'FIEL' ? credentials.FielId : credentials.CiecId,\n+            FechaInicio: fInicioSegmento,\n+            FechaFin: fFinSegmento,\n+            TipoSolicitud: tipoSolicitud || 'CFDI',\n+            TipoComprobante: tipoComprobante,\n+            TipoDescarga: tipo,\n+            RfcEmisor: rfcEmisor,\n+            RfcReceptor: rfcReceptor,\n+            IdSolicitudSat: resultadoSegmento.folio,\n+            Status: 5000,\n+            Message: resultadoSegmento.message,\n+            typeCredential: typeCredential,\n+            typeRequest: 'scraping'\n+          });\n+          await logInfo({\n+            contexto: 'SOLICITUD_CFDI',\n+            mensaje: 'Solicitud pendiente, se descargara en cron',\n+            usuarioId,\n+            clienteFinalId: parseInt(clienteFinalId, 10),\n+            meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento, folio: resultadoSegmento.folio }\n+          });\n+        } else if (resultadoSegmento?.status === 'sat_down') {\n+          jobsEncolados++;\n+          if (solicitudScrapingId) {\n+            await actualizarStatusSolicitudScraping(solicitudScrapingId, 'PENDIENTE', resultadoSegmento.message || 'SAT no disponible');\n+          }\n+          await logWarn({\n+            contexto: 'SOLICITUD_CFDI',\n+            mensaje: 'SAT no disponible, se reintentara',\n+            usuarioId,\n+            clienteFinalId: parseInt(clienteFinalId, 10),\n+            meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento }\n+          });\n+        } else {\n+          totalErrores++;\n+          const mensajeError = resultadoSegmento?.message || 'Error inesperado en proceso de scraping';\n+          if (solicitudScrapingId) {\n+            await actualizarStatusSolicitudScraping(solicitudScrapingId, 'PENDIENTE', mensajeError);\n+          }\n+          await logError({\n+            contexto: 'SOLICITUD_CFDI',\n+            mensaje: 'Error inesperado en proceso de scraping',\n+            usuarioId,\n+            clienteFinalId: parseInt(clienteFinalId, 10),\n+            meta: { tipoDescarga: tipo, fechaInicio: fInicioSegmento, fechaFin: fFinSegmento, error: mensajeError }\n+          });\n         }\n-      });\n+      }\n     }\n \n-    await crearSolicitudSat({\n-      ClienteFinalId: clienteFinalId,\n-      FielId: typeCredential === 'FIEL' ? credentials.FielId : credentials.CiecId,\n-      FechaInicio: fechaInicio,\n-      FechaFin: fechaFin,\n-      TipoSolicitud: resultado.requestType,\n-      TipoComprobante: tipoComprobante,\n-      TipoDescarga: tipoDescarga,\n-      RfcEmisor: rfcEmisor,\n-      RfcReceptor: rfcReceptor,\n-      IdSolicitudSat: resultado.idSolicitud,\n-      Status: resultado.status,\n-      Message: resultado.message,\n-      typeCredential: typeCredential,\n-      typeRequest: resultado.typeRequest\n+    await logInfo({\n+      contexto: 'SOLICITUD_CFDI',\n+      mensaje: 'Fin de descarga',\n+      usuarioId,\n+      clienteFinalId: parseInt(clienteFinalId, 10),\n+      meta: {\n+        totalProcesados,\n+        totalGuardados,\n+        totalPendientes,\n+        totalNoEncontrados,\n+        totalErrores,\n+        jobsEncolados\n+      }\n     });\n \n-    res.json(resultado);\n+    return res.json({\n+      ok: true,\n+      status: 200,\n+      message: resultadoSegmento.message || 'Proceso de descarga finalizado',\n+      type: resultadoSegmento.status,\n+      details: {\n+        totalProcesados,\n+        totalGuardados,\n+        totalPendientes,\n+        totalNoEncontrados,\n+        totalErrores,\n+        jobsEncolados\n+      }\n+    });\n   } catch (error) {\n     console.error('Error en descargarCfdi:', error);\n     res.status(400).json({ error: error });\ndiff --git a/src/cronJob/satCronJob.js b/src/cronJob/satCronJob.js\nindex 250579e..168a6d1 100644\n--- a/src/cronJob/satCronJob.js\n+++ b/src/cronJob/satCronJob.js\n@@ -1,14 +1,11 @@\n import cron from 'node-cron';\n-import { obtenerSolicitudesPendientes, actualizarStatusSolicitudSat } from '../models/SolicitudSat.mjs';\n+import { obtenerSolicitudesPendientes } from '../models/SolicitudSat.mjs';\n import { buscarFielPorId } from '../models/Fiel.mjs';\n-import { verificarSolicitudSat, descargarPaqueteSatYExtraerXMLs } from '../services/SatDescargaService.mjs';\n import { decrypt } from '../utils/Encryption.mjs';\n-import { crearNotificacion } from '../models/NotificacionSat.mjs';\n import { procesarDescargaFiel } from '../services/FielService.mjs';\n import { procesarDescargaCiec } from '../services/CiecService.mjs';\n import { buscarCiecPorId } from '../models/Ciec.mjs';\n-import { parseCfdiXml } from '../utils/ParseCfdiXml.mjs';\n-import { guardarCfdiCompleto } from '../models/Cfdi.mjs';\n+import { logInfo, logWarn, logError } from '../utils/logger.mjs';\n \n cron.schedule('*/8 * * * *', async () => {\n   console.log(`[${new Date().toISOString()}] Ejecutando monitoreo SAT...`);\n@@ -31,121 +28,31 @@ cron.schedule('*/8 * * * *', async () => {\n           credential = await buscarFielPorId(solicitud.FielId);\n \n         } else if(solicitud.typeCredential === 'CIEC') {\n-          credential = await buscarCiecPorId(solicitud.FielId);\n+          credential = await buscarCiecPorId(solicitud.CiecId ?? solicitud.FielId);\n         }\n \n         if (!credential) {\n           console.error(`Credencial no encontrada para solicitud ${solicitud.IdSolicitudSat}`);\n+          await logWarn({\n+            contexto: 'SAT_CRON',\n+            mensaje: 'Credencial no encontrada para solicitud',\n+            usuarioId: solicitud.UsuarioId,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.SolicitudId,\n+            meta: { idSolicitudSat: solicitud.IdSolicitudSat }\n+          });\n           continue;\n         }\n \n-        if(solicitud.typeRequest === 'soap' || solicitud.typeRequest === null) {\n-          const cerBuffer = Buffer.from(credential.CerBase64, 'base64');\n-          const keyBuffer = Buffer.from(credential.KeyBase64, 'base64');\n-          const password = decrypt(credential.Password);\n-  \n-          let resultado;\n-          try {\n-            resultado = await verificarSolicitudSat({\n-              cerBuffer,\n-              keyBuffer,\n-              password,\n-              idSolicitud: solicitud.IdSolicitudSat\n-            });\n-          } catch (verifyError) {\n-            if (verifyError.type === 'sat_down') {\n-              console.warn('SAT caido durante verificacion. No se actualiza estado.');\n-              break;\n-            }\n-            throw verifyError;\n-          }\n-  \n-          const tipoSolicitud = solicitud.TipoSolicitud?.toLowerCase() || 'xml';\n-          const packagesJson = JSON.stringify(resultado.packagesIds || []);\n-  \n-          if (resultado.finished || resultado.status === '5004' || resultado.status === 5004) {\n-            console.log(`Solicitud ${solicitud.IdSolicitudSat} (${tipoSolicitud}) finalizada o sin paquetes.`);\n-            \n-            let downloadMsg = '';\n-            // Logica automatica de descarga para XMLs Soap\n-            if (resultado.finished && tipoSolicitud === 'xml' && resultado.packagesIds && resultado.packagesIds.length > 0) {\n-                 console.log(`üì• Iniciando descarga autom√°tica de ${resultado.packagesIds.length} paquetes para solicitud SOAP ${solicitud.IdSolicitudSat}`);\n-                 let guardados = 0;\n-                 let errores = 0;\n-                 \n-                 for (const pkgId of resultado.packagesIds) {\n-                    try {\n-                        const xmls = await descargarPaqueteSatYExtraerXMLs({\n-                            cerBuffer,\n-                            keyBuffer,\n-                            password,\n-                            packageId: pkgId\n-                        }); \n-                        \n-                        for (const xmlStr of xmls) {\n-                            try {\n-                                const cfdi = parseCfdiXml(xmlStr);\n-                                if (cfdi) {\n-                                  cfdi.TipoDescarga = solicitud.TipoDescarga;\n-                                  const fId = Number(solicitud.FielId);\n-                                  await guardarCfdiCompleto(cfdi, solicitud.ClienteFinalId, fId || solicitud.FielId);\n-                                  guardados++;\n-                                }\n-                            } catch (e) {\n-                                console.error('Error guardando CFDI de paquete SOAP:', e.message);\n-                                errores++;\n-                            }\n-                        }\n-                    } catch (pkgError) {\n-                        console.error(`Error descargando paquete ${pkgId}:`, pkgError.message);\n-                    }\n-                 }\n-                 console.log(`‚úÖ Descarga SOAP completada. Guardados: ${guardados}, Errores: ${errores}`);\n-                 downloadMsg = ` Se descargaron autom√°ticamente ${guardados} comprobantes.`;\n-            }\n-\n-            await actualizarStatusSolicitudSat({\n-              idSolicitud: solicitud.IdSolicitudSat,\n-              status: resultado.status,\n-              message: resultado.message + downloadMsg,\n-              Activo: 0\n-            });\n-  \n-            if (resultado.finished) {\n-              // Notificaci√≥n diferenciada por tipo\n-              let mensaje = tipoSolicitud === 'metadata' \n-                ? 'Metadata lista para descargar'\n-                : 'Paquete listo para descargar';\n-\n-              if(downloadMsg) mensaje = 'Paquetes descargados y procesados correctamente.';\n-  \n-              const notificacionCreada = await crearNotificacion({\n-                UsuarioId: solicitud.UsuarioId,\n-                SolicitudId: solicitud.SolicitudId,\n-                Tipo: 'success',\n-                Mensaje: mensaje,\n-                PackagesIds: packagesJson\n-              });\n-              global.io.to(`user_${solicitud.UsuarioId}`).emit('notificacion', notificacionCreada);\n-            } else if (resultado.status === '5004' || resultado.status === 5004) {\n-              const notificacionCreada = await crearNotificacion({\n-                UsuarioId: solicitud.UsuarioId,\n-                SolicitudId: solicitud.SolicitudId,\n-                Tipo: 'error',\n-                Mensaje: 'No hay paquetes disponibles para la solicitud.',\n-                PackagesIds: null\n-              });\n-              global.io.to(`user_${solicitud.UsuarioId}`).emit('notificacion', notificacionCreada);\n-            }\n-          } else {\n-            await actualizarStatusSolicitudSat({\n-              idSolicitud: solicitud.IdSolicitudSat,\n-              status: resultado.status,\n-              message: resultado.message,\n-              Activo: 1\n-            });\n-          }\n-        } else if(solicitud.typeRequest === 'scraping' && (solicitud.TipoDescarga === 'issued' || solicitud.TipoDescarga === 'received')) {\n+        if(solicitud.typeRequest === 'scraping' && (solicitud.TipoDescarga === 'issued' || solicitud.TipoDescarga === 'received')) {\n+          await logInfo({\n+            contexto: 'SAT_CRON',\n+            mensaje: 'Descarga pendiente en proceso',\n+            usuarioId: solicitud.UsuarioId,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.SolicitudId,\n+            meta: { idSolicitudSat: solicitud.IdSolicitudSat, tipoDescarga: solicitud.TipoDescarga }\n+          });\n           if(solicitud.typeCredential === 'FIEL') {\n             await procesarDescargaFiel(\n               credential.KeyBase64,\n@@ -172,14 +79,38 @@ cron.schedule('*/8 * * * *', async () => {\n               solicitud.TipoDescarga // Nuevo parametro\n             );\n           }\n+          await logInfo({\n+            contexto: 'SAT_CRON',\n+            mensaje: 'Descarga pendiente finalizada',\n+            usuarioId: solicitud.UsuarioId,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.SolicitudId,\n+            meta: { idSolicitudSat: solicitud.IdSolicitudSat, tipoDescarga: solicitud.TipoDescarga }\n+          });\n         } else {\n         }\n       } catch (err) {\n         console.error(`Error procesando solicitud ${solicitud.IdSolicitudSat}:`, err.message);\n         if (err.type === 'sat_down') {\n           console.warn('üõë Servicio SAT no disponible. Deteniendo procesamiento de solicitudes pendientes por ahora.');\n+          await logWarn({\n+            contexto: 'SAT_CRON',\n+            mensaje: 'SAT no disponible, se detiene el cron temporalmente',\n+            usuarioId: solicitud.UsuarioId,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.SolicitudId,\n+            meta: { idSolicitudSat: solicitud.IdSolicitudSat }\n+          });\n           break; // Detener el loop de solicitudes\n         }\n+        await logError({\n+          contexto: 'SAT_CRON',\n+          mensaje: 'Error procesando solicitud pendiente',\n+          usuarioId: solicitud.UsuarioId,\n+          clienteFinalId: solicitud.ClienteFinalId,\n+          solicitudId: solicitud.SolicitudId,\n+          meta: { idSolicitudSat: solicitud.IdSolicitudSat, error: err.message }\n+        });\n       }\n     }\n   } catch (err) {\ndiff --git a/src/cronJob/scrapingJob.js b/src/cronJob/scrapingJob.js\nindex 4a44430..e2eed2a 100644\n--- a/src/cronJob/scrapingJob.js\n+++ b/src/cronJob/scrapingJob.js\n@@ -1,11 +1,12 @@\n import cron from 'node-cron';\n import { obtenerSiguienteSolicitudPendiente, actualizarStatusSolicitudScraping } from '../models/SolicitudScraping.mjs';\n import { crearSolicitudSat } from '../models/SolicitudSat.mjs';\n-import { scrapingFielService, scrapingFielRecibidosService } from '../services/FielService.mjs';\n-import { scrapingCiecService, scrapingCiecRecibidosService } from '../services/CiecService.mjs';\n+import { solicitarYDescargarEmitidosFiel, solicitarYDescargarRecibidosFiel } from '../services/FielService.mjs';\n+import { solicitarYDescargarEmitidosCiec, solicitarYDescargarRecibidosCiec } from '../services/CiecService.mjs';\n import { buscarFielPorId } from '../models/Fiel.mjs';\n import { buscarCiecPorId } from '../models/Ciec.mjs';\n import { decrypt } from '../utils/Encryption.mjs';\n+import { logInfo, logWarn, logError } from '../utils/logger.mjs';\n let isRunning = false;\n \n cron.schedule('*/6 * * * *', async () => {\n@@ -37,6 +38,14 @@ cron.schedule('*/6 * * * *', async () => {\n       solicitudesProcesadas++;\n       console.log(`Procesando solicitud scraping ID: ${solicitud.Id} - ${solicitud.TypeCredential} (Solicitud ${solicitudesProcesadas} de ${MAX_SOLICITUDES})`);\n       await actualizarStatusSolicitudScraping(solicitud.Id, 'PROCESANDO');\n+      await logInfo({\n+        contexto: 'SCRAPING_JOB',\n+        mensaje: 'Solicitud en proceso',\n+        usuarioId: solicitud.UsuarioId ?? null,\n+        clienteFinalId: solicitud.ClienteFinalId,\n+        solicitudId: solicitud.Id,\n+        meta: { tipoDescarga: solicitud.TipoDescarga, fechaInicio: solicitud.FechaInicio, fechaFin: solicitud.FechaFin }\n+      });\n \n       try {\n         let resultado;\n@@ -49,27 +58,32 @@ cron.schedule('*/6 * * * *', async () => {\n           const passwordFiel = decrypt(fiel.Password);\n           \n           if (solicitud.TipoDescarga === 'issued') {\n-            resultado = await scrapingFielService(\n-              fiel.KeyBase64,\n-              fiel.CerBase64,\n-              passwordFiel,\n-              fInicio,\n-              fFin,\n-              solicitud.RfcReceptor,\n-              solicitud.EstadoComprobante,\n-              solicitud.TipoComprobante\n-            );\n+            resultado = await solicitarYDescargarEmitidosFiel({\n+              key_base64: fiel.KeyBase64,\n+              cer_base64: fiel.CerBase64,\n+              password: passwordFiel,\n+              start_date: fInicio,\n+              end_date: fFin,\n+              rfc_receptor: solicitud.RfcReceptor,\n+              estado_comprobante: solicitud.EstadoComprobante,\n+              complemento: solicitud.TipoComprobante,\n+              clienteFinalId: solicitud.ClienteFinalId,\n+              fielId: solicitud.FielId,\n+              tipoDescarga: solicitud.TipoDescarga\n+            });\n           } else {\n-            // received\n-            resultado = await scrapingFielRecibidosService(\n-              fiel.KeyBase64,\n-              fiel.CerBase64,\n-              passwordFiel,\n-              fInicio, // Para recibidos, solo mandamos fecha de inicio (mes)\n-              solicitud.RfcEmisor, // En recibidos filtramos por quien emite\n-              solicitud.EstadoComprobante,\n-              solicitud.TipoComprobante\n-            );\n+            resultado = await solicitarYDescargarRecibidosFiel({\n+              key_base64: fiel.KeyBase64,\n+              cer_base64: fiel.CerBase64,\n+              password: passwordFiel,\n+              start_date: fInicio,\n+              rfc_emisor: solicitud.RfcEmisor,\n+              estado_comprobante: solicitud.EstadoComprobante,\n+              complemento: solicitud.TipoComprobante,\n+              clienteFinalId: solicitud.ClienteFinalId,\n+              fielId: solicitud.FielId,\n+              tipoDescarga: solicitud.TipoDescarga\n+            });\n           }\n \n         } else if (solicitud.TypeCredential === 'CIEC') {\n@@ -77,25 +91,30 @@ cron.schedule('*/6 * * * *', async () => {\n           if (!ciec) throw new Error('CIEC no encontrada para procesar la solicitud.');\n           \n           if (solicitud.TipoDescarga === 'issued') {\n-            resultado = await scrapingCiecService(\n-              ciec.RFC,\n-              decrypt(ciec.Password),\n-              fInicio,\n-              fFin,\n-              solicitud.RfcReceptor,\n-              solicitud.EstadoComprobante,\n-              solicitud.TipoComprobante\n-            );\n+            resultado = await solicitarYDescargarEmitidosCiec({\n+              rfc: ciec.RFC,\n+              password: decrypt(ciec.Password),\n+              start_date: fInicio,\n+              end_date: fFin,\n+              rfc_receptor: solicitud.RfcReceptor,\n+              estado_comprobante: solicitud.EstadoComprobante,\n+              complemento: solicitud.TipoComprobante,\n+              clienteFinalId: solicitud.ClienteFinalId,\n+              ciecId: solicitud.CiecId,\n+              tipoDescarga: solicitud.TipoDescarga\n+            });\n           } else {\n-             // received\n-             resultado = await scrapingCiecRecibidosService(\n-              ciec.RFC,\n-              decrypt(ciec.Password),\n-              fInicio,\n-              solicitud.RfcEmisor,\n-              solicitud.EstadoComprobante,\n-              solicitud.TipoComprobante\n-             );\n+            resultado = await solicitarYDescargarRecibidosCiec({\n+              rfc: ciec.RFC,\n+              password: decrypt(ciec.Password),\n+              start_date: fInicio,\n+              rfc_emisor: solicitud.RfcEmisor,\n+              estado_comprobante: solicitud.EstadoComprobante,\n+              complemento: solicitud.TipoComprobante,\n+              clienteFinalId: solicitud.ClienteFinalId,\n+              ciecId: solicitud.CiecId,\n+              tipoDescarga: solicitud.TipoDescarga\n+            });\n           }\n         } else {\n           break;\n@@ -103,50 +122,99 @@ cron.schedule('*/6 * * * *', async () => {\n \n         console.log('Resultado del scraping:', resultado);\n \n-        if (resultado && resultado.idSolicitud) {\n-          \n+        if (resultado?.status === 'completed') {\n+          await actualizarStatusSolicitudScraping(solicitud.Id, 'COMPLETADO', resultado.message || 'Paquete descargado y guardado');\n+          await logInfo({\n+            contexto: 'SCRAPING_JOB',\n+            mensaje: 'Solicitud completada',\n+            usuarioId: solicitud.UsuarioId ?? null,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.Id,\n+            meta: { status: 'completed', message: resultado.message }\n+          });\n+        } else if (resultado?.status === 'pending') {\n           await crearSolicitudSat({\n             ClienteFinalId: solicitud.ClienteFinalId,\n             FielId: solicitud.TypeCredential === 'FIEL' ? solicitud.FielId : solicitud.CiecId,\n             FechaInicio: fInicio,\n             FechaFin: fFin,\n-            TipoSolicitud: resultado.requestType || 'xml',\n+            TipoSolicitud: 'CFDI',\n             TipoComprobante: solicitud.TipoComprobante,\n             TipoDescarga: solicitud.TipoDescarga,\n             RfcEmisor: solicitud.RfcEmisor,\n             RfcReceptor: solicitud.RfcReceptor,\n-            IdSolicitudSat: resultado.idSolicitud,\n-            Status: resultado.status,\n+            IdSolicitudSat: resultado.folio,\n+            Status: 5000,\n             Message: resultado.message,\n             typeCredential: solicitud.TypeCredential,\n-            typeRequest: resultado.typeRequest || 'Scraping'\n+            typeRequest: 'scraping'\n           });\n-\n-          await actualizarStatusSolicitudScraping(solicitud.Id, 'COMPLETADO', 'Descarga exitosa e iniciada en SAT');\n+          await actualizarStatusSolicitudScraping(solicitud.Id, 'COMPLETADO', 'Solicitud pendiente, se descargara en cron');\n+          await logInfo({\n+            contexto: 'SCRAPING_JOB',\n+            mensaje: 'Solicitud pendiente, se descargara en cron',\n+            usuarioId: solicitud.UsuarioId ?? null,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.Id,\n+            meta: { status: 'pending', folio: resultado.folio }\n+          });\n+        } else if (resultado?.status === 'not_found') {\n+          await actualizarStatusSolicitudScraping(solicitud.Id, 'COMPLETADO', resultado.message || 'No se encontraron CFDIs');\n+          await logInfo({\n+            contexto: 'SCRAPING_JOB',\n+            mensaje: 'No se encontraron CFDIs',\n+            usuarioId: solicitud.UsuarioId ?? null,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.Id,\n+            meta: { status: 'not_found' }\n+          });\n+        } else if (resultado?.status === 'sat_down') {\n+          await actualizarStatusSolicitudScraping(solicitud.Id, 'PENDIENTE', resultado.message || 'SAT no disponible');\n+          await logWarn({\n+            contexto: 'SCRAPING_JOB',\n+            mensaje: 'SAT no disponible, se reintentara',\n+            usuarioId: solicitud.UsuarioId ?? null,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.Id,\n+            meta: { status: 'sat_down' }\n+          });\n+          break;\n         } else {\n-          const errorMsg = resultado?.message || 'No se obtuvo idSolicitud del servicio de scraping';\n-          if(resultado.info === 'empty_result') {\n-            await actualizarStatusSolicitudScraping(solicitud.Id, 'ERROR', errorMsg);\n-          } else {\n-            await actualizarStatusSolicitudScraping(solicitud.Id, 'PENDIENTE', errorMsg);\n-          }\n+          const errorMsg = resultado?.message || 'Respuesta inesperada del servidor de scraping';\n+          await actualizarStatusSolicitudScraping(solicitud.Id, 'PENDIENTE', errorMsg);\n+          await logError({\n+            contexto: 'SCRAPING_JOB',\n+            mensaje: 'Respuesta inesperada del servidor de scraping',\n+            usuarioId: solicitud.UsuarioId ?? null,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.Id,\n+            meta: { status: 'error', error: errorMsg }\n+          });\n         }\n \n       } catch (error) {\n         console.error(`Error procesando solicitud scraping ${solicitud.Id}:`, error);\n-        if(error.info === 'Timeout' && error.type === 'sat_down') {\n+        if (error.type === 'sat_down') {\n           await actualizarStatusSolicitudScraping(solicitud.Id, 'PENDIENTE', error.message);\n+          await logWarn({\n+            contexto: 'SCRAPING_JOB',\n+            mensaje: 'SAT no disponible, se reintentara',\n+            usuarioId: solicitud.UsuarioId ?? null,\n+            clienteFinalId: solicitud.ClienteFinalId,\n+            solicitudId: solicitud.Id,\n+            meta: { status: 'sat_down', error: error.message }\n+          });\n           break;\n         }\n-        if(error.status === 'not_found' && error.type === 'sat_down') {\n-          await actualizarStatusSolicitudScraping(solicitud.Id, 'ERROR', error.message);\n-          return;\n-        }\n-        if(error.info === 'empty_result' && error.type === 'sat_down') {\n-          await actualizarStatusSolicitudScraping(solicitud.Id, 'ERROR', error.message);\n-          return;\n-        }\n         await actualizarStatusSolicitudScraping(solicitud.Id, 'PENDIENTE', error.message);\n+        await logError({\n+          contexto: 'SCRAPING_JOB',\n+          mensaje: 'Error procesando solicitud',\n+          usuarioId: solicitud.UsuarioId ?? null,\n+          clienteFinalId: solicitud.ClienteFinalId,\n+          solicitudId: solicitud.Id,\n+          meta: { error: error.message }\n+        });\n       }\n     }\n \ndiff --git a/src/models/SolicitudScraping.mjs b/src/models/SolicitudScraping.mjs\nindex 0cc77f3..9e4da2d 100644\n--- a/src/models/SolicitudScraping.mjs\n+++ b/src/models/SolicitudScraping.mjs\n@@ -39,10 +39,11 @@ export async function crearSolicitudScraping(data) {\n export async function obtenerSiguienteSolicitudPendiente() {\n   const pool = await poolPromise;\n   const result = await pool.request().query(`\n-    SELECT TOP 1 * \n-    FROM SolicitudesScraping \n-    WHERE Status = 'PENDIENTE' \n-    ORDER BY CreatedAt ASC\n+    SELECT TOP 1 ss.*, cf.UsuarioId\n+    FROM SolicitudesScraping ss\n+    INNER JOIN ClientesFinales cf ON ss.ClienteFinalId = cf.ClienteFinalId\n+    WHERE ss.Status = 'PENDIENTE' \n+    ORDER BY ss.CreatedAt DESC\n   `);\n   return result.recordset[0];\n }\ndiff --git a/src/routes/SatRoutes.js b/src/routes/SatRoutes.js\nindex a632b1a..9afd988 100644\n--- a/src/routes/SatRoutes.js\n+++ b/src/routes/SatRoutes.js\n@@ -17,6 +17,7 @@ import {\n } from '../controllers/Lista69bController.js';\n import { getCaptcha, startProcess } from '../controllers/satScraperController.mjs';\n import { crearCiecController, listarCiecDeClienteController } from '../controllers/CiecController.mjs';\n+import { listarLogsController } from '../controllers/LogsController.mjs';\n import {\n   crearConfigDescargaController,\n   actualizarConfigDescargaController,\n@@ -87,6 +88,9 @@ router.put('/notificacionSat/:notificacionId', jwtAuth, updateNotificacionSat);\n // dashboard\n router.get('/dashboard/stats', jwtAuth, dashboardStats);\n \n+// Logs de procesos\n+router.get('/logs', jwtAuth, listarLogsController);\n+\n // === LISTA 69-B ADMINISTRACI√ìN ===\n // Verificaci√≥n manual\n router.post('/lista69b/verificar', jwtAuth, verificarManualmente);\ndiff --git a/src/services/CiecService.mjs b/src/services/CiecService.mjs\nindex ac0d711..ac8851a 100644\n--- a/src/services/CiecService.mjs\n+++ b/src/services/CiecService.mjs\n@@ -291,4 +291,211 @@ export async function scrapingCiecRecibidosService(rfc, password, start_date, rf\n     const errorMsg = error.response?.data?.error || error.response?.data?.message || error.message || error;\n     throw new Error(errorMsg);\n   }\n-}\n\\ No newline at end of file\n+}\n+\n+/**\n+ * Solicita Y descarga emitidos en un solo paso via CIEC (endpoint unificado).\n+ */\n+export async function solicitarYDescargarEmitidosCiec({\n+  rfc,\n+  password,\n+  start_date,\n+  end_date,\n+  rfc_receptor,\n+  estado_comprobante,\n+  complemento,\n+  clienteFinalId,\n+  ciecId,\n+  tipoDescarga\n+}) {\n+  try {\n+    console.log(`[CIEC-Emitidos] Solicitar+Descargar ${start_date} a ${end_date} para cliente ${clienteFinalId}`);\n+    const response = await axios.post(`${SCRAPER_BASE_URL}solicitarYDescargarEmitidosCiec`, {\n+      rfc,\n+      password,\n+      start_date,\n+      end_date,\n+      rfc_receptor: rfc_receptor || '',\n+      estado_comprobante: estado_comprobante || '',\n+      complemento: complemento || '',\n+      max_retries: 4,\n+      download_attempts: 3,\n+      retry_delay_sec: 10,\n+      headless: true,\n+      timeout_ms: 900000,\n+      wait_after_ms: 1000\n+    }, {\n+      headers: { 'Content-Type': 'application/json' },\n+      responseType: 'arraybuffer',\n+      timeout: 960000\n+    });\n+\n+    return await procesarRespuestaUnificada(response, clienteFinalId, ciecId, tipoDescarga || 'issued', 'CIEC');\n+  } catch (error) {\n+    return manejarErrorUnificado(error, 'CIEC-Emitidos');\n+  }\n+}\n+\n+/**\n+ * Solicita Y descarga recibidos en un solo paso via CIEC (endpoint unificado).\n+ */\n+export async function solicitarYDescargarRecibidosCiec({\n+  rfc,\n+  password,\n+  start_date,\n+  rfc_emisor,\n+  estado_comprobante,\n+  complemento,\n+  clienteFinalId,\n+  ciecId,\n+  tipoDescarga\n+}) {\n+  try {\n+    console.log(`[CIEC-Recibidos] Solicitar+Descargar ${start_date} para cliente ${clienteFinalId}`);\n+    const response = await axios.post(`${SCRAPER_BASE_URL}solicitarYDescargarRecibidosCiec`, {\n+      rfc,\n+      password,\n+      start_date,\n+      rfc_emisor: rfc_emisor || '',\n+      estado_comprobante: estado_comprobante || '',\n+      complemento: complemento || '',\n+      max_retries: 4,\n+      download_attempts: 3,\n+      retry_delay_sec: 10,\n+      headless: true,\n+      timeout_ms: 900000,\n+      wait_after_ms: 1000\n+    }, {\n+      headers: { 'Content-Type': 'application/json' },\n+      responseType: 'arraybuffer',\n+      timeout: 960000\n+    });\n+\n+    return await procesarRespuestaUnificada(response, clienteFinalId, ciecId, tipoDescarga || 'received', 'CIEC');\n+  } catch (error) {\n+    return manejarErrorUnificado(error, 'CIEC-Recibidos');\n+  }\n+}\n+\n+async function procesarRespuestaUnificada(response, clienteFinalId, credentialId, tipoDescarga, typeCredential) {\n+  const contentType = response.headers['content-type'] || '';\n+\n+  if (contentType.includes('application/zip')) {\n+    console.log(`[${typeCredential}] ZIP recibido directamente, procesando...`);\n+    return await procesarZipResponse(response.data, clienteFinalId, credentialId, tipoDescarga, typeCredential);\n+  }\n+\n+  let jsonData;\n+  try {\n+    const textData = Buffer.from(response.data).toString('utf-8');\n+    jsonData = JSON.parse(textData);\n+  } catch (e) {\n+    try {\n+      return await procesarZipResponse(response.data, clienteFinalId, credentialId, tipoDescarga, typeCredential);\n+    } catch (zipErr) {\n+      return { status: 'sat_error', message: 'Respuesta no reconocida del servidor de scraping' };\n+    }\n+  }\n+\n+  if (jsonData.ok && jsonData.data && jsonData.data.file_b64) {\n+    console.log(`[${typeCredential}] ZIP recibido como base64 en JSON, procesando...`);\n+    const zipBuffer = Buffer.from(jsonData.data.file_b64, 'base64');\n+    return await procesarZipResponse(zipBuffer, clienteFinalId, credentialId, tipoDescarga, typeCredential);\n+  }\n+\n+  if (jsonData.status === 'not_found') {\n+    console.log(`[${typeCredential}] No se encontraron CFDIs: ${jsonData.message}`);\n+    return { status: 'not_found', message: jsonData.message || 'No se encontraron CFDIs con los parametros enviados.' };\n+  }\n+\n+  if (jsonData.status === 'pending') {\n+    console.log(`[${typeCredential}] Paquete pendiente, folio: ${jsonData.folio}`);\n+    return {\n+      status: 'pending',\n+      folio: jsonData.folio,\n+      message: jsonData.message || 'Solicitud creada. El paquete aun no esta disponible para descarga.',\n+      download_attempts: jsonData.download_attempts\n+    };\n+  }\n+\n+  if (jsonData.ok === false) {\n+    const rawError = jsonData.error || jsonData.reason || jsonData.message || 'Error desconocido';\n+    const isSatDown = rawError.includes('net::ERR_CONNECTION_TIMED_OUT') ||\n+      rawError.includes('Timeout 30000ms exceeded') ||\n+      rawError.includes('ERR_CONNECTION_RESET');\n+    if (isSatDown) {\n+      return { status: 'sat_down', message: 'El servicio del SAT no esta disponible en este momento.', type: 'sat_down' };\n+    }\n+    return { status: 'sat_error', message: rawError };\n+  }\n+\n+  console.warn(`[${typeCredential}] Respuesta inesperada:`, jsonData);\n+  return { status: 'sat_error', message: jsonData.message || 'Respuesta inesperada del servidor de scraping' };\n+}\n+\n+async function procesarZipResponse(zipBuffer, clienteFinalId, credentialId, tipoDescarga, typeCredential) {\n+  const zip = new AdmZip(zipBuffer);\n+  const zipEntries = zip.getEntries();\n+  let guardados = 0;\n+  let errores = 0;\n+\n+  for (const entry of zipEntries) {\n+    if (entry.isDirectory || entry.entryName.includes('__MACOSX')) continue;\n+\n+    if (entry.entryName.toLowerCase().endsWith('.xml')) {\n+      try {\n+        const xmlText = zip.readAsText(entry);\n+        const cfdi = parseCfdiXml(xmlText);\n+        if (cfdi) {\n+          cfdi.TipoDescarga = tipoDescarga;\n+          await guardarCfdiCompleto(cfdi, clienteFinalId, credentialId, typeCredential);\n+          guardados++;\n+        } else {\n+          console.warn(`No se pudo parsear XML: ${entry.entryName}`);\n+          errores++;\n+        }\n+      } catch (e) {\n+        console.error(`Error procesando archivo ${entry.entryName}:`, e.message);\n+        errores++;\n+      }\n+    }\n+  }\n+\n+  console.log(`[${typeCredential}] ZIP procesado. Guardados: ${guardados}, Errores: ${errores}`);\n+  return { status: 'completed', guardados, errores, message: `Se procesaron ${guardados} comprobantes exitosamente.` };\n+}\n+\n+function manejarErrorUnificado(error, contexto) {\n+  console.error(`[${contexto}] Error:`, error.message || error);\n+\n+  if (error.response && error.response.data) {\n+    try {\n+      const textData = Buffer.from(error.response.data).toString('utf-8');\n+      const errorData = JSON.parse(textData);\n+\n+      if (errorData.status === 'not_found') {\n+        return { status: 'not_found', message: errorData.message };\n+      }\n+      if (errorData.status === 'pending') {\n+        return { status: 'pending', folio: errorData.folio, message: errorData.message };\n+      }\n+\n+      const rawError = errorData.error || errorData.reason || errorData.message || '';\n+      const isSatDown = rawError.includes('net::ERR_CONNECTION_TIMED_OUT') ||\n+        rawError.includes('Timeout 30000ms exceeded') ||\n+        rawError.includes('ERR_CONNECTION_RESET');\n+      if (isSatDown) {\n+        return { status: 'sat_down', message: 'El servicio del SAT no esta disponible en este momento.', type: 'sat_down' };\n+      }\n+      return { status: 'sat_error', message: rawError || 'Error en el servidor de scraping' };\n+    } catch (e) {\n+      // ignore parse errors\n+    }\n+  }\n+\n+  if (error.code === 'ECONNREFUSED' || error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {\n+    return { status: 'sat_error', message: `No se pudo conectar al servidor de scraping: ${error.code}` };\n+  }\n+\n+  return { status: 'sat_error', message: error.message || 'Error desconocido en el proceso de descarga' };\n+}\ndiff --git a/src/services/DescargaMasivaService.mjs b/src/services/DescargaMasivaService.mjs\nindex 54d2fd2..63a286c 100644\n--- a/src/services/DescargaMasivaService.mjs\n+++ b/src/services/DescargaMasivaService.mjs\n@@ -1,4 +1,3 @@\n-import { descargarCfdiPorRango } from './SatDescargaService.mjs';\n import { buscarClienteFinalPorId } from '../models/ClienteFinal.mjs';\n import { buscarFielPorRfcYCliente } from '../models/Fiel.mjs';\n import { buscarCiecPorRfcYCliente } from '../models/Ciec.mjs';\n@@ -8,6 +7,9 @@ import { crearEjecucionDescarga, crearEjecucionDetalle, actualizarResumenEjecuci\n import { actualizarEjecucionConfig } from '../models/ConfigDescarga.mjs';\n import { decrypt } from '../utils/Encryption.mjs';\n import { calcularProximaEjecucion, normalizeTipoSolicitud, resolveDateRange, formatDateOnly } from '../utils/DescargaMasivaUtils.mjs';\n+import { logInfo, logWarn, logError } from '../utils/logger.mjs';\n+import { solicitarYDescargarEmitidosFiel, solicitarYDescargarRecibidosFiel } from './FielService.mjs';\n+import { solicitarYDescargarEmitidosCiec, solicitarYDescargarRecibidosCiec } from './CiecService.mjs';\n \n const TIPOS_DESCARGA = ['received', 'issued'];\n \n@@ -53,66 +55,42 @@ async function encolarScraping({\n   return { ok: true, metodo: 'SCRAPING', status: 'ENCOLADO', solicitudId };\n }\n \n-async function procesarSolicitudSoap({\n-  cliente,\n-  fiel,\n-  fechaInicio,\n-  fechaFin,\n-  tipoSolicitud,\n-  tipoComprobante,\n-  tipoDescarga,\n-  rfcEmisor,\n-  rfcReceptor\n-}) {\n-  const cerBuffer = Buffer.from(fiel.CerBase64, 'base64');\n-  const keyBuffer = Buffer.from(fiel.KeyBase64, 'base64');\n-  const passwordFiel = decrypt(fiel.Password);\n-\n-  const resultado = await descargarCfdiPorRango({\n-    cerBuffer,\n-    keyBuffer,\n-    password: passwordFiel,\n-    fechaInicio,\n-    fechaFin,\n-    tipoSolicitud,\n-    tipoComprobante,\n-    tipoDescarga,\n-    rfcEmisor,\n-    rfcReceptor\n-  });\n+function isSatDownError(error) {\n+  return error && error.type === 'sat_down';\n+}\n \n-  if (resultado?.tipo === 'error_solicitud_soap') {\n-    return { ok: false, error: 'SOAP_REJECTED', details: resultado.error };\n+function buildSegmentos(fechaInicio, fechaFin, tipoDescarga) {\n+  const segmentos = [];\n+  const startFull = new Date(fechaInicio);\n+  const endFull = new Date(fechaFin);\n+  let current = new Date(startFull);\n+  if (tipoDescarga === 'received') {\n+    current.setDate(1);\n   }\n \n-  await crearSolicitudSat({\n-    ClienteFinalId: cliente.ClienteFinalId,\n-    FielId: fiel.FielId,\n-    FechaInicio: fechaInicio,\n-    FechaFin: fechaFin,\n-    TipoSolicitud: resultado.requestType,\n-    TipoComprobante: tipoComprobante,\n-    TipoDescarga: tipoDescarga,\n-    RfcEmisor: rfcEmisor,\n-    RfcReceptor: rfcReceptor,\n-    IdSolicitudSat: resultado.idSolicitud,\n-    Status: resultado.status,\n-    Message: resultado.message,\n-    typeCredential: 'FIEL',\n-    typeRequest: resultado.typeRequest || 'soap'\n-  });\n+  while (current <= endFull) {\n+    let segmentEnd;\n+    if (tipoDescarga === 'received') {\n+      const nextMonth = new Date(current);\n+      nextMonth.setMonth(nextMonth.getMonth() + 1);\n+      nextMonth.setDate(0);\n+      segmentEnd = nextMonth;\n+    } else {\n+      const nextYear = new Date(current);\n+      nextYear.setFullYear(nextYear.getFullYear() + 1);\n+      segmentEnd = nextYear > endFull ? new Date(endFull) : new Date(nextYear);\n+    }\n \n-  return {\n-    ok: true,\n-    metodo: 'SOAP',\n-    idSolicitud: resultado.idSolicitud,\n-    status: resultado.status,\n-    message: resultado.message\n-  };\n-}\n+    segmentos.push({\n+      fechaInicio: formatDateOnly(current),\n+      fechaFin: formatDateOnly(segmentEnd)\n+    });\n \n-function isSatDownError(error) {\n-  return error && error.type === 'sat_down';\n+    current = new Date(segmentEnd);\n+    current.setDate(current.getDate() + 1);\n+  }\n+\n+  return segmentos;\n }\n \n export async function ejecutarDescargasParaConfigs({\n@@ -129,6 +107,14 @@ export async function ejecutarDescargasParaConfigs({\n     TotalClientes: configs.length\n   });\n \n+  await logInfo({\n+    contexto: 'MASIVA',\n+    mensaje: 'Ejecuci√≥n iniciada',\n+    usuarioId,\n+    ejecucionId: ejecucion.EjecucionId,\n+    meta: { tipoEjecucion, totalConfigs: configs.length }\n+  });\n+\n   const detalleResultados = [];\n   let totalSolicitudes = 0;\n   let clientesExitosos = 0;\n@@ -149,6 +135,13 @@ export async function ejecutarDescargasParaConfigs({\n           RecibidosStatus: config.DescargarRecibidos ? 'ERROR' : 'OMITIDO',\n           RecibidosError: 'Cliente no encontrado o sin RFC'\n         });\n+        await logWarn({\n+          contexto: 'MASIVA',\n+          mensaje: 'Cliente no encontrado o sin RFC, se omite',\n+          usuarioId,\n+          ejecucionId: ejecucion.EjecucionId,\n+          clienteFinalId: config.ClienteFinalId\n+        });\n       }\n       continue;\n     }\n@@ -187,6 +180,20 @@ export async function ejecutarDescargasParaConfigs({\n       RecibidosError: null\n     };\n \n+    await logInfo({\n+      contexto: 'MASIVA',\n+      mensaje: 'Procesando cliente',\n+      usuarioId,\n+      clienteFinalId: config.ClienteFinalId,\n+      ejecucionId: ejecucion.EjecucionId,\n+      meta: {\n+        emitidos: emitidosRango,\n+        recibidos: recibidosRango,\n+        tipoSolicitud,\n+        tipoComprobante\n+      }\n+    });\n+\n     for (const tipoDescarga of TIPOS_DESCARGA) {\n       if (tipoDescarga === 'issued' && !config.DescargarEmitidos) {\n         continue;\n@@ -204,78 +211,226 @@ export async function ejecutarDescargasParaConfigs({\n           detalle.RecibidosStatus = 'ERROR';\n           detalle.RecibidosError = 'Rango de fechas recibidos invalido';\n         }\n+        await logWarn({\n+          contexto: 'MASIVA',\n+          mensaje: 'Rango inv√°lido, se marca error',\n+          usuarioId,\n+          clienteFinalId: config.ClienteFinalId,\n+          ejecucionId: ejecucion.EjecucionId,\n+          meta: { tipoDescarga, tipoComprobante, tipoSolicitud }\n+        });\n         continue;\n       }\n \n       try {\n-        let resultado = null;\n-        if (fiel) {\n-          resultado = await procesarSolicitudSoap({\n-            cliente,\n-            fiel,\n-            fechaInicio: rango.fechaInicio,\n-            fechaFin: rango.fechaFin,\n-            tipoSolicitud,\n-            tipoComprobante,\n-            tipoDescarga,\n-            rfcEmisor: cliente.RFC,\n-            rfcReceptor: ''\n-          });\n-        } else {\n-          resultado = { ok: false, error: 'NO_FIEL' };\n-        }\n-\n-        if (resultado.ok) {\n-          totalSolicitudes++;\n-          if (tipoDescarga === 'issued') {\n-            detalle.EmitidosStatus = 'EXITOSO';\n-            detalle.EmitidosMetodo = resultado.metodo;\n-            detalle.EmitidosSolicitudId = resultado.idSolicitud;\n-          } else {\n-            detalle.RecibidosStatus = 'EXITOSO';\n-            detalle.RecibidosMetodo = resultado.metodo;\n-            detalle.RecibidosSolicitudId = resultado.idSolicitud;\n-          }\n-        } else {\n-          const fallback = await encolarScraping({\n-            clienteFinalId: config.ClienteFinalId,\n-            tipoDescarga,\n-            tipoComprobante,\n-            rfcEmisor: cliente.RFC,\n-            rfcReceptor: '',\n-            estadoComprobante,\n-            fechaInicio: rango.fechaInicio,\n-            fechaFin: rango.fechaFin,\n-            fiel,\n-            ciec\n-          });\n+        const segmentos = buildSegmentos(rango.fechaInicio, rango.fechaFin, tipoDescarga);\n+        let tuvoPendientes = false;\n+        let tuvoErrores = false;\n+        let tuvoResultados = false;\n+        let notaResultado = null;\n+\n+        const segmentosOrdenados = [...segmentos].reverse();\n+        for (let idx = 0; idx < segmentosOrdenados.length; idx++) {\n+          const segmento = segmentosOrdenados[idx];\n+          if (idx > 0) {\n+            const fallback = await encolarScraping({\n+              clienteFinalId: config.ClienteFinalId,\n+              tipoDescarga,\n+              tipoComprobante,\n+              rfcEmisor: cliente.RFC,\n+              rfcReceptor: '',\n+              estadoComprobante,\n+              fechaInicio: segmento.fechaInicio,\n+              fechaFin: segmento.fechaFin,\n+              fiel,\n+              ciec\n+            });\n \n-          if (fallback.ok) {\n             totalSolicitudes++;\n+            tuvoPendientes = true;\n+            await logInfo({\n+              contexto: 'MASIVA',\n+              mensaje: 'Segmento encolado para procesamiento posterior',\n+              usuarioId,\n+              clienteFinalId: config.ClienteFinalId,\n+              ejecucionId: ejecucion.EjecucionId,\n+              meta: { tipoDescarga, segmento, solicitudScraperId: fallback.solicitudId }\n+            });\n+            await sleep(getRandomDelay(1000, 3000));\n+            continue;\n+          }\n+          let resultado = null;\n+          if (fiel) {\n+            const passwordFiel = decrypt(fiel.Password);\n             if (tipoDescarga === 'issued') {\n-              detalle.EmitidosStatus = 'EXITOSO';\n-              detalle.EmitidosMetodo = fallback.metodo;\n-              detalle.EmitidosSolicitudId = fallback.solicitudId || null;\n-              detalle.EmitidosError = resultado.error || null;\n+              resultado = await solicitarYDescargarEmitidosFiel({\n+                key_base64: fiel.KeyBase64,\n+                cer_base64: fiel.CerBase64,\n+                password: passwordFiel,\n+                start_date: segmento.fechaInicio,\n+                end_date: segmento.fechaFin,\n+                rfc_receptor: '',\n+                estado_comprobante: estadoComprobante,\n+                complemento: tipoComprobante,\n+                clienteFinalId: config.ClienteFinalId,\n+                fielId: fiel.FielId,\n+                tipoDescarga\n+              });\n             } else {\n-              detalle.RecibidosStatus = 'EXITOSO';\n-              detalle.RecibidosMetodo = fallback.metodo;\n-              detalle.RecibidosSolicitudId = fallback.solicitudId || null;\n-              detalle.RecibidosError = resultado.error || null;\n+              resultado = await solicitarYDescargarRecibidosFiel({\n+                key_base64: fiel.KeyBase64,\n+                cer_base64: fiel.CerBase64,\n+                password: passwordFiel,\n+                start_date: segmento.fechaInicio,\n+                rfc_emisor: cliente.RFC,\n+                estado_comprobante: estadoComprobante,\n+                complemento: tipoComprobante,\n+                clienteFinalId: config.ClienteFinalId,\n+                fielId: fiel.FielId,\n+                tipoDescarga\n+              });\n             }\n-          } else {\n+          } else if (ciec) {\n+            const passwordCiec = decrypt(ciec.Password);\n             if (tipoDescarga === 'issued') {\n-              detalle.EmitidosStatus = 'ERROR';\n-              detalle.EmitidosError = fallback.error || resultado.error;\n+              resultado = await solicitarYDescargarEmitidosCiec({\n+                rfc: ciec.RFC,\n+                password: passwordCiec,\n+                start_date: segmento.fechaInicio,\n+                end_date: segmento.fechaFin,\n+                rfc_receptor: '',\n+                estado_comprobante: estadoComprobante,\n+                complemento: tipoComprobante,\n+                clienteFinalId: config.ClienteFinalId,\n+                ciecId: ciec.CiecId,\n+                tipoDescarga\n+              });\n             } else {\n-              detalle.RecibidosStatus = 'ERROR';\n-              detalle.RecibidosError = fallback.error || resultado.error;\n+              resultado = await solicitarYDescargarRecibidosCiec({\n+                rfc: ciec.RFC,\n+                password: passwordCiec,\n+                start_date: segmento.fechaInicio,\n+                rfc_emisor: cliente.RFC,\n+                estado_comprobante: estadoComprobante,\n+                complemento: tipoComprobante,\n+                clienteFinalId: config.ClienteFinalId,\n+                ciecId: ciec.CiecId,\n+                tipoDescarga\n+              });\n             }\n+          } else {\n+            resultado = { status: 'sat_error', message: 'El cliente no cuenta con credenciales disponibles.' };\n           }\n+\n+          totalSolicitudes++;\n+\n+          if (resultado?.status === 'completed') {\n+            tuvoResultados = true;\n+            await logInfo({\n+              contexto: 'MASIVA',\n+              mensaje: 'Paquete descargado y procesado en tiempo real',\n+              usuarioId,\n+              clienteFinalId: config.ClienteFinalId,\n+              ejecucionId: ejecucion.EjecucionId,\n+              meta: { tipoDescarga, segmento, tipoComprobante }\n+            });\n+          } else if (resultado?.status === 'not_found') {\n+            notaResultado = resultado.message || 'No se encontraron CFDIs con los parametros enviados.';\n+            await logInfo({\n+              contexto: 'MASIVA',\n+              mensaje: 'No se encontraron CFDIs con los parametros enviados',\n+              usuarioId,\n+              clienteFinalId: config.ClienteFinalId,\n+              ejecucionId: ejecucion.EjecucionId,\n+              meta: { tipoDescarga, segmento, tipoComprobante }\n+            });\n+          } else if (resultado?.status === 'pending') {\n+            tuvoPendientes = true;\n+            await crearSolicitudSat({\n+              ClienteFinalId: config.ClienteFinalId,\n+              FielId: fiel ? fiel.FielId : ciec?.CiecId,\n+              FechaInicio: segmento.fechaInicio,\n+              FechaFin: segmento.fechaFin,\n+              TipoSolicitud: tipoSolicitud,\n+              TipoComprobante: tipoComprobante,\n+              TipoDescarga: tipoDescarga,\n+              RfcEmisor: cliente.RFC,\n+              RfcReceptor: '',\n+              IdSolicitudSat: resultado.folio,\n+              Status: 5000,\n+              Message: resultado.message,\n+              typeCredential: fiel ? 'FIEL' : 'CIEC',\n+              typeRequest: 'scraping'\n+            });\n+            await logInfo({\n+              contexto: 'MASIVA',\n+              mensaje: 'Solicitud pendiente, se descargara en cron',\n+              usuarioId,\n+              clienteFinalId: config.ClienteFinalId,\n+              ejecucionId: ejecucion.EjecucionId,\n+              meta: { tipoDescarga, segmento, folio: resultado.folio }\n+            });\n+          } else if (resultado?.status === 'sat_down') {\n+            satDownDetected = true;\n+            await logWarn({\n+              contexto: 'MASIVA',\n+              mensaje: 'SAT no disponible, se detiene la ejecucion',\n+              usuarioId,\n+              clienteFinalId: config.ClienteFinalId,\n+              ejecucionId: ejecucion.EjecucionId,\n+              meta: { tipoDescarga, segmento }\n+            });\n+            break;\n+          } else {\n+            tuvoErrores = true;\n+            const fallback = await encolarScraping({\n+              clienteFinalId: config.ClienteFinalId,\n+              tipoDescarga,\n+              tipoComprobante,\n+              rfcEmisor: cliente.RFC,\n+              rfcReceptor: '',\n+              estadoComprobante,\n+              fechaInicio: segmento.fechaInicio,\n+              fechaFin: segmento.fechaFin,\n+              fiel,\n+              ciec\n+            });\n+            await logWarn({\n+              contexto: 'MASIVA',\n+              mensaje: 'Respuesta inesperada, se encola para reintento',\n+              usuarioId,\n+              clienteFinalId: config.ClienteFinalId,\n+              ejecucionId: ejecucion.EjecucionId,\n+              meta: { tipoDescarga, segmento, error: resultado?.message, solicitudScraperId: fallback.solicitudId }\n+            });\n+          }\n+\n+          await sleep(getRandomDelay(1000, 3000));\n+        }\n+\n+        if (satDownDetected) {\n+          break;\n+        }\n+\n+        if (tipoDescarga === 'issued') {\n+          detalle.EmitidosStatus = tuvoErrores ? 'ERROR' : 'EXITOSO';\n+          detalle.EmitidosMetodo = 'SCRAPING';\n+          detalle.EmitidosError = notaResultado || (tuvoPendientes ? 'Pendiente de descarga' : null);\n+        } else {\n+          detalle.RecibidosStatus = tuvoErrores ? 'ERROR' : 'EXITOSO';\n+          detalle.RecibidosMetodo = 'SCRAPING';\n+          detalle.RecibidosError = notaResultado || (tuvoPendientes ? 'Pendiente de descarga' : null);\n         }\n       } catch (error) {\n         if (isSatDownError(error)) {\n           satDownDetected = true;\n+          await logWarn({\n+            contexto: 'MASIVA',\n+            mensaje: 'SAT no disponible, se detiene la ejecuci√≥n',\n+            usuarioId,\n+            ejecucionId: ejecucion.EjecucionId,\n+            clienteFinalId: config.ClienteFinalId\n+          });\n           break;\n         }\n         if (tipoDescarga === 'issued') {\n@@ -285,9 +440,16 @@ export async function ejecutarDescargasParaConfigs({\n           detalle.RecibidosStatus = 'ERROR';\n           detalle.RecibidosError = error.message || String(error);\n         }\n+        await logError({\n+          contexto: 'MASIVA',\n+          mensaje: 'Error procesando solicitud',\n+          usuarioId,\n+          clienteFinalId: config.ClienteFinalId,\n+          ejecucionId: ejecucion.EjecucionId,\n+          meta: { tipoDescarga, error: error.message || String(error) }\n+        });\n       }\n \n-      await sleep(getRandomDelay(1000, 3000));\n     }\n \n     if (satDownDetected) {\n@@ -331,9 +493,24 @@ export async function ejecutarDescargasParaConfigs({\n       Detalle: detalleJson,\n       FinalizadoEn: new Date()\n     });\n+\n+    await logInfo({\n+      contexto: 'MASIVA',\n+      mensaje: 'Ejecuci√≥n finalizada',\n+      usuarioId,\n+      ejecucionId: ejecucion.EjecucionId,\n+      meta: { estadoFinal, clientesExitosos, clientesConError, totalSolicitudes, totalClientes: configs.length }\n+    });\n   }\n \n   if (satDownDetected) {\n+    await logWarn({\n+      contexto: 'MASIVA',\n+      mensaje: 'Ejecuci√≥n marcada como pendiente por SAT ca√≠do',\n+      usuarioId,\n+      ejecucionId: ejecucion.EjecucionId,\n+      meta: { clientesExitosos, clientesConError, totalSolicitudes, totalClientes: configs.length }\n+    });\n     return {\n       ejecucionId: ejecucion.EjecucionId,\n       estado: 'PENDIENTE',\ndiff --git a/src/services/FielService.mjs b/src/services/FielService.mjs\nindex 0f74846..d1d2d0e 100644\n--- a/src/services/FielService.mjs\n+++ b/src/services/FielService.mjs\n@@ -305,4 +305,203 @@ export async function scrapingFielRecibidosService(key_path, cer_path, password,\n     const errorMsg = error.response?.data?.error || error.response?.data?.message || error.message || error;\n     throw new Error(errorMsg);\n   }\n-}\n\\ No newline at end of file\n+}\n+\n+/**\n+ * Solicita Y descarga emitidos en un solo paso via FIEL (endpoint unificado).\n+ */\n+export async function solicitarYDescargarEmitidosFiel({\n+  key_base64,\n+  cer_base64,\n+  password,\n+  start_date,\n+  end_date,\n+  rfc_receptor,\n+  estado_comprobante,\n+  complemento,\n+  clienteFinalId,\n+  fielId,\n+  tipoDescarga\n+}) {\n+  try {\n+    console.log(`[FIEL-Emitidos] Solicitar+Descargar ${start_date} a ${end_date} para cliente ${clienteFinalId}`);\n+    const response = await axios.post(`${SCRAPER_BASE_URL}solicitarYDescargarEmitidosFiel`, {\n+      key_base64,\n+      cer_base64,\n+      password,\n+      start_date,\n+      end_date,\n+      rfc_receptor: rfc_receptor || '',\n+      estado_comprobante: estado_comprobante || '',\n+      complemento: complemento || '',\n+      download_attempts: 3,\n+      retry_delay_sec: 10,\n+      headless: true,\n+      timeout_ms: 900000,\n+      wait_after_ms: 1000\n+    }, {\n+      headers: { 'Content-Type': 'application/json' },\n+      responseType: 'arraybuffer',\n+      timeout: 960000\n+    });\n+\n+    return await procesarRespuestaUnificada(response, clienteFinalId, fielId, tipoDescarga || 'issued', 'FIEL');\n+  } catch (error) {\n+    return manejarErrorUnificado(error, 'FIEL-Emitidos');\n+  }\n+}\n+\n+/**\n+ * Solicita Y descarga recibidos en un solo paso via FIEL (endpoint unificado).\n+ */\n+export async function solicitarYDescargarRecibidosFiel({\n+  key_base64,\n+  cer_base64,\n+  password,\n+  start_date,\n+  rfc_emisor,\n+  estado_comprobante,\n+  complemento,\n+  clienteFinalId,\n+  fielId,\n+  tipoDescarga\n+}) {\n+  try {\n+    const response = await axios.post(`${SCRAPER_BASE_URL}solicitarYDescargarRecibidosFiel`, {\n+      key_base64,\n+      cer_base64,\n+      password,\n+      start_date,\n+      rfc_emisor: rfc_emisor || '',\n+      estado_comprobante: estado_comprobante || '',\n+      complemento: complemento || '',\n+      download_attempts: 3,\n+      retry_delay_sec: 10,\n+      headless: true,\n+      timeout_ms: 900000,\n+      wait_after_ms: 1000\n+    }, {\n+      headers: { 'Content-Type': 'application/json' },\n+      responseType: 'arraybuffer',\n+      timeout: 960000\n+    });\n+\n+    return await procesarRespuestaUnificada(response, clienteFinalId, fielId, tipoDescarga || 'received', 'FIEL');\n+  } catch (error) {\n+    return manejarErrorUnificado(error, 'FIEL-Recibidos');\n+  }\n+}\n+\n+async function procesarRespuestaUnificada(response, clienteFinalId, credentialId, tipoDescarga, typeCredential) {\n+  const contentType = response.headers['content-type'] || '';\n+  console.log(`Respuesta recibida con content-type: ${contentType}`);\n+  \n+  if (contentType.includes('application/zip')) {\n+    return await procesarZipResponse(response.data, clienteFinalId, credentialId, tipoDescarga, typeCredential);\n+  }\n+  \n+  console.log(`Respuesta recibida:`, response.data);\n+  let jsonData;\n+  try {\n+    const textData = Buffer.from(response.data).toString('utf-8');\n+    jsonData = JSON.parse(textData);\n+  } catch (e) {\n+    try {\n+      return await procesarZipResponse(response.data, clienteFinalId, credentialId, tipoDescarga, typeCredential);\n+    } catch (zipErr) {\n+      return { status: 'sat_error', message: 'Respuesta no reconocida del servidor de scraping' };\n+    }\n+  }\n+  console.log(`Respuesta recibida con content-type:`, jsonData);\n+\n+  if (jsonData.ok && jsonData.data && jsonData.data.file_b64) {\n+    const zipBuffer = Buffer.from(jsonData.data.file_b64, 'base64');\n+    return await procesarZipResponse(zipBuffer, clienteFinalId, credentialId, tipoDescarga, typeCredential);\n+  }\n+\n+  if (jsonData.status === 'not_found') {\n+    return { status: 'not_found', message: jsonData.message || 'No se encontraron CFDIs con los parametros enviados.' };\n+  }\n+\n+  if (jsonData.status === 'pending') {\n+    return {\n+      status: 'pending',\n+      folio: jsonData.folio,\n+      message: jsonData.message || 'Solicitud creada. El paquete aun no esta disponible para descarga.',\n+      download_attempts: jsonData.download_attempts\n+    };\n+  }\n+\n+  if (jsonData.ok === false) {\n+    const rawError = jsonData.error || jsonData.reason || jsonData.message || 'Error desconocido';\n+    const isSatDown = rawError.includes('net::ERR_CONNECTION_TIMED_OUT') ||\n+      rawError.includes('Timeout 30000ms exceeded') ||\n+      rawError.includes('ERR_CONNECTION_RESET');\n+    if (isSatDown) {\n+      return { status: 'sat_down', message: 'El servicio del SAT no esta disponible en este momento.', type: 'sat_down' };\n+    }\n+    return { status: 'sat_down', message: 'El servicio del SAT no esta disponible en este momento.', type: 'sat_down' };\n+  }\n+\n+  return { status: 'sat_down', message: 'El servicio del SAT no esta disponible en este momento.', type: 'sat_down' };\n+}\n+\n+async function procesarZipResponse(zipBuffer, clienteFinalId, credentialId, tipoDescarga, typeCredential) {\n+  const zip = new AdmZip(zipBuffer);\n+  const zipEntries = zip.getEntries();\n+  let guardados = 0;\n+  let errores = 0;\n+\n+  for (const entry of zipEntries) {\n+    if (entry.isDirectory || entry.entryName.includes('__MACOSX')) continue;\n+\n+    if (entry.entryName.toLowerCase().endsWith('.xml')) {\n+      try {\n+        const xmlText = zip.readAsText(entry);\n+        const cfdi = parseCfdiXml(xmlText);\n+        if (cfdi) {\n+          cfdi.TipoDescarga = tipoDescarga;\n+          const fId = Number(credentialId);\n+          await guardarCfdiCompleto(cfdi, clienteFinalId, fId || credentialId, typeCredential);\n+          guardados++;\n+        } else {\n+          console.warn(`No se pudo parsear XML: ${entry.entryName}`);\n+          errores++;\n+        }\n+      } catch (e) {\n+        console.error(`Error procesando archivo ${entry.entryName}:`, e.message);\n+        errores++;\n+      }\n+    }\n+  }\n+\n+  console.log(`[${typeCredential}] ZIP procesado. Guardados: ${guardados}, Errores: ${errores}`);\n+  return { status: 'completed', guardados, errores, message: `Se procesaron ${guardados} comprobantes exitosamente.` };\n+}\n+\n+function manejarErrorUnificado(error, contexto) {\n+  if (error.response ) {\n+    try {\n+      const textData = Buffer.from(error.response.data).toString('utf-8');\n+      console.log(`Error en ${contexto}:`, textData);\n+      const errorData = JSON.parse(textData);\n+\n+      if (errorData.status === 'not_found') {\n+        return { status: 'not_found', message: errorData.message };\n+      }\n+      if (errorData.status === 'pending') {\n+        return { status: 'pending', folio: errorData.folio, message: errorData.message };\n+      } else {\n+        return { status: 'sat_down', message: 'El servicio del SAT no esta disponible en este momento.', type: 'sat_down' };\n+      }\n+    } catch (e) {\n+      // ignore parse errors\n+    }\n+  }\n+\n+  if (error.code === 'ECONNREFUSED' || error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {\n+    return { status: 'sat_error', message: `No se pudo conectar al servidor de scraping: ${error.code}` };\n+  }\n+\n+  return { status: 'sat_error', message: error.message || 'Error desconocido en el proceso de descarga' };\n+}\ndiff --git a/src/services/SatDescargaService.mjs b/src/services/SatDescargaService.mjs\nindex 3146ec7..298d3a1 100644\n--- a/src/services/SatDescargaService.mjs\n+++ b/src/services/SatDescargaService.mjs\n@@ -18,7 +18,7 @@ import AdmZip from 'adm-zip';\n import fs from 'fs';\n import path from 'path';\n import { parseStringPromise } from 'xml2js';\n-import { scrapingFielService } from './FielService.mjs';\n+import { logInfo, logWarn } from '../utils/logger.mjs';\n \n // export async function descargarCfdiPorRango({\n //   cerBuffer,\n@@ -128,6 +128,12 @@ export async function descargarCfdiPorRango({\n     throw new Error('La fecha inicial no puede ser mayor que la final');\n   }\n \n+  await logInfo({\n+    contexto: 'SOAP',\n+    mensaje: 'Preparando solicitud de descarga',\n+    meta: { tipoSolicitud, tipoComprobante, tipoDescarga, fechaInicio, fechaFin, rfcEmisor, rfcReceptor }\n+  });\n+\n   const cer = cerBuffer.toString('binary');\n   const key = keyBuffer.toString('binary');\n   let fiel;\n@@ -158,7 +164,11 @@ export async function descargarCfdiPorRango({\n     // ‚úÖ FORZAR ESTADO \"ACTIVOS\" PARA XML RECIBIDOS (SAT no permite cancelados en recibidos XML)\n     if (tipoDescarga === 'received' && reqType === 'xml') {\n       p = p.withDocumentStatus(new DocumentStatus('active'));\n-      console.log('üîí Filtro aplicado: solo documentos VIGENTES (received + xml)');\n+      logInfo({\n+        contexto: 'SOAP',\n+        mensaje: 'Filtro aplicado: solo documentos vigentes (received + xml)',\n+        meta: { tipoDescarga, reqType }\n+      }).catch(() => {});\n     }\n \n     if (tipoComprobante) {\n@@ -180,16 +190,34 @@ export async function descargarCfdiPorRango({\n   const code = query.getStatus().getCode();\n   const errors = params.validate();\n   if (errors.length > 0) {\n-    console.log('Query errors:');\n-    errors.forEach((error) => {\n-      console.log(`  - ${error}`);\n+    await logWarn({\n+      contexto: 'SOAP',\n+      mensaje: 'Errores de validaci√≥n en query SAT',\n+      meta: { errors, tipoDescarga, tipoSolicitud }\n     });\n   }\n   const message = query.getStatus().getMessage() || '';\n \n-  console.log(`Solicitud inicial (${tipoSolicitud}) c√≥digo=${code} mensaje=\"${message}\"`);\n+  await logInfo({\n+    contexto: 'SOAP',\n+    mensaje: `Solicitud inicial (${tipoSolicitud}) c√≥digo=${code}`,\n+    meta: {\n+      message,\n+      tipoDescarga,\n+      tipoComprobante,\n+      rfcEmisor,\n+      rfcReceptor,\n+      fechaInicio,\n+      fechaFin\n+    }\n+  });\n \n   if (!query.getStatus().isAccepted()) {\n+    await logWarn({\n+      contexto: 'SOAP',\n+      mensaje: 'Solicitud SAT no aceptada',\n+      meta: { code, message, errors, tipoDescarga, tipoSolicitud }\n+    });\n     return {\n       \"tipo\": \"error_solicitud_soap\",\n       \"error\": errors\ndiff --git a/src/utils/logger.mjs b/src/utils/logger.mjs\nnew file mode 100644\nindex 0000000..3246f4e\n--- /dev/null\n+++ b/src/utils/logger.mjs\n@@ -0,0 +1,85 @@\n+import winston from 'winston';\n+import { poolPromise, sql } from '../config/DbConfig.mjs';\n+\n+const LOG_LEVEL = process.env.LOG_LEVEL || 'info';\n+const LOG_TO_DB = (process.env.LOG_TO_DB || 'true').toLowerCase() !== 'false';\n+const EMIT_SOCKET = (process.env.LOG_TO_SOCKET || 'true').toLowerCase() !== 'false';\n+\n+const logger = winston.createLogger({\n+  level: LOG_LEVEL,\n+  format: winston.format.combine(\n+    winston.format.timestamp(),\n+    winston.format.errors({ stack: true }),\n+    winston.format.json()\n+  ),\n+  transports: [new winston.transports.Console({ level: LOG_LEVEL })]\n+});\n+\n+function safeStringify(meta) {\n+  if (meta == null) return null;\n+  try {\n+    return JSON.stringify(meta);\n+  } catch (err) {\n+    return JSON.stringify({ metaStringifyError: err.message || String(err) });\n+  }\n+}\n+\n+async function persistLog({ nivel, contexto, mensaje, usuarioId, clienteFinalId, solicitudId, ejecucionId, metaString }) {\n+  if (!LOG_TO_DB) return;\n+  try {\n+    const pool = await poolPromise;\n+    await pool.request()\n+      .input('Nivel', sql.VarChar(10), nivel)\n+      .input('Contexto', sql.VarChar(50), contexto)\n+      .input('Mensaje', sql.VarChar(400), mensaje)\n+      .input('UsuarioId', sql.Int, usuarioId ?? null)\n+      .input('ClienteFinalId', sql.Int, clienteFinalId ?? null)\n+      .input('SolicitudId', sql.Int, solicitudId ?? null)\n+      .input('EjecucionId', sql.Int, ejecucionId ?? null)\n+      .input('Meta', sql.NVarChar(sql.MAX), metaString)\n+      .query(`\n+        INSERT INTO AppLogs (\n+          Nivel, Contexto, Mensaje, UsuarioId, ClienteFinalId, SolicitudId, EjecucionId, Meta\n+        ) VALUES (\n+          @Nivel, @Contexto, @Mensaje, @UsuarioId, @ClienteFinalId, @SolicitudId, @EjecucionId, @Meta\n+        )\n+      `);\n+  } catch (err) {\n+    logger.warn('No se pudo guardar log en BD', { error: err.message });\n+  }\n+}\n+\n+function emitSocket({ nivel, contexto, mensaje, usuarioId, clienteFinalId, solicitudId, ejecucionId, meta, ts }) {\n+  if (!EMIT_SOCKET || !global.io) return;\n+  const payload = { nivel, contexto, mensaje, usuarioId, clienteFinalId, solicitudId, ejecucionId, meta, ts };\n+  if (usuarioId) {\n+    global.io.to(`user_${usuarioId}`).emit('log:update', payload);\n+  } else {\n+    global.io.emit('log:update', payload);\n+  }\n+}\n+\n+export async function logEvent({\n+  level = 'info',\n+  contexto = 'GENERAL',\n+  mensaje,\n+  usuarioId = null,\n+  clienteFinalId = null,\n+  solicitudId = null,\n+  ejecucionId = null,\n+  meta = null,\n+  emitSocketEvent = true\n+}) {\n+  if (!mensaje) return;\n+  const ts = new Date().toISOString();\n+  logger.log({ level, message: `[${contexto}] ${mensaje}`, usuarioId, clienteFinalId, solicitudId, ejecucionId, meta });\n+  const metaString = safeStringify(meta);\n+  await persistLog({ nivel: level, contexto, mensaje, usuarioId, clienteFinalId, solicitudId, ejecucionId, metaString });\n+  if (emitSocketEvent) {\n+    emitSocket({ nivel: level, contexto, mensaje, usuarioId, clienteFinalId, solicitudId, ejecucionId, meta, ts });\n+  }\n+}\n+\n+export const logInfo = (params) => logEvent({ ...params, level: 'info' });\n+export const logWarn = (params) => logEvent({ ...params, level: 'warn' });\n+export const logError = (params) => logEvent({ ...params, level: 'error' });\n"
test_patch: ''
fail_to_pass:
- node --experimental-vm-modules ./node_modules/.bin/jest tests/logs-controller.test.mjs
pass_to_pass:
- node -e "import('./src/utils/ParseCfdiXml.mjs').then(m=>console.log(typeof m.parseCfdiXml))"
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '1303'
  difficulty: hard
  files_changed: '12'
  pr_title: kevin-dev
  removed_lines: '496'
  source: gh-archive-pr
  test_files: '[{"path":"tests/logs-controller.test.mjs","content":"import { jest } from ''@jest/globals'';\n\nconst inputCalls = [];\nconst queryMock = jest.fn();\nconst request = {\n  input: jest.fn((name, type, value) => {\n    inputCalls.push({ name, type, value });\n    return request;\n  }),\n  query: queryMock\n};\nconst requestMock = jest.fn(() => request);\n\nawait jest.unstable_mockModule(''../src/config/DbConfig.mjs'', () => ({\n  poolPromise: Promise.resolve({ request: requestMock }),\n  sql: { Int: ''IntType'' }\n}));\n\nconst { listarLogsController } = await import(''../src/controllers/LogsController.mjs'');\n\nfunction buildRes() {\n  const res = {};\n  res.status = jest.fn(() => res);\n  res.json = jest.fn(() => res);\n  return res;\n}\n\nbeforeEach(() => {\n  inputCalls.length = 0;\n  queryMock.mockReset();\n  requestMock.mockClear();\n  request.input.mockClear();\n});\n\ntest(''listarLogsController rejects unauthenticated users'', async () => {\n  const req = { usuario: null, query: {} };\n  const res = buildRes();\n\n  await listarLogsController(req, res);\n\n  expect(res.status).toHaveBeenCalledWith(401);\n  expect(res.json).toHaveBeenCalledWith({ error: ''Usuario no autenticado'' });\n  expect(queryMock).not.toHaveBeenCalled();\n});\n\ntest(''listarLogsController clamps limit to max and returns logs'', async () => {\n  const req = { usuario: { usuarioId: 42 }, query: { limit: ''500'' } };\n  const res = buildRes();\n  const fakeLogs = [{ LogId: 1 }, { LogId: 2 }];\n  queryMock.mockResolvedValue({ recordset: fakeLogs });\n\n  await listarLogsController(req, res);\n\n  expect(inputCalls).toContainEqual({ name: ''UsuarioId'', type: ''IntType'', value: 42 });\n  expect(inputCalls).toContainEqual({ name: ''Limit'', type: ''IntType'', value: 200 });\n  expect(res.json).toHaveBeenCalledWith({ ok: true, limit: 200, logs: fakeLogs });\n});\n\ntest(''listarLogsController normalizes invalid and low limits'', async () => {\n  const res = buildRes();\n  queryMock.mockResolvedValue({ recordset: [] });\n\n  const reqLow = { usuario: { usuarioId: 7 }, query: { limit: ''0'' } };\n  await listarLogsController(reqLow, res);\n  expect(inputCalls).toContainEqual({ name: ''Limit'', type: ''IntType'', value: 1 });\n\n  inputCalls.length = 0;\n  const reqInvalid = { usuario: { usuarioId: 7 }, query: { limit: ''abc'' } };\n  await listarLogsController(reqInvalid, res);\n  expect(inputCalls).toContainEqual({ name: ''Limit'', type: ''IntType'', value: 10 });\n});\n"}]'
  test_generation: agentic-docker
prompt: |-
  DPorvenir/Sat_Project_Back (#28): kevin-dev

  Mejorar la velocidad del scrapper. El objetivo es que el proceso de scraping termine m√°s r√°pido manteniendo el mismo comportamiento y resultados visibles para el usuario, sin cambiar la funcionalidad esperada.
original_pr_body: |-
  DPorvenir/Sat_Project_Back (#28): kevin-dev

  avances de mejora de velocidad del scrapper
quality_score: 0.78
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
