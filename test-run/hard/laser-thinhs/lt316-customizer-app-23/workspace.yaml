id: laser-thinhs/lt316-customizer-app-23
repo: laser-thinhs/lt316-customizer-app
base_commit: 7803fb9077e83e78fb7b21c364ef0ff54adab802
merge_commit: c19a9e638a433b6841d30162c67f32b591076bd1
language: typescript
difficulty_score: 3
created_at: 2026-02-17T09:42:39.324489792Z
patch: |
  diff --git a/lib/tracing-core/index.ts b/lib/tracing-core/index.ts
  new file mode 100644
  index 0000000..16ad906
  --- /dev/null
  +++ b/lib/tracing-core/index.ts
  @@ -0,0 +1,239 @@
  +import { z } from "zod";
  +
  +const PNG_SIGNATURE = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
  +
  +const DEFAULT_MAX_UPLOAD_MB = Number(process.env.MAX_UPLOAD_MB ?? 10);
  +const DEFAULT_MAX_DIMENSION = Number(process.env.MAX_DIMENSION ?? 2000);
  +const DEFAULT_MIN_SPECK_AREA = Number(process.env.MIN_SPECK_AREA ?? 6);
  +
  +const CoreErrorShape = z.object({
  +  code: z.string(),
  +  message: z.string(),
  +  details: z.unknown().optional()
  +});
  +
  +export type CoreError = z.infer<typeof CoreErrorShape>;
  +
  +export class TracerCoreError extends Error {
  +  code: string;
  +  details?: unknown;
  +
  +  constructor(code: string, message: string, details?: unknown) {
  +    super(message);
  +    this.code = code;
  +    this.details = details;
  +  }
  +
  +  toJSON(): CoreError {
  +    return { code: this.code, message: this.message, details: this.details };
  +  }
  +}
  +
  +export const TracerSettingsSchema = z.object({
  +  mode: z.enum(["auto", "bw", "color"]).default("auto"),
  +  threshold: z.number().int().min(0).max(255).default(165),
  +  smoothing: z.number().min(0).max(20).default(2),
  +  despeckle: z.number().min(0).max(20).default(3),
  +  simplify: z.number().min(0).max(20).default(2),
  +  invert: z.boolean().default(false),
  +  removeBackground: z.boolean().default(true),
  +  bgTolerance: z.number().int().min(0).max(255).default(18),
  +  output: z.enum(["fill", "stroke"]).default("fill"),
  +  strokeWidth: z.number().min(0.1).max(20).optional(),
  +  outlineMode: z.boolean().default(false),
  +  minSpeckArea: z.number().min(0).default(DEFAULT_MIN_SPECK_AREA)
  +}).transform((input) => ({
  +  ...input,
  +  strokeWidth: input.output === "stroke" || input.outlineMode ? (input.strokeWidth ?? 1) : input.strokeWidth
  +}));
  +
  +export type TracerSettings = z.infer<typeof TracerSettingsSchema>;
  +
  +export type TraceResult = {
  +  svg: string;
  +  width: number;
  +  height: number;
  +  viewBox: string;
  +  stats: {
  +    elapsedMs: number;
  +    fallback: boolean;
  +    pathsRemoved: number;
  +    modeUsed: TracerSettings["mode"];
  +  };
  +};
  +
  +function readPngDimensions(buffer: Buffer): { width: number; height: number } | null {
  +  if (buffer.length < 24 || !buffer.subarray(0, 8).equals(PNG_SIGNATURE)) {
  +    return null;
  +  }
  +
  +  return {
  +    width: buffer.readUInt32BE(16),
  +    height: buffer.readUInt32BE(20)
  +  };
  +}
  +
  +function readJpegDimensions(buffer: Buffer): { width: number; height: number } | null {
  +  if (buffer.length < 4 || buffer[0] !== 0xff || buffer[1] !== 0xd8) {
  +    return null;
  +  }
  +
  +  let offset = 2;
  +  while (offset < buffer.length) {
  +    if (buffer[offset] !== 0xff) {
  +      offset += 1;
  +      continue;
  +    }
  +
  +    const marker = buffer[offset + 1];
  +    if (!marker || marker === 0xd9 || marker === 0xda) {
  +      break;
  +    }
  +
  +    const segmentLength = buffer.readUInt16BE(offset + 2);
  +    const isSof = marker >= 0xc0 && marker <= 0xcf && ![0xc4, 0xc8, 0xcc].includes(marker);
  +    if (isSof) {
  +      return {
  +        height: buffer.readUInt16BE(offset + 5),
  +        width: buffer.readUInt16BE(offset + 7)
  +      };
  +    }
  +
  +    offset += 2 + segmentLength;
  +  }
  +
  +  return null;
  +}
  +
  +function getDimensions(buffer: Buffer, mime: string) {
  +  if (mime === "image/png") {
  +    return readPngDimensions(buffer);
  +  }
  +  if (mime === "image/jpeg") {
  +    return readJpegDimensions(buffer);
  +  }
  +  return null;
  +}
  +
  +function toPathBBox(pathD: string): { area: number } {
  +  const values = pathD.match(/-?\d*\.?\d+/g)?.map(Number) ?? [];
  +  if (values.length < 4) {
  +    return { area: Number.POSITIVE_INFINITY };
  +  }
  +
  +  const xs: number[] = [];
  +  const ys: number[] = [];
  +  for (let i = 0; i < values.length - 1; i += 2) {
  +    xs.push(values[i]);
  +    ys.push(values[i + 1]);
  +  }
  +
  +  const width = Math.max(...xs) - Math.min(...xs);
  +  const height = Math.max(...ys) - Math.min(...ys);
  +  return { area: Math.max(width * height, 0) };
  +}
  +
  +export function normalizeSvg(rawSvg: string, width: number, height: number, minSpeckArea = DEFAULT_MIN_SPECK_AREA): { svg: string; pathsRemoved: number } {
  +  let svg = rawSvg
  +    .replace(/<\/?metadata[^>]*>/gi, "")
  +    .replace(/<\/?title[^>]*>/gi, "")
  +    .replace(/<\/?desc[^>]*>/gi, "")
  +    .replace(/\s(width|height)="([0-9.]+)(pt|cm|mm|in)"/gi, (_m, key, val) => ` ${key}="${val}px"`);
  +
  +  const hasViewBox = /viewBox=/i.test(svg);
  +  if (!hasViewBox) {
  +    svg = svg.replace(/<svg\b/i, `<svg viewBox=\"0 0 ${width} ${height}\"`);
  +  }
  +
  +  svg = svg
  +    .replace(/\swidth="[^"]*"/i, ` width="${width}px"`)
  +    .replace(/\sheight="[^"]*"/i, ` height="${height}px"`);
  +
  +  let pathsRemoved = 0;
  +  svg = svg.replace(/<path\b[^>]*d="([^"]+)"[^>]*\/?>(?:<\/path>)?/gi, (full, d) => {
  +    const bbox = toPathBBox(d);
  +    if (bbox.area < minSpeckArea) {
  +      pathsRemoved += 1;
  +      return "";
  +    }
  +    return full;
  +  });
  +
  +  return { svg, pathsRemoved };
  +}
  +
  +export function normalizeTracerError(error: unknown): CoreError {
  +  if (error instanceof TracerCoreError) {
  +    return error.toJSON();
  +  }
  +
  +  return {
  +    code: "TRACE_INTERNAL_ERROR",
  +    message: "Failed to trace image"
  +  };
  +}
  +
  +function buildFallbackSvg(width: number, height: number, settings: TracerSettings, buffer: Buffer, mime: string) {
  +  const dataUri = `data:${mime};base64,${buffer.toString("base64")}`;
  +  const strokeOnly = settings.output === "stroke" || settings.outlineMode;
  +  if (strokeOnly) {
  +    return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}"><rect x="0.5" y="0.5" width="${Math.max(width - 1, 1)}" height="${Math.max(height - 1, 1)}" fill="none" stroke="black" stroke-width="${settings.strokeWidth ?? 1}"/></svg>`;
  +  }
  +
  +  return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}"><image href="${dataUri}" width="${width}" height="${height}" /></svg>`;
  +}
  +
  +export async function traceRasterToSvg(
  +  input: { buffer: Buffer; mime: string; filename?: string },
  +  settingsInput: unknown
  +): Promise<TraceResult> {
  +  const started = Date.now();
  +  const maxUploadBytes = DEFAULT_MAX_UPLOAD_MB * 1024 * 1024;
  +  const allowedMime = new Set(["image/png", "image/jpeg"]);
  +
  +  if (!allowedMime.has(input.mime)) {
  +    throw new TracerCoreError("UNSUPPORTED_MIME", "Only PNG and JPEG uploads are allowed", { mime: input.mime });
  +  }
  +
  +  if (input.buffer.byteLength > maxUploadBytes) {
  +    throw new TracerCoreError("FILE_TOO_LARGE", `File exceeds ${DEFAULT_MAX_UPLOAD_MB}MB limit`, {
  +      limitMb: DEFAULT_MAX_UPLOAD_MB,
  +      sizeBytes: input.buffer.byteLength
  +    });
  +  }
  +
  +  const parsedSettings = TracerSettingsSchema.safeParse(settingsInput ?? {});
  +  if (!parsedSettings.success) {
  +    throw new TracerCoreError("INVALID_SETTINGS", "Invalid tracer settings", parsedSettings.error.flatten());
  +  }
  +
  +  const settings = parsedSettings.data;
  +  const dimensions = getDimensions(input.buffer, input.mime);
  +  if (!dimensions) {
  +    throw new TracerCoreError("INVALID_IMAGE", "Unable to parse image dimensions");
  +  }
  +
  +  if (dimensions.width > DEFAULT_MAX_DIMENSION || dimensions.height > DEFAULT_MAX_DIMENSION) {
  +    throw new TracerCoreError("DIMENSION_LIMIT_EXCEEDED", `Max dimension is ${DEFAULT_MAX_DIMENSION}px`, {
  +      width: dimensions.width,
  +      height: dimensions.height,
  +      maxDimension: DEFAULT_MAX_DIMENSION
  +    });
  +  }
  +
  +  const rawSvg = buildFallbackSvg(dimensions.width, dimensions.height, settings, input.buffer, input.mime);
  +  const normalized = normalizeSvg(rawSvg, dimensions.width, dimensions.height, settings.minSpeckArea);
  +
  +  return {
  +    svg: normalized.svg,
  +    width: dimensions.width,
  +    height: dimensions.height,
  +    viewBox: `0 0 ${dimensions.width} ${dimensions.height}`,
  +    stats: {
  +      elapsedMs: Date.now() - started,
  +      fallback: true,
  +      pathsRemoved: normalized.pathsRemoved,
  +      modeUsed: settings.mode
  +    }
  +  };
  +}
  diff --git a/src/__tests__/tracer.route.integration.test.ts b/src/__tests__/tracer.route.integration.test.ts
  new file mode 100644
  index 0000000..60fc23c
  --- /dev/null
  +++ b/src/__tests__/tracer.route.integration.test.ts
  @@ -0,0 +1,24 @@
  +import { POST } from "@/app/api/tracer/route";
  +
  +const TINY_PNG = Buffer.from(
  +  "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO7Z0t8AAAAASUVORK5CYII=",
  +  "base64"
  +);
  +
  +describe("tracer route integration", () => {
  +  it("returns svg with viewBox and ok shape", async () => {
  +    const form = new FormData();
  +    form.append("file", new File([TINY_PNG], "tiny.png", { type: "image/png" }));
  +    form.append("settings", JSON.stringify({ output: "fill" }));
  +
  +    const req = new Request("http://localhost/api/tracer", { method: "POST", body: form });
  +    const res = await POST(req);
  +    const json = await res.json();
  +
  +    expect(res.status).toBe(200);
  +    expect(json.ok).toBe(true);
  +    expect(json.result.svg).toContain("<svg");
  +    expect(json.result.svg).toContain("viewBox");
  +    expect(typeof json.requestId).toBe("string");
  +  });
  +});
  diff --git a/src/__tests__/tracing-core.test.ts b/src/__tests__/tracing-core.test.ts
  new file mode 100644
  index 0000000..f67ccc9
  --- /dev/null
  +++ b/src/__tests__/tracing-core.test.ts
  @@ -0,0 +1,27 @@
  +import { normalizeSvg, TracerSettingsSchema } from "../../lib/tracing-core";
  +
  +describe("tracing-core", () => {
  +  it("applies sane defaults", () => {
  +    const parsed = TracerSettingsSchema.parse({});
  +
  +    expect(parsed.threshold).toBe(165);
  +    expect(parsed.output).toBe("fill");
  +    expect(parsed.removeBackground).toBe(true);
  +    expect(parsed.strokeWidth).toBeUndefined();
  +  });
  +
  +  it("normalizes stroke defaults", () => {
  +    const parsed = TracerSettingsSchema.parse({ output: "stroke" });
  +    expect(parsed.strokeWidth).toBe(1);
  +  });
  +
  +  it("normalizes svg dimensions and strips tiny specks", () => {
  +    const input = '<svg width="20pt" height="10pt"><metadata>bad</metadata><path d="M1 1 L2 1 L2 2 Z"/><path d="M0 0 L10 0 L10 10 Z"/></svg>';
  +    const result = normalizeSvg(input, 20, 10, 6);
  +
  +    expect(result.svg).toContain('width="20px"');
  +    expect(result.svg).toContain('height="10px"');
  +    expect(result.svg).toContain('viewBox="0 0 20 10"');
  +    expect(result.pathsRemoved).toBe(1);
  +  });
  +});
  diff --git a/src/app/api/tracer/route.ts b/src/app/api/tracer/route.ts
  new file mode 100644
  index 0000000..99a9411
  --- /dev/null
  +++ b/src/app/api/tracer/route.ts
  @@ -0,0 +1,79 @@
  +import { randomUUID } from "node:crypto";
  +import { normalizeTracerError, traceRasterToSvg } from "../../../../lib/tracing-core";
  +
  +const TRACER_TIMEOUT_MS = Number(process.env.TRACER_TIMEOUT_MS ?? 15000);
  +
  +type TracerApiResponse = {
  +  requestId: string;
  +  ok: boolean;
  +  result?: unknown;
  +  error?: {
  +    code: string;
  +    message: string;
  +    details?: unknown;
  +  };
  +};
  +
  +function fail(requestId: string, status: number, code: string, message: string, details?: unknown) {
  +  const body: TracerApiResponse = {
  +    requestId,
  +    ok: false,
  +    error: { code, message, details }
  +  };
  +
  +  return Response.json(body, { status });
  +}
  +
  +export async function POST(req: Request) {
  +  const requestId = randomUUID();
  +  const started = Date.now();
  +  console.info("[tracer] request:start", { requestId });
  +
  +  try {
  +    const form = await req.formData();
  +    const file = form.get("file");
  +    const settingsRaw = form.get("settings");
  +
  +    if (!(file instanceof File)) {
  +      return fail(requestId, 400, "MISSING_FILE", "No file was uploaded");
  +    }
  +
  +    let settings: unknown = {};
  +    if (typeof settingsRaw === "string" && settingsRaw.trim()) {
  +      try {
  +        settings = JSON.parse(settingsRaw);
  +      } catch {
  +        return fail(requestId, 400, "INVALID_SETTINGS", "settings must be valid JSON");
  +      }
  +    }
  +
  +    const buffer = Buffer.from(await file.arrayBuffer());
  +
  +    const result = await Promise.race([
  +      traceRasterToSvg({ buffer, mime: file.type, filename: file.name }, settings),
  +      new Promise<never>((_, reject) =>
  +        setTimeout(() => reject(new Error("TRACER_TIMEOUT")), TRACER_TIMEOUT_MS)
  +      )
  +    ]);
  +
  +    console.info("[tracer] request:done", { requestId, elapsedMs: Date.now() - started });
  +    const body: TracerApiResponse = { requestId, ok: true, result };
  +    return Response.json(body, { status: 200 });
  +  } catch (error) {
  +    if (error instanceof Error && error.message === "TRACER_TIMEOUT") {
  +      console.warn("[tracer] request:timeout", { requestId, timeoutMs: TRACER_TIMEOUT_MS });
  +      return fail(requestId, 408, "TRACER_TIMEOUT", "Tracing timed out", { timeoutMs: TRACER_TIMEOUT_MS });
  +    }
  +
  +    const normalized = normalizeTracerError(error);
  +    console.error("[tracer] request:failed", {
  +      requestId,
  +      elapsedMs: Date.now() - started,
  +      code: normalized.code
  +    });
  +
  +    const status = normalized.code === "INVALID_SETTINGS" || normalized.code === "UNSUPPORTED_MIME" || normalized.code === "FILE_TOO_LARGE" || normalized.code === "DIMENSION_LIMIT_EXCEEDED" || normalized.code === "INVALID_IMAGE" ? 400 : 500;
  +
  +    return fail(requestId, status, normalized.code, normalized.message, normalized.details);
  +  }
  +}
  diff --git a/src/app/tracer/page.tsx b/src/app/tracer/page.tsx
  new file mode 100644
  index 0000000..2b2aff5
  --- /dev/null
  +++ b/src/app/tracer/page.tsx
  @@ -0,0 +1,187 @@
  +"use client";
  +
  +import { useEffect, useMemo, useState } from "react";
  +
  +type TracerSettings = {
  +  mode: "auto" | "bw" | "color";
  +  threshold: number;
  +  smoothing: number;
  +  despeckle: number;
  +  simplify: number;
  +  invert: boolean;
  +  removeBackground: boolean;
  +  bgTolerance: number;
  +  output: "fill" | "stroke";
  +  strokeWidth?: number;
  +  outlineMode: boolean;
  +};
  +
  +const DEFAULT_SETTINGS: TracerSettings = {
  +  mode: "auto",
  +  threshold: 165,
  +  smoothing: 2,
  +  despeckle: 3,
  +  simplify: 2,
  +  invert: false,
  +  removeBackground: true,
  +  bgTolerance: 18,
  +  output: "fill",
  +  strokeWidth: 1,
  +  outlineMode: false
  +};
  +
  +const PRESETS: Record<string, Partial<TracerSettings>> = {
  +  "Laser Engrave": {
  +    output: "fill",
  +    removeBackground: true,
  +    simplify: 2,
  +    threshold: 165,
  +    outlineMode: false
  +  },
  +  "Laser Cut": {
  +    output: "stroke",
  +    strokeWidth: 1,
  +    simplify: 3,
  +    threshold: 175,
  +    outlineMode: true
  +  },
  +  "Photo Logo": {
  +    smoothing: 5,
  +    despeckle: 5,
  +    threshold: 160,
  +    output: "fill"
  +  }
  +};
  +
  +export default function TracerPage() {
  +  const [file, setFile] = useState<File | null>(null);
  +  const [settings, setSettings] = useState<TracerSettings>(DEFAULT_SETTINGS);
  +  const [status, setStatus] = useState<"idle" | "uploading" | "tracing" | "done" | "failed">("idle");
  +  const [svg, setSvg] = useState("");
  +  const [error, setError] = useState<string | null>(null);
  +
  +  useEffect(() => {
  +    const raw = localStorage.getItem("tracer:last-settings");
  +    if (raw) {
  +      try {
  +        setSettings({ ...DEFAULT_SETTINGS, ...JSON.parse(raw) });
  +      } catch {
  +        localStorage.removeItem("tracer:last-settings");
  +      }
  +    }
  +  }, []);
  +
  +  useEffect(() => {
  +    localStorage.setItem("tracer:last-settings", JSON.stringify(settings));
  +  }, [settings]);
  +
  +  const banner = useMemo(() => {
  +    if (status === "uploading") return "Uploading...";
  +    if (status === "tracing") return "Tracing...";
  +    if (status === "done") return "Done";
  +    if (status === "failed") return "Failed";
  +    return "";
  +  }, [status]);
  +
  +  async function onTrace() {
  +    if (!file) {
  +      setError("Please choose a PNG or JPEG file.");
  +      return;
  +    }
  +
  +    setError(null);
  +    setStatus("uploading");
  +
  +    const form = new FormData();
  +    form.append("file", file);
  +    form.append("settings", JSON.stringify(settings));
  +
  +    setStatus("tracing");
  +    const res = await fetch("/api/tracer", { method: "POST", body: form });
  +    const payload = await res.json();
  +
  +    if (!payload.ok) {
  +      setStatus("failed");
  +      setError(payload.error?.message ?? "Tracing failed");
  +      return;
  +    }
  +
  +    setSvg(payload.result.svg);
  +    setStatus("done");
  +  }
  +
  +  return (
  +    <main className="mx-auto max-w-4xl space-y-4 p-6">
  +      <h1 className="text-2xl font-semibold">AI Image Tracer</h1>
  +      {banner ? <div className="rounded border p-2">Status: {banner}</div> : null}
  +      {error ? <div className="rounded border border-red-500 p-2 text-red-600">{error}</div> : null}
  +
  +      <input type="file" accept="image/png,image/jpeg" onChange={(e) => setFile(e.target.files?.[0] ?? null)} />
  +
  +      <div className="grid grid-cols-2 gap-3">
  +        <label>
  +          Presets
  +          <select
  +            className="ml-2 border"
  +            onChange={(e) => {
  +              const preset = PRESETS[e.target.value];
  +              if (preset) setSettings((prev) => ({ ...prev, ...preset }));
  +            }}
  +          >
  +            <option value="">Custom</option>
  +            {Object.keys(PRESETS).map((name) => (
  +              <option key={name} value={name}>
  +                {name}
  +              </option>
  +            ))}
  +          </select>
  +        </label>
  +
  +        <label>
  +          Outline mode
  +          <input
  +            className="ml-2"
  +            type="checkbox"
  +            checked={settings.outlineMode}
  +            onChange={(e) => setSettings((prev) => ({ ...prev, outlineMode: e.target.checked, output: e.target.checked ? "stroke" : prev.output }))}
  +          />
  +        </label>
  +      </div>
  +
  +      <button className="rounded border px-4 py-2" onClick={onTrace}>
  +        Trace image
  +      </button>
  +
  +      {svg ? (
  +        <section className="space-y-2">
  +          <div className="flex gap-2">
  +            <button
  +              className="rounded border px-3 py-1"
  +              onClick={() => {
  +                const blob = new Blob([svg], { type: "image/svg+xml" });
  +                const url = URL.createObjectURL(blob);
  +                const a = document.createElement("a");
  +                a.href = url;
  +                a.download = "trace.svg";
  +                a.click();
  +                URL.revokeObjectURL(url);
  +              }}
  +            >
  +              Download as .svg
  +            </button>
  +            <button
  +              className="rounded border px-3 py-1"
  +              onClick={async () => {
  +                if (!navigator.clipboard) return;
  +                await navigator.clipboard.writeText(svg);
  +              }}
  +            >
  +              Copy SVG
  +            </button>
  +          </div>
  +          <div className="rounded border p-3" dangerouslySetInnerHTML={{ __html: svg }} />
  +        </section>
  +      ) : null}
  +    </main>
  +  );
  +}
test_patch: ''
fail_to_pass:
- npm test -- --runTestsByPath src/__tests__/tracing-core-settings.test.ts src/__tests__/tracing-core-error.test.ts
pass_to_pass:
- npm test -- --runTestsByPath src/__tests__/assets.route.test.ts
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '556'
  difficulty: hard
  files_changed: '5'
  pr_title: Harden tracer flow with extractable core, API guardrails, and UI presets
  removed_lines: '0'
  source: gh-archive-pr
  test_files: '[{"path":"src/__tests__/tracing-core-settings.test.ts","content":"const loadCore = async (minSpeckArea?: string) => {\n  jest.resetModules();\n  if (minSpeckArea !== undefined) {\n    process.env.MIN_SPECK_AREA = minSpeckArea;\n  } else {\n    delete process.env.MIN_SPECK_AREA;\n  }\n\n  return import(\"../../lib/tracing-core\");\n};\n\ndescribe(\"tracing core settings schema\", () => {\n  it(\"applies defaults and respects env-based min speck area\", async () => {\n    const { TracerSettingsSchema } = await loadCore(\"9\");\n    const settings = TracerSettingsSchema.parse({});\n\n    expect(settings.mode).toBe(\"auto\");\n    expect(settings.output).toBe(\"fill\");\n    expect(settings.strokeWidth).toBeUndefined();\n    expect(settings.minSpeckArea).toBe(9);\n  });\n\n  it(\"infers stroke width for stroke output or outline mode\", async () => {\n    const { TracerSettingsSchema } = await loadCore();\n\n    const strokeSettings = TracerSettingsSchema.parse({ output: \"stroke\" });\n    expect(strokeSettings.output).toBe(\"stroke\");\n    expect(strokeSettings.strokeWidth).toBe(1);\n\n    const outlineSettings = TracerSettingsSchema.parse({ output: \"fill\", outlineMode: true });\n    expect(outlineSettings.outlineMode).toBe(true);\n    expect(outlineSettings.strokeWidth).toBe(1);\n  });\n});\n"},{"path":"src/__tests__/tracing-core-error.test.ts","content":"const loadCore = async () => {\n  jest.resetModules();\n  return import(\"../../lib/tracing-core\");\n};\n\ndescribe(\"TracerCoreError\", () => {\n  it(\"serializes to a safe JSON shape\", async () => {\n    const { TracerCoreError } = await loadCore();\n    const error = new TracerCoreError(\"TRACE_FAILED\", \"Unable to trace\", { reason: \"timeout\" });\n\n    expect(error.code).toBe(\"TRACE_FAILED\");\n    expect(error.message).toBe(\"Unable to trace\");\n    expect(error.toJSON()).toEqual({\n      code: \"TRACE_FAILED\",\n      message: \"Unable to trace\",\n      details: { reason: \"timeout\" }\n    });\n  });\n});\n"}]'
  test_generation: agentic-docker
prompt: |-
  laser-thinhs/lt316-customizer-app (#23): Harden tracer flow with extractable core, API guardrails, and UI presets

  Harden the image tracer feature so it is reliable in production and can be separated as a standalone service. Enforce strict validation of uploads (MIME type, size, and dimensions) with sane defaults and reject invalid inputs. Ensure tracing produces laser-friendly SVGs by normalizing output (consistent viewBox and units, stripping metadata) and removing tiny speck artifacts, and provide a safe fallback SVG when tracing isnâ€™t available.

  Make the tracer API return a consistent response envelope that includes a per-request ID, success status, result or error, and does not expose raw stack traces. Add request timeouts and lifecycle logging, and sanitize errors returned to clients.

  Improve the tracer UI with persistent settings, user-selectable presets, an outline mode toggle, clear status feedback (uploading, tracing, done, failed), and actions to download or copy the generated SVG.

  Add automated tests to cover default settings validation, SVG normalization behavior, and an integration test that posts a small PNG to the tracer API.
original_pr_body: "laser-thinhs/lt316-customizer-app (#23): Harden tracer flow with extractable core, API guardrails, and UI presets\n\n### Motivation\n- Make the image tracer reliable, safe to run in production, and easy to split out as a standalone service by extracting pure tracing logic and adding strict validation, timeouts, and a consistent API surface. \n- Improve user experience with persistent settings, presets, clear status feedback, and basic SVG hygiene so outputs are laser-friendly.\n\n### Description\n- Add a pure-core module at `lib/tracing-core/index.ts` exporting `TracerSettingsSchema`, `TracerSettings`, `traceRasterToSvg(...)`, `TracerCoreError`, and `normalizeTracerError`, with strict MIME/size/dimension checks and sane defaults (`MAX_UPLOAD_MB=10`, `MAX_DIMENSION=2000`, `MIN_SPECK_AREA=6`).\n- Implement SVG normalization and speck filtering in core (`viewBox` enforcement, unit normalization to `px`, metadata stripping, path-area based speck removal) and provide a safe fallback SVG when raster tracing is not available.\n- Harden API at `src/app/api/tracer/route.ts` to attach a per-request `requestId` (UUID), log request lifecycle, enforce a `TRACER_TIMEOUT_MS` guard (default 15000ms), sanitize errors, and return a consistent envelope `{ requestId, ok, result?, error? }` without exposing raw stacks.\n- Add a client UI page at `src/app/tracer/page.tsx` with localStorage persistence for last settings, a `Presets` dropdown (Laser Engrave, Laser Cut, Photo Logo), an `outlineMode` toggle, clear status banners (Uploading/Tracing/Done/Failed), and `Download .svg` / `Copy SVG` actions.\n- Add tests: unit tests for `TracerSettingsSchema` defaults and `normalizeSvg` behavior at `src/__tests__/tracing-core.test.ts`, and an integration test that posts a tiny PNG to the tracer API at `src/__tests__/tracer.route.integration.test.ts`.\n\n### Testing\n- Ran unit and integration tests with `npm test -- --runInBand src/__tests__/tracing-core.test.ts src/__tests__/tracer.route.integration.test.ts`, and both test suites passed. \n- Ran `npm run lint` which failed in this environment because `eslint` is not installed, causing `next lint` to error. \n- Attempted a headless browser check to capture the `/tracer` page which failed in the environment due to the Playwright/Chromium process crashing, but this did not affect the Jest test results.\n\n------\n[Codex Task](https://chatgpt.com/codex/tasks/task_e_6993a8017cac8326b447ccd4b3ebeaa1)"
quality_score: 0.72
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
