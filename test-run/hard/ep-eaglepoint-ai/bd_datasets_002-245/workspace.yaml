id: ep-eaglepoint-ai/bd_datasets_002-245
repo: ep-eaglepoint-ai/bd_datasets_002
base_commit: 53213e833628323c51303aaf99d11f6375a69f05
merge_commit: 2e0130becf4de53ca8f5a44815b3f64e63339ea7
language: typescript
difficulty_score: 3
created_at: 2026-02-17T13:18:00.012317605Z
patch: "diff --git a/9a9pcc-order-processing-refactor/.dockerignore b/9a9pcc-order-processing-refactor/.dockerignore\nnew file mode 100644\nindex 000000000..cdbaa2950\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/.dockerignore\n@@ -0,0 +1,20 @@\n+.git\n+.gitignore\n+.dockerignore\n+__pycache__/\n+.pytest_cache/\n+.venv/\n+.env\n+node_modules/\n+evaluation/2*\n+test_*.txt\n+*.txt\n+*.json\n+*.patch\n+*.log\n+!requirements.txt\n+Dockerfile\n+docker-compose.yml\n+trajectory/\n+patches/\n+README.md\ndiff --git a/9a9pcc-order-processing-refactor/.gitignore b/9a9pcc-order-processing-refactor/.gitignore\nnew file mode 100644\nindex 000000000..b89c337f4\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/.gitignore\n@@ -0,0 +1,17 @@\n+# Add your Python dependencies here\n+__pycache__/\n+.pytest_cache/\n+reports/\n+evaluation/2*\n+test_out.txt\n+test_result.txt\n+test_err.txt\n+*.pyc\n+.venv/\n+.env\n+\n+# Node\n+node_modules/\n+\n+# OS\n+.DS_Store\ndiff --git a/9a9pcc-order-processing-refactor/Dockerfile b/9a9pcc-order-processing-refactor/Dockerfile\nnew file mode 100644\nindex 000000000..e21d81262\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/Dockerfile\n@@ -0,0 +1,10 @@\n+FROM python:3.11-slim\n+\n+WORKDIR /app\n+\n+COPY requirements.txt .\n+RUN pip install --no-cache-dir -r requirements.txt\n+\n+COPY . .\n+\n+CMD [\"pytest\", \"-q\", \"tests\"]\ndiff --git a/9a9pcc-order-processing-refactor/README.md b/9a9pcc-order-processing-refactor/README.md\nnew file mode 100644\nindex 000000000..ec014d10c\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/README.md\n@@ -0,0 +1,21 @@\n+# Order Processing Refactor\n+\n+## Run with Docker\n+\n+### Run tests (before)\n+\n+```bash\n+docker compose run --rm -e PYTHONPATH=/app/repository_before app pytest -v\n+```\n+\n+### Run tests (after)\n+\n+```bash\n+docker compose run --rm -e PYTHONPATH=/app/repository_after app pytest -v\n+```\n+\n+### Run evaluation (compares both implementations)\n+\n+```bash\n+docker compose run --rm app python evaluation/evaluation.py\n+```\ndiff --git a/9a9pcc-order-processing-refactor/docker-compose.yml b/9a9pcc-order-processing-refactor/docker-compose.yml\nnew file mode 100644\nindex 000000000..9c01a1045\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/docker-compose.yml\n@@ -0,0 +1,9 @@\n+services:\n+  app:\n+    build:\n+      context: .\n+      dockerfile: Dockerfile\n+    command: pytest -q tests\n+\n+    volumes:\n+      - .:/app\ndiff --git a/9a9pcc-order-processing-refactor/evaluation/evaluation.py b/9a9pcc-order-processing-refactor/evaluation/evaluation.py\nnew file mode 100644\nindex 000000000..33fc51d20\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/evaluation/evaluation.py\n@@ -0,0 +1,318 @@\n+import os\n+import sys\n+import json\n+import uuid\n+import platform\n+import subprocess\n+from datetime import datetime\n+from pathlib import Path\n+\n+\n+def generate_run_id():\n+    \"\"\"Generate a short unique run ID.\"\"\"\n+    return uuid.uuid4().hex[:8]\n+\n+\n+def get_git_info():\n+    \"\"\"Get git commit and branch information.\"\"\"\n+    git_info = {\"git_commit\": \"unknown\", \"git_branch\": \"unknown\"}\n+    try:\n+        result = subprocess.run(\n+            [\"git\", \"rev-parse\", \"HEAD\"],\n+            capture_output=True,\n+            text=True,\n+            timeout=5\n+        )\n+        if result.returncode == 0:\n+            git_info[\"git_commit\"] = result.stdout.strip()[:8]\n+    except Exception:\n+        pass\n+    \n+    try:\n+        result = subprocess.run(\n+            [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"],\n+            capture_output=True,\n+            text=True,\n+            timeout=5\n+        )\n+        if result.returncode == 0:\n+            git_info[\"git_branch\"] = result.stdout.strip()\n+    except Exception:\n+        pass\n+    \n+    return git_info\n+\n+\n+def get_environment_info():\n+    \"\"\"Collect environment information for the report.\"\"\"\n+    git_info = get_git_info()\n+    \n+    return {\n+        \"python_version\": platform.python_version(),\n+        \"platform\": platform.platform(),\n+        \"os\": platform.system(),\n+        \"os_release\": platform.release(),\n+        \"architecture\": platform.machine(),\n+        \"hostname\": platform.node(),\n+        \"git_commit\": git_info[\"git_commit\"],\n+        \"git_branch\": git_info[\"git_branch\"],\n+    }\n+\n+\n+def run_pytest_with_pythonpath(pythonpath, tests_dir, label):\n+    \"\"\"\n+    Run pytest on the tests/ folder with specific PYTHONPATH.\n+    \"\"\"\n+    print(f\"\\n{'=' * 60}\")\n+    print(f\"RUNNING TESTS: {label.upper()}\")\n+    print(f\"{'=' * 60}\")\n+    print(f\"PYTHONPATH: {pythonpath}\")\n+    print(f\"Tests directory: {tests_dir}\")\n+    \n+    # Build pytest command\n+    # We use -p no:cacheprovider to avoid permission issues in some docker environments\n+    cmd = [\n+        sys.executable, \"-m\", \"pytest\",\n+        str(tests_dir),\n+        \"-v\",\n+        \"--tb=short\",\n+        \"-p\", \"no:cacheprovider\"\n+    ]\n+    \n+    env = os.environ.copy()\n+    env[\"PYTHONPATH\"] = pythonpath\n+    \n+    try:\n+        result = subprocess.run(\n+            cmd,\n+            capture_output=True,\n+            text=True,\n+            cwd=str(Path(tests_dir).parent),\n+            env=env,\n+            timeout=120\n+        )\n+        \n+        stdout = result.stdout\n+        stderr = result.stderr\n+        \n+        # Parse verbose output to get test results\n+        tests = parse_pytest_verbose_output(stdout)\n+        \n+        # Count results\n+        passed = sum(1 for t in tests if t.get(\"outcome\") == \"passed\")\n+        failed = sum(1 for t in tests if t.get(\"outcome\") == \"failed\")\n+        errors = sum(1 for t in tests if t.get(\"outcome\") == \"error\")\n+        skipped = sum(1 for t in tests if t.get(\"outcome\") == \"skipped\")\n+        total = len(tests)\n+        \n+        print(f\"\\nResults: {passed} passed, {failed} failed, {errors} errors, {skipped} skipped (total: {total})\")\n+        \n+        # Print individual test results\n+        for test in tests:\n+            status_icon = {\n+                \"passed\": \"âœ…\",\n+                \"failed\": \"âŒ\",\n+                \"error\": \"ðŸ’¥\",\n+                \"skipped\": \"â­ï¸\"\n+            }.get(test.get(\"outcome\"), \"â“\")\n+            print(f\"  {status_icon} {test.get('nodeid', 'unknown')}: {test.get('outcome', 'unknown')}\")\n+        \n+        return {\n+            \"success\": result.returncode == 0,\n+            \"exit_code\": result.returncode,\n+            \"tests\": tests,\n+            \"summary\": {\n+                \"total\": total,\n+                \"passed\": passed,\n+                \"failed\": failed,\n+                \"errors\": errors,\n+                \"skipped\": skipped,\n+            },\n+            \"stdout\": stdout[-3000:] if len(stdout) > 3000 else stdout,\n+            \"stderr\": stderr[-1000:] if len(stderr) > 1000 else stderr,\n+        }\n+        \n+    except subprocess.TimeoutExpired:\n+        print(\"âŒ Test execution timed out\")\n+        return {\n+            \"success\": False,\n+            \"exit_code\": -1,\n+            \"tests\": [],\n+            \"summary\": {\"error\": \"Test execution timed out\"},\n+            \"stdout\": \"\",\n+            \"stderr\": \"\",\n+        }\n+    except Exception as e:\n+        print(f\"âŒ Error running tests: {e}\")\n+        return {\n+            \"success\": False,\n+            \"exit_code\": -1,\n+            \"tests\": [],\n+            \"summary\": {\"error\": str(e)},\n+            \"stdout\": \"\",\n+            \"stderr\": \"\",\n+        }\n+\n+\n+def parse_pytest_verbose_output(output):\n+    \"\"\"Parse pytest verbose output to extract test results.\"\"\"\n+    tests = []\n+    lines = output.split('\\n')\n+    \n+    for line in lines:\n+        line_stripped = line.strip()\n+        \n+        if '::' in line_stripped:\n+            outcome = None\n+            if ' PASSED' in line_stripped:\n+                outcome = \"passed\"\n+            elif ' FAILED' in line_stripped:\n+                outcome = \"failed\"\n+            elif ' ERROR' in line_stripped:\n+                outcome = \"error\"\n+            elif ' SKIPPED' in line_stripped:\n+                outcome = \"skipped\"\n+            \n+            if outcome:\n+                for status_word in [' PASSED', ' FAILED', ' ERROR', ' SKIPPED']:\n+                    if status_word in line_stripped:\n+                        nodeid = line_stripped.split(status_word)[0].strip()\n+                        break\n+                \n+                tests.append({\n+                    \"nodeid\": nodeid,\n+                    \"name\": nodeid.split(\"::\")[-1] if \"::\" in nodeid else nodeid,\n+                    \"outcome\": outcome,\n+                })\n+    \n+    return tests\n+\n+\n+def run_evaluation():\n+    \"\"\"\n+    Run complete evaluation for both implementations.\n+    \"\"\"\n+    print(f\"\\n{'=' * 60}\")\n+    print(\"ORDER PROCESSING REFACTOR EVALUATION\")\n+    print(f\"{'=' * 60}\")\n+    \n+    project_root = Path(__file__).parent.parent\n+    tests_dir = project_root / \"tests\"\n+    \n+    # PYTHONPATH for before implementation\n+    before_pythonpath = str(project_root / \"repository_before\")\n+    \n+    # PYTHONPATH for after implementation  \n+    after_pythonpath = str(project_root / \"repository_after\")\n+    \n+    # Run tests with BEFORE implementation\n+    before_results = run_pytest_with_pythonpath(\n+        before_pythonpath,\n+        tests_dir,\n+        \"before (repository_before)\"\n+    )\n+    \n+    # Run tests with AFTER implementation\n+    after_results = run_pytest_with_pythonpath(\n+        after_pythonpath,\n+        tests_dir,\n+        \"after (repository_after)\"\n+    )\n+    \n+    # Build comparison\n+    comparison = {\n+        \"before_tests_passed\": before_results.get(\"success\", False),\n+        \"after_tests_passed\": after_results.get(\"success\", False),\n+        \"before_total\": before_results.get(\"summary\", {}).get(\"total\", 0),\n+        \"before_passed\": before_results.get(\"summary\", {}).get(\"passed\", 0),\n+        \"before_failed\": before_results.get(\"summary\", {}).get(\"failed\", 0),\n+        \"after_total\": after_results.get(\"summary\", {}).get(\"total\", 0),\n+        \"after_passed\": after_results.get(\"summary\", {}).get(\"passed\", 0),\n+        \"after_failed\": after_results.get(\"summary\", {}).get(\"failed\", 0),\n+    }\n+    \n+    print(f\"\\n{'=' * 60}\")\n+    print(\"EVALUATION SUMMARY\")\n+    print(f\"{'=' * 60}\")\n+    \n+    print(f\"\\nBefore Implementation (repository_before):\")\n+    print(f\"  Overall: {'âœ… PASSED' if before_results.get('success') else 'âŒ FAILED'}\")\n+    print(f\"  Tests: {comparison['before_passed']}/{comparison['before_total']} passed\")\n+    \n+    print(f\"\\nAfter Implementation (repository_after):\")\n+    print(f\"  Overall: {'âœ… PASSED' if after_results.get('success') else 'âŒ FAILED'}\")\n+    print(f\"  Tests: {comparison['after_passed']}/{comparison['after_total']} passed\")\n+    \n+    return {\n+        \"before\": before_results,\n+        \"after\": after_results,\n+        \"comparison\": comparison,\n+    }\n+\n+\n+def generate_output_path():\n+    \"\"\"Generate output path in format: evaluation/YYYY-MM-DD/HH-MM-SS/report.json\"\"\"\n+    now = datetime.now()\n+    date_str = now.strftime(\"%Y-%m-%d\")\n+    time_str = now.strftime(\"%H-%M-%S\")\n+    \n+    project_root = Path(__file__).parent.parent\n+    output_dir = project_root / \"evaluation\" / \"reports\" / date_str / time_str\n+    output_dir.mkdir(parents=True, exist_ok=True)\n+    \n+    return output_dir / \"report.json\"\n+\n+\n+def main():\n+    \"\"\"Main entry point for evaluation.\"\"\"\n+    import argparse\n+    \n+    parser = argparse.ArgumentParser(description=\"Run order processing refactor evaluation\")\n+    parser.add_argument(\"--output\", type=str, default=None)\n+    \n+    args = parser.parse_args()\n+    \n+    run_id = generate_run_id()\n+    started_at = datetime.now()\n+    \n+    try:\n+        results = run_evaluation()\n+        success = results[\"after\"].get(\"success\", False)\n+        error_message = None if success else \"After implementation tests failed\"\n+    except Exception as e:\n+        import traceback\n+        traceback.print_exc()\n+        results = None\n+        success = False\n+        error_message = str(e)\n+    \n+    finished_at = datetime.now()\n+    duration = (finished_at - started_at).total_seconds()\n+    \n+    report = {\n+        \"run_id\": run_id,\n+        \"started_at\": started_at.isoformat(),\n+        \"finished_at\": finished_at.isoformat(),\n+        \"duration_seconds\": round(duration, 6),\n+        \"success\": success,\n+        \"error\": error_message,\n+        \"environment\": get_environment_info(),\n+        \"results\": results,\n+    }\n+    \n+    if args.output:\n+        output_path = Path(args.output)\n+    else:\n+        output_path = generate_output_path()\n+    \n+    output_path.parent.mkdir(parents=True, exist_ok=True)\n+    \n+    with open(output_path, \"w\") as f:\n+        json.dump(report, f, indent=2)\n+    print(f\"\\nâœ… Report saved to: {output_path}\")\n+    \n+    return 0 if success else 1\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())\ndiff --git a/9a9pcc-order-processing-refactor/instances/instance.json b/9a9pcc-order-processing-refactor/instances/instance.json\nnew file mode 100644\nindex 000000000..f48c565d2\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/instances/instance.json\n@@ -0,0 +1,11 @@\n+{\n+            \"instance_id\": \"9A9PCC\",\n+            \"problem_statement\": \"Refactor a Python eâ€‘commerce order processing system by replacing nested conditionals with a strategy pattern for discounts, extracting duplicate shipping calculations into reusable methods, introducing a Money value object for safe currency operations, and creating custom exception classes for proper error handling. Use early returns to reduce nesting and ensure the refactored code produces identical results for all order scenarios while eliminating primitive obsession and improving maintainability. The solution must preserve all existing order processing logicâ€”inventory validation, discount tiers, shipping rules, tax calculations, and order creationâ€”while applying clean code principles.\",\n+            \"base_commit\": \"repository_before/\",\n+            \"test_patch\": \"tests/\",\n+            \"github_url\": \"https://github.com/ep-eaglepoint-ai/bd_datasets_002/tree/main/9a9pcc-order-processing-refactor\",\n+            \"environment_setup\": \"Dockerfile\",\n+            \"FAIL_TO_PASS\": [],\n+            \"PASS_TO_PASS\": []\n+        }\n+        \n\\ No newline at end of file\ndiff --git a/9a9pcc-order-processing-refactor/patches/diff.patch b/9a9pcc-order-processing-refactor/patches/diff.patch\nnew file mode 100644\nindex 000000000..cc192eaa0\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/patches/diff.patch\n@@ -0,0 +1,535 @@\n+diff --git a/repository_before/main.py b/repository_after/main.py\n+index 1ee75bef..249355de 100644\n+--- a/repository_before/main.py\n++++ b/repository_after/main.py\n+@@ -1,180 +1,389 @@\n+-from typing import Dict, Any, Optional\n++from typing import Dict, Any, Optional, List\n+ from datetime import datetime\n++from decimal import Decimal, ROUND_HALF_EVEN\n++from enum import Enum\n++from dataclasses import dataclass\n++from abc import ABC, abstractmethod\n+ \n+-class OrderProcessor:\n+-    def __init__(self):\n+-        self.orders = {}\n+-        self.inventory = {}\n++class OrderProcessingError(Exception):\n++    \"\"\"Base exception for all order processing errors.\"\"\"\n++    pass\n+ \n+-    def process_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:\n+-        if not order_data:\n+-            raise Exception(\"Order data is required\")\n+-        if 'items' not in order_data or not order_data['items']:\n+-            raise Exception(\"Order must have items\")\n+-        if 'customer' not in order_data:\n+-            raise Exception(\"Order must have customer\")\n+-        if 'shipping_address' not in order_data:\n+-            raise Exception(\"Order must have shipping address\")\n++class InvalidOrderError(OrderProcessingError):\n++    \"\"\"Raised when the order data is invalid or missing required fields.\"\"\"\n++    pass\n+ \n+-        customer = order_data['customer']\n+-        items = order_data['items']\n+-        shipping_address = order_data['shipping_address']\n+-        promo_code = order_data.get('promo_code')\n++class ProductNotFoundError(OrderProcessingError):\n++    \"\"\"Raised when a requested product does not exist in inventory.\"\"\"\n++    def __init__(self, product_id: str):\n++        super().__init__(f\"Product {product_id} not found\")\n++        self.product_id = product_id\n++        self.context = {\"product_id\": product_id}\n+ \n+-        for item in items:\n+-            product_id = item['product_id']\n+-            quantity = item['quantity']\n+-            if product_id not in self.inventory:\n+-                raise Exception(f\"Product {product_id} not found\")\n+-            if self.inventory[product_id]['stock'] < quantity:\n+-                raise Exception(f\"Insufficient stock for product {product_id}\")\n++class InsufficientInventoryError(OrderProcessingError):\n++    \"\"\"Raised when there is not enough stock for a product.\"\"\"\n++    def __init__(self, product_id: str, requested: int, available: int):\n++        super().__init__(f\"Insufficient stock for product {product_id}\")\n++        self.product_id = product_id\n++        self.requested = requested\n++        self.available = available\n++        self.context = {\"product_id\": product_id, \"requested\": requested, \"available\": available}\n+ \n+-        subtotal = 0.0\n+-        for item in items:\n+-            product = self.inventory[item['product_id']]\n+-            subtotal = subtotal + (product['price'] * item['quantity'])\n+-\n+-        discount = 0.0\n+-        customer_tier = customer.get('tier', 'standard')\n+-        if customer_tier == 'gold':\n+-            if subtotal >= 500:\n+-                discount = subtotal * 0.20\n+-            elif subtotal >= 200:\n+-                discount = subtotal * 0.15\n+-            elif subtotal >= 100:\n+-                discount = subtotal * 0.10\n+-            else:\n+-                discount = subtotal * 0.05\n+-        elif customer_tier == 'silver':\n+-            if subtotal >= 500:\n+-                discount = subtotal * 0.15\n+-            elif subtotal >= 200:\n+-                discount = subtotal * 0.10\n+-            elif subtotal >= 100:\n+-                discount = subtotal * 0.05\n+-            else:\n+-                discount = 0\n++class PaymentFailedError(OrderProcessingError):\n++    \"\"\"Raised when payment processing fails.\"\"\"\n++    pass\n++\n++class ShippingNotAvailableError(OrderProcessingError):\n++    \"\"\"Raised when shipping is not available for the given address.\"\"\"\n++    pass\n++\n++class OrderStatus(Enum):\n++    \"\"\"Enum for representing various order statuses.\"\"\"\n++    PENDING = 'pending'\n++    PAID = 'paid'\n++    SHIPPED = 'shipped'\n++    DELIVERED = 'delivered'\n++    CANCELLED = 'cancelled'\n++\n++@dataclass(frozen=True)\n++class Money:\n++    \"\"\"Value object to handle currency operations safely using Decimal.\"\"\"\n++    amount: Decimal\n++\n++    @classmethod\n++    def from_float(cls, value: float) -> 'Money':\n++        return cls(Decimal(str(value)))\n++\n++    def __add__(self, other: 'Money') -> 'Money':\n++        if not isinstance(other, Money):\n++            return NotImplemented\n++        return Money(self.amount + other.amount)\n++\n++    def __sub__(self, other: 'Money') -> 'Money':\n++        if not isinstance(other, Money):\n++            return NotImplemented\n++        return Money(self.amount - other.amount)\n++\n++    def __mul__(self, other: Any) -> 'Money':\n++        if isinstance(other, (int, float)):\n++            return Money(self.amount * Decimal(str(other)))\n++        if isinstance(other, Decimal):\n++            return Money(self.amount * other)\n++        return NotImplemented\n++\n++    def __ge__(self, other: 'Money') -> bool:\n++        if not isinstance(other, Money):\n++            return NotImplemented\n++        return self.amount >= other.amount\n++\n++    def __lt__(self, other: 'Money') -> bool:\n++        if not isinstance(other, Money):\n++            return NotImplemented\n++        return self.amount < other.amount\n++\n++    def round(self) -> 'Money':\n++        \"\"\"Rounds the amount to 2 decimal places using Banker's rounding.\"\"\"\n++        return Money(self.amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_EVEN))\n++\n++    def to_float(self) -> float:\n++        \"\"\"Returns the rounded amount as a float.\"\"\"\n++        return float(self.amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_EVEN))\n++\n++    def to_float_raw(self) -> float:\n++        \"\"\"Returns the raw unrounded amount as a float.\"\"\"\n++        return float(self.amount)\n++\n++@dataclass(frozen=True)\n++class Address:\n++    \"\"\"Value object for shipping address.\"\"\"\n++    country: str = 'US'\n++    state: str = ''\n++\n++    @classmethod\n++    def from_dict(cls, data: Dict[str, Any]) -> 'Address':\n++        \"\"\"Creates an Address from a dictionary with validation. Enforces required fields.\"\"\"\n++        if not isinstance(data, dict):\n++            raise InvalidOrderError(\"Shipping address must be a dictionary\")\n++        \n++        # Enforce required fields\n++        if 'country' not in data:\n++            raise InvalidOrderError(\"Missing required field: country\")\n++        if 'state' not in data:\n++            raise InvalidOrderError(\"Missing required field: state\")\n++            \n++        if not isinstance(data['country'], str):\n++            raise InvalidOrderError(\"Country must be a string\")\n++        if not isinstance(data['state'], str):\n++            raise InvalidOrderError(\"State must be a string\")\n++            \n++        return cls(\n++            country=data['country'],\n++            state=data['state']\n++        )\n++\n++class DiscountStrategy(ABC):\n++    \"\"\"Interface for discount calculation strategies.\"\"\"\n++    @abstractmethod\n++    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n++        pass\n++\n++class TierBasedDiscount(DiscountStrategy):\n++    \"\"\"Strategy for calculating discounts based on customer tier and subtotal.\"\"\"\n++    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n++        customer = context.get('customer', {})\n++        tier = customer.get('tier', 'standard')\n++        amount = subtotal.amount\n++\n++        if tier == 'gold':\n++            if amount >= 500: return subtotal * 0.20\n++            if amount >= 200: return subtotal * 0.15\n++            if amount >= 100: return subtotal * 0.10\n++            return subtotal * 0.05\n++        elif tier == 'silver':\n++            if amount >= 500: return subtotal * 0.15\n++            if amount >= 200: return subtotal * 0.10\n++            if amount >= 100: return subtotal * 0.05\n++            return Money(Decimal('0'))\n+         else:\n+-            if subtotal >= 500:\n+-                discount = subtotal * 0.10\n+-            elif subtotal >= 200:\n+-                discount = subtotal * 0.05\n+-            else:\n+-                discount = 0\n+-\n+-        if promo_code:\n+-            if promo_code == 'SAVE10':\n+-                promo_discount = subtotal * 0.10\n+-                if promo_discount > discount:\n+-                    discount = promo_discount\n+-            elif promo_code == 'SAVE20':\n+-                promo_discount = subtotal * 0.20\n+-                if promo_discount > discount:\n+-                    discount = promo_discount\n+-            elif promo_code == 'FLAT50':\n+-                if subtotal >= 100:\n+-                    promo_discount = 50.0\n+-                    if promo_discount > discount:\n+-                        discount = promo_discount\n+-\n+-        shipping_cost = 0.0\n+-        country = shipping_address.get('country', 'US')\n++            if amount >= 500: return subtotal * 0.10\n++            if amount >= 200: return subtotal * 0.05\n++            return Money(Decimal('0'))\n++\n++class PromoCodeDiscount(DiscountStrategy):\n++    \"\"\"Strategy for calculating discounts based on promotional codes.\"\"\"\n++    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n++        promo_code = context.get('promo_code')\n++        if not promo_code:\n++            return Money(Decimal('0'))\n++\n++        if promo_code == 'SAVE10':\n++            return subtotal * 0.10\n++        elif promo_code == 'SAVE20':\n++            return subtotal * 0.20\n++        elif promo_code == 'FLAT50':\n++            if subtotal >= Money(Decimal('100')):\n++                return Money(Decimal('50.0'))\n++        return Money(Decimal('0'))\n++\n++class VolumeDiscount(DiscountStrategy):\n++    \"\"\"Strategy for calculating discounts based on order volume.\"\"\"\n++    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n++        # Original logic has no specific volume discount, implemented for extensibility.\n++        return Money(Decimal('0'))\n++\n++class ShippingCalculator:\n++    \"\"\"Handles logic for calculating shipping costs.\"\"\"\n++    def calculate(self, items: List[Dict[str, Any]], address: Address, \n++                  subtotal: Money, discount: Money, inventory: Dict[str, Any]) -> Money:\n+         total_weight = sum(\n+-            self.inventory[item['product_id']].get('weight', 1) * item['quantity']\n++            inventory[item['product_id']].get('weight', 1) * item['quantity']\n+             for item in items\n+         )\n+-\n++        \n++        country = address.country\n++        cost = 0.0\n++        \n+         if country == 'US':\n+-            if total_weight <= 1:\n+-                shipping_cost = 5.99\n+-            elif total_weight <= 5:\n+-                shipping_cost = 9.99\n+-            elif total_weight <= 20:\n+-                shipping_cost = 14.99\n+-            else:\n+-                shipping_cost = 24.99\n++            if total_weight <= 1: cost = 5.99\n++            elif total_weight <= 5: cost = 9.99\n++            elif total_weight <= 20: cost = 14.99\n++            else: cost = 24.99\n+         elif country in ['CA', 'MX']:\n+-            if total_weight <= 1:\n+-                shipping_cost = 9.99\n+-            elif total_weight <= 5:\n+-                shipping_cost = 19.99\n+-            elif total_weight <= 20:\n+-                shipping_cost = 34.99\n+-            else:\n+-                shipping_cost = 49.99\n++            if total_weight <= 1: cost = 9.99\n++            elif total_weight <= 5: cost = 19.99\n++            elif total_weight <= 20: cost = 34.99\n++            else: cost = 49.99\n++        elif country in ['US', 'UK', 'DE', 'FR', 'JP', 'AU']: # Example supported list\n++            if total_weight <= 1: cost = 19.99\n++            elif total_weight <= 5: cost = 39.99\n++            elif total_weight <= 20: cost = 69.99\n++            else: cost = 99.99\n+         else:\n+-            if total_weight <= 1:\n+-                shipping_cost = 19.99\n+-            elif total_weight <= 5:\n+-                shipping_cost = 39.99\n+-            elif total_weight <= 20:\n+-                shipping_cost = 69.99\n+-            else:\n+-                shipping_cost = 99.99\n+-\n+-        if country == 'US' and (subtotal - discount) >= 100:\n+-            shipping_cost = 0.0\n+-\n+-        tax_rate = 0.0\n+-        state = shipping_address.get('state', '')\n+-        if country == 'US':\n+-            if state in ['CA', 'NY', 'TX']:\n+-                tax_rate = 0.08\n+-            elif state in ['WA', 'FL']:\n+-                tax_rate = 0.065\n+-            else:\n+-                tax_rate = 0.05\n++            # Added for Requirement 4\n++            raise ShippingNotAvailableError(f\"No shipping routes for {country}\")\n++            \n++        if country == 'US' and (subtotal - discount) >= Money(Decimal('100')):\n++            cost = 0.0\n++            \n++        return Money.from_float(cost)\n+ \n+-        taxable_amount = subtotal - discount\n+-        tax = taxable_amount * tax_rate\n++class TaxCalculator:\n++    \"\"\"Handles logic for calculating taxes.\"\"\"\n++    def calculate(self, taxable_amount: Money, address: Address) -> Money:\n++        if address.country != 'US':\n++            return Money(Decimal('0'))\n++            \n++        rate = 0.05\n++        state = address.state\n++        if state in ['CA', 'NY', 'TX']:\n++            rate = 0.08\n++        elif state in ['WA', 'FL']:\n++            rate = 0.065\n++            \n++        return taxable_amount * rate\n++\n++class OrderProcessor:\n++    \"\"\"Refactored system for processing e-commerce orders.\"\"\"\n++    \n++    def __init__(self, \n++                 discount_strategies: Optional[List[DiscountStrategy]] = None,\n++                 shipping_calculator: Optional[ShippingCalculator] = None,\n++                 tax_calculator: Optional[TaxCalculator] = None):\n++        \"\"\"\n++        Initializes the OrderProcessor with optional custom strategies and calculators.\n++        Implements Dependency Injection (DI) as per requirement 2.\n++        \"\"\"\n++        self.orders: Dict[str, Any] = {}\n++        self.inventory: Dict[str, Any] = {}\n++        \n++        self.discount_strategies = discount_strategies or [\n++            TierBasedDiscount(),\n++            PromoCodeDiscount(),\n++            VolumeDiscount()\n++        ]\n++        self.shipping_calculator = shipping_calculator or ShippingCalculator()\n++        self.tax_calculator = tax_calculator or TaxCalculator()\n+ \n++    def add_product(self, product_id: str, name: str, price: float, \n++                    stock: int, weight: float = 1.0) -> None:\n++        \"\"\"Adds or updates a product in the inventory.\"\"\"\n++        self.inventory[product_id] = {\n++            'name': name,\n++            'price': price,\n++            'stock': stock,\n++            'weight': weight\n++        }\n++\n++    def process_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:\n++        \"\"\"Processes an order, calculates costs, and updates inventory.\"\"\"\n++        self._validate_input(order_data)\n++        \n++        customer = order_data['customer']\n++        items_data = order_data['items']\n++        address = Address.from_dict(order_data['shipping_address'])\n++        promo_code = order_data.get('promo_code')\n++\n++        # Check stock and quantity before any operations\n++        for item in items_data:\n++            product_id = item.get('product_id')\n++            quantity = item.get('quantity')\n++            \n++            if not product_id or quantity is None:\n++                raise InvalidOrderError(\"Each item must have a product_id and quantity\")\n++            \n++            if quantity <= 0:\n++                raise InvalidOrderError(f\"Invalid quantity {quantity} for product {product_id}\")\n++                \n++            if product_id not in self.inventory:\n++                raise ProductNotFoundError(product_id)\n++                \n++            if self.inventory[product_id]['stock'] < quantity:\n++                raise InsufficientInventoryError(\n++                    product_id=product_id, \n++                    requested=quantity, \n++                    available=self.inventory[product_id]['stock']\n++                )\n++\n++        # Calculate subtotal\n++        subtotal_val = Decimal('0')\n++        for item in items_data:\n++            product = self.inventory[item['product_id']]\n++            subtotal_val += Decimal(str(product['price'])) * Decimal(str(item['quantity']))\n++        subtotal = Money(subtotal_val)\n++\n++        # Apply best discount strategy\n++        context = {'customer': customer, 'promo_code': promo_code}\n++        discount = self._get_best_discount(subtotal, context)\n++        \n++        # Calculate shipping and taxes\n++        shipping_cost = self.shipping_calculator.calculate(items_data, address, subtotal, discount, self.inventory)\n++        taxable_amount = subtotal - discount\n++        tax = self.tax_calculator.calculate(taxable_amount, address)\n++        \n+         total = subtotal - discount + shipping_cost + tax\n+ \n+-        total = round(total, 2)\n+-        discount = round(discount, 2)\n+-        tax = round(tax, 2)\n+-        shipping_cost = round(shipping_cost, 2)\n++        # Simulated payment processing (Requirement 4)\n++        if order_data.get('simulate_payment_failure'):\n++            raise PaymentFailedError(f\"Payment failed for amount {total.to_float()}\")\n+ \n++        # Create order record\n+         order_id = f\"ORD-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n+-\n+         order = {\n+             'order_id': order_id,\n+             'customer_id': customer.get('id'),\n+-            'items': items,\n+-            'subtotal': subtotal,\n+-            'discount': discount,\n+-            'shipping_cost': shipping_cost,\n+-            'tax': tax,\n+-            'total': total,\n+-            'status': 'pending',\n++            'items': items_data,\n++            'subtotal': subtotal.to_float_raw(),\n++            'discount': discount.to_float(),\n++            'shipping_cost': shipping_cost.to_float(),\n++            'tax': tax.to_float(),\n++            'total': total.to_float(),\n++            'status': OrderStatus.PENDING.value,\n+             'created_at': datetime.now().isoformat()\n+         }\n+ \n+         self.orders[order_id] = order\n+ \n+-        for item in items:\n++        # Deduct inventory\n++        for item in items_data:\n+             self.inventory[item['product_id']]['stock'] -= item['quantity']\n+ \n+         return order\n+ \n+-    def add_product(self, product_id: str, name: str, price: float, \n+-                    stock: int, weight: float = 1.0) -> None:\n+-        self.inventory[product_id] = {\n+-            'name': name,\n+-            'price': price,\n+-            'stock': stock,\n+-            'weight': weight\n+-        }\n++    def _validate_input(self, order_data: Dict[str, Any]) -> None:\n++        \"\"\"Guard clauses for initial input validation.\"\"\"\n++        if not order_data:\n++            raise InvalidOrderError(\"Order data is required\")\n++        if 'items' not in order_data or not order_data['items']:\n++            raise InvalidOrderError(\"Order must have items\")\n++        if 'customer' not in order_data:\n++            raise InvalidOrderError(\"Order must have customer\")\n++        if 'shipping_address' not in order_data:\n++            raise InvalidOrderError(\"Order must have shipping address\")\n++\n++    def _get_best_discount(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n++        \"\"\"Finds and returns the maximum discount from all available strategies.\"\"\"\n++        best_discount = Money(Decimal('0'))\n++        for strategy in self.discount_strategies:\n++            current_discount = strategy.calculate(subtotal, context)\n++            if current_discount >= best_discount:\n++                best_discount = current_discount\n++        return best_discount\n+ \n+     def get_order(self, order_id: str) -> Optional[Dict[str, Any]]:\n++        \"\"\"Retrieves an order by its ID.\"\"\"\n+         return self.orders.get(order_id)\n+ \n+     def update_order_status(self, order_id: str, status: str) -> None:\n++        \"\"\"\n++        Updates the status of an existing order with valid transition checks.\n++        Valid transitions:\n++        PENDING -> PAID, CANCELLED\n++        PAID -> SHIPPED, CANCELLED\n++        SHIPPED -> DELIVERED\n++        \"\"\"\n+         if order_id not in self.orders:\n+-            raise Exception(f\"Order {order_id} not found\")\n++            raise InvalidOrderError(f\"Order {order_id} not found\")\n++\n++        try:\n++            new_status = OrderStatus(status)\n++        except ValueError:\n++            raise InvalidOrderError(f\"Invalid status: {status}\")\n++\n++        current_status = OrderStatus(self.orders[order_id]['status'])\n++        \n++        if current_status == new_status:\n++            return\n++\n++        # Simple state machine validation\n++        valid_transitions = {\n++            OrderStatus.PENDING: [OrderStatus.PAID, OrderStatus.CANCELLED],\n++            OrderStatus.PAID: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],\n++            OrderStatus.SHIPPED: [OrderStatus.DELIVERED],\n++            OrderStatus.DELIVERED: [],\n++            OrderStatus.CANCELLED: []\n++        }\n+ \n+-        valid_statuses = ['pending', 'paid', 'shipped', 'delivered', 'cancelled']\n+-        if status not in valid_statuses:\n+-            raise Exception(f\"Invalid status: {status}\")\n++        if new_status not in valid_transitions.get(current_status, []):\n++            raise InvalidOrderError(f\"Invalid transition from {current_status.value} to {new_status.value}\")\n+ \n+-        self.orders[order_id]['status'] = status\n++        self.orders[order_id]['status'] = new_status.value\ndiff --git a/9a9pcc-order-processing-refactor/repository_after/__init__.py b/9a9pcc-order-processing-refactor/repository_after/__init__.py\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/9a9pcc-order-processing-refactor/repository_after/main.py b/9a9pcc-order-processing-refactor/repository_after/main.py\nnew file mode 100644\nindex 000000000..249355de3\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/repository_after/main.py\n@@ -0,0 +1,389 @@\n+from typing import Dict, Any, Optional, List\n+from datetime import datetime\n+from decimal import Decimal, ROUND_HALF_EVEN\n+from enum import Enum\n+from dataclasses import dataclass\n+from abc import ABC, abstractmethod\n+\n+class OrderProcessingError(Exception):\n+    \"\"\"Base exception for all order processing errors.\"\"\"\n+    pass\n+\n+class InvalidOrderError(OrderProcessingError):\n+    \"\"\"Raised when the order data is invalid or missing required fields.\"\"\"\n+    pass\n+\n+class ProductNotFoundError(OrderProcessingError):\n+    \"\"\"Raised when a requested product does not exist in inventory.\"\"\"\n+    def __init__(self, product_id: str):\n+        super().__init__(f\"Product {product_id} not found\")\n+        self.product_id = product_id\n+        self.context = {\"product_id\": product_id}\n+\n+class InsufficientInventoryError(OrderProcessingError):\n+    \"\"\"Raised when there is not enough stock for a product.\"\"\"\n+    def __init__(self, product_id: str, requested: int, available: int):\n+        super().__init__(f\"Insufficient stock for product {product_id}\")\n+        self.product_id = product_id\n+        self.requested = requested\n+        self.available = available\n+        self.context = {\"product_id\": product_id, \"requested\": requested, \"available\": available}\n+\n+class PaymentFailedError(OrderProcessingError):\n+    \"\"\"Raised when payment processing fails.\"\"\"\n+    pass\n+\n+class ShippingNotAvailableError(OrderProcessingError):\n+    \"\"\"Raised when shipping is not available for the given address.\"\"\"\n+    pass\n+\n+class OrderStatus(Enum):\n+    \"\"\"Enum for representing various order statuses.\"\"\"\n+    PENDING = 'pending'\n+    PAID = 'paid'\n+    SHIPPED = 'shipped'\n+    DELIVERED = 'delivered'\n+    CANCELLED = 'cancelled'\n+\n+@dataclass(frozen=True)\n+class Money:\n+    \"\"\"Value object to handle currency operations safely using Decimal.\"\"\"\n+    amount: Decimal\n+\n+    @classmethod\n+    def from_float(cls, value: float) -> 'Money':\n+        return cls(Decimal(str(value)))\n+\n+    def __add__(self, other: 'Money') -> 'Money':\n+        if not isinstance(other, Money):\n+            return NotImplemented\n+        return Money(self.amount + other.amount)\n+\n+    def __sub__(self, other: 'Money') -> 'Money':\n+        if not isinstance(other, Money):\n+            return NotImplemented\n+        return Money(self.amount - other.amount)\n+\n+    def __mul__(self, other: Any) -> 'Money':\n+        if isinstance(other, (int, float)):\n+            return Money(self.amount * Decimal(str(other)))\n+        if isinstance(other, Decimal):\n+            return Money(self.amount * other)\n+        return NotImplemented\n+\n+    def __ge__(self, other: 'Money') -> bool:\n+        if not isinstance(other, Money):\n+            return NotImplemented\n+        return self.amount >= other.amount\n+\n+    def __lt__(self, other: 'Money') -> bool:\n+        if not isinstance(other, Money):\n+            return NotImplemented\n+        return self.amount < other.amount\n+\n+    def round(self) -> 'Money':\n+        \"\"\"Rounds the amount to 2 decimal places using Banker's rounding.\"\"\"\n+        return Money(self.amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_EVEN))\n+\n+    def to_float(self) -> float:\n+        \"\"\"Returns the rounded amount as a float.\"\"\"\n+        return float(self.amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_EVEN))\n+\n+    def to_float_raw(self) -> float:\n+        \"\"\"Returns the raw unrounded amount as a float.\"\"\"\n+        return float(self.amount)\n+\n+@dataclass(frozen=True)\n+class Address:\n+    \"\"\"Value object for shipping address.\"\"\"\n+    country: str = 'US'\n+    state: str = ''\n+\n+    @classmethod\n+    def from_dict(cls, data: Dict[str, Any]) -> 'Address':\n+        \"\"\"Creates an Address from a dictionary with validation. Enforces required fields.\"\"\"\n+        if not isinstance(data, dict):\n+            raise InvalidOrderError(\"Shipping address must be a dictionary\")\n+        \n+        # Enforce required fields\n+        if 'country' not in data:\n+            raise InvalidOrderError(\"Missing required field: country\")\n+        if 'state' not in data:\n+            raise InvalidOrderError(\"Missing required field: state\")\n+            \n+        if not isinstance(data['country'], str):\n+            raise InvalidOrderError(\"Country must be a string\")\n+        if not isinstance(data['state'], str):\n+            raise InvalidOrderError(\"State must be a string\")\n+            \n+        return cls(\n+            country=data['country'],\n+            state=data['state']\n+        )\n+\n+class DiscountStrategy(ABC):\n+    \"\"\"Interface for discount calculation strategies.\"\"\"\n+    @abstractmethod\n+    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n+        pass\n+\n+class TierBasedDiscount(DiscountStrategy):\n+    \"\"\"Strategy for calculating discounts based on customer tier and subtotal.\"\"\"\n+    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n+        customer = context.get('customer', {})\n+        tier = customer.get('tier', 'standard')\n+        amount = subtotal.amount\n+\n+        if tier == 'gold':\n+            if amount >= 500: return subtotal * 0.20\n+            if amount >= 200: return subtotal * 0.15\n+            if amount >= 100: return subtotal * 0.10\n+            return subtotal * 0.05\n+        elif tier == 'silver':\n+            if amount >= 500: return subtotal * 0.15\n+            if amount >= 200: return subtotal * 0.10\n+            if amount >= 100: return subtotal * 0.05\n+            return Money(Decimal('0'))\n+        else:\n+            if amount >= 500: return subtotal * 0.10\n+            if amount >= 200: return subtotal * 0.05\n+            return Money(Decimal('0'))\n+\n+class PromoCodeDiscount(DiscountStrategy):\n+    \"\"\"Strategy for calculating discounts based on promotional codes.\"\"\"\n+    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n+        promo_code = context.get('promo_code')\n+        if not promo_code:\n+            return Money(Decimal('0'))\n+\n+        if promo_code == 'SAVE10':\n+            return subtotal * 0.10\n+        elif promo_code == 'SAVE20':\n+            return subtotal * 0.20\n+        elif promo_code == 'FLAT50':\n+            if subtotal >= Money(Decimal('100')):\n+                return Money(Decimal('50.0'))\n+        return Money(Decimal('0'))\n+\n+class VolumeDiscount(DiscountStrategy):\n+    \"\"\"Strategy for calculating discounts based on order volume.\"\"\"\n+    def calculate(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n+        # Original logic has no specific volume discount, implemented for extensibility.\n+        return Money(Decimal('0'))\n+\n+class ShippingCalculator:\n+    \"\"\"Handles logic for calculating shipping costs.\"\"\"\n+    def calculate(self, items: List[Dict[str, Any]], address: Address, \n+                  subtotal: Money, discount: Money, inventory: Dict[str, Any]) -> Money:\n+        total_weight = sum(\n+            inventory[item['product_id']].get('weight', 1) * item['quantity']\n+            for item in items\n+        )\n+        \n+        country = address.country\n+        cost = 0.0\n+        \n+        if country == 'US':\n+            if total_weight <= 1: cost = 5.99\n+            elif total_weight <= 5: cost = 9.99\n+            elif total_weight <= 20: cost = 14.99\n+            else: cost = 24.99\n+        elif country in ['CA', 'MX']:\n+            if total_weight <= 1: cost = 9.99\n+            elif total_weight <= 5: cost = 19.99\n+            elif total_weight <= 20: cost = 34.99\n+            else: cost = 49.99\n+        elif country in ['US', 'UK', 'DE', 'FR', 'JP', 'AU']: # Example supported list\n+            if total_weight <= 1: cost = 19.99\n+            elif total_weight <= 5: cost = 39.99\n+            elif total_weight <= 20: cost = 69.99\n+            else: cost = 99.99\n+        else:\n+            # Added for Requirement 4\n+            raise ShippingNotAvailableError(f\"No shipping routes for {country}\")\n+            \n+        if country == 'US' and (subtotal - discount) >= Money(Decimal('100')):\n+            cost = 0.0\n+            \n+        return Money.from_float(cost)\n+\n+class TaxCalculator:\n+    \"\"\"Handles logic for calculating taxes.\"\"\"\n+    def calculate(self, taxable_amount: Money, address: Address) -> Money:\n+        if address.country != 'US':\n+            return Money(Decimal('0'))\n+            \n+        rate = 0.05\n+        state = address.state\n+        if state in ['CA', 'NY', 'TX']:\n+            rate = 0.08\n+        elif state in ['WA', 'FL']:\n+            rate = 0.065\n+            \n+        return taxable_amount * rate\n+\n+class OrderProcessor:\n+    \"\"\"Refactored system for processing e-commerce orders.\"\"\"\n+    \n+    def __init__(self, \n+                 discount_strategies: Optional[List[DiscountStrategy]] = None,\n+                 shipping_calculator: Optional[ShippingCalculator] = None,\n+                 tax_calculator: Optional[TaxCalculator] = None):\n+        \"\"\"\n+        Initializes the OrderProcessor with optional custom strategies and calculators.\n+        Implements Dependency Injection (DI) as per requirement 2.\n+        \"\"\"\n+        self.orders: Dict[str, Any] = {}\n+        self.inventory: Dict[str, Any] = {}\n+        \n+        self.discount_strategies = discount_strategies or [\n+            TierBasedDiscount(),\n+            PromoCodeDiscount(),\n+            VolumeDiscount()\n+        ]\n+        self.shipping_calculator = shipping_calculator or ShippingCalculator()\n+        self.tax_calculator = tax_calculator or TaxCalculator()\n+\n+    def add_product(self, product_id: str, name: str, price: float, \n+                    stock: int, weight: float = 1.0) -> None:\n+        \"\"\"Adds or updates a product in the inventory.\"\"\"\n+        self.inventory[product_id] = {\n+            'name': name,\n+            'price': price,\n+            'stock': stock,\n+            'weight': weight\n+        }\n+\n+    def process_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"Processes an order, calculates costs, and updates inventory.\"\"\"\n+        self._validate_input(order_data)\n+        \n+        customer = order_data['customer']\n+        items_data = order_data['items']\n+        address = Address.from_dict(order_data['shipping_address'])\n+        promo_code = order_data.get('promo_code')\n+\n+        # Check stock and quantity before any operations\n+        for item in items_data:\n+            product_id = item.get('product_id')\n+            quantity = item.get('quantity')\n+            \n+            if not product_id or quantity is None:\n+                raise InvalidOrderError(\"Each item must have a product_id and quantity\")\n+            \n+            if quantity <= 0:\n+                raise InvalidOrderError(f\"Invalid quantity {quantity} for product {product_id}\")\n+                \n+            if product_id not in self.inventory:\n+                raise ProductNotFoundError(product_id)\n+                \n+            if self.inventory[product_id]['stock'] < quantity:\n+                raise InsufficientInventoryError(\n+                    product_id=product_id, \n+                    requested=quantity, \n+                    available=self.inventory[product_id]['stock']\n+                )\n+\n+        # Calculate subtotal\n+        subtotal_val = Decimal('0')\n+        for item in items_data:\n+            product = self.inventory[item['product_id']]\n+            subtotal_val += Decimal(str(product['price'])) * Decimal(str(item['quantity']))\n+        subtotal = Money(subtotal_val)\n+\n+        # Apply best discount strategy\n+        context = {'customer': customer, 'promo_code': promo_code}\n+        discount = self._get_best_discount(subtotal, context)\n+        \n+        # Calculate shipping and taxes\n+        shipping_cost = self.shipping_calculator.calculate(items_data, address, subtotal, discount, self.inventory)\n+        taxable_amount = subtotal - discount\n+        tax = self.tax_calculator.calculate(taxable_amount, address)\n+        \n+        total = subtotal - discount + shipping_cost + tax\n+\n+        # Simulated payment processing (Requirement 4)\n+        if order_data.get('simulate_payment_failure'):\n+            raise PaymentFailedError(f\"Payment failed for amount {total.to_float()}\")\n+\n+        # Create order record\n+        order_id = f\"ORD-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n+        order = {\n+            'order_id': order_id,\n+            'customer_id': customer.get('id'),\n+            'items': items_data,\n+            'subtotal': subtotal.to_float_raw(),\n+            'discount': discount.to_float(),\n+            'shipping_cost': shipping_cost.to_float(),\n+            'tax': tax.to_float(),\n+            'total': total.to_float(),\n+            'status': OrderStatus.PENDING.value,\n+            'created_at': datetime.now().isoformat()\n+        }\n+\n+        self.orders[order_id] = order\n+\n+        # Deduct inventory\n+        for item in items_data:\n+            self.inventory[item['product_id']]['stock'] -= item['quantity']\n+\n+        return order\n+\n+    def _validate_input(self, order_data: Dict[str, Any]) -> None:\n+        \"\"\"Guard clauses for initial input validation.\"\"\"\n+        if not order_data:\n+            raise InvalidOrderError(\"Order data is required\")\n+        if 'items' not in order_data or not order_data['items']:\n+            raise InvalidOrderError(\"Order must have items\")\n+        if 'customer' not in order_data:\n+            raise InvalidOrderError(\"Order must have customer\")\n+        if 'shipping_address' not in order_data:\n+            raise InvalidOrderError(\"Order must have shipping address\")\n+\n+    def _get_best_discount(self, subtotal: Money, context: Dict[str, Any]) -> Money:\n+        \"\"\"Finds and returns the maximum discount from all available strategies.\"\"\"\n+        best_discount = Money(Decimal('0'))\n+        for strategy in self.discount_strategies:\n+            current_discount = strategy.calculate(subtotal, context)\n+            if current_discount >= best_discount:\n+                best_discount = current_discount\n+        return best_discount\n+\n+    def get_order(self, order_id: str) -> Optional[Dict[str, Any]]:\n+        \"\"\"Retrieves an order by its ID.\"\"\"\n+        return self.orders.get(order_id)\n+\n+    def update_order_status(self, order_id: str, status: str) -> None:\n+        \"\"\"\n+        Updates the status of an existing order with valid transition checks.\n+        Valid transitions:\n+        PENDING -> PAID, CANCELLED\n+        PAID -> SHIPPED, CANCELLED\n+        SHIPPED -> DELIVERED\n+        \"\"\"\n+        if order_id not in self.orders:\n+            raise InvalidOrderError(f\"Order {order_id} not found\")\n+\n+        try:\n+            new_status = OrderStatus(status)\n+        except ValueError:\n+            raise InvalidOrderError(f\"Invalid status: {status}\")\n+\n+        current_status = OrderStatus(self.orders[order_id]['status'])\n+        \n+        if current_status == new_status:\n+            return\n+\n+        # Simple state machine validation\n+        valid_transitions = {\n+            OrderStatus.PENDING: [OrderStatus.PAID, OrderStatus.CANCELLED],\n+            OrderStatus.PAID: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],\n+            OrderStatus.SHIPPED: [OrderStatus.DELIVERED],\n+            OrderStatus.DELIVERED: [],\n+            OrderStatus.CANCELLED: []\n+        }\n+\n+        if new_status not in valid_transitions.get(current_status, []):\n+            raise InvalidOrderError(f\"Invalid transition from {current_status.value} to {new_status.value}\")\n+\n+        self.orders[order_id]['status'] = new_status.value\ndiff --git a/9a9pcc-order-processing-refactor/repository_before/__init__.py b/9a9pcc-order-processing-refactor/repository_before/__init__.py\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/9a9pcc-order-processing-refactor/repository_before/main.py b/9a9pcc-order-processing-refactor/repository_before/main.py\nnew file mode 100644\nindex 000000000..1ee75bef4\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/repository_before/main.py\n@@ -0,0 +1,180 @@\n+from typing import Dict, Any, Optional\n+from datetime import datetime\n+\n+class OrderProcessor:\n+    def __init__(self):\n+        self.orders = {}\n+        self.inventory = {}\n+\n+    def process_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:\n+        if not order_data:\n+            raise Exception(\"Order data is required\")\n+        if 'items' not in order_data or not order_data['items']:\n+            raise Exception(\"Order must have items\")\n+        if 'customer' not in order_data:\n+            raise Exception(\"Order must have customer\")\n+        if 'shipping_address' not in order_data:\n+            raise Exception(\"Order must have shipping address\")\n+\n+        customer = order_data['customer']\n+        items = order_data['items']\n+        shipping_address = order_data['shipping_address']\n+        promo_code = order_data.get('promo_code')\n+\n+        for item in items:\n+            product_id = item['product_id']\n+            quantity = item['quantity']\n+            if product_id not in self.inventory:\n+                raise Exception(f\"Product {product_id} not found\")\n+            if self.inventory[product_id]['stock'] < quantity:\n+                raise Exception(f\"Insufficient stock for product {product_id}\")\n+\n+        subtotal = 0.0\n+        for item in items:\n+            product = self.inventory[item['product_id']]\n+            subtotal = subtotal + (product['price'] * item['quantity'])\n+\n+        discount = 0.0\n+        customer_tier = customer.get('tier', 'standard')\n+        if customer_tier == 'gold':\n+            if subtotal >= 500:\n+                discount = subtotal * 0.20\n+            elif subtotal >= 200:\n+                discount = subtotal * 0.15\n+            elif subtotal >= 100:\n+                discount = subtotal * 0.10\n+            else:\n+                discount = subtotal * 0.05\n+        elif customer_tier == 'silver':\n+            if subtotal >= 500:\n+                discount = subtotal * 0.15\n+            elif subtotal >= 200:\n+                discount = subtotal * 0.10\n+            elif subtotal >= 100:\n+                discount = subtotal * 0.05\n+            else:\n+                discount = 0\n+        else:\n+            if subtotal >= 500:\n+                discount = subtotal * 0.10\n+            elif subtotal >= 200:\n+                discount = subtotal * 0.05\n+            else:\n+                discount = 0\n+\n+        if promo_code:\n+            if promo_code == 'SAVE10':\n+                promo_discount = subtotal * 0.10\n+                if promo_discount > discount:\n+                    discount = promo_discount\n+            elif promo_code == 'SAVE20':\n+                promo_discount = subtotal * 0.20\n+                if promo_discount > discount:\n+                    discount = promo_discount\n+            elif promo_code == 'FLAT50':\n+                if subtotal >= 100:\n+                    promo_discount = 50.0\n+                    if promo_discount > discount:\n+                        discount = promo_discount\n+\n+        shipping_cost = 0.0\n+        country = shipping_address.get('country', 'US')\n+        total_weight = sum(\n+            self.inventory[item['product_id']].get('weight', 1) * item['quantity']\n+            for item in items\n+        )\n+\n+        if country == 'US':\n+            if total_weight <= 1:\n+                shipping_cost = 5.99\n+            elif total_weight <= 5:\n+                shipping_cost = 9.99\n+            elif total_weight <= 20:\n+                shipping_cost = 14.99\n+            else:\n+                shipping_cost = 24.99\n+        elif country in ['CA', 'MX']:\n+            if total_weight <= 1:\n+                shipping_cost = 9.99\n+            elif total_weight <= 5:\n+                shipping_cost = 19.99\n+            elif total_weight <= 20:\n+                shipping_cost = 34.99\n+            else:\n+                shipping_cost = 49.99\n+        else:\n+            if total_weight <= 1:\n+                shipping_cost = 19.99\n+            elif total_weight <= 5:\n+                shipping_cost = 39.99\n+            elif total_weight <= 20:\n+                shipping_cost = 69.99\n+            else:\n+                shipping_cost = 99.99\n+\n+        if country == 'US' and (subtotal - discount) >= 100:\n+            shipping_cost = 0.0\n+\n+        tax_rate = 0.0\n+        state = shipping_address.get('state', '')\n+        if country == 'US':\n+            if state in ['CA', 'NY', 'TX']:\n+                tax_rate = 0.08\n+            elif state in ['WA', 'FL']:\n+                tax_rate = 0.065\n+            else:\n+                tax_rate = 0.05\n+\n+        taxable_amount = subtotal - discount\n+        tax = taxable_amount * tax_rate\n+\n+        total = subtotal - discount + shipping_cost + tax\n+\n+        total = round(total, 2)\n+        discount = round(discount, 2)\n+        tax = round(tax, 2)\n+        shipping_cost = round(shipping_cost, 2)\n+\n+        order_id = f\"ORD-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n+\n+        order = {\n+            'order_id': order_id,\n+            'customer_id': customer.get('id'),\n+            'items': items,\n+            'subtotal': subtotal,\n+            'discount': discount,\n+            'shipping_cost': shipping_cost,\n+            'tax': tax,\n+            'total': total,\n+            'status': 'pending',\n+            'created_at': datetime.now().isoformat()\n+        }\n+\n+        self.orders[order_id] = order\n+\n+        for item in items:\n+            self.inventory[item['product_id']]['stock'] -= item['quantity']\n+\n+        return order\n+\n+    def add_product(self, product_id: str, name: str, price: float, \n+                    stock: int, weight: float = 1.0) -> None:\n+        self.inventory[product_id] = {\n+            'name': name,\n+            'price': price,\n+            'stock': stock,\n+            'weight': weight\n+        }\n+\n+    def get_order(self, order_id: str) -> Optional[Dict[str, Any]]:\n+        return self.orders.get(order_id)\n+\n+    def update_order_status(self, order_id: str, status: str) -> None:\n+        if order_id not in self.orders:\n+            raise Exception(f\"Order {order_id} not found\")\n+\n+        valid_statuses = ['pending', 'paid', 'shipped', 'delivered', 'cancelled']\n+        if status not in valid_statuses:\n+            raise Exception(f\"Invalid status: {status}\")\n+\n+        self.orders[order_id]['status'] = status\ndiff --git a/9a9pcc-order-processing-refactor/requirements.txt b/9a9pcc-order-processing-refactor/requirements.txt\nnew file mode 100644\nindex 000000000..88e9af00d\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/requirements.txt\n@@ -0,0 +1,2 @@\n+pytest\n+pytest-json-report\ndiff --git a/9a9pcc-order-processing-refactor/tests/__init__.py b/9a9pcc-order-processing-refactor/tests/__init__.py\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/9a9pcc-order-processing-refactor/tests/conftest.py b/9a9pcc-order-processing-refactor/tests/conftest.py\nnew file mode 100644\nindex 000000000..62a6f59fe\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/tests/conftest.py\n@@ -0,0 +1,9 @@\n+import os\n+import pytest\n+\n+def pytest_sessionfinish(session, exitstatus):\n+    pythonpath = os.environ.get('PYTHONPATH', '')\n+    is_legacy = 'repository_before' in pythonpath\n+    \n+    if is_legacy and exitstatus == 1:\n+        session.exitstatus = 0\ndiff --git a/9a9pcc-order-processing-refactor/tests/test_comprehensive_requirements.py b/9a9pcc-order-processing-refactor/tests/test_comprehensive_requirements.py\nnew file mode 100644\nindex 000000000..581ecaaca\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/tests/test_comprehensive_requirements.py\n@@ -0,0 +1,157 @@\n+import unittest\n+from datetime import datetime\n+from unittest.mock import patch\n+import concurrent.futures\n+from main import (\n+    OrderProcessor, PaymentFailedError, ShippingNotAvailableError,\n+    InsufficientInventoryError, InvalidOrderError, OrderStatus\n+)\n+\n+class TestComprehensiveRequirements(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = OrderProcessor()\n+        self.processor.add_product(\"p1\", \"Product 1\", 100.0, 50, 1.0)\n+        self.processor.add_product(\"p2\", \"Product 2\", 50.0, 100, 0.5)\n+\n+    def test_req4_payment_failed_error(self):\n+        # Requirement 4 & 11: Specific exception and message\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'standard'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'},\n+            'simulate_payment_failure': True\n+        }\n+        with self.assertRaises(PaymentFailedError) as cm:\n+            self.processor.process_order(order_data)\n+        self.assertIn(\"Payment failed for amount\", str(cm.exception))\n+\n+    def test_req4_shipping_not_available_error(self):\n+        # Requirement 4 & 11: Specific exception and message\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'standard'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': ' Mars ', 'state': ' Olympus Mons '}\n+        }\n+        with self.assertRaises(ShippingNotAvailableError) as cm:\n+            self.processor.process_order(order_data)\n+        self.assertIn(\"No shipping routes for  Mars \", str(cm.exception))\n+\n+    def test_req7_shipping_boundaries(self):\n+        # Requirement 7: weights at threshold (1, 5, 20)\n+        # US: <=1: 5.99, <=5: 9.99, <=20: 14.99, else: 24.99\n+        thresholds = [\n+            (1.0, 5.99),\n+            (1.1, 9.99),\n+            (5.0, 9.99),\n+            (5.1, 14.99),\n+            (20.0, 14.99),\n+            (20.1, 24.99)\n+        ]\n+        for weight, expected_cost in thresholds:\n+            p = OrderProcessor()\n+            p.add_product(\"px\", \"PX\", 10.0, 10, weight)\n+            order_data = {\n+                'customer': {'id': 'c1'},\n+                'items': [{'product_id': 'px', 'quantity': 1}],\n+                'shipping_address': {'country': 'US', 'state': 'OR'} # Avoid free shipping (subtotal < 100)\n+            }\n+            order = p.process_order(order_data)\n+            self.assertEqual(order['shipping_cost'], expected_cost, f\"Failed for weight {weight}\")\n+\n+    def test_req12_serial_and_inventory_deduction(self):\n+        # Requirement 12: Deducts inventory, serial orders\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'standard'},\n+            'items': [{'product_id': 'p1', 'quantity': 10}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        \n+        # First order\n+        self.processor.process_order(order_data)\n+        self.assertEqual(self.processor.inventory['p1']['stock'], 40)\n+        \n+        # Second order\n+        self.processor.process_order(order_data)\n+        self.assertEqual(self.processor.inventory['p1']['stock'], 30)\n+\n+    def test_req12_atomicity_on_failure(self):\n+        # Requirement 12: stock unchanged if exception raised\n+        initial_stock = self.processor.inventory['p1']['stock']\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'standard'},\n+            'items': [{'product_id': 'p1', 'quantity': 10}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'},\n+            'simulate_payment_failure': True\n+        }\n+        \n+        with self.assertRaises(PaymentFailedError):\n+            self.processor.process_order(order_data)\n+            \n+        self.assertEqual(self.processor.inventory['p1']['stock'], initial_stock)\n+\n+    def test_req13_state_isolation(self):\n+        # Requirement 13: Instance isolation\n+        p1 = OrderProcessor()\n+        p2 = OrderProcessor()\n+        \n+        p1.add_product(\"item\", \"name\", 100.0, 10, 1.0)\n+        p2.add_product(\"item\", \"name\", 100.0, 20, 1.0)\n+        \n+        self.assertEqual(p1.inventory[\"item\"][\"stock\"], 10)\n+        self.assertEqual(p2.inventory[\"item\"][\"stock\"], 20)\n+        \n+        # Modify p1\n+        p1.inventory[\"item\"][\"stock\"] = 5\n+        self.assertEqual(p2.inventory[\"item\"][\"stock\"], 20)\n+\n+    def test_req17_timestamp_predictability(self):\n+        # Requirement 17: Format and predictability (ISO format)\n+        mock_time = datetime(2025, 1, 1, 12, 0, 0)\n+        with patch('main.datetime') as mock_datetime:\n+            mock_datetime.now.return_value = mock_time\n+            mock_datetime.strftime = datetime.strftime # keep strftime working\n+            \n+            # Note: main.py uses datetime.now().strftime and datetime.now().isoformat()\n+            # If we mock datetime, we need to be careful.\n+            # In main.py: f\"ORD-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n+            \n+            # Simple check for ISO format without full mock if mocking is brittle\n+            # we just check the structure.\n+            order_data = {\n+                'customer': {'id': 'c1'},\n+                'items': [{'product_id': 'p1', 'quantity': 1}],\n+                'shipping_address': {'country': 'US', 'state': 'NY'}\n+            }\n+            order = self.processor.process_order(order_data)\n+            \n+            # Check ISO format: YYYY-MM-DDTHH:MM:SS...\n+            created_at = order['created_at']\n+            try:\n+                datetime.fromisoformat(created_at)\n+            except ValueError:\n+                self.fail(f\"created_at {created_at} is not in ISO format\")\n+\n+    def test_req13_concurrent_isolation_simulation(self):\n+        # Requirement 13: Prove isolation by running parallel tests\n+        # We run multiple process_order calls in separate threads \n+        # using separate OrderProcessor instances to ensure no shared state leaks.\n+        \n+        def run_independent_order(processor_idx):\n+            proc = OrderProcessor()\n+            proc.add_product(f\"item_{processor_idx}\", \"Name\", 100.0, 10, 1.0)\n+            order_data = {\n+                'customer': {'id': f'cust_{processor_idx}'},\n+                'items': [{'product_id': f'item_{processor_idx}', 'quantity': 1}],\n+                'shipping_address': {'country': 'US', 'state': 'NY'}\n+            }\n+            order = proc.process_order(order_data)\n+            return proc.inventory[f'item_{processor_idx}']['stock']\n+\n+        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n+            results = list(executor.map(run_independent_order, range(10)))\n+            \n+        for stock in results:\n+            self.assertEqual(stock, 9, \"Threaded execution resulted in inconsistent state\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\ndiff --git a/9a9pcc-order-processing-refactor/tests/test_domain_objects.py b/9a9pcc-order-processing-refactor/tests/test_domain_objects.py\nnew file mode 100644\nindex 000000000..9f8e41379\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/tests/test_domain_objects.py\n@@ -0,0 +1,61 @@\n+import unittest\n+from decimal import Decimal\n+try:\n+    from main import Money, Address, OrderStatus, InvalidOrderError\n+    HAS_DOMAIN_OBJECTS = True\n+except ImportError:\n+    HAS_DOMAIN_OBJECTS = False\n+    # Mock symbols so the class can be defined\n+    class Money: pass\n+    class Address: pass\n+    class OrderStatus: pass\n+    class InvalidOrderError(Exception): pass\n+\n+class TestDomainObjects(unittest.TestCase):\n+    def setUp(self):\n+        if not HAS_DOMAIN_OBJECTS:\n+            self.fail(\"Refactored domain objects (Money, Address, OrderStatus) are missing in this implementation.\")\n+\n+    def test_money_arithmetic(self):\n+        m1 = Money.from_float(10.50)\n+        m2 = Money.from_float(5.25)\n+        \n+        # Add\n+        self.assertEqual((m1 + m2).to_float(), 15.75)\n+        # Subtract\n+        self.assertEqual((m1 - m2).to_float(), 5.25)\n+        # Multiply\n+        self.assertEqual((m1 * 2).to_float(), 21.00)\n+        self.assertEqual((m1 * Decimal('0.1')).to_float(), 1.05)\n+        \n+        # Compare\n+        self.assertTrue(m1 >= m2)\n+        self.assertFalse(m2 >= m1)\n+        self.assertTrue(m2 < m1)\n+\n+    def test_money_rounding(self):\n+        # Test Banker's rounding (ROUND_HALF_EVEN)\n+        m_up = Money(Decimal('10.505'))\n+        self.assertEqual(m_up.to_float(), 10.50) # 0 is even\n+        m_up2 = Money(Decimal('10.515'))\n+        self.assertEqual(m_up2.to_float(), 10.52) # 2 is even\n+\n+    def test_address_validation(self):\n+        # Valid\n+        addr = Address.from_dict({'country': 'US', 'state': 'NY'})\n+        self.assertEqual(addr.country, 'US')\n+        \n+        # Invalid types\n+        with self.assertRaises(InvalidOrderError):\n+            Address.from_dict({'country': 123})\n+        with self.assertRaises(InvalidOrderError):\n+            Address.from_dict(\"not a dict\")\n+\n+    def test_order_status_enum(self):\n+        self.assertEqual(OrderStatus.PENDING.value, 'pending')\n+        self.assertEqual(OrderStatus('pending'), OrderStatus.PENDING)\n+        with self.assertRaises(ValueError):\n+            OrderStatus('invalid_status')\n+\n+if __name__ == '__main__':\n+    unittest.main()\ndiff --git a/9a9pcc-order-processing-refactor/tests/test_order_processing.py b/9a9pcc-order-processing-refactor/tests/test_order_processing.py\nnew file mode 100644\nindex 000000000..d721d87fe\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/tests/test_order_processing.py\n@@ -0,0 +1,201 @@\n+import unittest\n+from datetime import datetime\n+from main import OrderProcessor\n+\n+class TestOrderProcessor(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = OrderProcessor()\n+        self.processor.add_product(\"p1\", \"Product 1\", 100.0, 10, 2.0)\n+        self.processor.add_product(\"p2\", \"Product 2\", 50.0, 20, 0.5)\n+\n+    def test_basic_order(self):\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'standard'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        order = self.processor.process_order(order_data)\n+        \n+        # Weight: 2.0 -> Shipping (US, 1 < w <= 5): 9.99 -> BUT free shipping if (subtotal-discount) >= 100\n+        # Tax (US, NY): 0.08 * (100 - 0) = 8.0\n+        # Total: 100 + 0.0 + 8.0 = 108.0\n+        self.assertEqual(order['subtotal'], 100.0)\n+        self.assertEqual(order['discount'], 0.0)\n+        self.assertEqual(order['shipping_cost'], 0.0)\n+        self.assertEqual(order['tax'], 8.0)\n+        self.assertEqual(order['total'], 108.0)\n+        self.assertEqual(self.processor.inventory['p1']['stock'], 9)\n+\n+    def test_gold_tier_discounts(self):\n+        # Gold tier thresholds: >=500 (20%), >=200 (15%), >=100 (10%), else 5%\n+        scenarios = [\n+            (6, 600.0, 120.0), # 600 * 0.20 = 120\n+            (3, 300.0, 45.0),  # 300 * 0.15 = 45\n+            (1.5, 150.0, 15.0), # 150 * 0.10 = 15\n+            (0.5, 50.0, 2.5)    # 50 * 0.05 = 2.5\n+        ]\n+        \n+        for qty, expected_subtotal, expected_discount in scenarios:\n+            processor = OrderProcessor()\n+            processor.add_product(\"p1\", \"P1\", 100.0, 10, 1.0)\n+            order_data = {\n+                'customer': {'id': 'c1', 'tier': 'gold'},\n+                'items': [{'product_id': 'p1', 'quantity': qty}],\n+                'shipping_address': {'country': 'US', 'state': 'OR'} # 5% tax\n+            }\n+            order = processor.process_order(order_data)\n+            self.assertEqual(order['subtotal'], expected_subtotal)\n+            self.assertEqual(order['discount'], expected_discount)\n+\n+    def test_silver_tier_discounts(self):\n+        # Silver tier thresholds: >=500 (15%), >=200 (10%), >=100 (5%), else 0\n+        scenarios = [\n+            (6, 600.0, 90.0),  # 600 * 0.15 = 90\n+            (3, 300.0, 30.0),  # 300 * 0.10 = 30\n+            (1.5, 150.0, 7.5),  # 150 * 0.05 = 7.5\n+            (0.5, 50.0, 0.0)    # 0\n+        ]\n+        \n+        for qty, expected_subtotal, expected_discount in scenarios:\n+            processor = OrderProcessor()\n+            processor.add_product(\"p1\", \"P1\", 100.0, 10, 1.0)\n+            order_data = {\n+                'customer': {'id': 'c1', 'tier': 'silver'},\n+                'items': [{'product_id': 'p1', 'quantity': qty}],\n+                'shipping_address': {'country': 'US', 'state': 'OR'}\n+            }\n+            order = processor.process_order(order_data)\n+            self.assertEqual(order['subtotal'], expected_subtotal)\n+            self.assertEqual(order['discount'], expected_discount)\n+\n+    def test_standard_tier_discounts(self):\n+        # Standard tier thresholds: >=500 (10%), >=200 (5%), else 0\n+        scenarios = [\n+            (6, 600.0, 60.0),  # 600 * 0.10 = 60\n+            (3, 300.0, 15.0),  # 300 * 0.05 = 15\n+            (1.5, 150.0, 0.0)   # 0\n+        ]\n+        \n+        for qty, expected_subtotal, expected_discount in scenarios:\n+            processor = OrderProcessor()\n+            processor.add_product(\"p1\", \"P1\", 100.0, 10, 1.0)\n+            order_data = {\n+                'customer': {'id': 'c1', 'tier': 'standard'},\n+                'items': [{'product_id': 'p1', 'quantity': qty}],\n+                'shipping_address': {'country': 'US', 'state': 'OR'}\n+            }\n+            order = processor.process_order(order_data)\n+            self.assertEqual(order['subtotal'], expected_subtotal)\n+            self.assertEqual(order['discount'], expected_discount)\n+\n+    def test_promo_codes(self):\n+        # SAVE10: 10%, SAVE20: 20%, FLAT50: 50.0 if subtotal >= 100\n+        # Promo discount vs Tier discount: max wins\n+        \n+        # Scenario: Gold tier (100 -> 10.0 discount) + SAVE20 (100 -> 20.0 discount)\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'gold'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': 'US', 'state': 'OR'},\n+            'promo_code': 'SAVE20'\n+        }\n+        order = self.processor.process_order(order_data)\n+        self.assertEqual(order['discount'], 20.0) # 20% wins over 10%\n+\n+        # Scenario: Gold tier (100 -> 10.0 discount) + FLAT50 (50.0 discount)\n+        order_data['promo_code'] = 'FLAT50'\n+        order = self.processor.process_order(order_data)\n+        self.assertEqual(order['discount'], 50.0) # 50.0 wins over 10.0\n+\n+    def test_shipping_costs(self):\n+        # US: <=1: 5.99, <=5: 9.99, <=20: 14.99, else: 24.99\n+        # CA/MX: <=1: 9.99, <=5: 19.99, <=20: 34.99, else: 49.99\n+        # Other: <=1: 19.99, <=5: 39.99, <=20: 69.99, else: 99.99\n+        \n+        ship_scenarios = [\n+            ('US', 0.5, 5.99),\n+            ('US', 3.0, 9.99),\n+            ('US', 15.0, 14.99),\n+            ('US', 25.0, 24.99),\n+            ('CA', 0.5, 9.99),\n+            ('MX', 3.0, 19.99),\n+            ('UK', 0.5, 19.99),\n+            ('UK', 25.0, 99.99)\n+        ]\n+        \n+        for country, weight, expected_cost in ship_scenarios:\n+            processor = OrderProcessor()\n+            processor.add_product(\"p1\", \"P1\", 10.0, 100, weight)\n+            order_data = {\n+                'customer': {'id': 'c1'},\n+                'items': [{'product_id': 'p1', 'quantity': 1}],\n+                'shipping_address': {'country': country, 'state': 'XX'}\n+            }\n+            order = processor.process_order(order_data)\n+            self.assertEqual(order['shipping_cost'], expected_cost, f\"Failed for {country} with weight {weight}\")\n+\n+    def test_free_shipping_us(self):\n+        # country == 'US' and (subtotal - discount) >= 100: FREE\n+        processor = OrderProcessor()\n+        processor.add_product(\"p1\", \"P1\", 150.0, 10, 10.0)\n+        order_data = {\n+            'customer': {'id': 'c1', 'tier': 'standard'}, # 0 discount for 150\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        order = processor.process_order(order_data)\n+        self.assertEqual(order['shipping_cost'], 0.0)\n+\n+    def test_taxes_us(self):\n+        # CA, NY, TX: 8%\n+        # WA, FL: 6.5%\n+        # Others: 5%\n+        tax_scenarios = [\n+            ('CA', 0.08),\n+            ('NY', 0.08),\n+            ('TX', 0.08),\n+            ('WA', 0.065),\n+            ('FL', 0.065),\n+            ('OR', 0.05)\n+        ]\n+        for state, rate in tax_scenarios:\n+            processor = OrderProcessor()\n+            processor.add_product(\"p1\", \"P1\", 100.0, 10, 1.0)\n+            order_data = {\n+                'customer': {'id': 'c1', 'tier': 'standard'},\n+                'items': [{'product_id': 'p1', 'quantity': 1}],\n+                'shipping_address': {'country': 'US', 'state': state}\n+            }\n+            order = processor.process_order(order_data)\n+            self.assertEqual(order['tax'], round(100.0 * rate, 2))\n+\n+    def test_inventory_validation(self):\n+        # Specific exception types (Requirement 11)\n+        from main import ProductNotFoundError, InsufficientInventoryError\n+        \n+        with self.assertRaises(ProductNotFoundError) as cm:\n+            self.processor.process_order({\n+                'customer': {'id': 'c1'},\n+                'items': [{'product_id': 'nonexistent', 'quantity': 1}],\n+                'shipping_address': {'country': 'US', 'state': 'NY'}\n+            })\n+        self.assertEqual(cm.exception.product_id, \"nonexistent\")\n+        self.assertIn(\"Product nonexistent not found\", str(cm.exception))\n+\n+        initial_stock = self.processor.inventory['p1']['stock']\n+        with self.assertRaises(InsufficientInventoryError) as cm:\n+            self.processor.process_order({\n+                'customer': {'id': 'c1'},\n+                'items': [{'product_id': 'p1', 'quantity': 100}],\n+                'shipping_address': {'country': 'US', 'state': 'NY'}\n+            })\n+        self.assertEqual(cm.exception.product_id, \"p1\")\n+        self.assertEqual(cm.exception.requested, 100)\n+        self.assertEqual(cm.exception.available, initial_stock)\n+        self.assertIn(\"Insufficient stock for product p1\", str(cm.exception))\n+        \n+        # Verify inventory atomicity (Requirement 12)\n+        self.assertEqual(self.processor.inventory['p1']['stock'], initial_stock)\n+\n+if __name__ == '__main__':\n+    unittest.main()\ndiff --git a/9a9pcc-order-processing-refactor/tests/test_refactoring.py b/9a9pcc-order-processing-refactor/tests/test_refactoring.py\nnew file mode 100644\nindex 000000000..6f14edf75\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/tests/test_refactoring.py\n@@ -0,0 +1,127 @@\n+import unittest\n+try:\n+    from main import (\n+        OrderProcessor, InvalidOrderError, ProductNotFoundError, \n+        InsufficientInventoryError, OrderStatus\n+    )\n+    HAS_REFACTORED_FEATURES = True\n+except ImportError:\n+    # Fallback for repository_before\n+    from main import OrderProcessor\n+    HAS_REFACTORED_FEATURES = False\n+    InvalidOrderError = Exception\n+    ProductNotFoundError = Exception\n+    InsufficientInventoryError = Exception\n+\n+class TestOrderRefactoring(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = OrderProcessor()\n+        self.processor.add_product(\"p1\", \"Product 1\", 100.0, 10, 1.0)\n+\n+    def test_invalid_status(self):\n+        order_data = {\n+            'customer': {'id': 'c1'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        order = self.processor.process_order(order_data)\n+        order_id = order['order_id']\n+        \n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.update_order_status(order_id, \"SUPER_PAID\")\n+        self.assertIn(\"Invalid status: SUPER_PAID\", str(cm.exception))\n+        # Extra check: ensure it's NOT just a generic Exception if we are expecting refactored features\n+        if type(cm.exception) is Exception and InvalidOrderError is not Exception:\n+            self.fail(\"Raised generic Exception instead of InvalidOrderError\")\n+\n+    def test_negative_quantity(self):\n+        order_data = {\n+            'customer': {'id': 'c1'},\n+            'items': [{'product_id': 'p1', 'quantity': -1}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.process_order(order_data)\n+        self.assertIn(\"Invalid quantity -1\", str(cm.exception))\n+\n+    def test_missing_data(self):\n+        with self.assertRaises(Exception):\n+            self.processor.process_order({})\n+        with self.assertRaises(Exception):\n+            self.processor.process_order({'customer': {'id': 'c1'}}) # missing items\n+\n+    def test_insufficient_stock_context(self):\n+        order_data = {\n+            'customer': {'id': 'c1'},\n+            'items': [{'product_id': 'p1', 'quantity': 100}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        with self.assertRaises(InsufficientInventoryError) as cm:\n+            self.processor.process_order(order_data)\n+        \n+        self.assertEqual(cm.exception.product_id, \"p1\")\n+        self.assertEqual(cm.exception.requested, 100)\n+        self.assertEqual(cm.exception.available, 10)\n+        self.assertEqual(cm.exception.context['requested'], 100) \n+        self.assertIn(\"Insufficient stock for product p1\", str(cm.exception))\n+\n+    def test_address_validation_missing_fields(self):\n+        # Requirement 10: missing fields must raise exceptions\n+        base_order = {\n+            'customer': {'id': 'c1'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}]\n+        }\n+        \n+        # Missing shipping_address\n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.process_order(base_order)\n+        self.assertIn(\"Order must have shipping address\", str(cm.exception))\n+        \n+        # Missing country\n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.process_order({**base_order, 'shipping_address': {'state': 'NY'}})\n+        self.assertIn(\"Missing required field: country\", str(cm.exception))\n+        \n+        # Missing state\n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.process_order({**base_order, 'shipping_address': {'country': 'US'}})\n+        self.assertIn(\"Missing required field: state\", str(cm.exception))\n+\n+    def test_status_transitions(self):\n+        # Requirement 10: cover all valid/invalid status transitions\n+        order_data = {\n+            'customer': {'id': 'c1'},\n+            'items': [{'product_id': 'p1', 'quantity': 1}],\n+            'shipping_address': {'country': 'US', 'state': 'NY'}\n+        }\n+        order = self.processor.process_order(order_data)\n+        order_id = order['order_id']\n+        \n+        # PENDING -> PAID (Valid)\n+        self.processor.update_order_status(order_id, 'paid')\n+        self.assertEqual(self.processor.get_order(order_id)['status'], 'paid')\n+        \n+        # PAID -> SHIPPED (Valid)\n+        self.processor.update_order_status(order_id, 'shipped')\n+        self.assertEqual(self.processor.get_order(order_id)['status'], 'shipped')\n+        \n+        # SHIPPED -> DELIVERED (Valid)\n+        self.processor.update_order_status(order_id, 'delivered')\n+        self.assertEqual(self.processor.get_order(order_id)['status'], 'delivered')\n+        \n+        # DELIVERED -> CANCELLED (Invalid)\n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.update_order_status(order_id, 'cancelled')\n+        self.assertIn(\"Invalid transition from delivered to cancelled\", str(cm.exception))\n+        \n+        # SHIPPED -> PAID (Invalid - reset to shipped for test)\n+        order2 = self.processor.process_order(order_data)\n+        oid2 = order2['order_id']\n+        self.processor.update_order_status(oid2, 'paid')\n+        self.processor.update_order_status(oid2, 'shipped')\n+        with self.assertRaises(InvalidOrderError) as cm:\n+            self.processor.update_order_status(oid2, 'paid')\n+        self.assertIn(\"Invalid transition from shipped to paid\", str(cm.exception))\n+\n+if __name__ == '__main__':\n+    unittest.main()\ndiff --git a/9a9pcc-order-processing-refactor/trajectory/trajectory.md b/9a9pcc-order-processing-refactor/trajectory/trajectory.md\nnew file mode 100644\nindex 000000000..118d89d12\n--- /dev/null\n+++ b/9a9pcc-order-processing-refactor/trajectory/trajectory.md\n@@ -0,0 +1,32 @@\n+1. Audit the Original Code (Identify Debt):\n+   I audited the original `OrderProcessor`. It was plagued by primitive obsession (floats for money, dicts for addresses), deeply nested if-else chains for discounts and shipping, and duplicate logic across methods. Generic exceptions provided no context for failures.\n+\n+2. Introduce Money Value Object:\n+   I introduced a `Money` value object using `decimal.Decimal` to handle currency operations safely. This prevents floating-point precision issues and centralizes rounding logic (Banker's rounding).\n+   Learn why you shouldn't use floats for money: [https://youtu.be/P-v82O6Oid0](https://youtu.be/P-v82O6Oid0)\n+\n+3. Extract Strategy Interface for Discounts:\n+   The complex discount logic was refactored using the Strategy Pattern. I created a `DiscountStrategy` interface, allowing for clean implementations of `TierBasedDiscount` and `PromoCodeDiscount`.\n+   Design Patterns: Strategy Pattern explained: [https://youtu.be/v9ejT8FO-7I](https://youtu.be/v9ejT8FO-7I)\n+\n+4. Implement Polymorphic Discount Selection:\n+   Instead of nested conditionals, the `OrderProcessor` now iterates through a list of strategies and automatically selects the highest (best) discount for the customer.\n+\n+5. Encapulate Shipping Logic:\n+   The duplicate and fragile shipping cost calculation was extracted into a dedicated `ShippingCalculator`. This class handles country-specific rules and free-shipping triggers independently.\n+\n+6. Centralize Tax Calculation:\n+   Taxes are now handled by a `TaxCalculator`, which maps states to rates. This makes the system easier to update as tax laws change without touching the core processing logic.\n+\n+7. Introduce Custom Exception Hierarchy:\n+   Generic `Exception` calls were replaced with domain-specific exceptions like `InsufficientInventoryError` and `InvalidOrderError`. These provide specific error messages and contextual data (like product IDs).\n+\n+8. Use Address and Status Value Objects:\n+   Raw strings and dictionaries were replaced with `Address` dataclasses and `OrderStatus` enums. This adds validation at the point of creation rather than deep inside the processing logic.\n+\n+9. Apply Guard Clauses and Early Returns:\n+   I refactored the main `process_order` method to use guard clauses. This \"flattened\" the code, making it significantly more readable by handling error cases first.\n+   Learn about Guard Clauses: [https://youtu.be/2NXqwBQ6K8E](https://youtu.be/2NXqwBQ6K8E)\n+\n+10. Result: Maintainable and Testable Architecture:\n+    The resulting system is modular. Each component (discounts, shipping, taxes, validation) can be tested and versioned independently while preserving the exact bit-for-bit output of the original implementation.\n"
test_patch: ''
fail_to_pass:
- cd j1p4vf-ecommerce-order-processing-refactor && npm test -- --runTestsByPath tests/refactor-additional.test.js
pass_to_pass:
- cd j1p4vf-ecommerce-order-processing-refactor && npm test -- --runTestsByPath tests/refactored.test.js
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '2098'
  difficulty: hard
  files_changed: '20'
  pr_title: 9a9pcc-order-processing-refactor
  removed_lines: '0'
  source: gh-archive-pr
  test_files: '[{"path":"j1p4vf-ecommerce-order-processing-refactor/tests/refactor-additional.test.js","content":"/**\n * Additional tests for order processing refactor behavior\n */\n\nconst PaymentService = require(''../repository_after/services/PaymentService'');\nconst InventoryService = require(''../repository_after/services/InventoryService'');\nconst FraudCheckService = require(''../repository_after/services/FraudCheckService'');\nconst inventory = require(''../repository_after/infra/inventory'');\nconst { PaymentDeclinedError, FraudCheckFailedError } = require(''../repository_after/errors/OrderProcessingError'');\n\ndescribe(''Order processing refactor additional behavior'', () => {\n  beforeEach(() => {\n    inventory.reset();\n  });\n\n  describe(''PaymentService validation'', () => {\n    test(''rejects missing payment token with standardized error'', async () => {\n      expect.assertions(2);\n      try {\n        await PaymentService.authorizePayment('''', 42.75);\n      } catch (error) {\n        expect(error).toBeInstanceOf(PaymentDeclinedError);\n        expect(error.details.errorType).toBe(''INVALID_TOKEN'');\n      }\n    });\n\n    test(''rejects non-positive amounts with standardized error'', async () => {\n      expect.assertions(2);\n      try {\n        await PaymentService.authorizePayment(''valid-token'', 0);\n      } catch (error) {\n        expect(error).toBeInstanceOf(PaymentDeclinedError);\n        expect(error.details.errorType).toBe(''INVALID_AMOUNT'');\n      }\n    });\n  });\n\n  describe(''InventoryService reservation rollback'', () => {\n    test(''rolls back reservations if a later item cannot be reserved'', async () => {\n      inventory.initStock(''item-ok'', 2);\n      inventory.initStock(''item-low'', 0);\n\n      const result = await InventoryService.reserveStock([\n        { id: ''item-ok'', quantity: 1 },\n        { id: ''item-low'', quantity: 1 }\n      ]);\n\n      expect(result.success).toBe(false);\n      expect(result.reservationsRolledBack).toBe(true);\n\n      const remainingStock = await inventory.checkStock(''item-ok'');\n      expect(remainingStock).toBe(2);\n    });\n  });\n\n  describe(''FraudCheckService risk evaluation'', () => {\n    test(''flags fraudulent order when risk threshold exceeded'', async () => {\n      const orderData = {\n        userId: '''',\n        items: Array.from({ length: 60 }, (_, i) => ({\n          id: `item-${i}`,\n          price: 300,\n          quantity: 1\n        })),\n        paymentToken: ''''\n      };\n\n      const result = await FraudCheckService.checkFraud(orderData);\n\n      expect(result.passed).toBe(false);\n      expect(result.error).toBeInstanceOf(FraudCheckFailedError);\n      expect(result.riskScore).toBeGreaterThanOrEqual(80);\n    });\n  });\n});\n"}]'
  test_generation: agentic-docker
prompt: |-
  ep-eaglepoint-ai/bd_datasets_002 (#245): 9a9pcc-order-processing-refactor

  Clarify the required changes for the order processing refactor. No PR description was provided, so specify the intended behavior changes, user-facing outcomes, and any constraints or breaking changes expected.
original_pr_body: |-
  ep-eaglepoint-ai/bd_datasets_002 (#245): 9a9pcc-order-processing-refactor

  (no description)
quality_score: 0.8
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
