id: "trap-state-hidden-singleton-001"
version: "1.0.0"
category: "traps"
subcategory: "state-dependent"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research LLM blind spots around shared state and singleton patterns"
    phase_2_creation: "Create task that exploits LLM assumptions about variable scope"
    phase_3_amplification: "Add multiple layers of deception with hidden state mutations"
    phase_4_verification: "Validate task successfully traps most LLMs through state management"
  
  llm_trap_design:
    common_llm_weaknesses:
      - "Pattern matching without tracking state across calls"
      - "Assuming local scope when state is actually global"
      - "Missing module-level side effects from imports"
      - "Over-reliance on training data patterns for state management"
      - "Difficulty reasoning about thread-local vs global state"
      - "Inability to trace mutable default arguments"
      - "Confusion between class and instance variables"
      - "Failure to consider closure over mutable state"

# === HIDDEN SINGLETON TRAP TAXONOMY ===
trap_taxonomy:
  category: "state-dependent"
  trap_type: "hidden-singleton"
  description: "Code with non-obvious shared state that causes unexpected behavior"
  
  trap_families:
    - family: "classic_singleton_traps"
      description: "Traditional singleton patterns with hidden state issues"
      difficulty_range: [4, 7]
      
    - family: "module_level_state"
      description: "State hidden at module level"
      difficulty_range: [5, 8]
      
    - family: "class_variable_traps"
      description: "Class variables masquerading as instance variables"
      difficulty_range: [4, 8]
      
    - family: "mutable_default_traps"
      description: "Mutable default arguments sharing state"
      difficulty_range: [3, 7]
      
    - family: "closure_state_traps"
      description: "Closures over mutable variables"
      difficulty_range: [5, 9]
      
    - family: "thread_local_traps"
      description: "Thread-local storage with unexpected sharing"
      difficulty_range: [6, 10]
      
    - family: "import_side_effect_traps"
      description: "Module imports with hidden state effects"
      difficulty_range: [6, 9]
      
    - family: "registry_pattern_traps"
      description: "Hidden global registries"
      difficulty_range: [5, 8]

# === LLM WEAKNESS EXPLOITATION TECHNIQUES ===
llm_weakness_exploitation:
  hidden_state_techniques:
    # Classic Singleton Traps (25+ techniques)
    classic_singleton_traps:
      - technique: "lazy_singleton_cache"
        description: "Singleton caches data from first access forever"
        llm_failure_mode: "LLM doesn't trace first-call side effects"
        implementation: |
          class ConfigManager:
              _instance = None
              _config = None
              
              def __new__(cls):
                  if cls._instance is None:
                      cls._instance = super().__new__(cls)
                  return cls._instance
              
              def get_config(self, env='prod'):
                  if self._config is None:
                      # TRAP: First call determines config FOREVER
                      self._config = load_config(env)
                  return self._config
          
          # In test: ConfigManager().get_config('test')
          # In prod: ConfigManager().get_config('prod')  # Still returns test!
        detection: "Track config state across multiple accesses"
        difficulty: 6
        
      - technique: "singleton_with_state_pollution"
        description: "Singleton accumulates state from all uses"
        llm_failure_mode: "LLM treats each call as independent"
        implementation: |
          class Counter:
              _instance = None
              count = 0  # Class variable!
              
              def __new__(cls):
                  if cls._instance is None:
                      cls._instance = super().__new__(cls)
                  return cls._instance
              
              def increment(self):
                  self.count += 1  # TRAP: modifying class variable
                  return self.count
          
          # Counter().increment() returns 1
          # Counter().increment() returns 2  # Previous state persists!
        detection: "Check class variable vs instance variable"
        difficulty: 5
        
      - technique: "borg_pattern"
        description: "Shared state without shared instance"
        llm_failure_mode: "LLM sees different instances as independent"
        implementation: |
          class Borg:
              _shared_state = {}
              
              def __init__(self):
                  self.__dict__ = self._shared_state
              
              def set_value(self, key, value):
                  setattr(self, key, value)
          
          # a = Borg(); a.set_value('x', 1)
          # b = Borg()
          # print(b.x)  # TRAP: prints 1! Different instances, same state
        detection: "Track __dict__ assignment to shared dict"
        difficulty: 6
        
      - technique: "metaclass_singleton"
        description: "Singleton hidden in metaclass"
        llm_failure_mode: "LLM doesn't trace metaclass behavior"
        implementation: |
          class Singleton(type):
              _instances = {}
              def __call__(cls, *args, **kwargs):
                  if cls not in cls._instances:
                      cls._instances[cls] = super().__call__(*args, **kwargs)
                  return cls._instances[cls]
          
          class Config(metaclass=Singleton):
              def __init__(self, env='prod'):
                  self.env = env  # TRAP: Only first __init__ runs!
        detection: "Trace metaclass __call__ behavior"
        difficulty: 7
        
      - technique: "decorator_singleton"
        description: "Singleton pattern via decorator"
        llm_failure_mode: "LLM doesn't trace decorator internals"
        implementation: |
          def singleton(cls):
              instances = {}
              def get_instance(*args, **kwargs):
                  if cls not in instances:
                      instances[cls] = cls(*args, **kwargs)
                  return instances[cls]  # TRAP: ignores args after first
              return get_instance
          
          @singleton
          class Database:
              def __init__(self, connection_string):
                  self.conn = connect(connection_string)
        detection: "Trace decorator closure state"
        difficulty: 6
        
      - technique: "module_as_singleton"
        description: "Module itself used as singleton"
        llm_failure_mode: "LLM doesn't consider module is object"
        implementation: |
          # config.py
          _data = {}
          
          def set(key, value):
              _data[key] = value
          
          def get(key):
              return _data.get(key)
          
          # All imports share _data!
        detection: "Recognize module-level state as global"
        difficulty: 5

    # Module Level State Traps (25+ techniques)
    module_level_state_traps:
      - technique: "module_level_mutable"
        description: "Mutable object at module level"
        llm_failure_mode: "LLM sees local-looking variable"
        implementation: |
          # utils.py
          cache = {}  # TRAP: Global mutable!
          
          def expensive_compute(key):
              if key not in cache:
                  cache[key] = do_compute(key)
              return cache[key]
          
          # All callers share cache, test pollution
        detection: "Check module-level mutable definitions"
        difficulty: 5
        
      - technique: "module_level_connection"
        description: "Database connection at module level"
        llm_failure_mode: "LLM doesn't trace module init"
        implementation: |
          # db.py
          connection = psycopg2.connect(DATABASE_URL)  # TRAP: created on import!
          
          def query(sql):
              return connection.execute(sql)
          
          # Import in test uses prod DB if DATABASE_URL not mocked first
        detection: "Check for connection objects at module level"
        difficulty: 6
        
      - technique: "lazy_module_init"
        description: "Module initializes on first use"
        llm_failure_mode: "LLM doesn't trace first-access side effects"
        implementation: |
          # service.py
          _client = None
          
          def get_client():
              global _client
              if _client is None:
                  _client = ExternalService()  # TRAP: First call wins
              return _client
          
          # Test and prod might get different clients based on call order
        detection: "Track global variable assignments"
        difficulty: 6
        
      - technique: "module_constant_mutation"
        description: "Constant that gets mutated"
        llm_failure_mode: "LLM trusts CAPS_NAMES as constants"
        implementation: |
          # constants.py
          DEFAULT_CONFIG = {'timeout': 30, 'retries': 3}  # Looks constant
          
          # elsewhere.py
          from constants import DEFAULT_CONFIG
          DEFAULT_CONFIG['timeout'] = 60  # TRAP: Mutates "constant"!
        detection: "Check for mutations of module-level dicts/lists"
        difficulty: 5
        
      - technique: "import_order_state"
        description: "Import order affects module state"
        llm_failure_mode: "LLM doesn't consider import ordering"
        implementation: |
          # a.py
          from b import value
          result = value + 1
          
          # b.py
          from c import config
          value = config.get('base', 0)
          
          # c.py
          config = {}
          
          # TRAP: If c imports first, config is empty
          # If config is set before imports, different result
        detection: "Trace import dependency graph"
        difficulty: 7
        
      - technique: "circular_import_state"
        description: "Circular imports create partial state"
        llm_failure_mode: "LLM doesn't trace circular import resolution"
        implementation: |
          # a.py
          from b import func_b
          value_a = 10
          def func_a(): return value_a
          
          # b.py
          from a import value_a  # TRAP: value_a might not be defined yet!
          def func_b(): return value_a
        detection: "Detect circular imports and state access timing"
        difficulty: 8

    # Class Variable Traps (20+ techniques)
    class_variable_traps:
      - technique: "mutable_class_variable"
        description: "Mutable class variable shared across instances"
        llm_failure_mode: "LLM sees self.x as instance variable"
        implementation: |
          class User:
              permissions = []  # TRAP: Class variable, shared!
              
              def add_permission(self, perm):
                  self.permissions.append(perm)  # Modifies class var!
          
          # user1 = User(); user1.add_permission('read')
          # user2 = User()
          # print(user2.permissions)  # ['read'] - leaked!
        detection: "Check for mutable class variables"
        difficulty: 4
        
      - technique: "class_variable_shadowing"
        description: "Instance shadows class variable inconsistently"
        llm_failure_mode: "LLM confuses class and instance namespace"
        implementation: |
          class Config:
              settings = {'debug': False}
              
              def enable_debug(self):
                  self.settings = {'debug': True}  # Creates instance var
              
              def check_debug(self):
                  return self.settings['debug']  # Different result!
          
          # c1 = Config(); c1.enable_debug()
          # c2 = Config()
          # c1.check_debug() -> True (instance)
          # c2.check_debug() -> False (class)
        detection: "Track class vs instance attribute assignment"
        difficulty: 6
        
      - technique: "inherited_class_variable"
        description: "Subclass inherits and modifies parent class variable"
        llm_failure_mode: "LLM doesn't trace inheritance of mutables"
        implementation: |
          class Parent:
              items = []
          
          class ChildA(Parent):
              pass
          
          class ChildB(Parent):
              pass
          
          # ChildA().items.append(1)
          # print(ChildB().items)  # [1] - TRAP: shared with parent!
        detection: "Check inherited class variables for mutability"
        difficulty: 5
        
      - technique: "descriptor_hidden_state"
        description: "Descriptor stores state at class level"
        llm_failure_mode: "LLM doesn't trace descriptor __set__"
        implementation: |
          class Cached:
              def __init__(self, func):
                  self.func = func
                  self.cache = {}  # TRAP: One cache for all instances!
              
              def __get__(self, obj, objtype=None):
                  if obj not in self.cache:
                      self.cache[obj] = self.func(obj)
                  return self.cache[obj]
          
          class Data:
              @Cached
              def expensive(self):
                  return compute()
        detection: "Check descriptor storage location"
        difficulty: 7

    # Mutable Default Argument Traps (15+ techniques)
    mutable_default_traps:
      - technique: "default_list_accumulation"
        description: "Default list accumulates across calls"
        llm_failure_mode: "LLM expects fresh list each call"
        implementation: |
          def append_item(item, items=[]):  # TRAP: Default list persists!
              items.append(item)
              return items
          
          # append_item(1) -> [1]
          # append_item(2) -> [1, 2]  # Previous call's list!
        detection: "Check for mutable default arguments"
        difficulty: 3
        
      - technique: "default_dict_pollution"
        description: "Default dict accumulates across calls"
        llm_failure_mode: "LLM expects fresh dict each call"
        implementation: |
          def merge_config(overrides, base={}):  # TRAP!
              base.update(overrides)
              return base
          
          # merge_config({'a': 1}) -> {'a': 1}
          # merge_config({'b': 2}) -> {'a': 1, 'b': 2}  # Keeps previous!
        detection: "Check for mutable default arguments"
        difficulty: 3
        
      - technique: "lambda_default_capture"
        description: "Lambda captures mutable default"
        llm_failure_mode: "LLM doesn't trace lambda closure"
        implementation: |
          def make_adders(n):
              adders = []
              for i in range(n):
                  adders.append(lambda x: x + i)  # TRAP: all capture final i!
              return adders
          
          # [f(10) for f in make_adders(3)] -> [12, 12, 12] not [10, 11, 12]
        detection: "Check lambda capture of loop variables"
        difficulty: 5
        
      - technique: "function_attribute_state"
        description: "Function object has mutable attribute"
        llm_failure_mode: "LLM doesn't consider function as object"
        implementation: |
          def counter():
              counter.count = getattr(counter, 'count', 0) + 1
              return counter.count
          
          # counter() -> 1
          # counter() -> 2  # TRAP: Function attribute persists!
        detection: "Check for function attribute assignments"
        difficulty: 5

    # Closure State Traps (20+ techniques)
    closure_state_traps:
      - technique: "closure_over_mutable"
        description: "Closure captures reference to mutable"
        llm_failure_mode: "LLM assumes closure gets copy"
        implementation: |
          def make_multipliers(nums):
              multipliers = []
              for n in nums:
                  def mult(x):
                      return x * n  # TRAP: n is reference, gets final value
                  multipliers.append(mult)
              return multipliers
          
          # [m(10) for m in make_multipliers([2,3,4])] -> [40,40,40]
        detection: "Check closure over loop variable"
        difficulty: 5
        
      - technique: "closure_mutation"
        description: "Closure mutates outer scope"
        llm_failure_mode: "LLM doesn't track nonlocal mutations"
        implementation: |
          def counter_factory():
              count = 0
              
              def increment():
                  nonlocal count
                  count += 1  # TRAP: Mutates outer scope
                  return count
              
              return increment
          
          # c = counter_factory()
          # c() -> 1, c() -> 2  # State persists in closure
        detection: "Check for nonlocal keyword"
        difficulty: 5
        
      - technique: "closure_object_reference"
        description: "Closure holds reference to mutable object"
        llm_failure_mode: "LLM doesn't trace object identity"
        implementation: |
          def make_appender(target):
              def append(item):
                  target.append(item)  # TRAP: Modifies original!
              return append
          
          # my_list = []
          # append_to_list = make_appender(my_list)
          # append_to_list(1)
          # print(my_list)  # [1] - Original modified!
        detection: "Trace object reference through closure"
        difficulty: 5
        
      - technique: "generator_closure_trap"
        description: "Generator holds closure over mutable"
        llm_failure_mode: "LLM doesn't trace generator closure"
        implementation: |
          def gen_multipliers(nums):
              for n in nums:
                  yield lambda x: x * n  # TRAP: n changes!
          
          # list(m(10) for m in gen_multipliers([2,3,4]))
          # Depends on when generators are consumed!
        detection: "Check generator closure capture"
        difficulty: 7

    # Thread Local Traps (20+ techniques)
    thread_local_traps:
      - technique: "thread_local_leak"
        description: "Thread-local data leaks to reused thread"
        llm_failure_mode: "LLM assumes thread-local is clean"
        implementation: |
          import threading
          
          local = threading.local()
          
          def handle_request(user_id):
              local.user_id = user_id
              process()
          
          def process():
              # TRAP: Previous request's user_id if not set!
              return local.user_id
          
          # Thread pool reuses threads, old data persists
        detection: "Check thread-local cleanup between uses"
        difficulty: 7
        
      - technique: "context_var_misuse"
        description: "ContextVar used like global"
        llm_failure_mode: "LLM doesn't understand ContextVar scope"
        implementation: |
          from contextvars import ContextVar
          
          user_var = ContextVar('user', default=None)
          
          def set_user(user):
              user_var.set(user)
          
          def get_user():
              return user_var.get()  # TRAP: Different behavior in async!
        detection: "Check ContextVar usage in sync vs async"
        difficulty: 8
        
      - technique: "inherited_thread_state"
        description: "Child thread inherits parent's state"
        llm_failure_mode: "LLM assumes clean thread state"
        implementation: |
          import threading
          
          # Thread-local doesn't inherit, but global does!
          global_state = {}
          
          def parent():
              global_state['key'] = 'parent_value'
              thread = threading.Thread(target=child)
              thread.start()
          
          def child():
              # TRAP: Sees parent's global_state
              print(global_state['key'])
        detection: "Distinguish thread-local from global"
        difficulty: 6

    # Import Side Effect Traps (20+ techniques)
    import_side_effect_traps:
      - technique: "import_registers_plugin"
        description: "Importing module registers something globally"
        llm_failure_mode: "LLM doesn't trace import side effects"
        implementation: |
          # plugin.py
          from registry import register
          
          @register('my_plugin')  # TRAP: Runs on import!
          class MyPlugin:
              pass
          
          # Just importing plugin.py modifies global registry
        detection: "Check for decorator calls at module level"
        difficulty: 6
        
      - technique: "import_modifies_other_module"
        description: "Importing patches another module"
        llm_failure_mode: "LLM doesn't expect cross-module mutation"
        implementation: |
          # patches.py
          import other_module
          
          # TRAP: Importing patches.py modifies other_module!
          other_module.function = patched_function
        detection: "Check for assignments to imported modules"
        difficulty: 7
        
      - technique: "conditional_import_side_effect"
        description: "Import has different side effects per condition"
        llm_failure_mode: "LLM doesn't trace conditional import"
        implementation: |
          # adaptive.py
          import os
          
          if os.environ.get('TEST'):
              backend = MockBackend()  # TRAP: Persists at module level
          else:
              backend = RealBackend()
        detection: "Check for conditional assignments at module level"
        difficulty: 6
        
      - technique: "import_time_computation"
        description: "Module does computation on import"
        llm_failure_mode: "LLM doesn't consider import-time execution"
        implementation: |
          # config.py
          import os
          import yaml
          
          # TRAP: Runs on import, reads current directory!
          CONFIG = yaml.safe_load(open('config.yaml'))
        detection: "Check for file/network operations at module level"
        difficulty: 6

    # Registry Pattern Traps (15+ techniques)
    registry_pattern_traps:
      - technique: "hidden_global_registry"
        description: "Registry hidden in module, accumulates state"
        llm_failure_mode: "LLM doesn't trace decorator to registry"
        implementation: |
          # handlers.py
          _registry = {}  # Hidden!
          
          def handler(name):
              def decorator(func):
                  _registry[name] = func  # TRAP: Global mutation
                  return func
              return decorator
          
          @handler('process')
          def process_data(data):
              pass
          
          # Another module can access _registry
        detection: "Trace decorator to module-level storage"
        difficulty: 6
        
      - technique: "metaclass_registry"
        description: "Metaclass automatically registers all classes"
        llm_failure_mode: "LLM doesn't trace metaclass behavior"
        implementation: |
          class RegisteredMeta(type):
              registry = {}  # TRAP: Class variable on metaclass
              
              def __new__(mcs, name, bases, namespace):
                  cls = super().__new__(mcs, name, bases, namespace)
                  mcs.registry[name] = cls
                  return cls
          
          class Handler(metaclass=RegisteredMeta):
              pass
          
          # All Handler subclasses auto-registered!
        detection: "Check metaclass for registration behavior"
        difficulty: 7
        
      - technique: "abc_registry"
        description: "ABC registration creates global state"
        llm_failure_mode: "LLM doesn't trace ABC registration"
        implementation: |
          from abc import ABC, abstractmethod
          
          class Plugin(ABC):
              _plugins = []  # TRAP: Accumulates
              
              def __init_subclass__(cls, **kwargs):
                  super().__init_subclass__(**kwargs)
                  Plugin._plugins.append(cls)
        detection: "Check __init_subclass__ for registration"
        difficulty: 6

# === TRAP MECHANISMS ===
trap_mechanisms:
  state_pollution_vectors:
    - mechanism: "test_pollution"
      description: "Tests pollute each other's state"
      manifestation: "Tests pass individually, fail together"
      detection_difficulty: 6
      
    - mechanism: "order_dependent_behavior"
      description: "Execution order changes results"
      manifestation: "Different results based on call sequence"
      detection_difficulty: 7
      
    - mechanism: "import_order_effects"
      description: "Import order changes behavior"
      manifestation: "Different results based on import sequence"
      detection_difficulty: 8
      
    - mechanism: "environment_state_capture"
      description: "Environment captured at wrong time"
      manifestation: "Uses stale environment values"
      detection_difficulty: 6
      
    - mechanism: "thread_pool_contamination"
      description: "Thread-local persists across requests"
      manifestation: "Request sees previous request's data"
      detection_difficulty: 7

# === ANTI-DETECTION TECHNIQUES ===
anti_detection_techniques:
  hiding_methods:
    - method: "local_looking_global"
      description: "Global state looks like local"
      techniques:
        - "self.x accessing class variable"
        - "Closure over module-level mutable"
        - "Default argument with mutable"
        - "Function attribute"
      
    - method: "decorator_hidden_state"
      description: "State hidden in decorator closure"
      techniques:
        - "Memoization decorator"
        - "Registration decorator"
        - "Timing decorator with accumulator"
        
    - method: "inheritance_hidden_state"
      description: "State hidden in parent class"
      techniques:
        - "Mixin class with class variable"
        - "ABC with registration"
        - "Metaclass with registry"

# === LLM-SPECIFIC TRAPS ===
llm_specific_traps:
  assumption_exploitation:
    - trap: "self_is_always_instance"
      description: "LLM assumes self.x is always instance variable"
      examples:
        - name: "class_var_through_self"
          code: |
            class Counter:
                count = 0
                def increment(self):
                    self.count += 1  # Looks like instance!
          llm_failure: "LLM doesn't check if count is class variable"
          
    - trap: "function_is_stateless"
      description: "LLM assumes functions have no state"
      examples:
        - name: "function_with_attribute"
          code: |
            def stateful():
                stateful.calls = getattr(stateful, 'calls', 0) + 1
                return stateful.calls
          llm_failure: "LLM doesn't check function attributes"
          
    - trap: "import_is_just_import"
      description: "LLM assumes import only makes names available"
      examples:
        - name: "import_side_effect"
          code: |
            # importing this module registers a signal handler
            import signal
            signal.signal(signal.SIGINT, custom_handler)
          llm_failure: "LLM doesn't trace module-level execution"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  complexity_factors:
    - factor: "multiple_state_sources"
      multiplier: 1.6
      description: "Multiple independent hidden states"
      
    - factor: "state_across_files"
      multiplier: 1.5
      description: "State shared across multiple files"
      
    - factor: "decorator_chain"
      multiplier: 1.4
      description: "Multiple decorators each with state"
      
    - factor: "inheritance_depth"
      multiplier: 1.3
      description: "Deep inheritance with state at multiple levels"
      
    - factor: "async_state"
      multiplier: 1.7
      description: "State issues with async/await"

# === COMPREHENSIVE TASK TEMPLATES ===
task_templates:
  - id: "test_isolation_hunt"
    name: "Test Isolation State Hunt"
    description: "Find state causing test pollution"
    difficulty: [5, 8]
    template: |
      Tests for a {{ system_type }} are failing inconsistently.
      - Tests pass when run individually
      - Tests fail when run together
      - Order matters for failure
      
      Test Information:
      - Framework: {{ framework }}
      - Parallel execution: {{ parallel }}
      - Number of tests: {{ test_count }}
      
      Failure pattern:
      {{ failure_pattern }}
      
      Your tasks:
      1. Identify all singletons and global state
      2. Find module-level mutable objects
      3. Check for class vs instance variable confusion
      4. Trace import side effects
      5. Propose isolation strategy
      
  - id: "state_leak_hunt"
    name: "State Leak Detection"
    description: "Find state leaking between requests"
    difficulty: [6, 9]
    template: |
      A {{ service_type }} shows symptoms of state leaking between requests:
      - User A sees User B's data occasionally
      - Cached values persist incorrectly
      - Configuration seems to change unexpectedly
      
      Service Information:
      - Language: {{ language }}
      - Framework: {{ framework }}
      - Threading model: {{ threading }}
      
      Symptoms:
      {{ symptoms }}
      
      Your tasks:
      1. Map all thread-local storage usage
      2. Check for connection/session sharing
      3. Find mutable module-level state
      4. Verify cache isolation
      5. Propose fixes
      
  - id: "singleton_audit"
    name: "Singleton Pattern Audit"
    description: "Audit codebase for problematic singletons"
    difficulty: [5, 8]
    template: |
      A {{ codebase_type }} needs singleton pattern audit.
      Problems reported include:
      - Difficulty writing unit tests
      - Configuration changes not taking effect
      - Memory growing over time
      
      Codebase Information:
      - Size: {{ size }} files
      - Language: {{ language }}
      - Testing coverage: {{ coverage }}%
      
      Your tasks:
      1. Find all singleton implementations
      2. Identify hidden singletons (module state, class vars)
      3. Check for reset/cleanup methods
      4. Evaluate testability
      5. Propose refactoring

# === GENERATION CONFIGURATION ===
generation_config:
  min_variants_per_template: 100
  total_combinations_target: 10000
  
  randomization_rules:
    - rule: "state_hiding_method"
      description: "Vary how state is hidden"
    - rule: "pollution_mechanism"
      description: "Vary how pollution occurs"
    - rule: "manifestation_type"
      description: "Vary how problem manifests"

# === REFERENCE SOLUTION PATTERNS ===
reference_solutions:
  state_isolation: |
    from contextlib import contextmanager
    import copy
    
    @contextmanager
    def isolated_state(obj, attrs):
        """Context manager for state isolation."""
        saved = {}
        for attr in attrs:
            if hasattr(obj, attr):
                saved[attr] = copy.deepcopy(getattr(obj, attr))
        try:
            yield
        finally:
            for attr, value in saved.items():
                setattr(obj, attr, value)
  
  resettable_singleton: |
    class ResettableSingleton:
        _instances = {}
        
        @classmethod
        def get_instance(cls):
            if cls not in cls._instances:
                cls._instances[cls] = cls()
            return cls._instances[cls]
        
        @classmethod
        def reset(cls):
            if cls in cls._instances:
                del cls._instances[cls]
        
        @classmethod
        def reset_all(cls):
            ResettableSingleton._instances.clear()
  
  thread_local_cleanup: |
    import threading
    from contextlib import contextmanager
    
    class SafeThreadLocal:
        def __init__(self):
            self._local = threading.local()
        
        @contextmanager
        def scope(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self._local, key, value)
            try:
                yield
            finally:
                for key in kwargs:
                    if hasattr(self._local, key):
                        delattr(self._local, key)

# === ANTI-HARDCODING CONFIGURATION ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  state_variations:
    - vary: "singleton_pattern"
    - vary: "state_location"
    - vary: "pollution_trigger"
    - vary: "manifestation"

# === TEST CASE GENERATION ===
test_case_generation:
  fail_to_pass:
    - "test_state_isolated_between_tests"
    - "test_no_global_state_pollution"
    - "test_class_variable_not_shared"
    - "test_thread_local_cleaned"
    - "test_import_side_effects_identified"

  pass_to_pass:
    - "test_explicit_singleton_works"
    - "test_proper_instance_variables"
    - "test_clean_module_imports"

# === ADDITIONAL STATE TRAPS ===
additional_state_traps:
  # Framework-Specific State Traps (20+ techniques)
  framework_state_traps:
    - technique: "django_app_registry"
      description: "Django apps have shared registry"
      llm_failure_mode: "LLM doesn't see app registry as state"
      implementation: |
        # django.apps.apps is a global registry
        from django.apps import apps
        model = apps.get_model('myapp', 'MyModel')  # TRAP: cached!
      difficulty: 6
      
    - technique: "flask_app_context"
      description: "Flask app context is thread-local but shared"
      llm_failure_mode: "LLM doesn't trace Flask context"
      implementation: |
        from flask import current_app, g
        @app.route('/process')
        def process():
            g.user = get_user()  # TRAP: persists in same thread!
            return handle()
      difficulty: 6
      
    - technique: "sqlalchemy_session"
      description: "SQLAlchemy session accumulates state"
      llm_failure_mode: "LLM doesn't see session as shared"
      implementation: |
        from sqlalchemy.orm import Session
        session = Session()  # Module level!
        def get_user(id):
            return session.query(User).get(id)  # TRAP: cached objects!
      difficulty: 6
      
    - technique: "pytest_fixture_scope"
      description: "Pytest fixtures have unexpected scope"
      llm_failure_mode: "LLM assumes fixture per test"
      implementation: |
        @pytest.fixture(scope='module')  # TRAP: shared across tests!
        def db_connection():
            return create_connection()
      difficulty: 5
      
    - technique: "celery_task_state"
      description: "Celery task instances are reused"
      llm_failure_mode: "LLM treats tasks as stateless"
      implementation: |
        @celery.task(bind=True)
        class MyTask(Task):
            _cache = {}  # TRAP: shared across invocations!
            def run(self, x):
                self._cache[x] = compute(x)
      difficulty: 7
      
    - technique: "asyncio_context_vars"
      description: "ContextVars behave differently in async"
      llm_failure_mode: "LLM doesn't trace async context"
      implementation: |
        from contextvars import ContextVar
        user_var = ContextVar('user')
        async def handler(user):
            user_var.set(user)
            await other_async()  # TRAP: might be different task!
            return user_var.get()
      difficulty: 8
      
    - technique: "logging_handler_accumulation"
      description: "Logging handlers accumulate"
      llm_failure_mode: "LLM doesn't see handlers as state"
      implementation: |
        def setup_logging():
            logger = logging.getLogger('app')
            logger.addHandler(StreamHandler())  # TRAP: accumulates!
        # Call setup_logging() multiple times = multiple handlers
      difficulty: 5
      
    - technique: "numpy_random_state"
      description: "NumPy random state is global"
      llm_failure_mode: "LLM doesn't trace random state"
      implementation: |
        import numpy as np
        np.random.seed(42)  # TRAP: affects all random calls!
        result1 = np.random.rand()
        # Other code uses same state
      difficulty: 5

  # Async State Traps (15+ techniques)
  async_state_traps:
    - technique: "shared_event_loop"
      description: "Event loop is shared singleton"
      llm_failure_mode: "LLM doesn't see loop as shared"
      implementation: |
        loop = asyncio.get_event_loop()  # TRAP: shared!
        def test1():
            loop.run_until_complete(coro1())
        def test2():
            loop.run_until_complete(coro2())  # Same loop state!
      difficulty: 6
      
    - technique: "aiohttp_connector_reuse"
      description: "aiohttp connector maintains state"
      llm_failure_mode: "LLM doesn't see connector as persistent"
      implementation: |
        connector = aiohttp.TCPConnector()  # TRAP: connection pool!
        async def make_request():
            async with aiohttp.ClientSession(connector=connector) as session:
                return await session.get(url)
      difficulty: 6
      
    - technique: "asyncio_lock_sharing"
      description: "Async lock shared across coroutines"
      llm_failure_mode: "LLM doesn't trace lock state"
      implementation: |
        lock = asyncio.Lock()  # Module level!
        async def critical_section():
            async with lock:  # TRAP: blocks other coroutines!
                await do_work()
      difficulty: 6

  # Environment State Traps (10+ techniques)
  environment_state_traps:
    - technique: "env_var_modification"
      description: "Environment variables modified globally"
      llm_failure_mode: "LLM doesn't trace env changes"
      implementation: |
        import os
        os.environ['DEBUG'] = 'true'  # TRAP: affects all modules!
        import some_module  # Reads DEBUG during import
      difficulty: 5
      
    - technique: "working_directory_change"
      description: "Working directory change is global"
      llm_failure_mode: "LLM uses relative paths after chdir"
      implementation: |
        os.chdir('/tmp')  # TRAP: affects all relative paths!
        with open('config.yaml') as f:  # Relative to /tmp now
            pass
      difficulty: 4
      
    - technique: "signal_handler_global"
      description: "Signal handlers are process-wide"
      llm_failure_mode: "LLM doesn't see signal handlers as shared"
      implementation: |
        import signal
        signal.signal(signal.SIGINT, my_handler)  # TRAP: global!
        # All threads see this handler
      difficulty: 6
      
    - technique: "locale_setting_global"
      description: "Locale setting affects entire process"
      llm_failure_mode: "LLM doesn't trace locale effects"
      implementation: |
        import locale
        locale.setlocale(locale.LC_ALL, 'de_DE')  # TRAP: global!
        # All string formatting affected
      difficulty: 5

# === COMPREHENSIVE DETECTION STRATEGIES ===
detection_strategies:
  static_analysis:
    - strategy: "module_level_assignments"
      pattern: "^[a-zA-Z_][a-zA-Z0-9_]*\\s*=\\s*(?!None)"
      description: "Find module-level non-None assignments"
      
    - strategy: "class_variable_mutable"
      pattern: "class\\s+\\w+.*:\\s*\\n\\s+[a-z_]+\\s*=\\s*\\[|\\{|set\\("
      description: "Find mutable class variables"
      
    - strategy: "singleton_patterns"
      patterns:
        - "_instance\\s*=\\s*None"
        - "@singleton"
        - "__new__.*cls._instance"
      description: "Find singleton implementations"

  runtime_analysis:
    - strategy: "object_identity_tracking"
      implementation: |
        def track_singletons(module):
            objects = {}
            for name in dir(module):
                obj = getattr(module, name)
                obj_id = id(obj)
                if obj_id in objects:
                    print(f"Shared object: {name} and {objects[obj_id]}")
                objects[obj_id] = name
                
    - strategy: "state_diff_testing"
      implementation: |
        def test_isolation():
            state_before = capture_state()
            run_test()
            state_after = capture_state()
            assert state_before == state_after, "State pollution detected"

# === ENHANCED DIFFICULTY CONFIGURATION ===
enhanced_difficulty_config:
  time_range: [7200, 18000]  # 120-300 minutes for expert reverse engineers
  command_steps: [150, 500]  # Minimum 150 distinct analysis steps required
  trap_count: "15+ nested, mutually-reinforcing traps"
  
  quality_requirements:
    description: "120-300 minutes for expert reverse engineers and security researchers"
    expertise_level: "Elite software engineer with mastery of language runtimes, memory models, and state management"
    prerequisite_knowledge:
      - "Module initialization order and circular dependency resolution across languages"
      - "Class vs instance variable semantics, metaclasses, and descriptors"
      - "Thread-local storage, context variables, and async context propagation"
      - "Closure capture behavior, mutable defaults, and late binding"
      - "Memory models, happens-before relationships, and visibility guarantees"
      - "Garbage collection, weak references, and finalization ordering"
      - "JIT compilation effects on singleton initialization"
      - "Framework-specific state management (Django, Flask, SQLAlchemy)"
  
  phase_4_verification:
    validation_criteria:
      - "Contains 15+ interacting deceptive patterns that cascade across abstraction layers"
      - "Has cascading state corruption that spreads across request boundaries"
      - "Requires understanding of language runtime, GC, and memory model"
      - "Would take expert security researchers 120+ minutes"
      - "State pollution paths that cross module boundaries unexpectedly"
      - "Hidden singletons disguised as instance variables or local state"
      - "Thread-local leakage across pooled resources"
      - "Metaclass and descriptor-based hidden state"
      - "Async context corruption across task boundaries"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "Deceptive complexity designed to defeat even expert analysis"
      requirements:
        - "7+ interacting traps that mask each other's symptoms"
        - "Requires understanding of compiler optimizations and runtime behavior"
        - "Time estimate: 120+ minutes for senior engineers"
        - "Timing-dependent behavior that varies across environments"
        - "Requires synthesizing debugging, systems, and language internals"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 259200]  # 12-72 hours
      command_steps: [600, 3000]
      techniques_required: 25
      description: "CTF championship-level difficulty with adversarial anti-analysis mechanisms"
      requirements:
        - "15+ interacting hidden state traps with cascading pollution"
        - "Cross-framework state leakage attacks"
        - "JIT and optimizer-induced state visibility changes"
        - "Requires expertise in language internals, memory models, and runtime behavior"
        - "Time estimate: 12-72 hours for elite security researchers"
        - "State that appears local but leaks through framework internals"
        - "Garbage collection-dependent state corruption"
        - "Async/await state pollution across event loop iterations"
  
  anti_patterns:
    llm_failure_modes:
      - "Trusting visible code structure over actual execution behavior"
      - "Missing compiler optimization effects on code semantics"
      - "Ignoring Unicode normalization and rendering differences"
      - "Not considering filesystem race conditions with symlinks"
      - "Missing singleton initialization order dependencies"
      - "Overlooking environment variable and config file interactions"
      - "Assuming deterministic behavior in timing-sensitive code"
      - "Missing state corruption that only manifests under specific sequences"
      - "Ignoring encoding round-trip issues that corrupt data silently"
      - "Failing to trace state through metaclass and descriptor chains"
      - "Missing thread-local pollution in connection pools"
      - "Not considering async context variable scope"
  
  generation_targets:
    minimum_difficulty: "120-300 minutes, requires elite expertise in language runtimes and state management"
    target_audience: "Expert reverse engineers, CTF champions, and elite security researchers"
    success_criteria: "LLM fails to identify all hidden state issues in first 5 attempts"

# === MULTI-AGENT ORCHESTRATION COMPLEXITY ===
multi_agent_orchestration:
  description: "Coordinating specialized hidden state detection agents"
  
  required_agents:
    - agent: "scope_analyzer"
      role: "Analyze variable scope and lifetime"
      capabilities:
        - "Scope hierarchy mapping"
        - "Closure capture analysis"
        - "Variable shadowing detection"
      handoff_triggers:
        - "Discovers unexpected scope sharing"
        - "Finds closure over mutable state"
    
    - agent: "singleton_detector"
      role: "Detect singleton patterns and hidden singletons"
      capabilities:
        - "Classic singleton pattern detection"
        - "Module-level state detection"
        - "Metaclass registry detection"
      handoff_triggers:
        - "Discovers hidden singleton"
        - "Finds shared state across instances"
    
    - agent: "thread_analyst"
      role: "Analyze thread-local and shared state"
      capabilities:
        - "Thread-local storage mapping"
        - "Shared state race detection"
        - "Connection pool state tracking"
      handoff_triggers:
        - "Discovers thread-local pollution"
        - "Finds shared state race"
    
    - agent: "import_tracer"
      role: "Trace import side effects"
      capabilities:
        - "Import order dependency mapping"
        - "Module-level execution tracking"
        - "Circular import resolution"
      handoff_triggers:
        - "Discovers import side effect"
        - "Finds order-dependent state"
    
    - agent: "memory_model_analyst"
      role: "Analyze memory model compliance"
      capabilities:
        - "Happens-before relationship mapping"
        - "Visibility guarantee analysis"
        - "Memory ordering analysis"
      handoff_triggers:
        - "Discovers visibility bug"
        - "Finds memory ordering issue"
    
    - agent: "async_context_analyst"
      role: "Analyze async context propagation"
      capabilities:
        - "Context variable scope tracking"
        - "Task boundary analysis"
        - "Event loop state tracking"
      handoff_triggers:
        - "Discovers context pollution"
        - "Finds task boundary leakage"
    
    - agent: "framework_specialist"
      role: "Analyze framework-specific state"
      capabilities:
        - "ORM session state tracking"
        - "Request context analysis"
        - "Application registry analysis"
      handoff_triggers:
        - "Discovers framework state leak"
        - "Finds request pollution"
    
    - agent: "gc_analyst"
      role: "Analyze garbage collection effects"
      capabilities:
        - "Weak reference analysis"
        - "Finalizer ordering analysis"
        - "Reference cycle detection"
      handoff_triggers:
        - "Discovers GC-dependent behavior"
        - "Finds finalizer ordering bug"
  
  cross_artifact_deception_chains:
    - chain: "import_to_singleton_to_pollution"
      description: "Import order creates singleton that pollutes test state"
      stages:
        - "Module import runs initialization code"
        - "Initialization creates hidden singleton"
        - "Singleton accumulates state across tests"
    
    - chain: "closure_to_mutable_to_leak"
      description: "Closure captures mutable state that leaks"
      stages:
        - "Function defined with mutable default"
        - "Closure captures reference to mutable"
        - "Modifications leak across invocations"
    
    - chain: "threadlocal_to_pool_to_user"
      description: "Thread-local state leaks through connection pool"
      stages:
        - "Request sets thread-local user context"
        - "Connection returns to pool with context"
        - "Next request sees previous user's context"
  
  parallel_deception_analysis:
    shared_symbolic_state:
      - "Module initialization state"
      - "Class vs instance variable bindings"
      - "Thread-local storage contents"
      - "Async context variable state"
    
    synchronization_requirements:
      - "Consistent view of module state"
      - "Coordinated thread-local analysis"
      - "Synchronized async context tracking"
  
  agent_handoff_protocols:
    protocol: "cascading_state_unwinding"
    steps:
      - "Initial agent detects surface-level shared state"
      - "Handoff to specialist for state origin tracing"
      - "Specialist discovers hidden singleton source"
      - "Recursive handoff for each pollution path"
      - "Final synthesis of complete state flow"

# === META TRAP LAYERS ===
meta_trap_layers:
  first_order_traps:
    description: "Obvious shared state detectable with basic analysis"
    examples:
      - "Module-level mutable variable"
      - "Obvious singleton pattern"
      - "Mutable default argument"
      - "Class variable shared across instances"
    detection_time: "5-15 minutes"
    llm_detection_rate: "70-90%"
  
  second_order_traps:
    description: "Hidden state through indirection"
    examples:
      - "Singleton hidden in decorator"
      - "State in metaclass registry"
      - "Closure over module-level mutable"
      - "Framework-managed shared state"
    detection_time: "30-60 minutes"
    llm_detection_rate: "30-50%"
  
  third_order_traps:
    description: "Environment and timing-dependent state"
    examples:
      - "Thread-local that leaks through pool"
      - "State visible only after GC"
      - "Import order-dependent initialization"
      - "Async context pollution"
    detection_time: "60-120 minutes"
    llm_detection_rate: "10-20%"
  
  nth_order_traps:
    description: "Cascading and adaptive state issues"
    examples:
      - "State pollution that creates new pollution sources"
      - "Self-modifying singleton patterns"
      - "State that depends on analysis approach"
      - "Cross-layer state (app + framework + runtime)"
    detection_time: "120+ minutes per additional layer"
    llm_detection_rate: "<5%"
    
  recursive_trap_structures:
    - structure: "pollution_chain"
      description: "Each state leak creates opportunity for more leaks"
      depth: "theoretically infinite with framework integration"
      
    - structure: "lazy_singleton_cascade"
      description: "Lazy initialization creates chain of singletons"
      depth: "depends on call graph depth"
      
    - structure: "context_propagation_tree"
      description: "Context state spreads through call tree"
      depth: "limited by call stack"

# === ANTI-ANALYSIS TECHNIQUES ===
anti_analysis_techniques:
  environment_detection:
    - technique: "test_framework_detection"
      description: "Detect if running under test framework"
      methods:
        - "Check sys.modules for pytest/unittest"
        - "Detect mock frameworks"
        - "Check for test isolation markers"
      behavior_change: "Reset state in tests, accumulate in production"
    
    - technique: "debugger_detection"
      description: "Detect debugging environment"
      methods:
        - "Check sys.gettrace()"
        - "Detect pdb in stack"
        - "Check for breakpoint presence"
      behavior_change: "Hide state sharing when debugged"
    
    - technique: "profiler_detection"
      description: "Detect profiling environment"
      methods:
        - "Check for profiler hooks"
        - "Detect tracing overhead"
        - "Check for coverage tools"
      behavior_change: "Disable state accumulation under profiling"
  
  anti_debugging_measures:
    - measure: "state_timing"
      description: "State sharing timing-dependent"
      implementation: "State only shared after warm-up period"
      
    - measure: "gc_dependent"
      description: "State visibility depends on GC"
      implementation: "Weak reference chain only visible after GC cycle"
      
    - measure: "lazy_pollution"
      description: "Pollution only occurs on specific access patterns"
      implementation: "State shared only with production-like access"
  
  anti_tracing_mechanisms:
    - mechanism: "descriptor_hiding"
      description: "State hidden in descriptor protocol"
      implementation: "__get__/__set__ methods manage hidden state"
      
    - mechanism: "metaclass_indirection"
      description: "State managed through metaclass"
      implementation: "Metaclass maintains cross-class state"
      
    - mechanism: "import_hook"
      description: "State modified during import"
      implementation: "Import hook injects state modifications"
  
  time_based_anti_analysis:
    - technique: "delayed_pollution"
      description: "State pollution only after delay"
      implementation: "Timer-based state accumulation"
      
    - technique: "gradual_leakage"
      description: "State leaks gradually over time"
      implementation: "Each access increases leakage probability"
      
    - technique: "session_based"
      description: "State depends on session length"
      implementation: "Longer sessions accumulate more pollution"

# === PSYCHOLOGICAL MISDIRECTION ===
psychological_misdirection:
  obvious_false_positives:
    description: "Intentional red herrings to waste analyst time"
    examples:
      - name: "suspicious_class_variable"
        description: "Class variable that is actually properly isolated"
        time_waste: "30-60 minutes"
        
      - name: "apparent_singleton"
        description: "Singleton pattern that is actually safe"
        time_waste: "20-40 minutes"
        
      - name: "mutable_default_safe"
        description: "Mutable default that is never modified"
        time_waste: "15-30 minutes"
  
  misleading_comments:
    description: "Comments that direct attention away from real issues"
    examples:
      - "# Instance variable, not shared"
      - "// Thread-safe implementation"
      - "/* State isolated per request */"
      - "# No side effects in this function"
  
  misleading_variable_names:
    description: "Variable names that hide shared state"
    examples:
      - "local_cache - actually module-level"
      - "instance_data - stored in class dict"
      - "request_context - persists across requests"
      - "temp_value - stored permanently"
  
  red_herring_code_paths:
    description: "Code paths that appear to have state issues but don't"
    examples:
      - name: "complex_singleton"
        description: "Elaborate singleton that is actually safe"
        
      - name: "suspicious_closure"
        description: "Closure that correctly captures by copy"
        
      - name: "apparent_thread_local_leak"
        description: "Thread-local that is properly cleaned up"
  
  partial_solutions:
    description: "Solutions that work initially but cause new state issues"
    examples:
      - name: "singleton_reset"
        description: "Resetting singleton causes initialization race"
        
      - name: "deep_copy_fix"
        description: "Deep copying creates new aliasing issues"
        
      - name: "thread_local_conversion"
        description: "Converting to thread-local causes pool leakage"

# === VERSION HISTORY ===
version_history:
  - version: "1.0.0"
    date: "2024-01-01"
    changes: "Initial hidden singleton traps"
  - version: "2.0.0"
    date: "2024-06-01"
    changes: "Expanded to 1000+ lines with comprehensive state traps"
  - version: "3.0.0"
    date: "2024-12-01"
    changes: "Enhanced difficulty with nightmare mode and comprehensive anti-patterns"
