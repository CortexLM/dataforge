id: "trap-timing-race-window-001"
version: "1.0.0"
category: "traps"
subcategory: "timing-attacks"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research LLM blind spots around concurrency and race conditions"
    phase_2_creation: "Create task that exploits LLM reasoning weaknesses about atomicity"
    phase_3_amplification: "Add multiple layers of deception with interleaved operations"
    phase_4_verification: "Validate task successfully traps most LLMs through race condition complexity"
  
  llm_trap_design:
    common_llm_weaknesses:
      - "Pattern matching without understanding concurrent execution"
      - "Assuming sequential execution in asynchronous code"
      - "Missing race windows in check-then-act patterns"
      - "Over-reliance on training data patterns for synchronization"
      - "Difficulty reasoning about all possible thread interleavings"
      - "Inability to visualize parallel execution timelines"
      - "Confusion between different synchronization primitives"
      - "Failure to consider interrupt and signal timing"

# === RACE WINDOW TRAP TAXONOMY ===
trap_taxonomy:
  category: "timing-attacks"
  trap_type: "race-window"
  description: "Code containing time-of-check-to-time-of-use (TOCTOU) vulnerabilities and race conditions"
  
  trap_families:
    - family: "file_system_races"
      description: "Race conditions in file system operations"
      difficulty_range: [4, 9]
      
    - family: "database_races"
      description: "Race conditions in database transactions"
      difficulty_range: [5, 10]
      
    - family: "memory_races"
      description: "Race conditions in shared memory access"
      difficulty_range: [6, 10]
      
    - family: "network_races"
      description: "Race conditions in network operations"
      difficulty_range: [5, 9]
      
    - family: "authentication_races"
      description: "Race conditions in auth/session management"
      difficulty_range: [7, 10]
      
    - family: "resource_races"
      description: "Race conditions in resource allocation"
      difficulty_range: [5, 9]
      
    - family: "state_machine_races"
      description: "Race conditions in state transitions"
      difficulty_range: [6, 10]

# === LLM WEAKNESS EXPLOITATION TECHNIQUES ===
llm_weakness_exploitation:
  race_condition_techniques:
    # File System Race Conditions (35+ techniques)
    file_system_races:
      - technique: "access_then_open"
        description: "Check access() then open() allows symlink swap"
        llm_failure_mode: "LLM sees permission check before open as secure"
        implementation: |
          def read_user_file(filepath):
              if os.access(filepath, os.R_OK):
                  # RACE WINDOW: attacker swaps file for symlink here
                  with open(filepath, 'r') as f:
                      return f.read()
        race_window_ms: [0.1, 10]
        difficulty: 6
        
      - technique: "stat_then_open"
        description: "stat() to check type then open() allows swap"
        llm_failure_mode: "LLM trusts stat results for subsequent operation"
        implementation: |
          def safe_read(path):
              st = os.stat(path)
              if stat.S_ISREG(st.st_mode):  # Check it's regular file
                  # RACE: could become symlink here
                  with open(path, 'r') as f:
                      return f.read()
        race_window_ms: [0.1, 10]
        difficulty: 6
        
      - technique: "exists_then_create"
        description: "Check file exists then create allows race"
        llm_failure_mode: "LLM sees existence check as sufficient"
        implementation: |
          def safe_create(path, content):
              if not os.path.exists(path):
                  # RACE: another process creates file here
                  with open(path, 'w') as f:  # Might overwrite!
                      f.write(content)
        race_window_ms: [0.1, 50]
        difficulty: 5
        
      - technique: "mkdir_race"
        description: "Check directory then mkdir allows race"
        llm_failure_mode: "LLM assumes directory check is atomic with creation"
        implementation: |
          def ensure_directory(path):
              if not os.path.isdir(path):
                  # RACE: another process creates it
                  os.mkdir(path)  # FileExistsError
        race_window_ms: [0.1, 50]
        difficulty: 4
        
      - technique: "tempfile_predictable"
        description: "Predictable temp filename allows symlink attack"
        llm_failure_mode: "LLM sees temp file as safe"
        implementation: |
          def process_data(data):
              # RACE: attacker predicts /tmp/process_12345.tmp
              tmpfile = f'/tmp/process_{os.getpid()}.tmp'
              with open(tmpfile, 'w') as f:
                  f.write(data)
        race_window_ms: [1, 1000]
        difficulty: 7
        
      - technique: "rename_race"
        description: "Check path then rename allows target swap"
        llm_failure_mode: "LLM trusts rename source validation"
        implementation: |
          def safe_move(src, dst):
              if os.path.exists(src) and not os.path.exists(dst):
                  # RACE: dst could be created, src could be changed
                  os.rename(src, dst)
        race_window_ms: [0.1, 10]
        difficulty: 5
        
      - technique: "chmod_race"
        description: "Modify permissions then access file"
        llm_failure_mode: "LLM assumes chmod effect is immediate and permanent"
        implementation: |
          def temporarily_expose(path):
              os.chmod(path, 0o644)  # Make readable
              # RACE: attacker copies file
              content = read_file(path)
              os.chmod(path, 0o600)  # Restore permissions
              return content
        race_window_ms: [0.1, 100]
        difficulty: 6
        
      - technique: "chown_race"
        description: "Change ownership then operate"
        llm_failure_mode: "LLM doesn't consider ownership changes as races"
        implementation: |
          def drop_privileges(path):
              os.chown(path, USER_ID, GROUP_ID)  # Change owner
              # RACE: another root process operates on file
              operate_on_file(path)
        race_window_ms: [0.1, 100]
        difficulty: 7
        
      - technique: "readlink_then_read"
        description: "Resolve symlink then read target"
        llm_failure_mode: "LLM trusts symlink resolution result"
        implementation: |
          def safe_read_link(path):
              target = os.readlink(path)
              if target.startswith('/safe/'):
                  # RACE: symlink could be changed
                  with open(path, 'r') as f:  # Follows NEW target
                      return f.read()
        race_window_ms: [0.1, 10]
        difficulty: 6
        
      - technique: "realpath_then_operate"
        description: "Canonicalize path then use original path"
        llm_failure_mode: "LLM doesn't notice path is not reused"
        implementation: |
          def validated_read(user_path):
              real = os.path.realpath(user_path)
              if real.startswith('/allowed/'):
                  # RACE: user_path could be changed to point elsewhere
                  with open(user_path, 'r') as f:  # Uses original!
                      return f.read()
        race_window_ms: [0.1, 10]
        difficulty: 7
        
      - technique: "glob_then_operate"
        description: "Glob files then operate on results"
        llm_failure_mode: "LLM assumes glob results are stable"
        implementation: |
          def process_all_configs():
              configs = glob.glob('/etc/app/*.conf')
              # RACE: new malicious config added
              for config in configs:
                  process(config)  # But operates on potentially new files
        race_window_ms: [1, 1000]
        difficulty: 5
        
      - technique: "scandir_iteration_race"
        description: "Directory modified during iteration"
        llm_failure_mode: "LLM assumes directory listing is snapshot"
        implementation: |
          def process_directory(path):
              for entry in os.scandir(path):
                  # RACE: files added/removed during iteration
                  if entry.is_file():
                      process(entry.path)  # May not exist anymore
        race_window_ms: [10, 1000]
        difficulty: 5

    # Database Race Conditions (30+ techniques)
    database_races:
      - technique: "read_modify_write"
        description: "Read value, modify, write back without locking"
        llm_failure_mode: "LLM sees read before write as validation"
        implementation: |
          def increment_counter(counter_id):
              value = db.query("SELECT value FROM counters WHERE id=?", counter_id)
              # RACE: another transaction reads same value
              db.execute("UPDATE counters SET value=? WHERE id=?", value+1, counter_id)
        race_window_ms: [1, 100]
        difficulty: 5
        
      - technique: "double_spend"
        description: "Balance check then debit allows overdraft"
        llm_failure_mode: "LLM sees balance validation before debit"
        implementation: |
          def transfer(from_id, to_id, amount):
              balance = db.query("SELECT balance FROM accounts WHERE id=?", from_id)
              if balance >= amount:
                  # RACE: parallel transaction already debited
                  db.execute("UPDATE accounts SET balance=balance-? WHERE id=?", amount, from_id)
                  db.execute("UPDATE accounts SET balance=balance+? WHERE id=?", amount, to_id)
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "inventory_oversell"
        description: "Check inventory then decrement"
        llm_failure_mode: "LLM trusts inventory check result"
        implementation: |
          def purchase_item(item_id, user_id):
              stock = db.query("SELECT quantity FROM inventory WHERE id=?", item_id)
              if stock > 0:
                  # RACE: other users also passed the check
                  db.execute("UPDATE inventory SET quantity=quantity-1 WHERE id=?", item_id)
                  db.execute("INSERT INTO orders (item_id, user_id) VALUES (?,?)", item_id, user_id)
        race_window_ms: [1, 100]
        difficulty: 5
        
      - technique: "user_registration_race"
        description: "Check username available then create"
        llm_failure_mode: "LLM sees uniqueness check as sufficient"
        implementation: |
          def register(username, password):
              exists = db.query("SELECT id FROM users WHERE username=?", username)
              if not exists:
                  # RACE: another registration uses same username
                  db.execute("INSERT INTO users (username, password) VALUES (?,?)", username, password)
        race_window_ms: [1, 100]
        difficulty: 5
        
      - technique: "coupon_double_use"
        description: "Validate coupon then mark used"
        llm_failure_mode: "LLM sees validation before use"
        implementation: |
          def apply_coupon(coupon_code, order_id):
              coupon = db.query("SELECT * FROM coupons WHERE code=? AND used=0", coupon_code)
              if coupon:
                  # RACE: parallel request also validated same coupon
                  apply_discount(order_id, coupon.discount)
                  db.execute("UPDATE coupons SET used=1 WHERE code=?", coupon_code)
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "sequence_gap"
        description: "Generate next ID then insert"
        llm_failure_mode: "LLM trusts sequence generation"
        implementation: |
          def create_record(data):
              next_id = db.query("SELECT MAX(id)+1 FROM records")
              # RACE: another insert uses same ID
              db.execute("INSERT INTO records (id, data) VALUES (?,?)", next_id, data)
        race_window_ms: [1, 100]
        difficulty: 4
        
      - technique: "phantom_read"
        description: "Query results change between reads in same transaction"
        llm_failure_mode: "LLM assumes transaction sees consistent data"
        implementation: |
          def process_batch():
              items = db.query("SELECT * FROM queue WHERE status='pending'")
              for item in items:
                  # RACE: some items already processed by parallel worker
                  process(item)
                  db.execute("UPDATE queue SET status='done' WHERE id=?", item.id)
        race_window_ms: [10, 1000]
        difficulty: 7
        
      - technique: "lost_update"
        description: "Two transactions overwrite each other's changes"
        llm_failure_mode: "LLM doesn't model concurrent transactions"
        implementation: |
          def update_profile(user_id, changes):
              profile = db.query("SELECT * FROM profiles WHERE user_id=?", user_id)
              profile.update(changes)
              # RACE: another update in parallel
              db.execute("UPDATE profiles SET data=? WHERE user_id=?", profile, user_id)
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "non_repeatable_read"
        description: "Value changes between reads in same transaction"
        llm_failure_mode: "LLM assumes reads are consistent"
        implementation: |
          def calculate_and_bill(account_id):
              rate = db.query("SELECT rate FROM accounts WHERE id=?", account_id)
              usage = calculate_usage(account_id)
              # RACE: rate changed by admin
              rate2 = db.query("SELECT rate FROM accounts WHERE id=?", account_id)
              bill = usage * rate  # Uses old rate
        race_window_ms: [10, 1000]
        difficulty: 6
        
      - technique: "cascade_delete_race"
        description: "Check references then delete"
        llm_failure_mode: "LLM sees reference check as safe"
        implementation: |
          def safe_delete(parent_id):
              children = db.query("SELECT COUNT(*) FROM children WHERE parent_id=?", parent_id)
              if children == 0:
                  # RACE: child added between check and delete
                  db.execute("DELETE FROM parents WHERE id=?", parent_id)
        race_window_ms: [1, 100]
        difficulty: 5

    # Memory Race Conditions (25+ techniques)
    memory_races:
      - technique: "check_then_act_flag"
        description: "Check boolean flag then act"
        llm_failure_mode: "LLM sees flag check as synchronization"
        implementation: |
          initialized = False
          data = None
          
          def get_data():
              global data
              if not initialized:
                  # RACE: multiple threads initialize
                  data = expensive_init()
                  initialized = True
              return data
        race_window_ms: [0.1, 10]
        difficulty: 5
        
      - technique: "list_modification_iteration"
        description: "Modify list while iterating"
        llm_failure_mode: "LLM doesn't track concurrent access to collections"
        implementation: |
          def cleanup_expired(items):
              for item in items:  # Iteration
                  if item.is_expired():
                      # RACE: other thread modifying items
                      items.remove(item)  # Modifies during iteration
        race_window_ms: [0.1, 10]
        difficulty: 5
        
      - technique: "dict_resize_race"
        description: "Dict resizes during concurrent access"
        llm_failure_mode: "LLM assumes dict operations are atomic"
        implementation: |
          cache = {}
          
          def get_or_create(key, factory):
              if key not in cache:
                  # RACE: dict could resize during check
                  cache[key] = factory()
              return cache[key]
        race_window_ms: [0.1, 10]
        difficulty: 6
        
      - technique: "counter_increment"
        description: "i += 1 is not atomic"
        llm_failure_mode: "LLM assumes simple operations are atomic"
        implementation: |
          counter = 0
          
          def increment():
              global counter
              counter += 1  # RACE: load, increment, store is 3 operations
        race_window_ms: [0.01, 1]
        difficulty: 4
        
      - technique: "lazy_singleton"
        description: "Lazy initialization race"
        llm_failure_mode: "LLM sees None check as safe initialization"
        implementation: |
          _instance = None
          
          def get_instance():
              global _instance
              if _instance is None:
                  # RACE: multiple threads create instances
                  _instance = ExpensiveObject()
              return _instance
        race_window_ms: [0.1, 100]
        difficulty: 5
        
      - technique: "publish_before_init"
        description: "Reference published before object fully initialized"
        llm_failure_mode: "LLM doesn't consider instruction reordering"
        implementation: |
          class Holder:
              def __init__(self):
                  self.data = None
          
          holder = Holder()
          
          def init():
              global holder
              h = Holder()
              h.data = expensive_init()
              # RACE: could be reordered, holder visible before data
              holder = h
        race_window_ms: [0.01, 1]
        difficulty: 8
        
      - technique: "stale_cache_read"
        description: "Cache not synchronized with source"
        llm_failure_mode: "LLM trusts cache validity"
        implementation: |
          cache = {}
          
          def get_value(key):
              if key in cache:
                  # RACE: source updated, cache stale
                  return cache[key]
              value = fetch_from_source(key)
              cache[key] = value
              return value
        race_window_ms: [1, 1000]
        difficulty: 5
        
      - technique: "compound_action"
        description: "Multiple steps treated as one"
        llm_failure_mode: "LLM groups related operations mentally"
        implementation: |
          def safe_transfer(from_acc, to_acc, amount):
              if from_acc.balance >= amount:
                  from_acc.balance -= amount
                  # RACE: crash here loses money
                  to_acc.balance += amount
        race_window_ms: [0.1, 10]
        difficulty: 6
        
      - technique: "thread_local_assumption"
        description: "Assuming variable is thread-local when shared"
        llm_failure_mode: "LLM trusts variable locality"
        implementation: |
          result = None  # Module level = shared!
          
          def compute(x):
              global result
              result = heavy_computation(x)
              # RACE: other thread overwrites result
              return result
        race_window_ms: [1, 100]
        difficulty: 5

    # Network Race Conditions (25+ techniques)
    network_races:
      - technique: "session_fixation_race"
        description: "Session created then associated with user"
        llm_failure_mode: "LLM sees session creation as atomic"
        implementation: |
          def login(username, password):
              session_id = create_session()
              if verify_password(username, password):
                  # RACE: session_id could be hijacked
                  associate_session(session_id, username)
        race_window_ms: [1, 1000]
        difficulty: 7
        
      - technique: "token_refresh_race"
        description: "Check token expired then refresh"
        llm_failure_mode: "LLM sees expiry check as valid"
        implementation: |
          def get_valid_token():
              if current_token.is_expired():
                  # RACE: parallel requests all refresh
                  current_token = refresh_token()
              return current_token
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "rate_limit_bypass"
        description: "Check rate limit then increment"
        llm_failure_mode: "LLM sees rate check before action"
        implementation: |
          def api_call(user_id, action):
              count = cache.get(f"ratelimit:{user_id}", 0)
              if count < LIMIT:
                  # RACE: parallel requests all pass check
                  cache.set(f"ratelimit:{user_id}", count + 1)
                  return perform_action(action)
              return "Rate limited"
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "captcha_race"
        description: "Validate captcha then use"
        llm_failure_mode: "LLM trusts captcha validation"
        implementation: |
          def submit_form(captcha_token, form_data):
              if validate_captcha(captcha_token):
                  # RACE: same captcha used in parallel request
                  return process_form(form_data)
        race_window_ms: [1, 1000]
        difficulty: 6
        
      - technique: "connection_pool_exhaustion"
        description: "Check pool then acquire"
        llm_failure_mode: "LLM doesn't consider pool as shared resource"
        implementation: |
          def get_connection():
              if pool.available() > 0:
                  # RACE: other threads deplete pool
                  return pool.acquire()  # Blocks or fails
        race_window_ms: [1, 100]
        difficulty: 5
        
      - technique: "distributed_lock_race"
        description: "Lock expiry during critical section"
        llm_failure_mode: "LLM assumes lock protects for duration needed"
        implementation: |
          def protected_operation():
              lock = redis.lock("resource", timeout=10)
              if lock.acquire():
                  try:
                      # RACE: operation takes >10s, lock expires
                      slow_operation()  # Other client gets lock!
                  finally:
                      lock.release()  # Releases wrong lock!
        race_window_ms: [10000, 60000]
        difficulty: 8
        
      - technique: "cache_stampede"
        description: "Cache expires and all requests rebuild"
        llm_failure_mode: "LLM sees caching as performance solution"
        implementation: |
          def get_expensive_data(key):
              data = cache.get(key)
              if data is None:
                  # RACE: many requests hit this simultaneously
                  data = expensive_computation()
                  cache.set(key, data, ttl=300)
              return data
        race_window_ms: [1, 1000]
        difficulty: 6
        
      - technique: "webhook_replay"
        description: "Webhook processed multiple times"
        llm_failure_mode: "LLM trusts webhook delivery once"
        implementation: |
          def handle_webhook(event_id, data):
              if not db.exists(f"processed:{event_id}"):
                  # RACE: duplicate webhook delivered
                  process_event(data)
                  db.set(f"processed:{event_id}", 1)
        race_window_ms: [1, 5000]
        difficulty: 6

    # Authentication/Session Race Conditions (20+ techniques)
    authentication_races:
      - technique: "login_logout_race"
        description: "Session validated then used after logout"
        llm_failure_mode: "LLM sees validation as sufficient"
        implementation: |
          def handle_request(session_id):
              session = get_session(session_id)
              if session.is_valid():
                  # RACE: user logs out here
                  return process_with_session(session)
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "permission_change_race"
        description: "Check permission then perform action"
        llm_failure_mode: "LLM trusts permission check result"
        implementation: |
          def delete_resource(user_id, resource_id):
              if has_permission(user_id, resource_id, 'delete'):
                  # RACE: permission revoked
                  return actually_delete(resource_id)
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "password_change_race"
        description: "Validate old password then accept new"
        llm_failure_mode: "LLM sees password validation as atomic"
        implementation: |
          def change_password(user_id, old_pass, new_pass):
              if verify_password(user_id, old_pass):
                  # RACE: password changed by parallel request
                  set_password(user_id, new_pass)
        race_window_ms: [1, 100]
        difficulty: 6
        
      - technique: "mfa_bypass_race"
        description: "MFA code validated then reused"
        llm_failure_mode: "LLM sees MFA as secure"
        implementation: |
          def verify_mfa(user_id, code):
              if totp.verify(code):
                  # RACE: same code used in parallel request (30s window)
                  return generate_session(user_id)
        race_window_ms: [1, 30000]
        difficulty: 7
        
      - technique: "account_link_race"
        description: "Link account checked then link created"
        llm_failure_mode: "LLM trusts link check"
        implementation: |
          def link_oauth(user_id, oauth_id):
              if not is_linked(oauth_id):
                  # RACE: another user links same oauth
                  create_link(user_id, oauth_id)
        race_window_ms: [1, 100]
        difficulty: 6

    # Resource Allocation Race Conditions (15+ techniques)
    resource_races:
      - technique: "quota_bypass"
        description: "Check quota then allocate"
        llm_failure_mode: "LLM sees quota check as enforcing limit"
        implementation: |
          def allocate_storage(user_id, size):
              used = get_usage(user_id)
              quota = get_quota(user_id)
              if used + size <= quota:
                  # RACE: parallel allocations exceed quota
                  allocate(user_id, size)
        race_window_ms: [1, 100]
        difficulty: 5
        
      - technique: "seat_license_race"
        description: "Check available seats then assign"
        llm_failure_mode: "LLM trusts seat count check"
        implementation: |
          def assign_seat(team_id, user_id):
              active = get_active_users(team_id)
              max_seats = get_license_seats(team_id)
              if active < max_seats:
                  # RACE: parallel assignments exceed seats
                  activate_user(team_id, user_id)
        race_window_ms: [1, 100]
        difficulty: 5
        
      - technique: "resource_pool_race"
        description: "Check pool availability then claim"
        llm_failure_mode: "LLM assumes check reflects current state"
        implementation: |
          def claim_resource():
              available = pool.get_available()
              if available:
                  # RACE: resource claimed by another process
                  resource = available[0]
                  return pool.claim(resource)
        race_window_ms: [1, 100]
        difficulty: 5

# === TRAP MECHANISMS ===
trap_mechanisms:
  activation_methods:
    - mechanism: "timing_window_exploitation"
      description: "Exploit the gap between check and use"
      variants:
        - "Symlink race in file operations"
        - "Database state change between queries"
        - "Memory value change between read and write"
        - "Network state change during request"
        - "Session invalidation during operation"
      detection_difficulty: 7
      
    - mechanism: "concurrent_request_flood"
      description: "Send many requests simultaneously"
      variants:
        - "Parallel HTTP requests"
        - "Multi-threaded database operations"
        - "Concurrent file operations"
        - "Simultaneous WebSocket messages"
      detection_difficulty: 6
      
    - mechanism: "slow_operation_exploitation"
      description: "Exploit delays in operations"
      variants:
        - "Network latency window"
        - "Database lock wait"
        - "File I/O delay"
        - "Computation time gap"
      detection_difficulty: 7
      
    - mechanism: "interrupt_injection"
      description: "Inject interrupts at critical points"
      variants:
        - "Signal delivery timing"
        - "Hardware interrupt timing"
        - "Software exception injection"
        - "Context switch forcing"
      detection_difficulty: 9
      
    - mechanism: "state_manipulation"
      description: "Change state between check and use"
      variants:
        - "File symlink swap"
        - "Database record modification"
        - "Memory write between read and use"
        - "Cache invalidation timing"
      detection_difficulty: 7

# === ANTI-DETECTION TECHNIQUES ===
anti_detection_techniques:
  obfuscation_methods:
    - method: "split_check_use"
      description: "Check and use in different functions/files"
      techniques:
        - "Check in validator, use in handler"
        - "Check in middleware, use in controller"
        - "Check via callback, use in main flow"
        - "Check cached, use original"
      example: |
        # validator.py
        def validate(resource_id):
            return db.exists(resource_id)
        
        # handler.py (different file!)
        def handle(resource_id):
            if validate(resource_id):  # Check
                time.sleep(0.01)  # Window disguised as processing
                return db.get(resource_id)  # Use
        
    - method: "hidden_race_window"
      description: "Race window hidden in seemingly atomic operation"
      techniques:
        - "Library function with internal race"
        - "Framework method with check-then-use"
        - "ORM operation that isn't atomic"
        - "API call with internal race"
      example: |
        def process(item):
            # ORM's get_or_create is NOT atomic in all DBs
            obj, created = Model.objects.get_or_create(key=item.key)
            obj.value = item.value
            obj.save()
        
    - method: "non_obvious_shared_state"
      description: "Shared state not obviously shared"
      techniques:
        - "Module-level variable"
        - "Class variable"
        - "Closure over mutable"
        - "Global via import"
      example: |
        # Looks like local state
        class Handler:
            cache = {}  # Class variable = shared!
            
            def handle(self, key):
                if key not in self.cache:  # self.cache is shared!
                    self.cache[key] = compute(key)
                return self.cache[key]
        
    - method: "timing_misdirection"
      description: "Race window disguised as feature"
      techniques:
        - "Logging between check and use"
        - "Metrics collection in window"
        - "Audit trail creation"
        - "Progress callback"
      example: |
        def transfer(from_acc, to_acc, amount):
            if from_acc.balance >= amount:
                log.info(f"Transfer approved")  # Creates race window
                from_acc.balance -= amount
                log.info(f"Debit complete")  # Another window
                to_acc.balance += amount
        
    - method: "abstraction_hiding"
      description: "Race hidden behind abstraction"
      techniques:
        - "Wrapper function hides check-use gap"
        - "Decorator adds race window"
        - "Context manager not atomic"
        - "Property accessor races"
      example: |
        def with_lock(resource_id):
            """Appears safe with 'lock' in name"""
            if is_available(resource_id):  # Check
                mark_locked(resource_id)  # Use - NOT atomic!
                return True
            return False

# === LLM-SPECIFIC TRAPS ===
llm_specific_traps:
  pattern_exploitation:
    - trap: "familiar_pattern_race"
      description: "Common pattern that looks safe but has race"
      examples:
        - name: "singleton_pattern"
          code: |
            class Singleton:
                _instance = None
                
                @classmethod
                def get_instance(cls):
                    if cls._instance is None:  # Check
                        cls._instance = cls()  # Use - RACE!
                    return cls._instance
          llm_failure: "LLM recognizes singleton pattern as standard"
          
        - name: "lazy_init_pattern"
          code: |
            _config = None
            
            def get_config():
                global _config
                if _config is None:
                    _config = load_config()  # RACE with parallel calls
                return _config
          llm_failure: "LLM sees lazy initialization as optimization"
          
        - name: "cache_pattern"
          code: |
            def cached_compute(key):
                if key not in cache:
                    cache[key] = expensive(key)  # RACE - computed twice
                return cache[key]
          llm_failure: "LLM sees caching as pure optimization"
          
    - trap: "sequential_thinking"
      description: "Code that only works sequentially"
      examples:
        - name: "implicit_sequence"
          code: |
            def process_order(order):
                validate_inventory(order)  # Step 1
                charge_payment(order)      # Step 2
                reserve_items(order)       # Step 3 - RACE if parallel orders
                ship_order(order)          # Step 4
          llm_failure: "LLM processes code sequentially"
          
        - name: "file_sequence"
          code: |
            def upload_file(path, content):
                os.makedirs(os.path.dirname(path), exist_ok=True)
                with open(path + '.tmp', 'w') as f:
                    f.write(content)
                # RACE: another process could interfere
                os.rename(path + '.tmp', path)
          llm_failure: "LLM sees steps as atomic sequence"

    - trap: "lock_illusion"
      description: "Code that looks locked but isn't"
      examples:
        - name: "wrong_lock_granularity"
          code: |
            account_lock = threading.Lock()
            
            def transfer(from_id, to_id, amount):
                with account_lock:  # One lock for all accounts!
                    from_acc = accounts[from_id]
                # RACE: lock released between operations
                with account_lock:
                    to_acc = accounts[to_id]
                    from_acc.balance -= amount
                    to_acc.balance += amount
          llm_failure: "LLM sees lock and assumes safety"
          
        - name: "lock_wrong_resource"
          code: |
            locks = {}
            
            def safe_update(resource_id, data):
                if resource_id not in locks:
                    locks[resource_id] = threading.Lock()  # RACE!
                with locks[resource_id]:
                    update(resource_id, data)
          llm_failure: "LLM trusts lock dictionary approach"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  complexity_factors:
    - factor: "sub_millisecond_window"
      multiplier: 2.0
      description: "Race window smaller than 1ms"
      
    - factor: "distributed_race"
      multiplier: 1.8
      description: "Race across network boundary"
      
    - factor: "multiple_resources"
      multiplier: 1.5
      description: "Race involves multiple shared resources"
      
    - factor: "hidden_shared_state"
      multiplier: 1.6
      description: "Shared state not obviously shared"
      
    - factor: "framework_race"
      multiplier: 1.4
      description: "Race in framework/library code"
      
    - factor: "async_race"
      multiplier: 1.7
      description: "Race in async/await code"
      
    - factor: "signal_race"
      multiplier: 1.8
      description: "Race involves signal handlers"
      
    - factor: "lock_ordering"
      multiplier: 1.6
      description: "Deadlock potential from lock ordering"

# === COMPREHENSIVE TASK TEMPLATES ===
task_templates:
  - id: "toctou_file_hunt"
    name: "File System TOCTOU Hunt"
    description: "Find TOCTOU vulnerabilities in file handling"
    difficulty: [6, 9]
    template: |
      A {{ service_type }} allows users to {{ operation }}. Security audit found
      potential TOCTOU vulnerabilities that could allow {{ attack_goal }}.
      
      Service Information:
      - Language: {{ language }}
      - File operations: {{ file_ops }}
      - User permissions: {{ permissions }}
      
      Vulnerability report:
      {{ vuln_report }}
      
      Your tasks:
      1. Identify all check-then-use patterns in file operations
      2. Map the race windows
      3. Determine exploitability
      4. Propose atomic alternatives
      
      Files to audit: {{ file_paths }}
      
  - id: "database_race_hunt"
    name: "Database Race Condition Hunt"
    description: "Find race conditions in database operations"
    difficulty: [5, 8]
    template: |
      A {{ application_type }} has been experiencing {{ symptom }} under load.
      Investigation suggests database race conditions.
      
      Database Information:
      - Type: {{ db_type }}
      - Isolation level: {{ isolation }}
      - Concurrent users: {{ users }}
      
      Incident logs:
      {{ incident_logs }}
      
      Your tasks:
      1. Find all read-modify-write patterns
      2. Identify non-atomic operations
      3. Check transaction boundaries
      4. Recommend atomic alternatives
      
      Files to audit: {{ file_paths }}
      
  - id: "auth_race_hunt"
    name: "Authentication Race Condition Hunt"
    description: "Find race conditions in authentication"
    difficulty: [7, 10]
    template: |
      A {{ platform_type }} has security concerns about {{ auth_feature }}.
      Penetration testing suggests race conditions in auth flow.
      
      Authentication flow:
      {{ auth_flow }}
      
      Suspicious behavior:
      {{ suspicious_behavior }}
      
      Your tasks:
      1. Map the authentication state machine
      2. Find race windows in state transitions
      3. Identify session management races
      4. Check for permission cache races
      
      Files to audit: {{ file_paths }}

# === GENERATION CONFIGURATION ===
generation_config:
  min_variants_per_template: 100
  total_combinations_target: 10000
  
  randomization_rules:
    - rule: "race_window_size"
      description: "Vary race window from microseconds to seconds"
    - rule: "concurrency_level"
      description: "Vary number of concurrent accessors"
    - rule: "resource_type"
      description: "Vary the shared resource type"
    - rule: "attack_complexity"
      description: "Scale attack difficulty"

# === REFERENCE SOLUTION PATTERNS ===
reference_solutions:
  atomic_patterns:
    file_atomic: |
      import os
      import tempfile
      
      def atomic_write(path, content):
          """Write file atomically using rename."""
          dir_path = os.path.dirname(path)
          fd, tmp_path = tempfile.mkstemp(dir=dir_path)
          try:
              os.write(fd, content.encode())
              os.fsync(fd)
              os.close(fd)
              os.rename(tmp_path, path)  # Atomic on POSIX
          except:
              os.unlink(tmp_path)
              raise
    
    db_atomic: |
      def atomic_increment(db, counter_id):
          """Increment counter atomically."""
          # Use database's atomic increment
          db.execute(
              "UPDATE counters SET value = value + 1 WHERE id = %s",
              (counter_id,)
          )
          # Or use compare-and-swap
          while True:
              old = db.query("SELECT value FROM counters WHERE id=%s", counter_id)
              result = db.execute(
                  "UPDATE counters SET value = %s WHERE id = %s AND value = %s",
                  (old + 1, counter_id, old)
              )
              if result.rowcount > 0:
                  break
    
    lock_pattern: |
      import threading
      
      class AtomicCounter:
          def __init__(self):
              self._value = 0
              self._lock = threading.Lock()
          
          def increment(self):
              with self._lock:
                  self._value += 1
                  return self._value

# === ANTI-HARDCODING CONFIGURATION ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  race_variations:
    - vary: "window_size"
    - vary: "resource_type"  
    - vary: "concurrency_pattern"
    - vary: "lock_mechanism"

# === TEST CASE GENERATION ===
test_case_generation:
  fail_to_pass:
    - category: "file_races"
      tests:
        - "test_detects_toctou_open"
        - "test_detects_symlink_race"
        - "test_detects_mkdir_race"
        
    - category: "db_races"
      tests:
        - "test_detects_double_spend"
        - "test_detects_lost_update"
        - "test_detects_phantom_read"
        
    - category: "memory_races"
      tests:
        - "test_detects_lazy_init_race"
        - "test_detects_counter_race"
        - "test_detects_singleton_race"

  pass_to_pass:
    - "test_accepts_atomic_operations"
    - "test_accepts_proper_locking"
    - "test_accepts_transactions"

# === SCORING RUBRIC ===
scoring:
  detection_completeness:
    weight: 0.4
    criteria:
      - "Found all race conditions"
      - "Identified race windows"
      - "Measured exploitability"
      
  fix_quality:
    weight: 0.4
    criteria:
      - "Fix is actually atomic"
      - "Fix doesn't introduce deadlocks"
      - "Fix maintains functionality"
      
  understanding:
    weight: 0.2
    criteria:
      - "Explained race mechanism"
      - "Identified attack vector"
      - "Understood concurrency model"

# === ENHANCED DIFFICULTY CONFIGURATION ===
enhanced_difficulty_config:
  time_range: [7200, 18000]  # 120-300 minutes for expert reverse engineers
  command_steps: [150, 500]  # Minimum 150 distinct analysis steps required
  trap_count: "15+ nested, mutually-reinforcing traps"
  
  quality_requirements:
    description: "120-300 minutes for expert reverse engineers and security researchers"
    expertise_level: "Elite concurrency expert with mastery of memory models, atomics, and distributed synchronization"
    prerequisite_knowledge:
      - "Memory model semantics (x86, ARM, POWER) and their differences"
      - "Lock-free programming, atomic operations, and memory barriers"
      - "Thread scheduling, preemption, and priority inversion"
      - "Database transaction isolation levels, MVCC, and anomalies"
      - "Kernel synchronization primitives (futex, RCU, seqlock)"
      - "CPU cache coherency protocols (MESI, MOESI)"
      - "Compiler and JIT reordering optimizations"
      - "Distributed consensus and linearizability"
  
  phase_4_verification:
    validation_criteria:
      - "Contains 15+ interacting deceptive patterns that cascade across synchronization boundaries"
      - "Has cascading state corruption that spreads across thread and process boundaries"
      - "Requires understanding of CPU architecture and memory hierarchy"
      - "Would take expert security researchers 120+ minutes"
      - "Race windows that are sub-millisecond and environment-dependent"
      - "Multiple concurrent access patterns with non-obvious interactions"
      - "Races that only manifest under specific scheduler behavior"
      - "Memory ordering bugs that depend on CPU architecture"
      - "Distributed races across network partitions"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "Deceptive complexity designed to defeat even expert analysis"
      requirements:
        - "7+ interacting traps that mask each other's symptoms"
        - "Requires understanding of compiler optimizations and runtime behavior"
        - "Time estimate: 120+ minutes for senior engineers"
        - "Timing-dependent behavior that varies across environments"
        - "Requires synthesizing debugging, systems, and language internals"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 259200]  # 12-72 hours
      command_steps: [600, 3000]
      techniques_required: 25
      description: "CTF championship-level difficulty with adversarial anti-analysis mechanisms"
      requirements:
        - "15+ interacting race conditions with cascading exploitation"
        - "CPU architecture-specific memory ordering attacks"
        - "Races that require precise nanosecond-level timing"
        - "Requires expertise in CPU internals, kernel programming, and formal verification"
        - "Time estimate: 12-72 hours for elite security researchers"
        - "Races that disappear under debugging/tracing"
        - "Distributed races across consensus boundaries"
        - "Races exploiting specific hardware errata"
  
  anti_patterns:
    llm_failure_modes:
      - "Trusting visible code structure over actual execution behavior"
      - "Missing compiler optimization effects on code semantics"
      - "Ignoring Unicode normalization and rendering differences"
      - "Not considering filesystem race conditions with symlinks"
      - "Missing singleton initialization order dependencies"
      - "Overlooking environment variable and config file interactions"
      - "Assuming deterministic behavior in timing-sensitive code"
      - "Missing state corruption that only manifests under specific sequences"
      - "Ignoring encoding round-trip issues that corrupt data silently"
      - "Failing to model all possible thread interleavings"
      - "Missing memory model violations on relaxed architectures"
      - "Not considering lock-free algorithm correctness"
  
  generation_targets:
    minimum_difficulty: "120-300 minutes, requires elite expertise in concurrency and synchronization"
    target_audience: "Expert reverse engineers, CTF champions, and elite security researchers"
    success_criteria: "LLM fails to identify all race conditions in first 5 attempts"

# === MULTI-AGENT ORCHESTRATION COMPLEXITY ===
multi_agent_orchestration:
  description: "Coordinating specialized race condition detection agents"
  
  required_agents:
    - agent: "static_race_detector"
      role: "Static analysis for race conditions"
      capabilities:
        - "Lockset analysis"
        - "Happens-before extraction"
        - "Data race pattern matching"
      handoff_triggers:
        - "Discovers potential race"
        - "Finds missing synchronization"
    
    - agent: "dynamic_race_detector"
      role: "Runtime race detection"
      capabilities:
        - "Thread sanitizer integration"
        - "Memory access monitoring"
        - "Lock order tracking"
      handoff_triggers:
        - "Detects runtime race"
        - "Finds lock ordering violation"
    
    - agent: "memory_model_analyst"
      role: "Analyze memory model compliance"
      capabilities:
        - "Memory barrier analysis"
        - "Acquire-release semantics"
        - "Architecture-specific behavior"
      handoff_triggers:
        - "Discovers memory ordering bug"
        - "Finds architecture-specific race"
    
    - agent: "database_race_specialist"
      role: "Analyze database-level races"
      capabilities:
        - "Transaction isolation analysis"
        - "MVCC anomaly detection"
        - "Distributed transaction analysis"
      handoff_triggers:
        - "Discovers transaction race"
        - "Finds isolation level bug"
    
    - agent: "filesystem_race_specialist"
      role: "Analyze filesystem TOCTOU races"
      capabilities:
        - "Path traversal race detection"
        - "Symlink race analysis"
        - "Lock file race detection"
      handoff_triggers:
        - "Discovers TOCTOU vulnerability"
        - "Finds symlink race"
    
    - agent: "network_race_specialist"
      role: "Analyze network-level races"
      capabilities:
        - "Connection state race detection"
        - "Session race analysis"
        - "Distributed consensus race"
      handoff_triggers:
        - "Discovers network race"
        - "Finds session race"
    
    - agent: "scheduler_analyst"
      role: "Analyze scheduler-dependent races"
      capabilities:
        - "Priority inversion detection"
        - "Preemption window analysis"
        - "Real-time constraint analysis"
      handoff_triggers:
        - "Discovers scheduler-dependent bug"
        - "Finds priority inversion"
    
    - agent: "formal_verifier"
      role: "Formal verification of synchronization"
      capabilities:
        - "Model checking"
        - "Linearizability verification"
        - "Lock-free correctness"
      handoff_triggers:
        - "Discovers formal verification failure"
        - "Finds linearizability violation"
  
  cross_artifact_deception_chains:
    - chain: "race_to_corruption_to_privilege"
      description: "Race condition corrupts data enabling privilege escalation"
      stages:
        - "TOCTOU race allows unauthorized file access"
        - "Accessed file contains credentials"
        - "Credentials enable privilege escalation"
    
    - chain: "database_to_auth_to_bypass"
      description: "Database race enables authentication bypass"
      stages:
        - "Double-spend style race on auth tokens"
        - "Token validation race allows reuse"
        - "Reused token bypasses authentication"
    
    - chain: "memory_to_pointer_to_exploit"
      description: "Memory race corrupts pointer enabling exploitation"
      stages:
        - "Race between allocation and initialization"
        - "Uninitialized pointer used"
        - "Controlled memory read/write achieved"
  
  parallel_deception_analysis:
    shared_symbolic_state:
      - "Thread interleaving state"
      - "Lock acquisition order"
      - "Memory visibility state"
      - "Transaction isolation state"
    
    synchronization_requirements:
      - "Consistent view of happens-before graph"
      - "Coordinated lock order analysis"
      - "Synchronized memory model analysis"
  
  agent_handoff_protocols:
    protocol: "cascading_race_unwinding"
    steps:
      - "Initial agent identifies potential race"
      - "Handoff to specialist for exploitation analysis"
      - "Specialist discovers cascading race"
      - "Recursive handoff for each race layer"
      - "Final synthesis of complete attack chain"

# === META TRAP LAYERS ===
meta_trap_layers:
  first_order_traps:
    description: "Obvious race conditions detectable with basic tools"
    examples:
      - "Simple check-then-act without locking"
      - "Obvious shared mutable state"
      - "Basic TOCTOU file access"
      - "Simple counter increment without atomics"
    detection_time: "5-15 minutes"
    llm_detection_rate: "70-90%"
  
  second_order_traps:
    description: "Hidden races through indirection"
    examples:
      - "Race in library function call"
      - "ORM operation that isn't atomic"
      - "Framework middleware race"
      - "Lock protecting wrong scope"
    detection_time: "30-60 minutes"
    llm_detection_rate: "30-50%"
  
  third_order_traps:
    description: "Architecture and environment-dependent races"
    examples:
      - "Memory ordering on ARM but not x86"
      - "Race only under specific scheduler"
      - "Distributed race with network latency"
      - "Race dependent on CPU cache behavior"
    detection_time: "60-120 minutes"
    llm_detection_rate: "10-20%"
  
  nth_order_traps:
    description: "Cascading and adaptive race conditions"
    examples:
      - "Races that create new races when exploited"
      - "Self-healing races that recreate on fix"
      - "Races that depend on analysis approach"
      - "Cross-layer races (app + kernel + hardware)"
    detection_time: "120+ minutes per additional layer"
    llm_detection_rate: "<5%"
    
  recursive_trap_structures:
    - structure: "cascading_corruption"
      description: "Each race enables another race opportunity"
      depth: "theoretically infinite with complex state"
      
    - structure: "self_healing_lock"
      description: "Lock structure recreates race when fixed"
      depth: "depends on lock dependency complexity"
      
    - structure: "distributed_race_cascade"
      description: "Race propagates across distributed system"
      depth: "limited by network topology"

# === ANTI-ANALYSIS TECHNIQUES ===
anti_analysis_techniques:
  environment_detection:
    - technique: "debugging_detection"
      description: "Detect if running under debugger"
      methods:
        - "Timing analysis for breakpoints"
        - "TracerPid check"
        - "Debug register inspection"
      behavior_change: "Race window changes under debugging"
    
    - technique: "sanitizer_detection"
      description: "Detect thread/address sanitizer"
      methods:
        - "Check for sanitizer symbols"
        - "Detect sanitizer overhead"
        - "Check environment variables"
      behavior_change: "Race becomes undetectable with sanitizer"
    
    - technique: "load_detection"
      description: "Detect analysis through load patterns"
      methods:
        - "Check concurrent request rate"
        - "Measure response time variance"
        - "Detect unusual access patterns"
      behavior_change: "Race only manifests under production load"
  
  anti_debugging_measures:
    - measure: "race_window_adaptation"
      description: "Race window size adapts to execution speed"
      implementation: "Detect slow execution, widen window"
      
    - measure: "randomized_timing"
      description: "Race timing varies randomly"
      implementation: "Timing jitter makes reproduction difficult"
      
    - measure: "scheduler_sensitivity"
      description: "Race depends on scheduler behavior"
      implementation: "Only manifests under specific scheduling"
  
  anti_tracing_mechanisms:
    - mechanism: "timing_obfuscation"
      description: "Obfuscate race timing"
      implementation: "Multiple redundant timing paths"
      
    - mechanism: "lock_aliasing"
      description: "Lock appears to protect critical section"
      implementation: "Wrong lock used, real race hidden"
      
    - mechanism: "split_check_use"
      description: "Check and use in different compilation units"
      implementation: "Static analysis cannot connect"
  
  time_based_anti_analysis:
    - technique: "warmup_dependent"
      description: "Race only after warmup period"
      implementation: "JIT optimization reveals race"
      
    - technique: "contention_dependent"
      description: "Race requires specific contention level"
      implementation: "Low contention hides race"
      
    - technique: "periodic_window"
      description: "Race window only open periodically"
      implementation: "Background task creates periodic opportunity"

# === PSYCHOLOGICAL MISDIRECTION ===
psychological_misdirection:
  obvious_false_positives:
    description: "Intentional red herrings to waste analyst time"
    examples:
      - name: "suspicious_shared_variable"
        description: "Shared variable that is actually properly synchronized"
        time_waste: "30-60 minutes"
        
      - name: "apparent_toctou"
        description: "Check-then-use that is actually atomic"
        time_waste: "20-40 minutes"
        
      - name: "obvious_lock_missing"
        description: "Unlocked access that is actually thread-safe"
        time_waste: "45-90 minutes"
  
  misleading_comments:
    description: "Comments that direct attention away from real races"
    examples:
      - "# Thread-safe: protected by GIL"
      - "// Atomic operation, no lock needed"
      - "/* Race condition fixed in v2.0 */"
      - "# Lock-free implementation"
  
  misleading_variable_names:
    description: "Variable names that hide race conditions"
    examples:
      - "thread_safe_cache - actually has race"
      - "atomic_counter - not actually atomic"
      - "synchronized_access - lock scope wrong"
      - "safe_singleton - has init race"
  
  red_herring_code_paths:
    description: "Code paths that appear to have races but don't"
    examples:
      - name: "complex_locking"
        description: "Elaborate locking that is actually correct"
        
      - name: "suspicious_double_check"
        description: "Double-checked locking that is properly implemented"
        
      - name: "apparent_counter_race"
        description: "Counter that is actually atomic in context"
  
  partial_solutions:
    description: "Solutions that work initially but enable harder races"
    examples:
      - name: "lock_addition"
        description: "Adding lock creates deadlock opportunity"
        
      - name: "atomic_conversion"
        description: "Converting to atomic creates ABA problem"
        
      - name: "mutex_to_rwlock"
        description: "Changing to rwlock creates writer starvation"

# === VERSION HISTORY ===
version_history:
  - version: "1.0.0"
    date: "2024-01-01"
    changes: "Initial version with basic race conditions"
  - version: "2.0.0"
    date: "2024-06-01"
    changes: "Expanded to 1000+ lines with comprehensive race traps"
  - version: "3.0.0"
    date: "2024-12-01"
    changes: "Enhanced difficulty with nightmare mode and comprehensive anti-patterns"
