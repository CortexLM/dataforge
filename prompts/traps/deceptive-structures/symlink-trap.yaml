id: "trap-deceptive-symlink-001"
version: "1.0.0"
category: "traps"
subcategory: "deceptive-structures"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research LLM blind spots around file system links and path handling"
    phase_2_creation: "Create task that exploits LLM assumptions about file path integrity"
    phase_3_amplification: "Add multiple layers of deception with nested link structures"
    phase_4_verification: "Validate task successfully traps most LLMs through link manipulation"
  
  llm_trap_design:
    common_llm_weaknesses:
      - "Pattern matching without understanding link semantics"
      - "Assuming paths are stable between check and use"
      - "Missing symlink cycle detection in traversals"
      - "Over-reliance on training data for safe file operations"
      - "Difficulty reasoning about path canonicalization"
      - "Inability to detect path escape attacks"
      - "Confusion between symlinks and hardlinks"
      - "Failure to consider mount point traversal"

# === SYMLINK TRAP TAXONOMY ===
trap_taxonomy:
  category: "deceptive-structures"
  trap_type: "symlink-trap"
  description: "File system structures with malicious symbolic links and path manipulation"
  
  trap_families:
    - family: "symlink_cycles"
      description: "Symlinks forming infinite loops"
      difficulty_range: [4, 7]
      
    - family: "path_escape"
      description: "Symlinks escaping allowed directories"
      difficulty_range: [5, 9]
      
    - family: "toctou_symlink"
      description: "Symlink swap between check and use"
      difficulty_range: [6, 10]
      
    - family: "hardlink_attacks"
      description: "Hardlinks to sensitive files"
      difficulty_range: [5, 8]
      
    - family: "mount_traversal"
      description: "Symlinks crossing mount points"
      difficulty_range: [6, 9]
      
    - family: "case_sensitivity"
      description: "Case sensitivity path attacks"
      difficulty_range: [4, 8]
      
    - family: "path_normalization"
      description: "Path normalization bypass attacks"
      difficulty_range: [5, 9]
      
    - family: "device_file_tricks"
      description: "Links to device files"
      difficulty_range: [6, 9]

# === LLM WEAKNESS EXPLOITATION TECHNIQUES ===
llm_weakness_exploitation:
  symlink_techniques:
    # Symlink Cycle Traps (20+ techniques)
    symlink_cycle_traps:
      - technique: "direct_cycle"
        description: "A -> A creates direct loop"
        llm_failure_mode: "LLM follows link without cycle check"
        implementation: |
          # ln -s a a
          def naive_read(path):
              while os.path.islink(path):
                  path = os.readlink(path)  # TRAP: Infinite loop!
              return open(path).read()
        detection: "Must track visited paths"
        difficulty: 4
        
      - technique: "indirect_cycle_2"
        description: "A -> B -> A creates 2-link cycle"
        llm_failure_mode: "LLM only checks immediate target"
        implementation: |
          # ln -s b a && ln -s a b
          def walk_links(path):
              target = os.readlink(path)
              return walk_links(target)  # TRAP: A -> B -> A
        detection: "Must track visited inodes"
        difficulty: 5
        
      - technique: "long_cycle"
        description: "A -> B -> C -> D -> A creates long cycle"
        llm_failure_mode: "LLM depth limit may be too high"
        implementation: |
          # Chain of 100 symlinks forming cycle
          def resolve_full_path(path, depth=0):
              if depth > 1000:  # TRAP: Cycle of 100 still completes many times
                  return path
              if os.path.islink(path):
                  return resolve_full_path(os.readlink(path), depth+1)
        detection: "Track visited paths, not just depth"
        difficulty: 6
        
      - technique: "nested_directory_cycle"
        description: "Symlink to parent directory creates infinite path"
        llm_failure_mode: "LLM doesn't detect directory cycles"
        implementation: |
          # /a/b/c/parent -> /a/b
          def walk_tree(root):
              for dirpath, dirnames, filenames in os.walk(root):
                  # TRAP: /a/b/c/parent/c/parent/c/parent...
                  process(dirpath)
        detection: "Track inodes during walk"
        difficulty: 5
        
      - technique: "cycle_with_indirection"
        description: "Cycle hidden in directory structure"
        llm_failure_mode: "LLM doesn't canonicalize paths"
        implementation: |
          # /a/b -> /c and /c/d -> /a creates cycle via /a/b/d
          def traverse(path):
              for item in os.listdir(path):
                  full = os.path.join(path, item)
                  if os.path.isdir(full):
                      traverse(full)  # TRAP: indirect cycle
        detection: "Canonicalize and track"
        difficulty: 6
        
      - technique: "relative_symlink_cycle"
        description: "Relative symlinks forming cycle"
        llm_failure_mode: "LLM doesn't resolve relative paths correctly"
        implementation: |
          # ./a -> ../x/a creates cycle when traversing
          def list_all(path):
              for entry in os.scandir(path):
                  if entry.is_dir(follow_symlinks=True):
                      list_all(entry.path)  # TRAP: relative cycle
        detection: "Resolve to absolute paths"
        difficulty: 6

    # Path Escape Traps (30+ techniques)
    path_escape_traps:
      - technique: "parent_escape"
        description: "Symlink with .. escapes directory"
        llm_failure_mode: "LLM trusts path is within root"
        implementation: |
          # /uploads/evil -> ../../../etc/passwd
          def read_upload(filename):
              path = os.path.join('/uploads', filename)
              return open(path).read()  # TRAP: follows symlink!
        detection: "Canonicalize and verify within root"
        difficulty: 6
        
      - technique: "absolute_escape"
        description: "Symlink with absolute path escapes"
        llm_failure_mode: "LLM checks relative component only"
        implementation: |
          # /sandbox/data -> /etc/shadow
          def safe_read(root, filename):
              if '..' in filename:  # TRAP: doesn't catch absolute symlink!
                  raise SecurityError()
              return open(os.path.join(root, filename)).read()
        detection: "Check resolved path, not filename"
        difficulty: 5
        
      - technique: "intermediate_escape"
        description: "Symlink in path component escapes"
        llm_failure_mode: "LLM only checks final path"
        implementation: |
          # /data/user/docs where docs -> /etc
          def validate_path(path):
              if not path.startswith('/data/user/'):  # TRAP: /data/user/docs/shadow
                  raise SecurityError()
              return path
        detection: "Resolve each component"
        difficulty: 7
        
      - technique: "double_encoded_escape"
        description: "URL-encoded .. in symlink target"
        llm_failure_mode: "LLM doesn't decode symlink target"
        implementation: |
          # /uploads/%2e%2e/%2e%2e/etc/passwd
          def web_read(url_path):
              decoded = urllib.parse.unquote(url_path)
              # TRAP: symlink target might also be encoded!
              return open(decoded).read()
        detection: "Decode all path components"
        difficulty: 7
        
      - technique: "null_byte_truncation"
        description: "Null byte in path truncates validation"
        llm_failure_mode: "LLM doesn't sanitize null bytes"
        implementation: |
          # In older systems: /uploads/file.txt\x00.jpg
          def validate_extension(path):
              if not path.endswith('.jpg'):  # TRAP: C-style null truncation
                  raise SecurityError()
              return open(path).read()
        detection: "Reject paths with null bytes"
        difficulty: 6
        
      - technique: "case_bypass"
        description: "Case variation bypasses check"
        llm_failure_mode: "LLM case-sensitive check on case-insensitive FS"
        implementation: |
          # On macOS/Windows: /Etc/Passwd == /etc/passwd
          def check_path(path):
              if '/etc/' in path.lower():  # TRAP: /ETC/ or /eTc/
                  raise SecurityError()
              return open(path).read()
        detection: "Canonicalize with correct case"
        difficulty: 5
        
      - technique: "trailing_slash_bypass"
        description: "Trailing slash changes resolution"
        llm_failure_mode: "LLM doesn't consider trailing slash semantics"
        implementation: |
          # /data/link -> /etc, checking /data/link vs /data/link/
          def validate(path):
              real = os.path.realpath(path)
              if not real.startswith('/data/'):
                  raise SecurityError()
              # TRAP: /data/link/passwd escapes!
        detection: "Normalize trailing slashes"
        difficulty: 6
        
      - technique: "unicode_normalization_escape"
        description: "Unicode normalization changes path"
        llm_failure_mode: "LLM doesn't normalize Unicode"
        implementation: |
          # Different Unicode representations of same path
          # e vs e + combining accent
          def check(path):
              if path == '/safe/file.txt':  # TRAP: Unicode equivalent!
                  return open(path).read()
        detection: "Normalize Unicode before comparison"
        difficulty: 7
        
      - technique: "proc_escape"
        description: "Symlink through /proc escapes"
        llm_failure_mode: "LLM doesn't consider /proc/self/fd/"
        implementation: |
          # /uploads/x -> /proc/self/fd/3 (open file descriptor)
          def read_file(path):
              # TRAP: symlink points to fd of sensitive file!
              return open(path).read()
        detection: "Block /proc paths"
        difficulty: 8
        
      - technique: "dev_escape"
        description: "Symlink to device file"
        llm_failure_mode: "LLM doesn't check file type"
        implementation: |
          # /uploads/random -> /dev/urandom
          def read_file(path):
              with open(path, 'rb') as f:
                  return f.read(1024)  # TRAP: infinite stream!
        detection: "Check file type after resolve"
        difficulty: 6

    # TOCTOU Symlink Traps (25+ techniques)
    toctou_symlink_traps:
      - technique: "stat_open_race"
        description: "Stat says safe, symlink swapped before open"
        llm_failure_mode: "LLM trusts stat result for open"
        implementation: |
          def safe_open(path):
              st = os.stat(path)
              if stat.S_ISREG(st.st_mode):  # Check: regular file
                  # RACE: attacker replaces with symlink
                  return open(path).read()  # Use: opens symlink target!
        race_window_ms: [0.1, 10]
        difficulty: 7
        
      - technique: "access_open_race"
        description: "access() check then open()"
        llm_failure_mode: "LLM sees access() as authorization"
        implementation: |
          def read_if_allowed(path):
              if os.access(path, os.R_OK):  # Check
                  # RACE: swap for symlink to /etc/shadow
                  return open(path).read()  # Use
        race_window_ms: [0.1, 10]
        difficulty: 7
        
      - technique: "realpath_open_race"
        description: "Resolve path then use original"
        llm_failure_mode: "LLM uses wrong path after resolve"
        implementation: |
          def validated_read(user_path):
              real = os.path.realpath(user_path)
              if real.startswith('/safe/'):
                  # RACE: user_path changed to point elsewhere
                  return open(user_path).read()  # TRAP: uses original!
        race_window_ms: [0.1, 10]
        difficulty: 8
        
      - technique: "mkdir_race"
        description: "Check no dir, attacker creates symlink"
        llm_failure_mode: "LLM trusts existence check"
        implementation: |
          def safe_mkdir(path):
              if not os.path.exists(path):  # Check
                  # RACE: attacker creates symlink
                  os.mkdir(path)  # Use: follows symlink!
        race_window_ms: [0.1, 50]
        difficulty: 6
        
      - technique: "write_race"
        description: "Verify path then write to it"
        llm_failure_mode: "LLM separates validation from use"
        implementation: |
          def safe_write(path, content):
              real = os.path.realpath(path)
              if is_allowed(real):  # Check
                  # RACE: swap path for symlink
                  with open(path, 'w') as f:  # Use
                      f.write(content)  # Writes to symlink target!
        race_window_ms: [0.1, 10]
        difficulty: 8
        
      - technique: "unlink_race"
        description: "Check file safe to delete, swap to different"
        llm_failure_mode: "LLM validates then deletes"
        implementation: |
          def safe_delete(path):
              if os.path.isfile(path) and in_temp(path):  # Check
                  # RACE: swap to symlink to important file
                  os.unlink(path)  # Use: deletes symlink target!
        race_window_ms: [0.1, 10]
        difficulty: 7
        
      - technique: "chmod_race"
        description: "Validate then chmod"
        llm_failure_mode: "LLM separates check from chmod"
        implementation: |
          def fix_permissions(path):
              if is_user_file(path):  # Check
                  # RACE: swap to symlink
                  os.chmod(path, 0o777)  # Use: chmods symlink target!
        race_window_ms: [0.1, 10]
        difficulty: 7
        
      - technique: "extract_race"
        description: "Validate archive then extract"
        llm_failure_mode: "LLM validates archive once"
        implementation: |
          def safe_extract(archive_path, dest):
              if is_safe_archive(archive_path):  # Check
                  # RACE: archive replaced with malicious one
                  tarfile.open(archive_path).extractall(dest)  # Use
        race_window_ms: [1, 100]
        difficulty: 7

    # Hardlink Attack Traps (20+ techniques)
    hardlink_attack_traps:
      - technique: "hardlink_to_sensitive"
        description: "Hardlink in user dir points to sensitive file"
        llm_failure_mode: "LLM doesn't detect hardlinks"
        implementation: |
          # ln /etc/shadow /uploads/myfile
          def write_upload(path, content):
              # TRAP: modifying hardlink modifies /etc/shadow!
              with open(path, 'w') as f:
                  f.write(content)
        detection: "Check inode and link count"
        difficulty: 6
        
      - technique: "hardlink_copy_escape"
        description: "Copy hardlink preserves link"
        llm_failure_mode: "LLM assumes copy is independent"
        implementation: |
          def safe_process(src, dest):
              shutil.copy(src, dest)  # TRAP: might copy hardlink!
              # dest now linked to same inode
        detection: "Check if source is hardlink"
        difficulty: 6
        
      - technique: "hardlink_backup_attack"
        description: "Create hardlink to file before it gets protected"
        llm_failure_mode: "LLM doesn't see hardlinks as persistent references"
        implementation: |
          # 1. Hardlink to config while readable
          # 2. Config permissions changed
          # 3. Read via hardlink still works!
          def create_backup(path):
              os.link(path, '/attacker/backup')
        detection: "Prevent hardlinks across directories"
        difficulty: 7
        
      - technique: "hardlink_count_check"
        description: "File has multiple hardlinks"
        llm_failure_mode: "LLM doesn't check st_nlink"
        implementation: |
          def exclusive_access(path):
              # TRAP: Should check link count == 1
              with open(path, 'w') as f:
                  f.write(secret)  # Other hardlinks see it!
        detection: "Verify st_nlink == 1"
        difficulty: 5
        
      - technique: "cross_directory_hardlink"
        description: "Hardlink crosses directory boundaries"
        llm_failure_mode: "LLM trusts directory containment"
        implementation: |
          # /safe/file hardlinked to /unsafe/file
          def delete_if_safe(path):
              if path.startswith('/safe/'):
                  os.unlink(path)  # TRAP: also deletes /unsafe/file!
        detection: "Check all paths to inode"
        difficulty: 7

    # Mount Point Traps (15+ techniques)
    mount_traversal_traps:
      - technique: "bind_mount_escape"
        description: "Symlink escapes bind mount"
        llm_failure_mode: "LLM doesn't understand bind mounts"
        implementation: |
          # /container/data bind-mounted from /host/data
          # /container/data/escape -> /etc
          def read_in_container(path):
              # TRAP: symlink target resolved on host!
              return open(path).read()
        detection: "Check mount namespace"
        difficulty: 8
        
      - technique: "proc_mount_access"
        description: "Symlink to /proc accesses host info"
        llm_failure_mode: "LLM doesn't block procfs paths"
        implementation: |
          # /data/info -> /proc/1/environ
          def read_file(path):
              return open(path).read()  # TRAP: reads host environment!
        detection: "Block /proc, /sys paths"
        difficulty: 7
        
      - technique: "overlayfs_escape"
        description: "OverlayFS allows escape via workdir"
        llm_failure_mode: "LLM doesn't understand overlay semantics"
        implementation: |
          # Overlay workdir can expose lower layer
          def modify_file(path):
              # TRAP: might modify lower layer directly!
              with open(path, 'w') as f:
                  f.write(content)
        detection: "Check filesystem type"
        difficulty: 9
        
      - technique: "tempfs_exhaustion"
        description: "Symlink to tmpfs for DoS"
        llm_failure_mode: "LLM doesn't check filesystem size"
        implementation: |
          # /uploads/huge -> /dev/shm
          def write_file(path, content):
              # TRAP: fills tmpfs, crashes system!
              with open(path, 'w') as f:
                  f.write(content)
        detection: "Check filesystem limits"
        difficulty: 6

    # Path Normalization Traps (20+ techniques)
    path_normalization_traps:
      - technique: "dot_dot_slash_variants"
        description: "Various ../ encodings bypass check"
        llm_failure_mode: "LLM checks literal ../ only"
        implementation: |
          BYPASS_VARIANTS = [
              '../', '..\\', '..%2f', '..%5c',
              '%2e%2e/', '.%2e/', '%2e./',
              '....//.//', 'foo/../../../'
          ]
          def check_traversal(path):
              if '../' in path:  # TRAP: misses variants!
                  raise SecurityError()
        detection: "Normalize then check canonicalized path"
        difficulty: 6
        
      - technique: "double_slash_normalization"
        description: "Double slashes treated differently"
        llm_failure_mode: "LLM doesn't normalize slashes"
        implementation: |
          # /safe//../../etc/passwd
          def is_safe(path):
              if not path.startswith('/safe/'):  # TRAP: //
                  raise SecurityError()
        detection: "Collapse multiple slashes"
        difficulty: 5
        
      - technique: "trailing_dot_normalization"
        description: "Trailing dots treated differently"
        llm_failure_mode: "LLM doesn't strip dots"
        implementation: |
          # /etc/passwd... on some systems
          def validate(path):
              if path == '/etc/passwd':  # TRAP: with dots
                  raise SecurityError()
        detection: "Normalize dots"
        difficulty: 5
        
      - technique: "ntfs_alternate_stream"
        description: "NTFS alternate data streams"
        llm_failure_mode: "LLM doesn't know ADS syntax"
        implementation: |
          # file.txt::$DATA on Windows
          def is_txt(path):
              if path.endswith('.txt'):
                  return True  # TRAP: evil.exe::$DATA:file.txt
        detection: "Strip stream specifiers"
        difficulty: 7
        
      - technique: "8_3_filename_bypass"
        description: "Windows 8.3 filename bypass"
        llm_failure_mode: "LLM doesn't know 8.3 names"
        implementation: |
          # LONGFI~1.TXT == longfilename.txt
          def is_blocked(path):
              if 'longfilename.txt' in path:  # TRAP: LONGFI~1.TXT
                  raise SecurityError()
        detection: "Canonicalize Windows paths"
        difficulty: 6

# === TRAP MECHANISMS ===
trap_mechanisms:
  attack_vectors:
    - mechanism: "symlink_creation"
      description: "Attacker creates symlink in controlled directory"
      prerequisites:
        - "Write access to directory"
        - "Symlinks allowed on filesystem"
      detection_difficulty: 5
      
    - mechanism: "symlink_race"
      description: "Attacker rapidly swaps symlink target"
      prerequisites:
        - "Time window between check and use"
        - "Write access to create symlinks"
      detection_difficulty: 8
      
    - mechanism: "hardlink_creation"
      description: "Attacker creates hardlink to sensitive file"
      prerequisites:
        - "Write access to directory"
        - "Hardlinks allowed (same filesystem)"
        - "Read access to source file"
      detection_difficulty: 6
      
    - mechanism: "path_injection"
      description: "Attacker injects path components"
      prerequisites:
        - "User input used in path"
        - "Insufficient sanitization"
      detection_difficulty: 5

# === ANTI-DETECTION TECHNIQUES ===
anti_detection_techniques:
  evasion_methods:
    - method: "legitimate_looking_symlink"
      description: "Symlink appears to be normal file"
      techniques:
        - "Named like expected file"
        - "In expected location"
        - "Created by 'setup' script"
        
    - method: "indirect_symlink"
      description: "Symlink chain hides final target"
      techniques:
        - "A -> B -> C -> sensitive"
        - "Each hop looks legitimate"
        
    - method: "race_timing"
      description: "Race window exploited precisely"
      techniques:
        - "Automated swap tool"
        - "Timing analysis of target"

# === LLM-SPECIFIC TRAPS ===
llm_specific_traps:
  assumption_exploitation:
    - trap: "path_is_path"
      description: "LLM assumes path strings are stable"
      examples:
        - name: "path_join_safe"
          code: |
            def safe_path(base, user_input):
                path = os.path.join(base, user_input)
                return open(path).read()  # TRAP: symlink in user_input!
          llm_failure: "LLM trusts os.path.join is safe"
          
    - trap: "realpath_once"
      description: "LLM resolves path once, uses original"
      examples:
        - name: "validate_then_use"
          code: |
            def read(user_path):
                real = os.path.realpath(user_path)
                if real.startswith('/safe/'):
                    return open(user_path).read()  # TRAP: wrong path!
          llm_failure: "LLM uses wrong variable after resolve"
          
    - trap: "exists_means_safe"
      description: "LLM assumes existence check is sufficient"
      examples:
        - name: "check_exists"
          code: |
            def process(path):
                if os.path.exists(path):
                    return open(path).read()  # TRAP: no type check!
          llm_failure: "LLM doesn't check what exists"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  complexity_factors:
    - factor: "nested_symlinks"
      multiplier: 1.5
      description: "Multiple levels of symlinks"
      
    - factor: "race_condition"
      multiplier: 1.8
      description: "Involves TOCTOU race"
      
    - factor: "cross_filesystem"
      multiplier: 1.4
      description: "Involves multiple filesystems"
      
    - factor: "encoding_tricks"
      multiplier: 1.5
      description: "Path encoding variations"
      
    - factor: "platform_specific"
      multiplier: 1.3
      description: "Platform-specific behaviors"

# === COMPREHENSIVE TASK TEMPLATES ===
task_templates:
  - id: "secure_file_access"
    name: "Secure File Access Implementation"
    description: "Implement secure file access without symlink vulnerabilities"
    difficulty: [6, 9]
    template: |
      A {{ service_type }} allows users to access files within {{ root_dir }}.
      
      Current implementation:
      {{ current_code }}
      
      Reported vulnerabilities:
      {{ vulnerabilities }}
      
      Your tasks:
      1. Identify all symlink attack vectors
      2. Implement safe path resolution
      3. Handle all edge cases
      4. Add proper error handling
      5. Test with adversarial inputs
      
  - id: "directory_traversal"
    name: "Safe Directory Traversal"
    description: "Traverse directory safely with symlink handling"
    difficulty: [5, 8]
    template: |
      A {{ tool_type }} needs to traverse directories safely.
      
      Requirements:
      - Must not follow symlinks outside allowed area
      - Must detect cycles
      - Must handle all path variants
      
      Test directory structure:
      {{ structure }}
      
      Your tasks:
      1. Implement cycle detection
      2. Add path escape prevention
      3. Handle edge cases
      4. Verify with malicious structures

# === GENERATION CONFIGURATION ===
generation_config:
  min_variants_per_template: 100
  total_combinations_target: 10000
  
  randomization_rules:
    - rule: "symlink_structure"
      description: "Vary link structure complexity"
    - rule: "attack_type"
      description: "Vary type of symlink attack"
    - rule: "detection_difficulty"
      description: "Vary how hidden the attack is"

# === REFERENCE SOLUTION PATTERNS ===
reference_solutions:
  safe_open: |
    import os
    
    def safe_open(path, root, mode='r'):
        """Open file safely within root directory."""
        # Resolve all symlinks
        real_path = os.path.realpath(path)
        real_root = os.path.realpath(root)
        
        # Check containment
        if not real_path.startswith(real_root + os.sep):
            if real_path != real_root:
                raise PermissionError("Path escape detected")
        
        # Check it's a regular file
        if not os.path.isfile(real_path):
            raise PermissionError("Not a regular file")
        
        # Open the resolved path, not original
        return open(real_path, mode)
  
  safe_walk: |
    import os
    
    def safe_walk(root, follow_symlinks=False):
        """Walk directory safely, avoiding cycles."""
        visited = set()
        
        def _walk(path):
            # Get real path and inode
            real = os.path.realpath(path)
            try:
                st = os.stat(real)
                key = (st.st_dev, st.st_ino)
            except OSError:
                return
            
            # Cycle detection
            if key in visited:
                return
            visited.add(key)
            
            dirs, files = [], []
            try:
                for entry in os.scandir(real):
                    if entry.is_dir(follow_symlinks=follow_symlinks):
                        dirs.append(entry.name)
                    else:
                        files.append(entry.name)
            except PermissionError:
                return
            
            yield real, dirs, files
            
            for d in dirs:
                yield from _walk(os.path.join(real, d))
        
        yield from _walk(root)

# === ANTI-HARDCODING CONFIGURATION ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  symlink_variations:
    - vary: "link_depth"
    - vary: "target_type"
    - vary: "path_encoding"
    - vary: "race_window"

# === TEST CASE GENERATION ===
test_case_generation:
  fail_to_pass:
    - "test_symlink_cycle_detected"
    - "test_path_escape_blocked"
    - "test_race_condition_prevented"
    - "test_hardlink_detected"
    - "test_mount_traversal_blocked"

  pass_to_pass:
    - "test_normal_files_accessible"
    - "test_subdirectories_traversable"
    - "test_legitimate_symlinks_work"

# === ADDITIONAL SYMLINK TECHNIQUES ===
additional_symlink_techniques:
  # Chroot Escape Techniques (15+ techniques)
  chroot_escape_traps:
    - technique: "chroot_fd_escape"
      description: "Open fd before chroot allows escape"
      llm_failure_mode: "LLM doesn't track open file descriptors"
      implementation: |
        fd = os.open('/', os.O_RDONLY)  # Keep reference to real root
        os.chroot('/sandbox')
        os.chdir('/')
        # TRAP: Can escape via fd!
        os.fchdir(fd)
        os.chroot('.')  # Back to real root!
      difficulty: 9
      
    - technique: "chroot_relative_symlink"
      description: "Relative symlink escapes chroot"
      llm_failure_mode: "LLM doesn't see symlink as escape"
      implementation: |
        # Inside chroot: link -> ../../../etc/passwd
        os.chroot('/sandbox')
        # TRAP: Following link escapes!
        content = open('/sandbox/link', 'r').read()
      difficulty: 7
      
    - technique: "proc_self_escape"
      description: "/proc/self paths escape restrictions"
      llm_failure_mode: "LLM doesn't block /proc access"
      implementation: |
        # /proc/self/root points to actual root
        # /proc/self/cwd might escape chroot
        content = open('/proc/self/root/etc/passwd', 'r').read()
      difficulty: 8
      
    - technique: "pivot_root_attack"
      description: "pivot_root can be used to escape"
      llm_failure_mode: "LLM doesn't restrict pivot_root"
      implementation: |
        # Create new mount namespace and pivot_root
        # TRAP: Can escape container restrictions
      difficulty: 9

  # Container Escape Techniques (15+ techniques)
  container_escape_traps:
    - technique: "docker_socket_escape"
      description: "Docker socket allows container escape"
      llm_failure_mode: "LLM doesn't see socket as escape"
      implementation: |
        # If /var/run/docker.sock is mounted:
        # Link to it allows controlling host Docker!
        os.symlink('/var/run/docker.sock', '/app/docker.sock')
      difficulty: 8
      
    - technique: "cgroup_escape"
      description: "Cgroup filesystem allows escape"
      llm_failure_mode: "LLM doesn't restrict cgroup access"
      implementation: |
        # /sys/fs/cgroup might allow process escape
        # release_agent can execute code on host
      difficulty: 9
      
    - technique: "hostpath_escape"
      description: "Kubernetes hostPath allows escape"
      llm_failure_mode: "LLM trusts volume mounts"
      implementation: |
        # hostPath: / mounted to /host
        # Symlink in container: /app/data -> /host/etc
        # Reading /app/data/passwd reads host file!
      difficulty: 7
      
    - technique: "serviceaccount_token_escape"
      description: "Service account token allows cluster access"
      llm_failure_mode: "LLM doesn't see token as sensitive"
      implementation: |
        # /var/run/secrets/kubernetes.io/serviceaccount/token
        # Symlink to expose token to attacker
      difficulty: 7

  # Advanced Path Manipulation (20+ techniques)
  advanced_path_traps:
    - technique: "path_truncation"
      description: "Long path truncated to bypass checks"
      llm_failure_mode: "LLM doesn't check path length limits"
      implementation: |
        # Create path longer than PATH_MAX
        # Truncation might bypass security checks
        long_path = '/safe/' + 'a' * 4096 + '/../etc/passwd'
      difficulty: 7
      
    - technique: "special_filenames"
      description: "Reserved filenames on Windows"
      llm_failure_mode: "LLM doesn't know Windows reserved names"
      implementation: |
        # CON, PRN, AUX, NUL, COM1-9, LPT1-9
        # These can't be used as file names on Windows
        # Symlink to them causes issues
      difficulty: 6
      
    - technique: "drive_relative_path"
      description: "Windows drive-relative paths"
      llm_failure_mode: "LLM doesn't understand drive letters"
      implementation: |
        # C:filename (no backslash) is relative to current dir on C:
        # Not same as C:\\filename
      difficulty: 6
      
    - technique: "unc_path_bypass"
      description: "UNC paths bypass some checks"
      llm_failure_mode: "LLM doesn't handle UNC paths"
      implementation: |
        # \\\\?\\C:\\path bypasses PATH_MAX limit
        # \\\\127.0.0.1\\C$\\path accesses via network
      difficulty: 7
      
    - technique: "junction_point_attack"
      description: "Windows junction points like symlinks"
      llm_failure_mode: "LLM doesn't recognize junctions"
      implementation: |
        # Junction points are directory symlinks on Windows
        # mklink /J junction_name target
      difficulty: 6
      
    - technique: "reparse_point_attack"
      description: "NTFS reparse points for redirection"
      llm_failure_mode: "LLM doesn't handle reparse points"
      implementation: |
        # Reparse points can redirect to various targets
        # IO_REPARSE_TAG_MOUNT_POINT
        # IO_REPARSE_TAG_SYMLINK
      difficulty: 8
      
    - technique: "extended_length_path"
      description: "\\\\?\\ prefix for extended length"
      llm_failure_mode: "LLM doesn't handle extended paths"
      implementation: |
        # \\\\?\\C:\\very\\long\\path...
        # Bypasses 260 char limit, some security checks
      difficulty: 7

  # Filesystem Feature Exploitation (15+ techniques)
  filesystem_feature_traps:
    - technique: "xattr_symlink_data"
      description: "Extended attributes on symlinks"
      llm_failure_mode: "LLM doesn't check xattr on links"
      implementation: |
        # Symlink might have xattr with sensitive data
        # Or xattr controlling symlink behavior
        os.setxattr('/path/link', 'user.data', b'secret', follow_symlinks=False)
      difficulty: 7
      
    - technique: "acl_symlink_bypass"
      description: "ACL on symlink vs target differs"
      llm_failure_mode: "LLM checks wrong ACL"
      implementation: |
        # Symlink ACL might allow access
        # But target ACL denies
        # Or vice versa
      difficulty: 7
      
    - technique: "selinux_context_symlink"
      description: "SELinux context on symlink"
      llm_failure_mode: "LLM doesn't check SELinux context"
      implementation: |
        # Symlink has different SELinux context than target
        # Might allow bypass of MAC policy
      difficulty: 8
      
    - technique: "capability_inheritance"
      description: "File capabilities and symlinks"
      llm_failure_mode: "LLM doesn't trace capabilities"
      implementation: |
        # setcap on symlink target vs symlink
        # Capability might not apply as expected
      difficulty: 8

# === COMPREHENSIVE MITIGATION STRATEGIES ===
mitigation_strategies:
  defense_patterns:
    - pattern: "O_NOFOLLOW"
      description: "Open without following symlinks"
      implementation: |
        fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)
        
    - pattern: "openat_sequence"
      description: "Use openat for safe traversal"
      implementation: |
        def safe_open(root, relative_path):
            components = relative_path.split('/')
            fd = os.open(root, os.O_RDONLY | os.O_DIRECTORY)
            for comp in components[:-1]:
                fd = os.openat(fd, comp, os.O_RDONLY | os.O_DIRECTORY | os.O_NOFOLLOW)
            return os.openat(fd, components[-1], os.O_RDONLY | os.O_NOFOLLOW)
            
    - pattern: "realpath_verify"
      description: "Verify realpath is within bounds"
      implementation: |
        def safe_path(root, user_path):
            full = os.path.join(root, user_path)
            real = os.path.realpath(full)
            real_root = os.path.realpath(root)
            if not real.startswith(real_root + os.sep):
                raise SecurityError("Path escape")
            return real

# === SCORING AND EVALUATION ===
scoring:
  detection_criteria:
    - criterion: "identified_all_symlinks"
      weight: 0.2
      description: "Found all symlink structures"
      
    - criterion: "detected_cycles"
      weight: 0.2
      description: "Detected symlink cycles"
      
    - criterion: "blocked_escapes"
      weight: 0.3
      description: "Prevented path escape attacks"
      
    - criterion: "handled_races"
      weight: 0.2
      description: "Addressed TOCTOU races"
      
    - criterion: "proper_solution"
      weight: 0.1
      description: "Solution doesn't break functionality"

  common_mistakes:
    - mistake: "checking_path_not_target"
      description: "Validating user path instead of resolved path"
      frequency: "high"
      
    - mistake: "missing_o_nofollow"
      description: "Opening file without O_NOFOLLOW flag"
      frequency: "high"
      
    - mistake: "depth_limit_only"
      description: "Using depth limit instead of cycle detection"
      frequency: "medium"
      
    - mistake: "string_prefix_check"
      description: "Using startswith instead of proper path check"
      frequency: "high"

# === ENHANCED DIFFICULTY CONFIGURATION ===
enhanced_difficulty_config:
  time_range: [7200, 18000]  # 120-300 minutes for expert reverse engineers
  command_steps: [150, 500]  # Minimum 150 distinct analysis steps required
  trap_count: "15+ nested, mutually-reinforcing traps"
  
  quality_requirements:
    description: "120-300 minutes for expert reverse engineers and security researchers"
    expertise_level: "Elite security researcher with mastery of file system internals, kernel behavior, and container security"
    prerequisite_knowledge:
      - "Symbolic link and hard link semantics across all major operating systems"
      - "Path canonicalization algorithms and TOCTOU race conditions"
      - "Chroot, pivot_root, and container escape techniques"
      - "Mount namespace, bind mounts, and filesystem layering"
      - "VFS layer internals and file descriptor passing"
      - "Linux capabilities and security modules (SELinux, AppArmor)"
      - "NTFS reparse points, junctions, and alternate data streams"
      - "Kernel-level file system race conditions"
  
  phase_4_verification:
    validation_criteria:
      - "Contains 15+ interacting deceptive patterns that cascade across abstraction layers"
      - "Has cascading path traversal that crosses security boundaries"
      - "Requires understanding of kernel VFS layer and filesystem internals"
      - "Would take expert security researchers 120+ minutes"
      - "Symlink chains that span multiple security boundaries"
      - "TOCTOU races with sub-millisecond timing requirements"
      - "Container escape via filesystem manipulation"
      - "Privilege escalation through symlink attacks"
      - "Cross-filesystem and cross-namespace attacks"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "Deceptive complexity designed to defeat even expert analysis"
      requirements:
        - "7+ interacting traps that mask each other's symptoms"
        - "Requires understanding of compiler optimizations and runtime behavior"
        - "Time estimate: 120+ minutes for senior engineers"
        - "Timing-dependent behavior that varies across environments"
        - "Requires synthesizing debugging, systems, and language internals"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 259200]  # 12-72 hours
      command_steps: [600, 3000]
      techniques_required: 25
      description: "CTF championship-level difficulty with adversarial anti-analysis mechanisms"
      requirements:
        - "15+ interacting symlink traps with cascading path escapes"
        - "Kernel-level race exploitation with precise timing"
        - "Multi-namespace and multi-filesystem attacks"
        - "Requires expertise in kernel internals, container security, and forensics"
        - "Time estimate: 12-72 hours for elite security researchers"
        - "Traps that evade common security monitoring tools"
        - "Self-healing symlink structures that recreate after removal"
        - "Anti-forensic evidence destruction via symlink manipulation"
  
  anti_patterns:
    llm_failure_modes:
      - "Trusting visible code structure over actual execution behavior"
      - "Missing compiler optimization effects on code semantics"
      - "Ignoring Unicode normalization and rendering differences"
      - "Not considering filesystem race conditions with symlinks"
      - "Missing singleton initialization order dependencies"
      - "Overlooking environment variable and config file interactions"
      - "Assuming deterministic behavior in timing-sensitive code"
      - "Missing state corruption that only manifests under specific sequences"
      - "Ignoring encoding round-trip issues that corrupt data silently"
      - "Failing to detect kernel-level symlink resolution races"
      - "Missing cross-namespace escape vectors"
      - "Not considering hardlink inode preservation"
  
  generation_targets:
    minimum_difficulty: "120-300 minutes, requires elite expertise in filesystem security and kernel internals"
    target_audience: "Expert reverse engineers, CTF champions, and elite security researchers"
    success_criteria: "LLM fails to identify all symlink traps in first 5 attempts"

# === MULTI-AGENT ORCHESTRATION COMPLEXITY ===
multi_agent_orchestration:
  description: "Coordinating specialized filesystem trap detection agents"
  
  required_agents:
    - agent: "path_analyzer"
      role: "Analyze path resolution and canonicalization"
      capabilities:
        - "Full path resolution tracing"
        - "Symbolic link chain analysis"
        - "Path encoding detection"
      handoff_triggers:
        - "Discovers path traversal potential"
        - "Finds symlink depth anomaly"
    
    - agent: "race_detector"
      role: "Detect TOCTOU race conditions"
      capabilities:
        - "Check-then-use pattern detection"
        - "Race window calculation"
        - "Timing analysis for exploitation"
      handoff_triggers:
        - "Discovers check-use separation"
        - "Finds exploitable race window"
    
    - agent: "namespace_analyst"
      role: "Analyze namespace and mount interactions"
      capabilities:
        - "Mount namespace mapping"
        - "Bind mount analysis"
        - "Namespace escape detection"
      handoff_triggers:
        - "Discovers cross-namespace paths"
        - "Finds mount point confusion"
    
    - agent: "kernel_tracer"
      role: "Trace kernel-level path resolution"
      capabilities:
        - "VFS operation tracing"
        - "File descriptor state tracking"
        - "Security module interaction analysis"
      handoff_triggers:
        - "Discovers kernel-level race"
        - "Finds security module bypass"
    
    - agent: "container_analyst"
      role: "Analyze container escape vectors"
      capabilities:
        - "Container filesystem mapping"
        - "Escape vector enumeration"
        - "Capability analysis"
      handoff_triggers:
        - "Discovers container escape potential"
        - "Finds privilege escalation path"
    
    - agent: "hardlink_tracker"
      role: "Track hardlink relationships"
      capabilities:
        - "Inode reference counting"
        - "Cross-directory hardlink detection"
        - "Sensitive file hardlink discovery"
      handoff_triggers:
        - "Discovers hardlink to sensitive file"
        - "Finds inode persistence attack"
    
    - agent: "forensic_examiner"
      role: "Analyze anti-forensic filesystem manipulation"
      capabilities:
        - "Timeline reconstruction"
        - "Evidence destruction detection"
        - "Artifact recovery"
      handoff_triggers:
        - "Discovers evidence tampering"
        - "Finds self-destructing structures"
    
    - agent: "privilege_analyst"
      role: "Analyze privilege implications"
      capabilities:
        - "Capability requirement analysis"
        - "Privilege escalation path detection"
        - "Security context analysis"
      handoff_triggers:
        - "Discovers privilege escalation"
        - "Finds capability abuse"
  
  cross_artifact_deception_chains:
    - chain: "symlink_to_race_to_escape"
      description: "Symlink creates race window that enables container escape"
      stages:
        - "Symlink appears to point to safe location"
        - "Race window allows target modification"
        - "Modified target enables namespace escape"
    
    - chain: "hardlink_to_persistence_to_escalation"
      description: "Hardlink preserves access through privilege changes"
      stages:
        - "Hardlink created to accessible file"
        - "Original file permissions changed"
        - "Hardlink maintains previous access"
    
    - chain: "mount_to_confusion_to_bypass"
      description: "Mount manipulation causes security bypass"
      stages:
        - "Bind mount appears as regular directory"
        - "Path validation checks wrong location"
        - "Actual access bypasses security"
  
  parallel_deception_analysis:
    shared_symbolic_state:
      - "Inode state across filesystem operations"
      - "Mount table state during analysis"
      - "Race window timing calculations"
      - "Security context propagation"
    
    synchronization_requirements:
      - "Atomic view of filesystem state"
      - "Consistent mount namespace snapshot"
      - "Coordinated race window detection"
  
  agent_handoff_protocols:
    protocol: "multi_layer_path_escape_unwinding"
    steps:
      - "Initial agent detects surface-level path anomaly"
      - "Handoff to specialist for deeper analysis"
      - "Specialist discovers nested escape vector"
      - "Recursive handoff for each security boundary"
      - "Final synthesis of complete attack chain"

# === META TRAP LAYERS ===
meta_trap_layers:
  first_order_traps:
    description: "Obvious symlink issues detectable with basic checks"
    examples:
      - "Direct symlink to /etc/passwd"
      - "Simple parent directory escape (../)"
      - "Obvious symlink cycle"
      - "Basic hardlink to sensitive file"
    detection_time: "5-15 minutes"
    llm_detection_rate: "70-90%"
  
  second_order_traps:
    description: "Symlink issues hidden behind indirection"
    examples:
      - "Multi-hop symlink chain ending at sensitive file"
      - "Symlink in path component, not final element"
      - "Race condition in check-then-use"
      - "Hardlink preserved through permission changes"
    detection_time: "30-60 minutes"
    llm_detection_rate: "30-50%"
  
  third_order_traps:
    description: "Platform and context-dependent issues"
    examples:
      - "Symlink behavior differs in container vs host"
      - "Race window too small for standard detection"
      - "Mount namespace confusion"
      - "Security module bypass via path manipulation"
    detection_time: "60-120 minutes"
    llm_detection_rate: "10-20%"
  
  nth_order_traps:
    description: "Cascading and adaptive path traps"
    examples:
      - "Symlink chains that reconstruct after partial cleanup"
      - "Race conditions that create new race conditions"
      - "Self-modifying directory structures"
      - "Cross-layer attacks (filesystem + namespace + security)"
    detection_time: "120+ minutes per additional layer"
    llm_detection_rate: "<5%"
    
  recursive_trap_structures:
    - structure: "self_healing_symlinks"
      description: "Symlink structure recreates itself when modified"
      depth: "theoretically infinite with automation"
      
    - structure: "cascading_race_windows"
      description: "Each race condition creates opportunity for next"
      depth: "depends on timing precision"
      
    - structure: "namespace_ladder"
      description: "Stepping through namespaces via path manipulation"
      depth: "limited by namespace nesting"

# === ANTI-ANALYSIS TECHNIQUES ===
anti_analysis_techniques:
  environment_detection:
    - technique: "mount_detection"
      description: "Detect analysis environment via mount structure"
      methods:
        - "Check for unusual mount points"
        - "Detect container filesystem layout"
        - "Identify sandbox mount restrictions"
      behavior_change: "Disable traps in analysis environment"
    
    - technique: "namespace_detection"
      description: "Detect namespace isolation"
      methods:
        - "Check /proc/self/ns links"
        - "Compare namespace IDs"
        - "Test namespace escape"
      behavior_change: "Different trap behavior per namespace"
    
    - technique: "inotify_detection"
      description: "Detect filesystem monitoring"
      methods:
        - "Check for inotify watches on trap directories"
        - "Detect fanotify presence"
        - "Identify audit rules"
      behavior_change: "Delay or disable trap when monitored"
  
  anti_debugging_measures:
    - measure: "race_timing"
      description: "Race windows calibrated for production, not debugging"
      implementation: "Detect slow execution and widen window to appear safe"
      
    - measure: "ptrace_evasion"
      description: "Different behavior when ptraced"
      implementation: "Detect TracerPid and modify symlink behavior"
      
    - measure: "audit_evasion"
      description: "Evade audit logging"
      implementation: "Use paths that avoid audit rules"
  
  anti_tracing_mechanisms:
    - mechanism: "kernel_path_caching"
      description: "Exploit kernel path cache behavior"
      implementation: "Timing-based detection of cache invalidation"
      
    - mechanism: "fd_passing"
      description: "Pass file descriptors to evade path tracing"
      implementation: "Open with safe path, pass fd to malicious process"
      
    - mechanism: "procfs_manipulation"
      description: "Manipulate /proc entries"
      implementation: "Hide true paths via /proc/self/fd manipulation"
  
  time_based_anti_analysis:
    - technique: "delayed_resolution"
      description: "Symlink resolution changes after delay"
      implementation: "Background process modifies symlinks after analysis start"
      
    - technique: "race_window_adaptation"
      description: "Race window size adapts to detection attempts"
      implementation: "Narrower window after failed exploitation suggests detection"
      
    - technique: "periodic_reconstruction"
      description: "Trap structures periodically reconstruct"
      implementation: "Cron or timer-based symlink recreation"

# === PSYCHOLOGICAL MISDIRECTION ===
psychological_misdirection:
  obvious_false_positives:
    description: "Intentional red herrings to waste analyst time"
    examples:
      - name: "suspicious_but_safe_symlink"
        description: "Symlink to /tmp that is actually properly sandboxed"
        time_waste: "30-60 minutes"
        
      - name: "documented_hardlink"
        description: "Hardlink that is intentional and documented"
        time_waste: "20-40 minutes"
        
      - name: "obvious_race_window"
        description: "Race condition that is already mitigated"
        time_waste: "45-90 minutes"
  
  misleading_comments:
    description: "Comments that direct attention away from real traps"
    examples:
      - "# Path validated and sanitized"
      - "// Symlinks resolved before use"
      - "/* Race condition eliminated with lock */"
      - "# O_NOFOLLOW used for all opens"
  
  misleading_variable_names:
    description: "Variable names that hide symlink issues"
    examples:
      - "real_path - actually user-controlled path used later"
      - "safe_target - not actually validated"
      - "resolved_link - original path used instead"
      - "validated_path - validation result ignored"
  
  red_herring_code_paths:
    description: "Code paths that appear to handle symlinks but miss traps"
    examples:
      - name: "incomplete_resolution"
        description: "Resolves symlinks but uses original path for operation"
        
      - name: "partial_validation"
        description: "Validates final target but not intermediate components"
        
      - name: "wrong_lock_scope"
        description: "Lock doesn't cover the actual race window"
  
  partial_solutions:
    description: "Solutions that work initially but enable harder attacks"
    examples:
      - name: "symlink_resolution"
        description: "Resolving symlinks enables hardlink attack"
        
      - name: "path_sanitization"
        description: "Sanitizing path enables encoding-based bypass"
        
      - name: "race_mitigation"
        description: "Closing one race window opens another"

# === VERSION HISTORY ===
version_history:
  - version: "1.0.0"
    date: "2024-01-01"
    changes: "Initial symlink traps"
  - version: "2.0.0"
    date: "2024-06-01"
    changes: "Expanded to 1000+ lines with comprehensive symlink attacks"
  - version: "3.0.0"
    date: "2024-12-01"
    changes: "Enhanced difficulty with nightmare mode and comprehensive anti-patterns"
