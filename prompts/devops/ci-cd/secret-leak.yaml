id: "devops-cicd-secret-leak-001"
version: "2.0.0"
category: "devops"
subcategory: "ci-cd"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research obscure secret exposure vectors in CI/CD pipelines"
    phase_2_creation: "Create complex multi-stage pipeline with subtle secret leakage"
    phase_3_amplification: "Add supply chain attack scenarios and forensic requirements"
    phase_4_verification: "Validate task requires production-level secret management expertise"
  
  complexity_targets:
    minimum_unique_tasks: 10000
    difficulty_range: ["medium", "hard", "expert", "nightmare"]
    domain_expertise_required: ["secret_management", "ci_cd_security", "supply_chain", "cryptography"]
  
  task_generation_rules:
    - "Combine 3+ leakage vectors per task"
    - "Include real breach case studies"
    - "Require end-to-end secret rotation"
    - "Add compliance and audit requirements"
    - "Include incident response components"
  
  phase_4_verification:
    requirements:
      - "Has at least 5 interacting hidden traps"
      - "Has cascading failures across infrastructure layers (network, compute, storage)"
      - "Requires knowledge of cloud provider internals and Kubernetes scheduler"
      - "Would take experienced SREs 30+ minutes"

# SWE-bench_Pro style fields
problem_statement: |
  A CI/CD pipeline has credential exposure vulnerabilities:
  
  1. Secrets printed in build logs
  2. Credentials in Dockerfile/docker-compose
  3. API keys in environment variable expansion
  4. Secrets in git history
  5. Artifacts containing credentials
  6. Third-party action/plugin exposure
  7. Cache poisoning with secrets
  8. Webhook payload leakage
  9. Container image secret embedding
  10. Debug mode credential exposure

requirements: |
  - Remove secrets from all logs
  - Use proper secret management
  - Clean git history of secrets
  - Secure build artifacts
  - Implement secret rotation
  - Audit third-party dependencies
  - Configure secure caching
  - Implement secret scanning
  - Set up alerting for exposure
  - Document incident response

interface: |
  Input: CI/CD pipeline configuration
  Output: Secure pipeline with proper secret handling
  Validation: No secrets in logs, artifacts, or git

# === COMPREHENSIVE TOPIC UNIVERSE ===
# 100+ detailed topics for secret leak scenarios
topic_universe:
  # Secret Exposure Vectors (35 topics)
  secret_exposure_vectors:
    build_log_exposure:
      - echo_commands: |
          Secret echo in build scripts:
          - echo "Deploying with $API_KEY"
          - set -x enabling command trace
          - printf debugging with secrets
          - env command dumping environment
          Detection:
          - Scan logs for high-entropy strings
          - Pattern matching for known formats
          - Alert on environment dumps
      
      - error_message_exposure: |
          Secrets in error messages:
          - Connection string in SQL errors
          - API key in HTTP error responses
          - Stack traces with config values
          - Debug output in CI failures
      
      - verbose_mode_leakage: |
          Verbose/debug mode issues:
          - npm install --verbose
          - pip install -vvv
          - curl -v with headers
          - git clone --verbose with auth
          - terraform with TF_LOG=DEBUG
      
      - test_output_exposure: |
          Secrets in test outputs:
          - Integration test logs
          - API response logging in tests
          - Mock configuration exposure
          - Test fixture credentials
      
      - dependency_install_logs: |
          Package manager log exposure:
          - npm auth token in debug
          - pip index credentials
          - Maven settings.xml in errors
          - Docker registry auth logs
    
    source_code_exposure:
      - committed_secrets: |
          Secrets committed to git:
          - .env files
          - config.json with credentials
          - Hardcoded API keys
          - Private keys (.pem, .key)
          - Service account JSON files
          Detection tools:
          - git-secrets
          - trufflehog
          - gitleaks
          - detect-secrets
      
      - git_history_secrets: |
          Secrets in git history:
          - Removed but still in history
          - Branch with old credentials
          - Merge commit artifacts
          - Squashed commit remnants
          Cleaning:
          - git filter-branch
          - BFG Repo-Cleaner
          - git filter-repo
      
      - submodule_secrets: |
          Submodule credential exposure:
          - Auth in submodule URLs
          - .gitmodules credentials
          - Recursive clone exposure
      
      - git_hooks_exposure: |
          Git hooks with secrets:
          - Pre-push with credentials
          - Post-receive deployment keys
          - Commit-msg with API tokens
    
    container_exposure:
      - dockerfile_secrets: |
          Dockerfile secret patterns:
          - ARG with secret values
          - ENV with hardcoded credentials
          - COPY of .env files
          - ADD of private keys
          - RUN with inline secrets
          Layer inspection:
          - docker history --no-trunc
          - dive image analysis
          - container-diff
      
      - docker_build_args: |
          Build-time secret exposure:
          - ARG stored in image metadata
          - Multi-stage build leakage
          - BuildKit secret mounts
          Secure alternatives:
          - --secret flag (BuildKit)
          - Multi-stage without ARG
          - External secret injection
      
      - image_registry_auth: |
          Registry credential exposure:
          - ~/.docker/config.json
          - Docker credential helpers
          - ECR/GCR/ACR auth tokens
          - Harbor robot accounts
      
      - compose_secrets: |
          Docker Compose secrets:
          - Inline environment variables
          - env_file exposure
          - volume-mounted secrets
          - Swarm secrets vs env vars
    
    ci_platform_exposure:
      - github_actions_secrets: |
          GitHub Actions exposure vectors:
          - ${{ secrets.* }} in outputs
          - Artifact upload with secrets
          - Matrix job secret exposure
          - Reusable workflow inheritance
          - Fork PR access to secrets
          Protection:
          - Secret masking
          - Environment protection rules
          - Required reviewers
      
      - gitlab_ci_secrets: |
          GitLab CI exposure:
          - CI_JOB_TOKEN scope
          - Masked variable limitations
          - Protected branch variables
          - Group-level inheritance
          - External secrets integration
      
      - jenkins_credentials: |
          Jenkins credential exposure:
          - Credential binding leakage
          - Pipeline syntax exposure
          - Global credentials scope
          - Credential rotation
          - CloudBees credential management
      
      - azure_devops_secrets: |
          Azure DevOps exposure:
          - Variable group inheritance
          - Service connection tokens
          - Pipeline template secrets
          - Release pipeline variables
      
      - circleci_contexts: |
          CircleCI secret management:
          - Context sharing
          - Organization secrets
          - Project-level variables
          - Orb secret access
    
    artifact_exposure:
      - build_artifact_secrets: |
          Secrets in build artifacts:
          - config files in packages
          - .env in npm packages
          - settings.py in wheels
          - application.yml in JARs
          Scanning:
          - artifact inspection
          - SBOM analysis
          - package content audit
      
      - cache_poisoning: |
          CI cache secret exposure:
          - npm/yarn cache with tokens
          - pip cache with credentials
          - Docker layer cache
          - Gradle/Maven cache
      
      - release_asset_secrets: |
          Release asset exposure:
          - Debug builds with secrets
          - Source maps with env vars
          - Documentation with examples
          - Sample configurations

  # Secret Management Solutions (25 topics)
  secret_management:
    vault_solutions:
      - hashicorp_vault: |
          HashiCorp Vault integration:
          - Transit secrets engine
          - Dynamic secrets (database, AWS)
          - AppRole authentication
          - JWT/OIDC auth methods
          - Secrets versioning
          - Lease management
          CI/CD patterns:
          - vault-action for GitHub
          - vault-plugin for Jenkins
          - GitLab native integration
      
      - aws_secrets_manager: |
          AWS Secrets Manager:
          - Automatic rotation
          - Cross-account access
          - Lambda rotation functions
          - Resource-based policies
          - Version staging labels
          - Secret replication
      
      - aws_parameter_store: |
          AWS Systems Manager Parameter Store:
          - SecureString parameters
          - Hierarchical namespaces
          - KMS key integration
          - Parameter policies
          - Change notifications
      
      - azure_key_vault: |
          Azure Key Vault:
          - Managed identities
          - Access policies vs RBAC
          - Soft delete and purge
          - Key rotation
          - Certificate management
          - Private endpoints
      
      - gcp_secret_manager: |
          GCP Secret Manager:
          - IAM-based access
          - Automatic replication
          - Version management
          - Customer-managed encryption
          - Secret rotation
          - Audit logging
    
    kubernetes_secrets:
      - k8s_native_secrets: |
          Kubernetes secrets:
          - Base64 encoding (not encryption!)
          - Secret types (opaque, tls, dockercfg)
          - Secret mounting vs env vars
          - Immutable secrets
          Limitations:
          - etcd encryption required
          - RBAC for secret access
          - No native rotation
      
      - external_secrets_operator: |
          External Secrets Operator:
          - SecretStore/ClusterSecretStore
          - ExternalSecret sync
          - Multiple backend support
          - Refresh intervals
          - Push secrets
      
      - sealed_secrets: |
          Bitnami Sealed Secrets:
          - Client-side encryption
          - Safe to commit to git
          - Cluster-specific decryption
          - Key rotation
      
      - sops: |
          SOPS (Secrets OPerationS):
          - File encryption
          - Multiple KMS support
          - Git-friendly diffs
          - Path-based rules
          - Key groups
    
    workload_identity:
      - github_oidc: |
          GitHub OIDC for cloud auth:
          - No stored credentials
          - Federated identity
          - Short-lived tokens
          - Repository/branch claims
          Setup for AWS, GCP, Azure
      
      - gitlab_oidc: |
          GitLab OIDC integration:
          - CI_JOB_JWT token
          - Cloud provider federation
          - ID token claims
          - Project/ref filtering
      
      - workload_identity_gke: |
          GKE Workload Identity:
          - KSA to GSA binding
          - Pod-level identity
          - Credential-free access
          - Metadata server proxy
      
      - irsa_eks: |
          EKS IRSA (IAM Roles for Service Accounts):
          - OIDC provider setup
          - Service account annotation
          - Token projection
          - Cross-account roles

  # Detection and Scanning (20 topics)
  detection_scanning:
    pre_commit_scanning:
      - git_secrets: |
          git-secrets by AWS:
          - Pattern-based detection
          - AWS key patterns built-in
          - Custom patterns support
          - Pre-commit hook
          - Commit scanning
      
      - detect_secrets: |
          Yelp detect-secrets:
          - High-entropy string detection
          - Plugin architecture
          - Baseline management
          - Audit workflow
          - CI/CD integration
      
      - gitleaks: |
          Gitleaks scanning:
          - Regex-based rules
          - Entropy checking
          - Allowlist support
          - CI/CD native
          - Git history scanning
      
      - trufflehog: |
          TruffleHog scanning:
          - Entropy analysis
          - Regex patterns
          - Git history deep scan
          - Filesystem scanning
          - Verified detection
    
    ci_cd_scanning:
      - github_secret_scanning: |
          GitHub native scanning:
          - Partner patterns
          - Custom patterns
          - Push protection
          - Alert management
          - Auto-revocation
      
      - gitlab_secret_detection: |
          GitLab secret detection:
          - SAST template
          - Custom patterns
          - MR blocking
          - Vulnerability report
      
      - snyk_secrets: |
          Snyk secret scanning:
          - Broad pattern coverage
          - IDE integration
          - PR checks
          - Dashboard visibility
    
    runtime_detection:
      - log_scanning: |
          Runtime log scanning:
          - Real-time pattern matching
          - SIEM integration
          - Alert on detection
          - Automated response
      
      - network_monitoring: |
          Network-based detection:
          - Credential in transit
          - Unencrypted secret transfer
          - DLP integration

  # Incident Response (15 topics)
  incident_response:
    immediate_actions:
      - credential_rotation: |
          Immediate rotation process:
          - Revoke exposed credential
          - Generate new credential
          - Update all dependents
          - Verify functionality
          - Document timeline
      
      - exposure_assessment: |
          Assess exposure scope:
          - When was it exposed?
          - Who had access?
          - Was it used maliciously?
          - What systems were accessible?
          - What data was at risk?
      
      - git_history_cleaning: |
          Clean git history:
          - BFG Repo-Cleaner
          - git filter-repo
          - Force push to all remotes
          - Notify all contributors
          - Garbage collect
    
    investigation:
      - timeline_reconstruction: |
          Build incident timeline:
          - First commit with secret
          - Clone/fork events
          - CI/CD log access
          - API access logs
          - Audit trail review
      
      - access_audit: |
          Audit credential usage:
          - Cloud provider audit logs
          - API usage logs
          - Service access patterns
          - Anomaly detection
    
    remediation:
      - process_improvement: |
          Process improvements:
          - Pre-commit hooks mandatory
          - Secret scanning in CI
          - Developer training
          - Security champions program
      
      - architecture_changes: |
          Architectural remediation:
          - Adopt secret manager
          - Implement OIDC
          - Reduce secret scope
          - Implement rotation

  # Supply Chain Security (10 topics)
  supply_chain:
    third_party_risks:
      - action_plugin_exposure: |
          Third-party action risks:
          - Secrets passed to untrusted actions
          - Version pinning importance
          - Action marketplace risks
          - Forked action attacks
          Mitigations:
          - Pin to SHA, not tag
          - Audit action code
          - Use verified publishers
      
      - dependency_attacks: |
          Dependency-based exposure:
          - Typosquatting packages
          - Dependency confusion
          - Malicious package updates
          - Post-install scripts
      
      - ci_runner_compromise: |
          Runner/agent compromise:
          - Self-hosted runner risks
          - Shared runner exposure
          - Runner token theft
          - Persistence mechanisms

# === FAILURE SCENARIOS ===
# 50+ detailed failure scenarios
failure_scenarios:
  high_profile_breaches:
    - scenario: "Codecov Bash Uploader Compromise (2021)"
      description: |
        1. Attacker modified Codecov bash script in CI
        2. Script exfiltrated environment variables
        3. Affected thousands of repositories
        4. CI environment secrets stolen
        5. Supply chain attack vector
      lessons:
        - "Verify integrity of third-party scripts"
        - "Use pinned versions with checksums"
        - "Monitor for unexpected network traffic"
        - "Limit environment variable exposure"
    
    - scenario: "Uber Data Breach (2016)"
      description: |
        1. AWS credentials in GitHub repository
        2. Attacker found via search
        3. Accessed S3 bucket with user data
        4. 57 million records exposed
        5. $148 million settlement
      lessons:
        - "Never commit credentials to source control"
        - "Implement pre-commit scanning"
        - "Use temporary credentials (IAM roles)"
    
    - scenario: "CircleCI Security Incident (2023)"
      description: |
        1. Malware on CircleCI engineer laptop
        2. Attacker accessed production systems
        3. All customer secrets potentially exposed
        4. Forced rotation of all secrets
        5. Trust implications for CI providers
      lessons:
        - "Defense in depth"
        - "Limit blast radius of secrets"
        - "Regular secret rotation"
        - "Zero trust architecture"
  
  common_exposure_patterns:
    - scenario: "Debug mode left enabled in production"
      description: |
        1. Developer enables debug for troubleshooting
        2. Forgets to disable before merge
        3. Debug output includes API keys
        4. Logs shipped to monitoring system
        5. Monitoring system breached later
      prevention:
        - "CI checks for debug flags"
        - "Environment-based configuration"
        - "Code review requirements"
    
    - scenario: "Fork PR accesses secrets"
      description: |
        1. Attacker forks public repository
        2. Creates PR with malicious workflow
        3. Workflow exfiltrates secrets
        4. Secrets sent to attacker server
      prevention:
        - "Require approval for fork PRs"
        - "Don't expose secrets to forks"
        - "Use pull_request_target carefully"
    
    - scenario: "Artifact contains config with secrets"
      description: |
        1. Build process includes config files
        2. Config file has embedded credentials
        3. Artifact published to public registry
        4. Anyone can extract secrets
      prevention:
        - "Scan artifacts before publish"
        - "Externalize configuration"
        - "Use environment variables"
    
    - scenario: "Docker image contains .env file"
      description: |
        1. Dockerfile copies entire directory
        2. .env file included in COPY
        3. Image pushed to registry
        4. docker history reveals secrets
      prevention:
        - ".dockerignore for sensitive files"
        - "Multi-stage builds"
        - "Don't use ADD/COPY for secrets"
    
    - scenario: "Cache contains authentication tokens"
      description: |
        1. CI caches node_modules
        2. npm/yarn cache contains .npmrc
        3. .npmrc has registry token
        4. Cache shared between builds
        5. Token accessible in other builds
      prevention:
        - "Don't cache auth files"
        - "Use credentials in environment only"
        - "Scope cache to branch/job"
  
  compliance_failures:
    - scenario: "PCI-DSS audit failure from key exposure"
      description: |
        1. Encryption key found in build logs
        2. Auditor flags as critical finding
        3. Cardholder data potentially compromised
        4. Must prove no unauthorized access
        5. 90-day remediation required
      impact:
        - "Possible compliance decertification"
        - "Mandatory key rotation"
        - "Expanded audit scope"
    
    - scenario: "HIPAA violation from API key in logs"
      description: |
        1. Healthcare API key logged in CI
        2. Key provided access to PHI
        3. Breach notification required
        4. HHS investigation triggered
      impact:
        - "Civil monetary penalties"
        - "Corrective action plan"
        - "Reputation damage"

# === CLOUD-SPECIFIC ISSUES ===
# 100+ cloud-specific secret management issues
cloud_specific_issues:
  aws:
    iam:
      - access_key_exposure: |
          AWS access key risks:
          - Long-lived credentials
          - Overly permissive policies
          - Root account keys
          - Shared credentials
          Mitigations:
          - Use IAM roles instead
          - Implement key rotation
          - Minimum privilege policies
          - AWS Organizations SCPs
      
      - assume_role_patterns: |
          AssumeRole for CI/CD:
          - Cross-account access
          - External ID requirement
          - Session duration limits
          - Role chaining
          - Trust policy security
      
      - oidc_federation: |
          GitHub OIDC to AWS:
          - No stored credentials
          - Claim-based access
          - Repository/branch filtering
          - Session tags
          Configuration:
          - Create OIDC provider
          - Configure trust policy
          - Use aws-actions/configure-aws-credentials
    
    services:
      - secrets_manager_patterns: |
          Secrets Manager best practices:
          - Automatic rotation setup
          - Cross-account access
          - VPC endpoints
          - Replica regions
          - Resource policies
      
      - kms_key_management: |
          KMS for secret encryption:
          - Key policies
          - Key rotation
          - Cross-account grants
          - Alias management
          - Multi-region keys
      
      - parameter_store_tiers: |
          Parameter Store patterns:
          - Standard vs Advanced tier
          - Hierarchical paths
          - Change notification
          - Session Manager integration
  
  gcp:
    iam:
      - service_account_keys: |
          Service account key risks:
          - Key file exposure
          - Key rotation challenges
          - Excessive permissions
          Mitigations:
          - Workload Identity Federation
          - Impersonation
          - Short-lived tokens
      
      - workload_identity_federation: |
          WIF for CI/CD:
          - GitHub OIDC provider
          - Attribute mapping
          - Attribute conditions
          - Service account impersonation
    
    services:
      - secret_manager_patterns: |
          GCP Secret Manager:
          - IAM conditions
          - Version aliases
          - Replication policies
          - Customer-managed encryption
          - Pub/Sub notifications
  
  azure:
    identity:
      - service_principal_secrets: |
          Service principal risks:
          - Client secret expiration
          - Certificate management
          - Federated credentials
          Mitigations:
          - Managed identities
          - OIDC federation
          - Certificate rotation
      
      - managed_identity: |
          Managed identity patterns:
          - System-assigned vs User-assigned
          - Cross-resource access
          - Token acquisition
          - AKS pod identity
    
    services:
      - key_vault_patterns: |
          Key Vault best practices:
          - Access policies vs RBAC
          - Private endpoints
          - Soft-delete recovery
          - Backup and restore
          - Purge protection
  
  github:
    - secrets_management: |
        GitHub secrets:
        - Repository vs Organization
        - Environment secrets
        - Dependabot secrets
        - OIDC token claims
        Limitations:
        - 64KB size limit
        - No binary secrets
        - Masking in logs
    
    - environments: |
        Environment protection:
        - Required reviewers
        - Wait timer
        - Deployment branches
        - Custom rules
    
    - actions_security: |
        Actions security:
        - GITHUB_TOKEN permissions
        - Fork behavior
        - Reusable workflow secrets
        - Composite action limitations
  
  gitlab:
    - variables_management: |
        GitLab CI variables:
        - Protected variables
        - Masked variables
        - File type variables
        - Group inheritance
        - External secrets
    
    - vault_integration: |
        HashiCorp Vault integration:
        - JWT authentication
        - ID token claims
        - Secret retrieval
        - Dynamic secrets

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  secret_count:
    description: "Number of secrets to manage"
    complexity_factor:
      - "< 10: 1.0x"
      - "10-50: 1.5x"
      - "50-200: 2.0x"
      - "> 200: 3.0x"
  
  rotation_requirements:
    description: "Secret rotation frequency"
    complexity_factor:
      - "Annual: 1.0x"
      - "Quarterly: 1.3x"
      - "Monthly: 1.5x"
      - "Weekly: 2.0x"
      - "Daily/Automatic: 2.5x"
  
  compliance_requirements:
    pci_dss:
      complexity_factor: 2.0
      requirements:
        - "Requirement 3: Protect stored data"
        - "Requirement 6: Secure systems"
        - "Requirement 8: Identify and authenticate"
        - "Key rotation every 12 months"
    
    hipaa:
      complexity_factor: 1.8
      requirements:
        - "Access controls"
        - "Audit controls"
        - "Integrity controls"
        - "Encryption requirements"
    
    sox:
      complexity_factor: 1.5
      requirements:
        - "Access management"
        - "Change management"
        - "Audit trail"
    
    fedramp:
      complexity_factor: 2.5
      requirements:
        - "FIPS 140-2 compliance"
        - "Key management procedures"
        - "Continuous monitoring"
        - "Incident response"
  
  multi_cloud:
    description: "Secrets span multiple cloud providers"
    complexity_factor: 2.0
    challenges:
      - "Different secret formats"
      - "Multiple authentication methods"
      - "Unified rotation strategy"
      - "Cross-cloud access patterns"
  
  legacy_systems:
    description: "Legacy systems with hardcoded secrets"
    complexity_factor: 2.5
    challenges:
      - "No environment variable support"
      - "Compiled configuration"
      - "Vendor limitations"
      - "Migration complexity"

# === terminal-bench style fields ===
difficulty:
  estimated: "hard"
  time_range: [1800, 14400]
  command_steps: [40, 200]

# === Difficulty amplifiers ===
difficulty_amplifiers:
  nightmare:
    multiplier: 3.0
    description: "Production-level incident requiring multi-team coordination knowledge"
    requirements:
      - "7+ interacting failures across CI/CD, containers, and infrastructure"
      - "Requires understanding of cloud provider-specific behaviors"
      - "Time estimate: 120+ minutes for senior SREs"
      - "Cross-service dependencies that cascade in non-obvious ways"
      - "Requires synthesizing security, performance, and reliability knowledge"

# === Quality requirements ===
quality_requirements:
  minimum_difficulty: "90-240 minutes, requires senior SRE/DevSecOps engineers with cloud architecture and secret management expertise"
  time_estimate: "90-240 minutes for senior SRE/DevSecOps engineers, 4-8 hours for intermediate"
  trap_count: "10+ deeply interacting traps across CI/CD, container, cloud, and monitoring boundaries"

# === Multi-Agent Orchestration Complexity ===
multi_agent_orchestration:
  description: "Coordinating 5-8 specialized DevOps agents for comprehensive secret leak detection and remediation"
  required_agents:
    - secret_scanner_expert:
        role: "Deep analysis of codebases, artifacts, and logs for exposed credentials"
        expertise: ["entropy analysis", "pattern matching", "credential format identification"]
    - git_forensics_specialist:
        role: "Analyzing git history for historical secret exposure and remediation"
        expertise: ["git filter-branch", "BFG repo-cleaner", "force push coordination"]
    - cloud_iam_expert:
        role: "Assessing and rotating compromised cloud credentials across accounts"
        expertise: ["IAM policy analysis", "credential rotation", "service account management"]
    - ci_cd_security_auditor:
        role: "Reviewing pipeline configurations for secret exposure vectors"
        expertise: ["variable masking", "environment isolation", "artifact scanning"]
    - container_secrets_analyst:
        role: "Analyzing container images and runtime for embedded secrets"
        expertise: ["layer inspection", "BuildKit secrets", "runtime injection"]
    - vault_integration_specialist:
        role: "Implementing and auditing secret management solutions"
        expertise: ["HashiCorp Vault", "cloud secret managers", "dynamic secrets"]
    - incident_response_coordinator:
        role: "Managing secret breach response across multiple systems"
        expertise: ["containment", "rotation", "forensics", "notification"]
    - compliance_auditor:
        role: "Ensuring secret management meets regulatory requirements"
        expertise: ["PCI-DSS key management", "HIPAA safeguards", "SOC2 controls"]
  
  cross_platform_attack_chains:
    - name: "CI/CD Secret Exfiltration to Full Compromise"
      stages:
        - "Developer commits .env file to feature branch"
        - "Pre-commit hook bypassed via --no-verify flag"
        - "Secret scanning misses base64-encoded credentials"
        - "CI/CD pipeline logs expose database connection string"
        - "Log aggregator indexes secrets searchable by attackers"
        - "Attacker gains database access via harvested credentials"
        - "Lateral movement to application servers using DB-stored secrets"
        - "Cloud credentials exfiltrated from application config"
        - "Full cloud account compromise via escalated IAM role"
    - name: "Container Image Secret Extraction"
      stages:
        - "Dockerfile uses ARG for build-time secrets"
        - "Secrets embedded in intermediate image layers"
        - "Image pushed to public registry by mistake"
        - "Attacker pulls image and extracts layer history"
        - "API keys recovered from image metadata"
        - "Production API compromised using extracted keys"
        - "Persistent access established via compromised service account"
  
  parallel_analysis_requirements:
    - "Simultaneous scanning of git history across all branches and forks"
    - "Correlated analysis of CI/CD logs, container layers, and artifact stores"
    - "Real-time monitoring of secret usage patterns across services"
    - "Cross-reference of exposed secrets with cloud provider audit logs"
  
  agent_handoff_scenarios:
    - "Secret scanner finds credential → Git forensics traces exposure timeline → IAM expert assesses blast radius → Incident coordinator manages rotation"
    - "Container analyst identifies embedded secret → CI/CD auditor traces build pipeline → Vault specialist implements secure injection"
    - "Compliance auditor identifies PCI violation → Secret scanner quantifies exposure → Incident coordinator manages breach notification"

# === Nightmare Plus Difficulty Level ===
difficulty_levels:
  nightmare_plus:
    estimated_time: [28800, 172800]  # 8-48 hours
    command_steps: [400, 1500]
    techniques_required: 12
    description: "Secret management crisis requiring deep infrastructure and security expertise with multi-cloud, multi-system coordination"
    characteristics:
      - "Secrets exposed across 5+ different storage locations"
      - "Git history contamination spanning 100+ commits"
      - "Cross-repository secret propagation via forks"
      - "Encoded/encrypted secrets requiring decryption analysis"
      - "Secret rotation impacting 50+ dependent services"
      - "Compliance breach requiring legal notification"
      - "Multi-cloud credential cascade effects"
      - "CI/CD trust chain compromise scenarios"
    required_expertise:
      - "Deep understanding of git internals and history rewriting"
      - "Knowledge of CI/CD platform secret handling mechanisms"
      - "Experience with enterprise secret management solutions"
      - "Familiarity with cloud provider credential systems"
      - "Understanding of container layer storage and caching"

# === Cloud Native Internals ===
cloud_native_internals:
  kubernetes_internals:
    kubelet:
      - "Secret volume mounting and tmpfs behavior"
      - "Service account token projection and rotation"
      - "ImagePullSecrets credential passing"
      - "Secrets sync with external secret stores"
    controller_manager:
      - "ServiceAccount token controller behavior"
      - "TokenRequest API for bound tokens"
      - "Secret garbage collection and cleanup"
    scheduler:
      - "Secret availability as scheduling constraint"
      - "Node affinity for secret-holding volumes"
    admission_controllers:
      - "PodSecurity admission for secret exposure risks"
      - "ValidatingWebhook for secret policy enforcement"
      - "MutatingWebhook for secret injection"
    etcd:
      - "Encryption at rest configuration"
      - "Encryption provider key rotation"
      - "etcd access via kubectl for secret extraction"
  
  container_runtime_internals:
    containerd:
      - "Secrets handling in OCI runtime spec"
      - "Image pull credential caching"
      - "tmpfs for secret volumes"
    cri_o:
      - "Secrets directory permissions"
      - "RuntimeClass for secret isolation"
    buildkit:
      - "--mount=type=secret for build-time secrets"
      - "Secret caching behavior"
      - "Multi-stage secret isolation"
  
  service_mesh_internals:
    envoy:
      - "SDS (Secret Discovery Service) for dynamic certificates"
      - "mTLS certificate rotation"
      - "Header-based authentication token passing"
    istio_data_plane:
      - "Citadel certificate management"
      - "Service account token exchange"
      - "Workload identity integration"
  
  cloud_provider_iam_quirks:
    aws:
      - "IAM role credential caching in IMDS (169.254.169.254)"
      - "Secrets Manager rotation Lambda complexity"
      - "Parameter Store SecureString KMS interactions"
      - "IRSA token projection and audience validation"
    gcp:
      - "Workload Identity credential caching behavior"
      - "Secret Manager version access patterns"
      - "Service account key exposure via metadata server"
    azure:
      - "Managed Identity token caching and refresh"
      - "Key Vault secret versioning and soft delete"
      - "AKS pod identity vs workload identity transition"

# === Supply Chain Attack Vectors ===
supply_chain_attack_vectors:
  dependency_confusion_variants:
    - ci_secret_injection: "Malicious packages exfiltrating CI/CD environment variables"
    - build_cache_harvesting: "Extracting secrets from build caches via dependency"
    - postinstall_credential_theft: "npm/pip scripts accessing process.env secrets"
  
  build_process_manipulation:
    - dockerfile_arg_exposure: "ARG instructions storing secrets in image layers"
    - multi_stage_secret_leakage: "Secrets copied between build stages"
    - buildkit_cache_exposure: "Secrets persisted in BuildKit cache"
    - github_actions_artifact_secrets: "Secrets in uploaded artifacts"
    - jenkins_workspace_secrets: "Credentials in workspace files"
  
  registry_poisoning:
    - docker_config_json_exposure: "Registry credentials in ~/.docker/config.json"
    - helm_repo_auth_leakage: "Helm repository credentials exposure"
    - npm_auth_token_theft: ".npmrc token extraction"
  
  artifact_signing_bypass:
    - signing_key_exposure: "Private keys in version control"
    - certificate_private_key_leakage: "TLS private keys in logs"
    - ssh_key_extraction: "SSH keys from build artifacts"

# === Incident Response Complexity ===
incident_response_complexity:
  production_debugging_scenarios:
    - scenario: "Database credentials exposed in public GitHub commit"
      complexity_factors:
        - "Determine if credentials were used by attackers"
        - "Audit database access logs for unauthorized queries"
        - "Coordinate credential rotation across 20+ microservices"
        - "Update all deployment configurations atomically"
        - "Maintain service availability during rotation"
        - "Clean git history without disrupting active development"
      required_coordination:
        - "Security team for threat assessment"
        - "DBA team for credential rotation and audit"
        - "Platform team for deployment coordination"
        - "Development teams for configuration updates"
        - "Legal team for breach notification assessment"
    
    - scenario: "CI/CD pipeline secret leaked to build logs"
      complexity_factors:
        - "Identify all builds with exposed secrets"
        - "Audit log aggregator for secret indexing"
        - "Trace secret propagation to downstream artifacts"
        - "Coordinate multi-team credential rotation"
        - "Implement emergency log redaction"
      forensic_requirements:
        - "Build log analysis for exposure timeline"
        - "Log aggregator query audit"
        - "Artifact content verification"
        - "Network traffic analysis for exfiltration"
    
    - scenario: "Production container image contains embedded secrets"
      complexity_factors:
        - "Identify all running containers with compromised image"
        - "Extract and rotate all embedded secrets"
        - "Rebuild and redeploy clean images"
        - "Audit container logs for secret exposure"
        - "Implement image scanning gates"

# === LLM trap configurations ===
traps:
  - type: "echo_secret"
    description: "Secret echoed in build script"
    trigger: "Using echo or print with secrets"
    severity: "critical"
  
  - type: "dockerfile_arg"
    description: "Secrets passed as build ARG"
    trigger: "Using ARG for secrets in Dockerfile"
    severity: "critical"
  
  - type: "env_expansion"
    description: "Secret exposed in error message"
    trigger: "Shell expanding secret in debug output"
    severity: "high"
  
  - type: "git_committed"
    description: "Secret committed to git history"
    trigger: "Secrets in .env or config files committed"
    severity: "critical"
  
  - type: "artifact_inclusion"
    description: "Secret included in build artifact"
    trigger: "Config file with secrets in package"
    severity: "high"
  
  - type: "cache_exposure"
    description: "Secret in cached directory"
    trigger: "Caching auth configuration files"
    severity: "high"
  
  - type: "fork_pr_access"
    description: "Fork PR can access secrets"
    trigger: "pull_request trigger exposes secrets"
    severity: "critical"
  
  - type: "untrusted_action"
    description: "Third-party action receives secrets"
    trigger: "Passing secrets to unpinned action"
    severity: "high"

# === Task generation template ===
instruction_template: |
  You are securing secrets in a {{ scenario_type }} CI/CD pipeline on {{ ci_platform }}.
  The pipeline configuration is at {{ path }}.
  
  Environment Details:
  - CI Platform: {{ ci_platform }} {{ ci_version }}
  - Cloud Provider: {{ cloud_provider }}
  - Secret Manager: {{ secret_manager }}
  - Number of secrets: {{ secret_count }}
  - Pipeline runs per day: {{ run_count }}
  
  Current Issues:
  - Exposed secrets found: {{ exposed_count }}
  - Secrets in git history: {{ git_history_secrets }}
  - Unrotated secrets: {{ unrotated_count }}
  
  Compliance Requirements: {{ compliance_frameworks }}
  
  Your task:
  {{ task_steps }}
  
  Deliverables:
  - Secure pipeline configuration
  - Secret management setup
  - Git history cleanup (if needed)
  - Scanning configuration
  - Rotation procedures
  - Incident response playbook

# === Reference solution (hidden from agent) ===
reference_solution: |
  # CI/CD Secret Management - Comprehensive Guide
  
  # ============================================================
  # PHASE 1: SECRET SCANNING SETUP
  # ============================================================
  
  ## 1.1 Pre-commit Hook Configuration
  
  # .pre-commit-config.yaml
  repos:
    - repo: https://github.com/Yelp/detect-secrets
      rev: v1.4.0
      hooks:
        - id: detect-secrets
          args: ['--baseline', '.secrets.baseline']
          exclude: package-lock.json
    
    - repo: https://github.com/gitleaks/gitleaks
      rev: v8.18.0
      hooks:
        - id: gitleaks
    
    - repo: https://github.com/awslabs/git-secrets
      rev: master
      hooks:
        - id: git-secrets
  
  ## 1.2 Initialize Secret Baseline
  
  # Generate baseline (review for false positives)
  detect-secrets scan > .secrets.baseline
  
  # Audit existing secrets
  detect-secrets audit .secrets.baseline
  
  ## 1.3 Gitleaks Configuration
  
  # .gitleaks.toml
  [extend]
  useDefault = true
  
  [allowlist]
  description = "Allowlist for known safe patterns"
  paths = [
      '''.*\.secrets\.baseline$''',
      '''.*test.*''',
      '''.*mock.*''',
  ]
  
  [[rules]]
  id = "custom-api-key"
  description = "Custom API Key Pattern"
  regex = '''(?i)my_company_api_key\s*=\s*['"][a-z0-9]{32}['"]'''
  
  # ============================================================
  # PHASE 2: SECURE PIPELINE CONFIGURATION
  # ============================================================
  
  ## 2.1 GitHub Actions - Secure Workflow
  
  name: Secure Build Pipeline
  
  on:
    push:
      branches: [main]
    pull_request:
      branches: [main]
  
  # Minimum required permissions
  permissions:
    contents: read
    id-token: write  # For OIDC
  
  jobs:
    secret-scan:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
          with:
            fetch-depth: 0  # Full history for scanning
        
        - name: Run gitleaks
          uses: gitleaks/gitleaks-action@v2
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
        - name: Run trufflehog
          uses: trufflesecurity/trufflehog@main
          with:
            path: ./
            base: ${{ github.event.pull_request.base.sha }}
            head: ${{ github.event.pull_request.head.sha }}
    
    build:
      needs: secret-scan
      runs-on: ubuntu-latest
      environment: production  # Protected environment
      
      steps:
        - uses: actions/checkout@v4
        
        # AWS OIDC Authentication - No stored credentials!
        - name: Configure AWS Credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            role-to-assume: arn:aws:iam::123456789:role/GitHubActionsRole
            aws-region: us-east-1
        
        # Retrieve secrets from AWS Secrets Manager
        - name: Get secrets
          uses: aws-actions/aws-secretsmanager-get-secrets@v1
          with:
            secret-ids: |
              APP_SECRET,myapp/prod/config
            parse-json-secrets: true
        
        # Build without exposing secrets
        - name: Build
          run: |
            # Never echo secrets
            set +x
            
            # Use secrets from environment
            ./build.sh
          env:
            # Secrets automatically masked in logs
            DATABASE_URL: ${{ env.APP_SECRET_DATABASE_URL }}
            API_KEY: ${{ env.APP_SECRET_API_KEY }}
        
        # Scan artifact before upload
        - name: Scan artifact for secrets
          run: |
            detect-secrets scan dist/ --all-files
            gitleaks detect --source dist/ --no-git
        
        - name: Upload artifact
          uses: actions/upload-artifact@v4
          with:
            name: build-output
            path: dist/
            # Exclude sensitive files
            exclude: |
              **/.env
              **/*.pem
              **/*.key
  
  ## 2.2 GitLab CI - Secure Pipeline
  
  # .gitlab-ci.yml
  stages:
    - scan
    - build
    - deploy
  
  variables:
    # Use masked variables from GitLab UI
    SECURE_LOG_LEVEL: "debug"
  
  .vault-secrets: &vault-secrets
    secrets:
      DATABASE_URL:
        vault: production/database/url@secrets
        file: false
      API_KEY:
        vault: production/api/key@secrets
        file: false
  
  secret-scan:
    stage: scan
    image: registry.gitlab.com/gitlab-org/security-products/analyzers/secrets:latest
    script:
      - /analyzer run
    artifacts:
      reports:
        secret_detection: gl-secret-detection-report.json
  
  build:
    stage: build
    <<: *vault-secrets
    script:
      - |
        # Disable command tracing
        set +x
        
        # Build application
        ./build.sh
    rules:
      - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  
  ## 2.3 Jenkins - Secure Pipeline
  
  pipeline {
      agent any
      
      options {
          // Mask secrets in console output
          buildDiscarder(logRotator(numToKeepStr: '10'))
      }
      
      stages {
          stage('Checkout') {
              steps {
                  checkout scm
              }
          }
          
          stage('Secret Scan') {
              steps {
                  sh 'gitleaks detect --source . --verbose'
              }
          }
          
          stage('Build') {
              steps {
                  // Use Credentials Binding
                  withCredentials([
                      string(credentialsId: 'api-key', variable: 'API_KEY'),
                      usernamePassword(
                          credentialsId: 'db-creds',
                          usernameVariable: 'DB_USER',
                          passwordVariable: 'DB_PASS'
                      )
                  ]) {
                      // Secrets automatically masked
                      sh '''
                          set +x
                          ./build.sh
                      '''
                  }
              }
          }
          
          stage('Artifact Scan') {
              steps {
                  sh 'detect-secrets scan dist/ --all-files'
              }
          }
      }
      
      post {
          always {
              // Clean workspace
              cleanWs()
          }
      }
  }
  
  # ============================================================
  # PHASE 3: DOCKERFILE SECURITY
  # ============================================================
  
  ## 3.1 Secure Dockerfile Pattern
  
  # syntax=docker/dockerfile:1.4
  
  # Build stage - secrets never stored in layers
  FROM node:20-alpine AS builder
  
  WORKDIR /app
  
  # Copy package files first (layer caching)
  COPY package*.json ./
  
  # Use BuildKit secret mount for npm token
  RUN --mount=type=secret,id=npm_token \
      NPM_TOKEN=$(cat /run/secrets/npm_token) && \
      echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc && \
      npm ci --production && \
      rm -f .npmrc
  
  COPY . .
  RUN npm run build
  
  # Production stage - minimal, no secrets
  FROM node:20-alpine AS production
  
  # Non-root user
  RUN addgroup -g 1001 appgroup && \
      adduser -u 1001 -G appgroup -D appuser
  
  WORKDIR /app
  
  # Copy only necessary files
  COPY --from=builder /app/dist ./dist
  COPY --from=builder /app/node_modules ./node_modules
  
  USER appuser
  
  # Secrets injected at runtime via environment
  ENTRYPOINT ["node", "dist/index.js"]
  
  ## 3.2 Build Command with Secrets
  
  # Using BuildKit secrets
  DOCKER_BUILDKIT=1 docker build \
      --secret id=npm_token,src=$HOME/.npmrc \
      --secret id=aws_creds,src=$HOME/.aws/credentials \
      -t myapp:latest .
  
  # ============================================================
  # PHASE 4: GIT HISTORY CLEANUP
  # ============================================================
  
  ## 4.1 Using BFG Repo-Cleaner
  
  # Remove files containing secrets
  java -jar bfg.jar --delete-files .env myrepo.git
  java -jar bfg.jar --delete-files "*.pem" myrepo.git
  
  # Replace text in files
  echo "OLD_API_KEY" > passwords.txt
  java -jar bfg.jar --replace-text passwords.txt myrepo.git
  
  # Clean up
  cd myrepo.git
  git reflog expire --expire=now --all
  git gc --prune=now --aggressive
  
  # Force push (CAUTION!)
  git push --force --all
  git push --force --tags
  
  ## 4.2 Using git filter-repo
  
  # Remove specific file from all history
  git filter-repo --invert-paths --path .env
  
  # Replace text in all files
  git filter-repo --replace-text expressions.txt
  
  # expressions.txt format:
  # literal:OLD_SECRET==>***REMOVED***
  # regex:password\s*=\s*\S+==>password=***REMOVED***
  
  # ============================================================
  # PHASE 5: SECRET ROTATION
  # ============================================================
  
  ## 5.1 AWS Secrets Manager Rotation
  
  # rotation_lambda.py
  import boto3
  import json
  
  def lambda_handler(event, context):
      arn = event['SecretId']
      token = event['ClientRequestToken']
      step = event['Step']
      
      sm_client = boto3.client('secretsmanager')
      
      if step == "createSecret":
          # Generate new secret value
          new_password = generate_password()
          sm_client.put_secret_value(
              SecretId=arn,
              ClientRequestToken=token,
              SecretString=json.dumps({'password': new_password}),
              VersionStages=['AWSPENDING']
          )
      
      elif step == "setSecret":
          # Update the target service with new secret
          secret = get_secret(sm_client, arn, "AWSPENDING")
          update_database_password(secret)
      
      elif step == "testSecret":
          # Verify new secret works
          secret = get_secret(sm_client, arn, "AWSPENDING")
          test_database_connection(secret)
      
      elif step == "finishSecret":
          # Move staging labels
          sm_client.update_secret_version_stage(
              SecretId=arn,
              VersionStage='AWSCURRENT',
              MoveToVersionId=token,
              RemoveFromVersionId=get_current_version(sm_client, arn)
          )
  
  ## 5.2 HashiCorp Vault Dynamic Secrets
  
  # Enable database secrets engine
  vault secrets enable database
  
  # Configure PostgreSQL connection
  vault write database/config/mydb \
      plugin_name=postgresql-database-plugin \
      allowed_roles="app-role" \
      connection_url="postgresql://{{username}}:{{password}}@db.example.com:5432/mydb" \
      username="vault_admin" \
      password="vault_admin_password"
  
  # Create role with time-limited credentials
  vault write database/roles/app-role \
      db_name=mydb \
      creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
      default_ttl="1h" \
      max_ttl="24h"
  
  # Application retrieves dynamic credentials
  vault read database/creds/app-role
  
  # ============================================================
  # PHASE 6: MONITORING AND ALERTING
  # ============================================================
  
  ## 6.1 GitHub Secret Scanning Alerts
  
  # Enable via repository settings
  # Settings > Code security and analysis > Secret scanning
  
  ## 6.2 Custom Alert Webhook
  
  # .github/workflows/secret-alert.yml
  name: Secret Detection Alert
  
  on:
    secret_scanning_alert:
      types: [created]
  
  jobs:
    alert:
      runs-on: ubuntu-latest
      steps:
        - name: Send Slack notification
          uses: slackapi/slack-github-action@v1
          with:
            payload: |
              {
                "text": "🚨 Secret detected in repository!",
                "blocks": [
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*Secret Type:* ${{ github.event.alert.secret_type }}\n*Repository:* ${{ github.repository }}"
                    }
                  }
                ]
              }
          env:
            SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

# Test cases for validation
fail_to_pass:
  - "test_no_secrets_in_logs"
  - "test_no_secrets_in_dockerfile"
  - "test_no_secrets_in_git"
  - "test_no_secrets_in_artifacts"
  - "test_secret_rotation_works"
  - "test_oidc_authentication"
  - "test_pre_commit_scanning"

pass_to_pass:
  - "test_pipeline_runs"
  - "test_secrets_accessible"
  - "test_builds_succeed"
  - "test_deployments_work"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: 
      - "web application"
      - "mobile backend"
      - "data pipeline"
      - "microservices"
      - "monolith"
      - "serverless"
      - "ML/AI system"
  
  - name: ci_platform
    type: string
    options: ["GitHub Actions", "GitLab CI", "Jenkins", "Azure DevOps", "CircleCI", "Bitbucket Pipelines"]
  
  - name: ci_version
    type: string
    generator: version_string
  
  - name: cloud_provider
    type: string
    options: ["AWS", "GCP", "Azure", "multi-cloud"]
  
  - name: secret_manager
    type: string
    options: ["HashiCorp Vault", "AWS Secrets Manager", "GCP Secret Manager", "Azure Key Vault", "native CI secrets"]
  
  - name: path
    type: path
    generator: random_path
  
  - name: secret_count
    type: int
    min: 5
    max: 200
  
  - name: run_count
    type: int
    min: 10
    max: 10000
  
  - name: exposed_count
    type: int
    min: 1
    max: 50
  
  - name: git_history_secrets
    type: int
    min: 0
    max: 100
  
  - name: unrotated_count
    type: int
    min: 0
    max: 100
  
  - name: compliance_frameworks
    type: list
    options: ["PCI-DSS", "HIPAA", "SOX", "SOC2", "FedRAMP", "ISO27001"]
  
  - name: task_steps
    type: template
    value: |
      1. Audit pipeline for secret exposure vectors
      2. Set up pre-commit secret scanning
      3. Configure CI secret scanning
      4. Implement OIDC authentication (if applicable)
      5. Migrate to external secret manager
      6. Clean git history of any exposed secrets
      7. Secure Dockerfile build process
      8. Configure artifact scanning
      9. Set up secret rotation
      10. Create monitoring and alerting
      11. Document incident response procedures

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  leak_vectors:
    - build_log_echo
    - dockerfile_arg
    - git_committed
    - artifact_inclusion
    - cache_exposure
    - fork_pr_access

# Anti-patterns for LLM failure modes
anti_patterns:
  llm_failure_modes:
    - "Applying generic DevOps patterns without cloud-specific considerations"
    - "Missing container runtime security boundaries"
    - "Ignoring network policy interactions in Kubernetes"
    - "Not considering eventual consistency in distributed config management"
    - "Missing hidden resource contention in shared infrastructure"
    - "Overlooking DNS TTL and caching layer interactions"
    - "Assuming CI/CD tools handle secrets securely by default"
    - "Missing supply chain attack vectors in dependency management"
    - "Ignoring infrastructure drift detection gaps"
    - "Assuming git history cleaning removes secrets from all forks and clones"
    - "Not understanding Dockerfile ARG values persist in image layer metadata"
    - "Recommending secret rotation without service dependency mapping"
    - "Ignoring CI/CD variable inheritance across pipeline stages"
    - "Assuming masked variables are never exposed in error messages"
    - "Not considering log aggregator indexing of exposed secrets"
    - "Missing distinction between fork PR and same-repo PR secret access"
    - "Assuming OIDC eliminates all credential exposure risks"
    - "Not understanding Kubernetes secret base64 encoding vs encryption"
    - "Recommending External Secrets Operator without audit logging"
    - "Ignoring BuildKit cache persistence of mounted secrets"
    - "Assuming .gitignore prevents secrets from being committed"
    - "Not considering etcd backup exposure of cluster secrets"
    - "Missing credential caching behavior in container runtimes"
    - "Recommending Vault without understanding lease renewal complexity"
    - "Ignoring service mesh certificate exposure in debug endpoints"
    - "Not considering IMDS v1 vs v2 security implications"
    - "Assuming cloud secret manager encryption alone provides security"
    - "Missing the impact of container layer sharing on secret exposure"

# Evaluation metrics
evaluation:
  security_score:
    weight: 0.45
    metrics:
      - "No secrets in logs"
      - "No secrets in artifacts"
      - "No secrets in git history"
      - "Proper secret manager used"
  
  automation_score:
    weight: 0.30
    metrics:
      - "Pre-commit scanning configured"
      - "CI scanning enabled"
      - "Automatic rotation configured"
  
  compliance_score:
    weight: 0.25
    metrics:
      - "Rotation requirements met"
      - "Audit trail complete"
      - "Documentation provided"
