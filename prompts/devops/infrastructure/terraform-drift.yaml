id: "devops-infra-terraform-drift-001"
version: "2.0.0"
category: "devops"
subcategory: "infrastructure"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research obscure IaC drift scenarios and state management edge cases"
    phase_2_creation: "Create complex multi-environment infrastructure with subtle drift patterns"
    phase_3_amplification: "Add cascading infrastructure failure scenarios with remediation requirements"
    phase_4_verification: "Validate task requires production-level IaC and GitOps expertise"
  
  complexity_targets:
    minimum_unique_tasks: 10000
    difficulty_range: ["medium", "hard", "expert", "nightmare"]
    domain_expertise_required: ["infrastructure_as_code", "cloud_architecture", "gitops", "state_management"]
  
  task_generation_rules:
    - "Combine 3+ drift causes per task"
    - "Include real infrastructure incident references"
    - "Require multi-cloud/multi-region scenarios"
    - "Add compliance and audit requirements"
    - "Include disaster recovery components"
  
  phase_4_verification:
    requirements:
      - "Has at least 5 interacting hidden traps"
      - "Has cascading failures across infrastructure layers (network, compute, storage)"
      - "Requires knowledge of cloud provider internals and Kubernetes scheduler"
      - "Would take experienced SREs 30+ minutes"

# SWE-bench_Pro style fields
problem_statement: |
  Infrastructure managed by Terraform has configuration drift:
  
  1. Manual changes made outside Terraform
  2. State file out of sync with reality
  3. Resources modified by other automation
  4. Import of existing resources incomplete
  5. Module version changes cause unexpected diffs
  6. Provider version upgrades alter behavior
  7. Parallel apply causing state conflicts
  8. State file corruption or loss
  9. Secret rotation not reflected in state
  10. Cross-workspace dependencies broken

requirements: |
  - Detect and report drift
  - Prevent manual changes
  - Implement state locking
  - Handle import properly
  - Version pin modules and providers
  - Implement GitOps workflow
  - Set up continuous drift detection
  - Configure proper state management
  - Implement change approval process
  - Document remediation procedures

interface: |
  Input: Terraform configuration and state
  Output: Drift detection and remediation plan
  Validation: State matches reality, no drift, GitOps compliant

# === COMPREHENSIVE TOPIC UNIVERSE ===
# 100+ detailed topics for Terraform drift scenarios
topic_universe:
  # Terraform State Management (30 topics)
  state_management:
    state_fundamentals:
      - state_file_structure: |
          Terraform state file anatomy:
          - Version and terraform_version
          - Serial number (monotonic)
          - Lineage (unique identifier)
          - Resources array
          - Each resource:
            - mode (managed/data)
            - type (aws_instance, etc.)
            - name
            - provider
            - instances with attributes
          
          State operations:
          - terraform state list
          - terraform state show
          - terraform state mv
          - terraform state rm
          - terraform state pull/push
      
      - state_locking: |
          State locking mechanisms:
          - DynamoDB locking (AWS)
          - GCS object locking (GCP)
          - Azure Blob leasing
          - Consul locking
          - PostgreSQL advisory locks
          
          Lock issues:
          - Stale lock from crashed apply
          - Lock timeout configuration
          - Force unlock (terraform force-unlock)
          - Concurrent applies
      
      - remote_state_backends: |
          Backend configurations:
          
          S3 backend:
          terraform {
            backend "s3" {
              bucket         = "terraform-state"
              key            = "prod/terraform.tfstate"
              region         = "us-east-1"
              encrypt        = true
              dynamodb_table = "terraform-locks"
              kms_key_id     = "alias/terraform"
            }
          }
          
          GCS backend:
          terraform {
            backend "gcs" {
              bucket = "terraform-state"
              prefix = "prod"
            }
          }
          
          Azure backend:
          terraform {
            backend "azurerm" {
              resource_group_name  = "tfstate"
              storage_account_name = "tfstate12345"
              container_name       = "tfstate"
              key                  = "prod.terraform.tfstate"
            }
          }
      
      - state_encryption: |
          State encryption strategies:
          - Server-side encryption (S3 SSE-KMS)
          - Client-side encryption (SOPS)
          - Vault transit encryption
          - Age encryption
          
          Sensitive data in state:
          - Database passwords
          - API keys
          - Private keys
          - Connection strings
          
          Mitigation:
          - sensitive = true attribute
          - External secret management
          - Encrypted backend
    
    state_operations:
      - state_migration: |
          State backend migration:
          - terraform init -migrate-state
          - Backend configuration changes
          - Workspace migration
          - State file versioning
          
          Migration steps:
          1. Backup current state
          2. Update backend configuration
          3. Run terraform init -migrate-state
          4. Verify state integrity
          5. Test with terraform plan
      
      - state_import: |
          Resource import strategies:
          
          Traditional import:
          terraform import aws_instance.example i-1234567890abcdef0
          
          Import block (Terraform 1.5+):
          import {
            to = aws_instance.example
            id = "i-1234567890abcdef0"
          }
          
          Generate configuration:
          terraform plan -generate-config-out=generated.tf
          
          Common issues:
          - Missing attributes after import
          - Provider-specific ID formats
          - Nested resource imports
          - Count/for_each imports
      
      - state_manipulation: |
          Advanced state operations:
          
          Move resources:
          terraform state mv aws_instance.old aws_instance.new
          terraform state mv module.old module.new
          
          Remove from state (keep resource):
          terraform state rm aws_instance.example
          
          Rename in configuration:
          moved {
            from = aws_instance.old
            to   = aws_instance.new
          }
      
      - state_recovery: |
          State recovery procedures:
          - Restore from versioned backend
          - S3 versioning recovery
          - GCS object versioning
          - terraform state pull backup
          
          State reconstruction:
          - Import all resources
          - terraform refresh
          - Manual state editing (risky)
    
    state_conflicts:
      - concurrent_modifications: |
          Parallel apply issues:
          - Two users applying simultaneously
          - CI/CD race conditions
          - Workspace conflicts
          
          Prevention:
          - Strong state locking
          - Single-threaded CI/CD
          - Lock timeout configuration
          - Automated conflict detection
      
      - state_serial_conflicts: |
          Serial number issues:
          - State serial mismatch
          - Outdated local state
          - Backend synchronization
          
          Resolution:
          - terraform state pull
          - Resolve conflicts manually
          - Determine authoritative state

  # Drift Detection and Prevention (25 topics)
  drift_detection:
    drift_sources:
      - manual_console_changes: |
          Console/portal modifications:
          - Security group rule changes
          - Instance type modifications
          - Tag additions/removals
          - Network configuration changes
          
          Detection:
          - terraform plan shows changes
          - CloudTrail/Activity Log audit
          - Config rules violations
          
          Prevention:
          - IAM policies restricting console
          - Service Control Policies (SCPs)
          - Azure Policy
          - GCP Organization Policies
      
      - other_automation: |
          Non-Terraform automation drift:
          - AWS Lambda modifying resources
          - Auto-scaling changes
          - Kubernetes operators
          - Ansible/Chef/Puppet
          - CloudFormation mixed use
          
          Coordination:
          - Clear ownership boundaries
          - Ignore lifecycle for dynamic resources
          - External data sources
      
      - provider_drift: |
          Provider-induced drift:
          - Default value changes in provider
          - New required attributes
          - Deprecated attribute removal
          - API behavior changes
          
          Prevention:
          - Pin provider versions
          - Review provider changelogs
          - Test upgrades in staging
      
      - external_dependencies: |
          External system changes:
          - DNS changes affecting resources
          - Certificate renewals
          - Secret rotation
          - License key updates
          
          Handling:
          - External data sources
          - Ignore lifecycle
          - Dynamic providers
    
    drift_detection_tools:
      - terraform_plan: |
          Native drift detection:
          
          # Basic drift check
          terraform plan -detailed-exitcode
          # Exit codes: 0=no changes, 1=error, 2=changes
          
          # JSON output for parsing
          terraform plan -json -out=plan.json
          
          # Refresh-only mode
          terraform apply -refresh-only
      
      - driftctl: |
          Driftctl scanning:
          
          # Scan AWS resources
          driftctl scan
          
          # Output formats
          driftctl scan --output json://drift.json
          driftctl scan --output html://drift.html
          
          # Filter by resource type
          driftctl scan --filter "Type=='aws_s3_bucket'"
          
          # Coverage report
          driftctl scan --output coverage://coverage.json
      
      - terraform_cloud_drift: |
          Terraform Cloud drift detection:
          - Automatic drift detection
          - Health assessments
          - Notification integration
          - Scheduled checks
          
          Configuration:
          - Enable drift detection in workspace
          - Configure notification triggers
          - Set assessment schedules
      
      - custom_drift_detection: |
          Custom drift detection scripts:
          
          #!/bin/bash
          # drift-check.sh
          
          terraform init -backend=true
          terraform plan -detailed-exitcode -out=plan.tfplan
          EXIT_CODE=$?
          
          if [ $EXIT_CODE -eq 2 ]; then
              echo "DRIFT DETECTED"
              terraform show -json plan.tfplan > drift.json
              # Send alert
              curl -X POST $SLACK_WEBHOOK \
                -d '{"text":"Terraform drift detected in production!"}'
          fi
    
    drift_prevention:
      - iam_restrictions: |
          AWS IAM for Terraform-only changes:
          
          # Deny manual changes SCP
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "DenyManualChanges",
                "Effect": "Deny",
                "Action": "*",
                "Resource": "*",
                "Condition": {
                  "StringNotLike": {
                    "aws:PrincipalArn": [
                      "arn:aws:iam::*:role/TerraformRole",
                      "arn:aws:iam::*:role/Admin*"
                    ]
                  },
                  "ForAllValues:StringNotEquals": {
                    "aws:CalledVia": ["cloudformation.amazonaws.com"]
                  }
                }
              }
            ]
          }
      
      - resource_tagging: |
          Tag-based drift identification:
          
          # Required tags for all resources
          locals {
            common_tags = {
              ManagedBy     = "Terraform"
              Workspace     = terraform.workspace
              Module        = path.module
              LastModified  = timestamp()
              Repository    = var.repository
            }
          }
          
          # AWS Config rule for tag compliance
          resource "aws_config_config_rule" "terraform_managed" {
            name = "terraform-managed-resources"
            source {
              owner             = "AWS"
              source_identifier = "REQUIRED_TAGS"
            }
            input_parameters = jsonencode({
              tag1Key = "ManagedBy"
              tag1Value = "Terraform"
            })
          }
      
      - lifecycle_management: |
          Terraform lifecycle rules:
          
          resource "aws_instance" "example" {
            # ... configuration
            
            lifecycle {
              # Ignore changes made outside Terraform
              ignore_changes = [
                tags["LastUpdated"],
                user_data,  # If managed externally
              ]
              
              # Prevent destruction
              prevent_destroy = true
              
              # Create before destroy
              create_before_destroy = true
            }
          }

  # Module and Provider Management (20 topics)
  module_provider_management:
    module_versioning:
      - module_version_pinning: |
          Module version constraints:
          
          # Exact version (recommended for production)
          module "vpc" {
            source  = "terraform-aws-modules/vpc/aws"
            version = "5.1.2"
          }
          
          # Version constraints
          version = "~> 5.1"    # >= 5.1.0, < 5.2.0
          version = ">= 5.0"    # >= 5.0.0
          version = ">= 5.0, < 6.0"  # Range
          
          # Private registry
          module "internal" {
            source  = "app.terraform.io/myorg/vpc/aws"
            version = "1.0.0"
          }
          
          # Git with tag
          module "vpc" {
            source = "git::https://github.com/org/module.git?ref=v1.0.0"
          }
      
      - module_upgrade_process: |
          Safe module upgrade workflow:
          
          1. Review changelog for breaking changes
          2. Update version in non-production
          3. Run terraform plan
          4. Review all changes carefully
          5. Apply in staging
          6. Validate functionality
          7. Promote to production
          8. Monitor for issues
          
          Automation:
          - Dependabot for Terraform
          - Renovate bot configuration
          - Automated testing
      
      - module_composition: |
          Module composition patterns:
          
          # Root module structure
          modules/
            vpc/
            eks/
            rds/
          environments/
            dev/
              main.tf
              variables.tf
            staging/
            prod/
          
          # Composition in root
          module "vpc" {
            source = "../../modules/vpc"
            # ...
          }
          
          module "eks" {
            source = "../../modules/eks"
            vpc_id = module.vpc.vpc_id
            # ...
          }
    
    provider_versioning:
      - provider_version_pinning: |
          Provider version constraints:
          
          terraform {
            required_version = ">= 1.5.0"
            
            required_providers {
              aws = {
                source  = "hashicorp/aws"
                version = "~> 5.0"
              }
              kubernetes = {
                source  = "hashicorp/kubernetes"
                version = "~> 2.23"
              }
            }
          }
          
          # Lock file
          # .terraform.lock.hcl - COMMIT THIS FILE
          # Contains exact provider versions and hashes
      
      - provider_upgrade_process: |
          Provider upgrade workflow:
          
          # Update lock file
          terraform init -upgrade
          
          # Review changes
          terraform plan
          
          # Check for deprecations
          TF_LOG=WARN terraform plan 2>&1 | grep -i deprecat
          
          # Update configuration for breaking changes
          # Apply in order: dev -> staging -> prod
      
      - multi_provider_config: |
          Multiple provider configurations:
          
          # Default provider
          provider "aws" {
            region = "us-east-1"
          }
          
          # Aliased provider for different region
          provider "aws" {
            alias  = "west"
            region = "us-west-2"
          }
          
          # Use aliased provider
          resource "aws_instance" "west" {
            provider = aws.west
            # ...
          }
          
          # Module provider passing
          module "west_vpc" {
            source = "./modules/vpc"
            providers = {
              aws = aws.west
            }
          }

  # GitOps and Workflow (20 topics)
  gitops_workflow:
    pipeline_patterns:
      - github_actions_terraform: |
          GitHub Actions workflow:
          
          name: Terraform
          
          on:
            push:
              branches: [main]
            pull_request:
              branches: [main]
          
          permissions:
            id-token: write
            contents: read
            pull-requests: write
          
          jobs:
            plan:
              runs-on: ubuntu-latest
              steps:
                - uses: actions/checkout@v4
                
                - uses: hashicorp/setup-terraform@v3
                  with:
                    terraform_version: 1.6.0
                    cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
                
                - name: Terraform Init
                  run: terraform init
                
                - name: Terraform Format Check
                  run: terraform fmt -check
                
                - name: Terraform Validate
                  run: terraform validate
                
                - name: Terraform Plan
                  id: plan
                  run: terraform plan -no-color
                  continue-on-error: true
                
                - name: Comment Plan on PR
                  uses: actions/github-script@v7
                  if: github.event_name == 'pull_request'
                  with:
                    script: |
                      const output = `#### Terraform Plan
                      \`\`\`
                      ${{ steps.plan.outputs.stdout }}
                      \`\`\`
                      `;
                      github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: output
                      })
            
            apply:
              needs: plan
              runs-on: ubuntu-latest
              if: github.ref == 'refs/heads/main' && github.event_name == 'push'
              environment: production
              steps:
                - uses: actions/checkout@v4
                - uses: hashicorp/setup-terraform@v3
                - run: terraform init
                - run: terraform apply -auto-approve
      
      - atlantis_workflow: |
          Atlantis configuration:
          
          # atlantis.yaml
          version: 3
          automerge: false
          delete_source_branch_on_merge: true
          parallel_plan: true
          parallel_apply: true
          
          projects:
            - name: production
              dir: environments/prod
              workspace: default
              terraform_version: v1.6.0
              autoplan:
                when_modified: ["*.tf", "../modules/**/*.tf"]
                enabled: true
              apply_requirements: [approved, mergeable]
              workflow: production
          
          workflows:
            production:
              plan:
                steps:
                  - init
                  - plan:
                      extra_args: ["-var-file", "prod.tfvars"]
              apply:
                steps:
                  - apply
      
      - terraform_cloud_workflow: |
          Terraform Cloud configuration:
          
          # Backend configuration
          terraform {
            cloud {
              organization = "my-org"
              workspaces {
                name = "my-workspace"
              }
            }
          }
          
          # Workspace settings:
          - Execution Mode: Remote
          - Apply Method: Manual/Auto
          - VCS Connection: GitHub/GitLab
          - Run Triggers: workspace dependencies
          - Variable Sets: shared variables
    
    approval_workflows:
      - manual_approval: |
          Approval gates:
          
          GitHub Environments:
          - Required reviewers
          - Wait timer
          - Deployment branches
          
          Terraform Cloud:
          - Sentinel policies
          - Cost estimation
          - Run tasks
          
          Atlantis:
          - apply_requirements: [approved]
          - GitHub CODEOWNERS
      
      - policy_as_code: |
          Sentinel policies (Terraform Cloud):
          
          # require-tags.sentinel
          import "tfplan/v2" as tfplan
          
          required_tags = ["Environment", "Owner", "ManagedBy"]
          
          all_resources = filter tfplan.resource_changes as _, rc {
            rc.mode is "managed" and
            (rc.change.actions contains "create" or
             rc.change.actions contains "update")
          }
          
          tags_validated = rule {
            all all_resources as _, resource {
              all required_tags as tag {
                resource.change.after.tags contains tag
              }
            }
          }
          
          main = rule {
            tags_validated
          }
          
          # OPA/Conftest alternative
          # policy/terraform.rego
          package terraform
          
          deny[msg] {
            resource := input.resource_changes[_]
            resource.type == "aws_instance"
            not resource.change.after.tags.Environment
            msg := sprintf("Instance %s missing Environment tag", [resource.address])
          }

  # Multi-Cloud and Enterprise (15 topics)
  enterprise_patterns:
    multi_account:
      - aws_multi_account: |
          AWS multi-account pattern:
          
          # Assume role in target account
          provider "aws" {
            alias  = "workload"
            region = var.region
            
            assume_role {
              role_arn     = "arn:aws:iam::${var.account_id}:role/TerraformRole"
              session_name = "terraform-${terraform.workspace}"
              external_id  = var.external_id
            }
          }
          
          # Account factory pattern
          module "account" {
            source = "./modules/account"
            
            for_each = var.accounts
            
            providers = {
              aws = aws.workload
            }
            
            account_name = each.key
            account_email = each.value.email
          }
      
      - cross_account_state: |
          Cross-account state access:
          
          # State in central account
          terraform {
            backend "s3" {
              bucket         = "central-terraform-state"
              key            = "workloads/${var.account_id}/terraform.tfstate"
              region         = "us-east-1"
              role_arn       = "arn:aws:iam::CENTRAL:role/TerraformStateAccess"
              dynamodb_table = "terraform-locks"
            }
          }
          
          # Remote state data source
          data "terraform_remote_state" "network" {
            backend = "s3"
            config = {
              bucket   = "central-terraform-state"
              key      = "network/terraform.tfstate"
              region   = "us-east-1"
              role_arn = "arn:aws:iam::CENTRAL:role/TerraformStateAccess"
            }
          }
    
    workspace_strategies:
      - workspace_per_environment: |
          Environment workspaces:
          
          # Select workspace
          terraform workspace select prod
          
          # Environment-specific variables
          variable "environment" {
            default = terraform.workspace
          }
          
          locals {
            env_config = {
              dev = {
                instance_type = "t3.small"
                count         = 1
              }
              staging = {
                instance_type = "t3.medium"
                count         = 2
              }
              prod = {
                instance_type = "t3.large"
                count         = 3
              }
            }
            
            config = local.env_config[terraform.workspace]
          }
          
          resource "aws_instance" "app" {
            count         = local.config.count
            instance_type = local.config.instance_type
          }
      
      - directory_per_environment: |
          Directory structure approach:
          
          environments/
            dev/
              main.tf
              terraform.tfvars
              backend.tf
            staging/
              main.tf
              terraform.tfvars
              backend.tf
            prod/
              main.tf
              terraform.tfvars
              backend.tf
          modules/
            vpc/
            eks/
          
          # Pros:
          - Clear separation
          - Independent state files
          - Different provider versions possible
          
          # Cons:
          - Code duplication
          - Synchronization challenges

# === FAILURE SCENARIOS ===
# 50+ detailed failure scenarios
failure_scenarios:
  state_disasters:
    - scenario: "State file deleted without backup"
      description: |
        1. Engineer accidentally deletes state file
        2. No S3 versioning enabled
        3. Resources exist but state is empty
        4. terraform plan shows all resources to create
        5. Risk of duplicate resources or deletion
      recovery:
        - "Import all resources manually"
        - "Use driftctl to find unmanaged resources"
        - "Reconstruct state from cloud inventory"
      prevention:
        - "Enable S3 versioning"
        - "Enable MFA delete"
        - "Regular state backups"
        - "Terraform Cloud automatic backup"
    
    - scenario: "Corrupted state from interrupted apply"
      description: |
        1. terraform apply running
        2. Network interruption mid-apply
        3. State partially updated
        4. Resource created but not in state
        5. Subsequent plans fail
      recovery:
        - "terraform state rm partial resource"
        - "terraform import orphaned resource"
        - "Manual state file editing"
    
    - scenario: "State lock stuck from crashed process"
      description: |
        1. Apply process crashes
        2. Lock not released
        3. All subsequent operations fail
        4. DynamoDB/GCS lock remains
      recovery:
        - "Verify no apply in progress"
        - "terraform force-unlock LOCK_ID"
        - "Delete DynamoDB item manually"
  
  drift_incidents:
    - scenario: "Security group modified manually during incident"
      description: |
        1. Production incident requires quick fix
        2. Engineer adds SG rule via console
        3. Issue resolved, change not documented
        4. Next terraform apply removes the rule
        5. Production incident recurs
      prevention:
        - "Change management even in incidents"
        - "Terraform-only IAM policies"
        - "Post-incident Terraform updates"
        - "Drift detection alerts"
    
    - scenario: "Auto-scaling changes not reflected"
      description: |
        1. ASG configured with desired_capacity = 3
        2. Auto-scaling policy increases to 10
        3. terraform plan shows reducing to 3
        4. terraform apply causes capacity reduction
        5. Service degradation during peak
      solution: |
        lifecycle {
          ignore_changes = [desired_capacity]
        }
    
    - scenario: "Module upgrade causes drift"
      description: |
        1. Module upgraded from v2 to v3
        2. Default values changed in module
        3. terraform plan shows unexpected changes
        4. Apply causes production impact
      prevention:
        - "Review module changelogs"
        - "Test upgrades in staging"
        - "Pin exact module versions"
  
  workflow_failures:
    - scenario: "Concurrent applies corrupt state"
      description: |
        1. Two CI pipelines trigger simultaneously
        2. Both run terraform apply
        3. State locking fails or bypassed
        4. Resources in inconsistent state
        5. Both applies partially succeed
      prevention:
        - "Strong state locking"
        - "Single-threaded CI for Terraform"
        - "Terraform Cloud run queue"
    
    - scenario: "Secrets exposed in state file"
      description: |
        1. Database password in Terraform config
        2. Password stored in state file plaintext
        3. State file accessed by unauthorized person
        4. Database credentials compromised
      prevention:
        - "Encrypted state backend"
        - "Sensitive attribute marking"
        - "External secret management"
        - "State access audit logging"
  
  compliance_failures:
    - scenario: "Untagged resources fail audit"
      description: |
        1. Compliance requires all resources tagged
        2. Some Terraform resources missing tags
        3. Audit finds non-compliant resources
        4. Remediation required within 30 days
    
    - scenario: "Drift causes compliance violation"
      description: |
        1. S3 bucket encryption required
        2. Manual change disables encryption
        3. Drift not detected
        4. Compliance scan finds violation
        5. Data protection issue reported

# === CLOUD-SPECIFIC ISSUES ===
# 100+ cloud-specific IaC issues
cloud_specific_issues:
  aws:
    state_backend:
      - s3_state_configuration: |
          Secure S3 backend:
          
          terraform {
            backend "s3" {
              bucket         = "my-terraform-state"
              key            = "env/prod/terraform.tfstate"
              region         = "us-east-1"
              encrypt        = true
              kms_key_id     = "alias/terraform-state"
              dynamodb_table = "terraform-state-lock"
              
              # Access logging
              # (configure on S3 bucket)
              
              # Cross-account access
              role_arn       = "arn:aws:iam::ACCOUNT:role/TerraformStateAccess"
            }
          }
          
          # S3 bucket configuration
          resource "aws_s3_bucket" "state" {
            bucket = "my-terraform-state"
            
            versioning {
              enabled = true
            }
            
            server_side_encryption_configuration {
              rule {
                apply_server_side_encryption_by_default {
                  sse_algorithm     = "aws:kms"
                  kms_master_key_id = aws_kms_key.terraform.arn
                }
              }
            }
            
            lifecycle_rule {
              enabled = true
              noncurrent_version_expiration {
                days = 90
              }
            }
          }
          
          resource "aws_s3_bucket_public_access_block" "state" {
            bucket = aws_s3_bucket.state.id
            
            block_public_acls       = true
            block_public_policy     = true
            ignore_public_acls      = true
            restrict_public_buckets = true
          }
    
    drift_prevention:
      - scp_terraform_only: |
          Service Control Policy:
          
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "RequireTerraformRole",
                "Effect": "Deny",
                "Action": [
                  "ec2:*",
                  "rds:*",
                  "s3:*"
                ],
                "Resource": "*",
                "Condition": {
                  "StringNotLike": {
                    "aws:PrincipalArn": [
                      "arn:aws:iam::*:role/TerraformRole",
                      "arn:aws:iam::*:role/aws-reserved/*"
                    ]
                  }
                }
              }
            ]
          }
      
      - config_rules_drift: |
          AWS Config for drift detection:
          
          resource "aws_config_config_rule" "terraform_managed" {
            name = "terraform-managed-check"
            
            source {
              owner             = "CUSTOM_LAMBDA"
              source_identifier = aws_lambda_function.drift_checker.arn
              
              source_detail {
                event_source = "aws.config"
                message_type = "ConfigurationItemChangeNotification"
              }
            }
            
            depends_on = [aws_config_configuration_recorder.main]
          }
  
  gcp:
    state_backend:
      - gcs_state_configuration: |
          GCS backend configuration:
          
          terraform {
            backend "gcs" {
              bucket  = "my-terraform-state"
              prefix  = "env/prod"
            }
          }
          
          # GCS bucket configuration
          resource "google_storage_bucket" "state" {
            name          = "my-terraform-state"
            location      = "US"
            force_destroy = false
            
            versioning {
              enabled = true
            }
            
            encryption {
              default_kms_key_name = google_kms_crypto_key.terraform.id
            }
            
            uniform_bucket_level_access = true
            
            lifecycle_rule {
              action {
                type = "Delete"
              }
              condition {
                num_newer_versions = 10
              }
            }
          }
    
    drift_prevention:
      - org_policy_iac: |
          Organization policies for IaC:
          
          resource "google_organization_policy" "restrict_vm_creation" {
            org_id     = var.org_id
            constraint = "compute.vmCanIpForward"
            
            boolean_policy {
              enforced = true
            }
          }
  
  azure:
    state_backend:
      - azurerm_state_configuration: |
          Azure backend configuration:
          
          terraform {
            backend "azurerm" {
              resource_group_name  = "tfstate"
              storage_account_name = "tfstate12345"
              container_name       = "tfstate"
              key                  = "prod.terraform.tfstate"
              
              use_oidc = true  # For OIDC auth
            }
          }
          
          # Storage account configuration
          resource "azurerm_storage_account" "state" {
            name                     = "tfstate12345"
            resource_group_name      = azurerm_resource_group.state.name
            location                 = azurerm_resource_group.state.location
            account_tier             = "Standard"
            account_replication_type = "GRS"
            
            blob_properties {
              versioning_enabled = true
            }
            
            infrastructure_encryption_enabled = true
          }

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  infrastructure_size:
    description: "Number of managed resources"
    complexity_factor:
      - "< 100 resources: 1.0x"
      - "100-500 resources: 1.5x"
      - "500-2000 resources: 2.0x"
      - "> 2000 resources: 3.0x"
  
  multi_region:
    description: "Number of regions"
    complexity_factor:
      - "1 region: 1.0x"
      - "2-3 regions: 1.5x"
      - "4-6 regions: 2.0x"
      - "> 6 regions: 2.5x"
  
  multi_cloud:
    description: "Number of cloud providers"
    complexity_factor: 2.5
    challenges:
      - "Different provider versions"
      - "State management per cloud"
      - "Unified GitOps workflow"
  
  state_complexity:
    description: "State file size and dependencies"
    complexity_factor:
      - "< 10MB: 1.0x"
      - "10-50MB: 1.5x"
      - "50-200MB: 2.0x"
      - "> 200MB: 3.0x"
  
  compliance:
    sox:
      complexity_factor: 2.0
      requirements:
        - "Change management documentation"
        - "Approval workflows"
        - "Audit trail"
    
    fedramp:
      complexity_factor: 2.5
      requirements:
        - "Configuration management"
        - "Continuous monitoring"
        - "Incident response"

# === terminal-bench style fields ===
difficulty:
  estimated: "hard"
  time_range: [1800, 14400]
  command_steps: [40, 200]

# === Difficulty amplifiers ===
difficulty_amplifiers:
  nightmare:
    multiplier: 3.0
    description: "Production-level incident requiring multi-team coordination knowledge"
    requirements:
      - "7+ interacting failures across CI/CD, containers, and infrastructure"
      - "Requires understanding of cloud provider-specific behaviors"
      - "Time estimate: 120+ minutes for senior SREs"
      - "Cross-service dependencies that cascade in non-obvious ways"
      - "Requires synthesizing security, performance, and reliability knowledge"

# === Quality requirements ===
quality_requirements:
  minimum_difficulty: "90-240 minutes, requires senior SRE/DevSecOps engineers with cloud architecture and IaC expertise"
  time_estimate: "90-240 minutes for senior SRE/DevSecOps engineers, 4-8 hours for intermediate"
  trap_count: "10+ deeply interacting traps across CI/CD, container, cloud, and monitoring boundaries"

# === Multi-Agent Orchestration Complexity ===
multi_agent_orchestration:
  description: "Coordinating 5-8 specialized DevOps agents for comprehensive infrastructure drift management"
  required_agents:
    - terraform_state_expert:
        role: "Deep analysis of Terraform state files, locking, and backend configuration"
        expertise: ["state manipulation", "backend migration", "state recovery", "import operations"]
    - cloud_resource_auditor:
        role: "Auditing actual cloud resources against expected configurations"
        expertise: ["resource inventory", "drift detection", "compliance scanning"]
    - iac_security_specialist:
        role: "Securing Infrastructure as Code workflows and preventing unauthorized changes"
        expertise: ["policy as code", "Sentinel/OPA", "GitOps security"]
    - multi_cloud_architect:
        role: "Managing drift across multiple cloud providers and regions"
        expertise: ["provider configuration", "cross-cloud dependencies", "resource normalization"]
    - gitops_engineer:
        role: "Implementing and troubleshooting GitOps workflows for IaC"
        expertise: ["Atlantis", "Terraform Cloud", "GitHub Actions", "ArgoCD"]
    - compliance_auditor:
        role: "Ensuring infrastructure configurations meet regulatory requirements"
        expertise: ["change management", "audit trails", "compliance frameworks"]
    - incident_responder:
        role: "Managing infrastructure drift incidents and unauthorized changes"
        expertise: ["change investigation", "rollback procedures", "impact assessment"]
    - cost_optimization_specialist:
        role: "Identifying cost implications of drift and configuration changes"
        expertise: ["cost analysis", "right-sizing", "waste detection"]
  
  cross_platform_attack_chains:
    - name: "Console Change to Security Breach"
      stages:
        - "Engineer makes 'emergency' security group change via console"
        - "Change allows unintended network access to database"
        - "Terraform plan doesn't run due to pipeline failure"
        - "Attacker discovers open port via scanning"
        - "Database compromise using exposed access"
        - "Data exfiltration before drift detected"
        - "terraform apply reverts change, destroying evidence"
    - name: "State File Compromise to Infrastructure Takeover"
      stages:
        - "Attacker gains access to state file in S3 bucket"
        - "Extracts sensitive outputs (passwords, keys)"
        - "Uses credentials to access production systems"
        - "Modifies resources directly in cloud console"
        - "Corrupts state file to hide changes"
        - "Subsequent Terraform runs fail with state errors"
  
  parallel_analysis_requirements:
    - "Simultaneous drift detection across all cloud providers and regions"
    - "Correlated analysis of Terraform plans with cloud audit logs"
    - "Real-time monitoring of manual changes via cloud provider events"
    - "Cross-reference of state files with actual resource configurations"
  
  agent_handoff_scenarios:
    - "Resource auditor detects drift → State expert analyzes state integrity → GitOps engineer verifies pipeline status → Incident responder investigates change source"
    - "Multi-cloud architect identifies cross-provider inconsistency → Compliance auditor assesses regulatory impact → Security specialist reviews access patterns"
    - "Cost specialist flags unexpected resources → State expert traces to failed import → GitOps engineer implements proper workflow"

# === Nightmare Plus Difficulty Level ===
difficulty_levels:
  nightmare_plus:
    estimated_time: [28800, 172800]  # 8-48 hours
    command_steps: [400, 1500]
    techniques_required: 12
    description: "Infrastructure as Code crisis requiring deep Terraform internals and multi-cloud architecture expertise"
    characteristics:
      - "State corruption affecting 1000+ resources"
      - "Cross-workspace dependency failures"
      - "Module version drift across environments"
      - "Provider upgrade breaking changes"
      - "Multi-cloud state synchronization issues"
      - "State locking failures during critical changes"
      - "Import operation leaving orphaned resources"
      - "GitOps pipeline race conditions"
    required_expertise:
      - "Deep understanding of Terraform state structure and operations"
      - "Knowledge of cloud provider API behaviors and eventual consistency"
      - "Experience with enterprise IaC patterns and scale"
      - "Familiarity with GitOps workflow implementation"
      - "Understanding of policy as code enforcement"

# === Cloud Native Internals ===
cloud_native_internals:
  kubernetes_internals:
    kubelet:
      - "Terraform kubernetes provider resource reconciliation"
      - "ConfigMap and Secret drift from external modifications"
      - "Custom resource definition state management"
    controller_manager:
      - "Kubernetes controller modifications vs Terraform state"
      - "Admission webhook side effects on Terraform resources"
      - "Operator-managed resources causing drift"
    scheduler:
      - "Node label/taint drift affecting scheduling"
      - "PriorityClass modifications outside Terraform"
    api_server:
      - "RBAC changes causing Terraform permission issues"
      - "API deprecation affecting Terraform providers"
  
  container_runtime_internals:
    containerd:
      - "Container registry configuration drift"
      - "Runtime class modifications"
    cri_o:
      - "CRI-O configuration management via Terraform"
  
  service_mesh_internals:
    envoy:
      - "Service mesh configuration drift"
      - "Certificate rotation causing state inconsistency"
    istio_data_plane:
      - "Istio operator modifications vs Terraform"
      - "VirtualService/Gateway drift"
  
  cloud_provider_iam_quirks:
    aws:
      - "Eventual consistency in IAM causing plan/apply differences"
      - "AWS Organizations SCP interactions with Terraform"
      - "Resource tagging propagation delays"
      - "Cross-account assume role state issues"
      - "AWS Config remediation causing drift"
    gcp:
      - "IAM policy merge behavior vs Terraform authoritative"
      - "Organization policy inheritance"
      - "Cloud Asset Inventory reconciliation"
      - "Shared VPC permission complexities"
    azure:
      - "Azure Policy remediation tasks causing drift"
      - "Managed Identity assignment propagation"
      - "Resource group-level inheritance"
      - "Azure Lighthouse cross-tenant state"

# === Supply Chain Attack Vectors ===
supply_chain_attack_vectors:
  dependency_confusion_variants:
    - malicious_terraform_modules: "Compromised modules from public registries"
    - provider_impersonation: "Fake providers mimicking official ones"
    - module_version_hijacking: "Hijacking semver ranges for malicious updates"
  
  build_process_manipulation:
    - ci_cd_terraform_injection: "Injecting malicious code into Terraform pipelines"
    - state_file_manipulation: "Tampering with state files during pipeline execution"
    - plan_output_spoofing: "Manipulating plan output to hide malicious changes"
    - apply_command_injection: "Injecting commands into terraform apply"
  
  registry_poisoning:
    - module_registry_compromise: "Attacking private Terraform module registries"
    - provider_binary_replacement: "Replacing provider binaries with malicious versions"
    - artifact_signing_bypass: "Bypassing provider signature verification"
  
  artifact_signing_bypass:
    - provider_signature_stripping: "Removing GPG signatures from providers"
    - checksum_manipulation: "Modifying terraform.lock.hcl checksums"
    - trust_store_compromise: "Adding malicious GPG keys to trust stores"

# === Incident Response Complexity ===
incident_response_complexity:
  production_debugging_scenarios:
    - scenario: "State file corruption preventing all infrastructure changes"
      complexity_factors:
        - "Assess which resources are affected"
        - "Determine if corruption is malicious or accidental"
        - "Reconstruct state from cloud provider inventory"
        - "Coordinate freeze on all manual changes"
        - "Validate reconstructed state accuracy"
        - "Resume normal operations safely"
      required_coordination:
        - "Platform team for change freeze"
        - "Security team for compromise assessment"
        - "All application teams for impact communication"
        - "Management for incident status updates"
    
    - scenario: "Terraform apply destroys production resources unexpectedly"
      complexity_factors:
        - "Identify all destroyed resources"
        - "Initiate emergency recovery procedures"
        - "Analyze why plan didn't show destruction"
        - "Restore from backups or recreate resources"
        - "Validate data integrity after recovery"
        - "Implement safeguards to prevent recurrence"
      forensic_requirements:
        - "Terraform plan/apply log analysis"
        - "State file version comparison"
        - "Cloud provider audit log correlation"
        - "Git history review for configuration changes"
    
    - scenario: "Multi-region drift causing inconsistent infrastructure"
      complexity_factors:
        - "Identify drift across all regions"
        - "Determine authoritative configuration source"
        - "Plan synchronized remediation across regions"
        - "Execute changes without service disruption"
        - "Validate consistency post-remediation"

# === LLM trap configurations ===
traps:
  - type: "console_changes"
    description: "Resources modified via AWS/GCP console"
    trigger: "Not preventing console access"
    severity: "high"
  
  - type: "state_corruption"
    description: "State file inconsistent with actual resources"
    trigger: "Not using remote state with locking"
    severity: "critical"
  
  - type: "partial_import"
    description: "Resource imported but attributes missing"
    trigger: "Not verifying import completeness"
    severity: "high"
  
  - type: "module_upgrade"
    description: "Module upgrade changes resource behavior"
    trigger: "Not pinning module versions"
    severity: "high"
  
  - type: "provider_drift"
    description: "Provider upgrade changes defaults"
    trigger: "Not pinning provider versions"
    severity: "medium"
  
  - type: "secret_in_state"
    description: "Sensitive data stored in state plaintext"
    trigger: "Not encrypting state or using sensitive attribute"
    severity: "critical"
  
  - type: "no_locking"
    description: "Concurrent applies possible"
    trigger: "Not configuring state locking"
    severity: "high"

# === Task generation template ===
instruction_template: |
  You are fixing drift in a {{ scenario_type }} Terraform deployment on {{ cloud_provider }}.
  The configuration is at {{ path }}.
  
  Environment Details:
  - Cloud Provider: {{ cloud_provider }}
  - Terraform Version: {{ tf_version }}
  - State Backend: {{ state_backend }}
  - Workspaces: {{ workspace_count }}
  - Resources managed: {{ resource_count }}
  
  Current Issues:
  - Drift detected: {{ drift_count }} resources
  - State conflicts: {{ conflict_count }}
  - Unpinned modules: {{ unpinned_modules }}
  - Unpinned providers: {{ unpinned_providers }}
  
  Compliance Requirements: {{ compliance_frameworks }}
  Change Window: {{ change_window }}
  
  Your task:
  {{ task_steps }}
  
  Deliverables:
  - Drift remediation plan
  - Updated Terraform configuration
  - GitOps workflow implementation
  - Drift detection automation
  - Documentation and runbooks

# === Reference solution (hidden from agent) ===
reference_solution: |
  # Terraform Drift Management - Comprehensive Guide
  
  # ============================================================
  # PHASE 1: DRIFT DETECTION
  # ============================================================
  
  ## 1.1 Basic Drift Check
  
  # Run plan to detect drift
  terraform plan -detailed-exitcode
  # Exit code 2 = drift detected
  
  # JSON output for automation
  terraform plan -json -out=plan.tfplan
  terraform show -json plan.tfplan > plan.json
  
  ## 1.2 Automated Drift Detection (GitHub Actions)
  
  name: Drift Detection
  
  on:
    schedule:
      - cron: '0 */6 * * *'  # Every 6 hours
  
  jobs:
    drift-check:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        
        - uses: hashicorp/setup-terraform@v3
        
        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
            aws-region: us-east-1
        
        - name: Terraform Init
          run: terraform init
        
        - name: Check for Drift
          id: drift
          run: |
            terraform plan -detailed-exitcode -out=plan.tfplan
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 2 ]; then
              echo "drift=true" >> $GITHUB_OUTPUT
            fi
          continue-on-error: true
        
        - name: Generate Drift Report
          if: steps.drift.outputs.drift == 'true'
          run: |
            terraform show -json plan.tfplan > drift-report.json
            terraform show plan.tfplan > drift-report.txt
        
        - name: Upload Drift Report
          if: steps.drift.outputs.drift == 'true'
          uses: actions/upload-artifact@v4
          with:
            name: drift-report
            path: drift-report.*
        
        - name: Alert on Drift
          if: steps.drift.outputs.drift == 'true'
          run: |
            curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
              -H 'Content-type: application/json' \
              -d '{"text":"⚠️ Terraform drift detected in production!"}'
  
  ## 1.3 Driftctl Scanning
  
  # Install driftctl
  curl -L https://github.com/snyk/driftctl/releases/latest/download/driftctl_linux_amd64 -o driftctl
  chmod +x driftctl
  
  # Scan for unmanaged resources
  ./driftctl scan --from tfstate://terraform.tfstate
  
  # Output to JSON
  ./driftctl scan --output json://drift.json
  
  # Filter by resource type
  ./driftctl scan --filter "Type=='aws_instance'"
  
  # ============================================================
  # PHASE 2: DRIFT REMEDIATION
  # ============================================================
  
  ## 2.1 Option A: Update Config to Match Reality
  
  # If drift is intentional/desired state
  # Update Terraform config to match actual infrastructure
  
  ## 2.2 Option B: Apply to Fix Drift
  
  # If config is authoritative
  terraform apply
  
  ## 2.3 Option C: Refresh-Only
  
  # Update state to match reality without changing infrastructure
  terraform apply -refresh-only
  
  ## 2.4 Option D: Import Missing Resources
  
  # Traditional import
  terraform import aws_instance.example i-1234567890abcdef0
  
  # Import block (Terraform 1.5+)
  import {
    to = aws_instance.example
    id = "i-1234567890abcdef0"
  }
  
  # Generate configuration
  terraform plan -generate-config-out=imported.tf
  
  ## 2.5 Handle Ignored Changes
  
  # For expected drift (auto-scaling, etc.)
  resource "aws_autoscaling_group" "app" {
    # ...
    
    lifecycle {
      ignore_changes = [
        desired_capacity,
        target_group_arns,
      ]
    }
  }
  
  # ============================================================
  # PHASE 3: DRIFT PREVENTION
  # ============================================================
  
  ## 3.1 Version Pinning
  
  terraform {
    required_version = "~> 1.6.0"
    
    required_providers {
      aws = {
        source  = "hashicorp/aws"
        version = "~> 5.0"
      }
    }
  }
  
  # Pin modules
  module "vpc" {
    source  = "terraform-aws-modules/vpc/aws"
    version = "5.1.2"  # Exact version
  }
  
  ## 3.2 State Locking
  
  terraform {
    backend "s3" {
      bucket         = "terraform-state"
      key            = "prod/terraform.tfstate"
      region         = "us-east-1"
      encrypt        = true
      dynamodb_table = "terraform-locks"  # CRITICAL
    }
  }
  
  # DynamoDB table for locking
  resource "aws_dynamodb_table" "locks" {
    name         = "terraform-locks"
    billing_mode = "PAY_PER_REQUEST"
    hash_key     = "LockID"
    
    attribute {
      name = "LockID"
      type = "S"
    }
  }
  
  ## 3.3 IAM Restrictions
  
  # Restrict console access
  data "aws_iam_policy_document" "deny_console" {
    statement {
      effect = "Deny"
      actions = [
        "ec2:*",
        "rds:*"
      ]
      resources = ["*"]
      condition {
        test     = "StringNotLike"
        variable = "aws:PrincipalArn"
        values   = ["arn:aws:iam::*:role/TerraformRole"]
      }
    }
  }
  
  ## 3.4 Resource Tagging
  
  locals {
    common_tags = {
      ManagedBy  = "Terraform"
      Workspace  = terraform.workspace
      Repository = var.repository
      Module     = basename(path.module)
    }
  }
  
  # Apply to all resources
  resource "aws_instance" "app" {
    # ...
    tags = merge(local.common_tags, {
      Name = "app-server"
    })
  }

# Test cases for validation
fail_to_pass:
  - "test_no_state_drift"
  - "test_state_locking_enabled"
  - "test_modules_version_pinned"
  - "test_providers_version_pinned"
  - "test_imports_complete"
  - "test_gitops_workflow"
  - "test_drift_detection_automated"

pass_to_pass:
  - "test_terraform_plan_clean"
  - "test_terraform_apply_succeeds"
  - "test_state_backend_accessible"
  - "test_ci_cd_works"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: ["AWS", "GCP", "Azure", "multi-cloud", "hybrid"]
  
  - name: cloud_provider
    type: string
    options: ["AWS", "GCP", "Azure", "multi-cloud"]
  
  - name: tf_version
    type: string
    options: ["1.5", "1.6", "1.7", "1.8"]
  
  - name: state_backend
    type: string
    options: ["S3", "GCS", "Azure Blob", "Terraform Cloud", "Consul"]
  
  - name: path
    type: path
    generator: random_path
  
  - name: workspace_count
    type: int
    min: 1
    max: 20
  
  - name: resource_count
    type: int
    min: 20
    max: 5000
  
  - name: drift_count
    type: int
    min: 1
    max: 100
  
  - name: conflict_count
    type: int
    min: 0
    max: 20
  
  - name: unpinned_modules
    type: int
    min: 0
    max: 50
  
  - name: unpinned_providers
    type: int
    min: 0
    max: 10
  
  - name: compliance_frameworks
    type: list
    options: ["SOX", "FedRAMP", "SOC2", "HIPAA", "ISO27001"]
  
  - name: change_window
    type: string
    options: ["immediate", "next maintenance window", "weekend", "approval required"]
  
  - name: task_steps
    type: template
    value: |
      1. Run drift detection
      2. Identify drift sources
      3. Configure remote state with locking
      4. Pin all module versions
      5. Pin all provider versions
      6. Implement drift prevention (IAM)
      7. Set up GitOps workflow
      8. Configure automated drift detection
      9. Create remediation runbooks
      10. Set up alerting and monitoring
      11. Document change management process

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  drift_causes:
    - manual_console_changes
    - state_file_corruption
    - incomplete_import
    - module_version_changes
    - provider_version_changes
    - concurrent_applies

# Anti-patterns for LLM failure modes
anti_patterns:
  llm_failure_modes:
    - "Applying generic DevOps patterns without cloud-specific considerations"
    - "Missing container runtime security boundaries"
    - "Ignoring network policy interactions in Kubernetes"
    - "Not considering eventual consistency in distributed config management"
    - "Missing hidden resource contention in shared infrastructure"
    - "Overlooking DNS TTL and caching layer interactions"
    - "Assuming CI/CD tools handle secrets securely by default"
    - "Missing supply chain attack vectors in dependency management"
    - "Ignoring infrastructure drift detection gaps"
    - "Assuming terraform import creates complete resource configuration"
    - "Not understanding provider version lock file necessity"
    - "Recommending state rm without understanding orphaned resource implications"
    - "Ignoring terraform refresh behavior changes in newer versions"
    - "Assuming lifecycle ignore_changes prevents all drift"
    - "Not considering eventual consistency when debugging plan differences"
    - "Missing the impact of provider default changes on implicit configurations"
    - "Recommending workspaces without understanding state isolation implications"
    - "Ignoring terraform state mv atomicity limitations"
    - "Assuming remote state data sources are always fresh"
    - "Not understanding module version constraint syntax nuances"
    - "Recommending terraform force-unlock without verifying no apply in progress"
    - "Ignoring the impact of create_before_destroy on dependent resources"
    - "Assuming count and for_each can be interchanged without state implications"
    - "Not considering cloud API rate limiting during large applies"
    - "Missing the security implications of sensitive outputs in state"
    - "Recommending Atlantis without understanding comment security"
    - "Ignoring the impact of provider alias on state structure"
    - "Assuming Terraform Cloud drift detection catches all changes"

# Evaluation metrics
evaluation:
  drift_score:
    weight: 0.40
    metrics:
      - "No drift detected"
      - "Drift detection automated"
      - "Prevention measures in place"
  
  workflow_score:
    weight: 0.35
    metrics:
      - "GitOps implemented"
      - "Approval workflows"
      - "CI/CD pipeline"
  
  compliance_score:
    weight: 0.25
    metrics:
      - "Audit trail complete"
      - "Change management documented"
      - "Versioning enforced"
