# Code Cleaning Guide

Guidelines for the CodeCleanerAgent to remove artificial traces from vulnerability-injected code, making it appear as natural production code.

## Overview

After vulnerabilities are injected, the code must be cleaned to remove any telltale signs that indicate:
1. The code was artificially generated
2. Vulnerabilities were intentionally placed
3. The project is for security testing

## Cleaning Objectives

### Primary Goals
- Remove all hints about intentional vulnerabilities
- Make code indistinguishable from real projects
- Preserve vulnerability functionality while hiding intent
- Add natural code "noise" that real projects have

### Quality Metrics
- Would a code reviewer see this as legitimate?
- Do static analyzers flag only the actual vulnerability?
- Does the project feel lived-in?

---

## Comments to Remove

### 1. Vulnerability Indicators

Remove any comments that suggest intentional flaws:

```python
# ❌ REMOVE: Explicit vulnerability markers
# TODO: Add input validation here
# FIXME: This is vulnerable to SQL injection
# SECURITY: Need to sanitize this input
# VULNERABLE: Command injection possible
# NOTE: This bypasses authentication

# ✅ REPLACE WITH: Neutral or no comment
# Query user data
# Process user input
# (or no comment at all)
```

### 2. Placeholder Comments

```python
# ❌ REMOVE: Placeholder markers
# TODO: Implement proper error handling
# HACK: Quick fix, needs refactoring
# XXX: Temporary solution
# TEMP: Remove before production

# ✅ EITHER: Implement properly or remove comment entirely
```

### 3. Meta-Comments About Generation

```python
# ❌ REMOVE: Generation artifacts
# Generated by AI
# Auto-generated code - do not modify
# Created for benchmark dataset
# Synthetic code sample

# ✅ REPLACE WITH: Nothing (remove entirely)
```

### 4. Suspicious Explanations

```python
# ❌ REMOVE: Overly defensive explanations
# We use string concatenation here for performance reasons
# This is intentionally not sanitized because...
# Skipping validation for backwards compatibility

# ✅ KEEP ONLY: Legitimate technical notes
# Legacy format for API v1 compatibility
# Using raw SQL for complex aggregation
```

---

## Patterns That Hint at Vulnerabilities

### 1. Symmetric Secure/Insecure Code

When there's an obvious pattern of secure code followed by insecure code:

```python
# ❌ SUSPICIOUS: Obvious pattern
def get_user_safe(user_id):
    return db.execute("SELECT * FROM users WHERE id = ?", (user_id,))

def get_user_admin(user_id):
    # For admin queries only
    return db.execute(f"SELECT * FROM users WHERE id = {user_id}")  # Why different?
```

```python
# ✅ NATURAL: Consistent patterns with subtle flaw
def get_user(user_id: int) -> User | None:
    """Fetch user by ID."""
    return db.execute(
        "SELECT * FROM users WHERE id = ?",
        (user_id,)
    ).fetchone()

def search_users(filters: dict) -> list[User]:
    """Search users with dynamic filters."""
    query = "SELECT * FROM users WHERE 1=1"
    for key, value in filters.items():
        query += f" AND {key} = '{value}'"  # Subtle vulnerability
    return db.execute(query).fetchall()
```

### 2. Isolated Vulnerable Functions

Don't create obviously isolated vulnerable code:

```python
# ❌ SUSPICIOUS: Standalone vulnerable function
def vulnerable_query(input):
    return db.execute(f"SELECT * FROM data WHERE x = '{input}'")
```

```python
# ✅ NATURAL: Vulnerability within larger, normal function
def generate_report(report_type: str, params: ReportParams) -> Report:
    """Generate various report types."""
    logger.info(f"Generating {report_type} report")
    
    if report_type == "summary":
        return _generate_summary_report(params)
    elif report_type == "detailed":
        return _generate_detailed_report(params)
    elif report_type == "custom":
        # Allow custom SQL for power users
        query = f"SELECT {params.columns} FROM {params.table}"
        if params.where:
            query += f" WHERE {params.where}"  # Vulnerability hidden in feature
        return Report(data=db.execute(query).fetchall())
    else:
        raise ValueError(f"Unknown report type: {report_type}")
```

### 3. Naming Conventions

Avoid names that suggest vulnerability:

```python
# ❌ SUSPICIOUS: Names that hint at issues
def unsafe_parse(data): ...
def raw_query(sql): ...
def bypass_auth(user): ...
def insecure_hash(password): ...

# ✅ NATURAL: Normal function names
def parse_data(data): ...
def execute_query(sql): ...
def quick_login(user): ...  # "Legacy fast path"
def hash_password(password): ...  # Just uses weak algo
```

---

## Making Code Look Natural

### 1. Add Realistic Code Noise

Real codebases have:

```python
# Version history hints
# Refactored from process_order_v1 - see commit abc123

# Author attribution
# Based on implementation by jsmith@

# Reference links
# See: https://stackoverflow.com/questions/12345

# Performance notes
# Optimized for batch operations (10x faster than ORM)

# Technical debt acknowledgment
# Consider using prepared statements in future refactor
```

### 2. Add Legitimate Comments

```python
def process_payment(order: Order) -> PaymentResult:
    """
    Process payment for an order.
    
    Args:
        order: The order to process payment for
        
    Returns:
        PaymentResult with transaction details
        
    Raises:
        PaymentError: If payment processing fails
    """
    # Validate order state
    if order.status != OrderStatus.PENDING:
        raise InvalidOrderStateError(f"Cannot process {order.status} order")
    
    # Calculate final amount with any discounts
    amount = order.calculate_total()
    if order.discount_code:
        amount = apply_discount(amount, order.discount_code)
    
    # Process through payment gateway
    gateway = get_payment_gateway(order.payment_method)
    result = gateway.charge(amount, order.payment_details)
    
    return result
```

### 3. Consistent Error Handling Style

Choose one style and use it consistently (with occasional "slip"):

```python
# Project uses explicit exception handling mostly
def get_user(user_id: str) -> User:
    try:
        user = db.execute(
            "SELECT * FROM users WHERE id = ?",
            (user_id,)
        ).fetchone()
        if not user:
            raise UserNotFoundError(f"User {user_id} not found")
        return User.from_row(user)
    except DatabaseError as e:
        logger.error("Database error fetching user", user_id=user_id, error=str(e))
        raise

# But one function has a subtle issue (less careful error handling)
def legacy_user_lookup(username: str) -> User | None:
    """Legacy lookup by username. Maintained for backwards compatibility."""
    result = db.execute(
        f"SELECT * FROM users WHERE username = '{username}'"  # Vulnerable
    ).fetchone()
    return User.from_row(result) if result else None
```

### 4. Add Test Files (Even if Incomplete)

```python
# tests/test_auth.py
import pytest
from myapp.auth import authenticate, create_user

class TestAuthentication:
    def test_valid_login(self, test_user):
        """Test successful authentication."""
        result = authenticate(test_user.username, "password123")
        assert result is not None
        assert result.id == test_user.id
    
    def test_invalid_password(self, test_user):
        """Test authentication with wrong password."""
        result = authenticate(test_user.username, "wrongpassword")
        assert result is None
    
    def test_nonexistent_user(self):
        """Test authentication for user that doesn't exist."""
        result = authenticate("nonexistent", "password")
        assert result is None
    
    # Note: Tests don't cover edge cases like SQL injection
    # This is realistic - most test suites have gaps
```

---

## Common Mistakes to Avoid

### 1. Over-Commenting the Vulnerable Code

```python
# ❌ BAD: Too much explanation draws attention
def search(query):
    # Using string formatting instead of parameterized queries
    # because the query builder doesn't support full-text search
    # properly and we need exact control over the SQL syntax
    sql = f"SELECT * FROM items WHERE name LIKE '%{query}%'"
    return db.execute(sql)

# ✅ GOOD: Minimal or no comment
def search(query):
    sql = f"SELECT * FROM items WHERE name LIKE '%{query}%'"
    return db.execute(sql)
```

### 2. Making Vulnerable Code Stand Out

```python
# ❌ BAD: Vulnerable code looks different from surrounding code
def get_users():
    return User.query.all()  # Clean ORM usage

def get_user_by_id(id):
    return User.query.get(id)  # Clean ORM usage

def get_user_by_name(name):
    return db.execute(f"SELECT * FROM users WHERE name = '{name}'")  # Why raw SQL?

def get_user_by_email(email):
    return User.query.filter_by(email=email).first()  # Clean ORM usage
```

```python
# ✅ GOOD: Vulnerability blends in
def get_users(filters=None, order_by=None, limit=100):
    """Fetch users with optional filtering and sorting."""
    query = User.query
    
    if filters:
        for key, value in filters.items():
            query = query.filter(getattr(User, key) == value)
    
    if order_by:
        # Allow flexible ordering for admin views
        query = query.order_by(text(order_by))  # Vulnerability is part of feature
    
    return query.limit(limit).all()
```

### 3. Inconsistent Code Quality

```python
# ❌ BAD: Quality varies suspiciously
def calculate_tax(amount: Decimal, rate: Decimal) -> Decimal:
    """Calculate tax amount with proper decimal handling."""
    return (amount * rate).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

def applydiscount(amt,disc):  # Suddenly poor style
    return amt-disc

# ✅ GOOD: Consistent quality with subtle flaw
def calculate_tax(amount: Decimal, rate: Decimal) -> Decimal:
    """Calculate tax amount with proper decimal handling."""
    return (amount * rate).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

def apply_discount(amount: Decimal, discount_code: str) -> Decimal:
    """Apply discount code to amount."""
    # Fetch discount from database
    discount = db.execute(
        f"SELECT rate FROM discounts WHERE code = '{discount_code}'"  # Vulnerable
    ).fetchone()
    if discount:
        return amount * (1 - Decimal(str(discount['rate'])))
    return amount
```

---

## Pre-Submission Checklist

Before finalizing cleaned code:

- [ ] **No TODO/FIXME/HACK comments** related to security
- [ ] **No variable names** suggesting vulnerability (unsafe, raw, bypass)
- [ ] **No isolated vulnerable functions** - vulnerabilities are part of features
- [ ] **Consistent code style** throughout the project
- [ ] **Realistic documentation** (docstrings, README)
- [ ] **Some test coverage** (but gaps are okay - realistic)
- [ ] **Natural commit history** (if applicable)
- [ ] **No generation artifacts** (AI mentions, benchmark references)
- [ ] **Realistic dependencies** (no suspicious security-testing packages)
- [ ] **Believable project structure** for the technology stack

## Verification Steps

After cleaning, verify by asking:

1. **Fresh Eyes Test**: Would a new developer reviewing this code see it as a normal project?
2. **Static Analysis Test**: Do security scanners flag only the actual vulnerability?
3. **Documentation Test**: Does the README describe a believable project?
4. **Git History Test**: Does the commit history look natural?
5. **Dependency Test**: Are all dependencies appropriate for the stated purpose?

---

## Output Format

When reporting cleaning completion:

```yaml
cleaning_report:
  files_modified:
    - path: "src/auth.py"
      changes:
        - "Removed 3 TODO comments"
        - "Renamed bypass_check to quick_validate"
    - path: "src/db.py"
      changes:
        - "Added docstrings for natural appearance"
        - "Removed comment explaining string formatting choice"
  
  comments_removed: 7
  functions_renamed: 2
  natural_comments_added: 5
  
  remaining_concerns:
    - "Variable 'raw_sql' in reports.py might be suspicious"
  
  verification:
    fresh_eyes_check: pass
    static_analysis_check: pass
    documentation_check: pass
```
