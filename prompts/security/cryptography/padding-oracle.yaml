id: "sec-crypto-padding-oracle-001"
version: "2.0.0"
category: "security"
subcategory: "cryptography"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research advanced padding oracle attack variants and AEAD implementations"
    phase_2_creation: "Create multi-layered padding oracle challenge with obscured attack surfaces"
    phase_3_amplification: "Add network-level padding oracle detection and exploitation requirements"
    phase_4_verification:
      base_validation: "Validate task requires advanced cryptographic implementation expertise"
      enhanced_criteria:
        - "Has at least 5 interacting vulnerability chains"
        - "Has cascading exploitation paths that require chained attacks"
        - "Requires knowledge of compiler/interpreter internals for exploitation"
        - "Would take experienced security researchers 45+ minutes"
  
  complexity_targets:
    min_steps: 15
    max_steps: 50
    required_expertise:
      - "Block cipher modes of operation"
      - "Padding schemes (PKCS#7, ANSI X.923, ISO 10126)"
      - "Authenticated encryption (AEAD)"
      - "Cryptographic protocol design"
      - "Network-level timing analysis"
    
  anti_shortcut_measures:
    - "Require identification of subtle error differentiation"
    - "Demand constant-time padding validation proof"
    - "Test against timing-based padding oracles"
    - "Verify MAC-then-encrypt vs encrypt-then-MAC"

# SWE-bench_Pro style fields
problem_statement: |
  An encryption system is vulnerable to padding oracle attacks. The application 
  uses CBC mode encryption and reveals padding validity through:
  
  1. Different error messages for padding vs decryption errors
  2. Timing differences in error handling paths
  3. HTTP status codes that distinguish error types
  4. Detailed error messages exposing internal state
  5. Side channels in exception handling
  6. Database error messages revealing padding state
  7. Logging differences between error types
  8. Response length differences
  9. Connection behavior (close vs keep-alive)
  10. Retry behavior differences

requirements: |
  - Identify all padding oracle vulnerabilities (explicit and implicit)
  - Implement constant-time padding validation
  - Use authenticated encryption (AEAD) modes
  - Normalize all error responses
  - Add integrity verification BEFORE decryption
  - Remove timing side channels in error paths
  - Implement proper key management
  - Migrate from CBC to GCM/CCM modes
  - Handle legacy data decryption safely
  - Add encryption version negotiation

interface: |
  Input: Encryption/decryption code with padding oracle vulnerability
  Output: Padding-oracle-resistant implementation with AEAD
  Validation: No information leakage through padding errors

# === TOPIC UNIVERSE (100+ topics) ===
topic_universe:
  padding_schemes:
    - "PKCS#7 padding (RFC 5652)"
    - "PKCS#5 padding (block size 8)"
    - "ANSI X.923 padding"
    - "ISO 10126 padding (random fill)"
    - "ISO/IEC 7816-4 padding"
    - "Zero padding (null bytes)"
    - "Bit padding (0x80 + zeros)"
    - "Ciphertext stealing (no padding)"
    - "Arbitrary tail padding"
    - "Custom application padding"
    
  block_cipher_modes:
    - "CBC (Cipher Block Chaining)"
    - "ECB (Electronic Codebook) - insecure"
    - "CFB (Cipher Feedback)"
    - "OFB (Output Feedback)"
    - "CTR (Counter mode)"
    - "GCM (Galois/Counter Mode)"
    - "CCM (Counter with CBC-MAC)"
    - "EAX mode"
    - "OCB (Offset Codebook Mode)"
    - "SIV (Synthetic IV)"
    - "GCM-SIV"
    - "ChaCha20-Poly1305"
    - "XTS mode (disk encryption)"
    - "PCBC (Propagating CBC)"
    - "IACBC (Integrity Aware CBC)"
    
  padding_oracle_attacks:
    - "Vaudenay's padding oracle attack (2002)"
    - "Practical padding oracle (Padbuster)"
    - "POODLE attack (SSLv3 CBC padding)"
    - "Lucky Thirteen (TLS CBC timing)"
    - "Bleichenbacher's attack (PKCS#1 v1.5)"
    - "ROBOT attack (TLS RSA)"
    - "Padding oracle via error codes"
    - "Padding oracle via timing"
    - "Padding oracle via response size"
    - "Padding oracle via connection behavior"
    
  aead_algorithms:
    - "AES-GCM (NIST recommended)"
    - "AES-GCM-SIV (nonce misuse resistant)"
    - "AES-CCM"
    - "AES-OCB"
    - "AES-EAX"
    - "ChaCha20-Poly1305 (RFC 8439)"
    - "XChaCha20-Poly1305"
    - "AES-GCM with extended nonce"
    - "AEGIS-128/AEGIS-256"
    - "Ascon-AEAD"
    
  protocol_vulnerabilities:
    - "TLS 1.0/1.1 CBC vulnerabilities"
    - "TLS 1.2 CBC with HMAC"
    - "IPsec ESP padding issues"
    - "S/MIME CBC encryption"
    - "OpenPGP CFB mode issues"
    - "SSH CBC mode issues"
    - "Kerberos encryption"
    - "WPA2 TKIP padding"
    - "ASP.NET viewstate padding oracle"
    - "Java AES/CBC/PKCS5Padding"
    
  implementation_details:
    - "Constant-time memcmp"
    - "Constant-time padding check"
    - "MAC-then-encrypt vs encrypt-then-MAC"
    - "Associated data handling"
    - "Nonce management in AEAD"
    - "Key derivation for encryption"
    - "IV generation strategies"
    - "Ciphertext format design"
    - "Version negotiation"
    - "Error handling architecture"
    
  real_world_protocols:
    - "TLS record layer"
    - "IPsec ESP/AH"
    - "SSH encryption"
    - "Signal Protocol"
    - "Noise Protocol Framework"
    - "WireGuard encryption"
    - "Age encryption"
    - "JOSE/JWT encryption (JWE)"
    - "XML Encryption"
    - "CMS/PKCS#7 encryption"
    
  attack_amplification:
    - "Parallel padding oracle queries"
    - "Optimized byte recovery"
    - "Known plaintext optimization"
    - "Partial decryption attacks"
    - "Padding oracle for key recovery"
    - "Chosen ciphertext attacks"
    - "Adaptive chosen ciphertext"
    - "Block duplication attacks"
    - "Block manipulation attacks"
    - "Malleability exploitation"
    
  detection_and_testing:
    - "Padding oracle detection tools"
    - "Timing analysis for padding"
    - "Error message analysis"
    - "Fuzzing for padding issues"
    - "Protocol analysis"
    - "Black-box oracle detection"
    - "White-box vulnerability review"
    - "Differential analysis"
    - "Side-channel testing"
    - "Automated vulnerability scanning"

# === ATTACK CHAINS (50+ chains) ===
attack_chains:
  classic_padding_oracle:
    - name: "CBC Padding Oracle Decryption"
      steps:
        - "Identify padding oracle (error differentiation)"
        - "Capture encrypted ciphertext"
        - "For each block (from last to first):"
        - "  For each byte (from last to first):"
        - "    Modify IV/previous block byte"
        - "    Query oracle with modified ciphertext"
        - "    Detect valid padding response"
        - "    Calculate intermediate state"
        - "    XOR with original to get plaintext"
        - "Complete plaintext recovery achieved"
      difficulty: "medium"
      time_complexity: "O(n * 256) where n = ciphertext bytes"
      cve_references: ["CVE-2010-3332", "CVE-2014-3566"]
      
    - name: "CBC Padding Oracle Encryption"
      steps:
        - "Identify padding oracle"
        - "Use decryption oracle to find intermediate values"
        - "Construct valid ciphertext for arbitrary plaintext"
        - "Encrypt chosen message without key"
      difficulty: "hard"
      
    - name: "Multi-block Parallel Attack"
      steps:
        - "Identify independent padding oracles"
        - "Query oracle for multiple blocks in parallel"
        - "Reduce attack time by parallelism factor"
        - "Aggregate results for full decryption"
      difficulty: "medium"
      
  timing_based_oracles:
    - name: "Lucky Thirteen Attack"
      steps:
        - "Identify TLS CBC connection"
        - "Send modified ciphertext to server"
        - "Measure decryption time precisely"
        - "Detect timing difference for padding errors"
        - "13 bytes of timing variation exploitable"
        - "Recover plaintext byte by byte"
      difficulty: "expert"
      cve_references: ["CVE-2013-0169"]
      
    - name: "Remote Timing Padding Oracle"
      steps:
        - "Establish baseline response timing"
        - "Send ciphertexts with varying padding"
        - "Measure response time differences"
        - "Correlate timing with padding validity"
        - "Recover plaintext via statistical analysis"
      difficulty: "hard"
      requirements: "Low latency connection, many samples"
      
    - name: "Cache Timing Padding Oracle"
      steps:
        - "Co-locate with target process"
        - "Flush cache before decryption"
        - "Measure cache timing during padding check"
        - "Detect early exit on invalid padding"
        - "Recover padding validity"
      difficulty: "expert"
      
  protocol_specific_attacks:
    - name: "POODLE Attack (SSLv3)"
      steps:
        - "Downgrade connection to SSLv3"
        - "Exploit SSLv3 CBC padding (any padding accepted)"
        - "Position target byte at block boundary"
        - "Use JavaScript to send requests"
        - "Recover session cookies byte by byte"
      difficulty: "medium"
      cve_references: ["CVE-2014-3566"]
      
    - name: "ASP.NET Padding Oracle"
      steps:
        - "Identify ASP.NET application"
        - "Intercept encrypted viewstate/cookies"
        - "Query with modified ciphertext"
        - "Differentiate error responses (500 vs 200)"
        - "Decrypt and forge viewstate"
        - "Achieve remote code execution"
      difficulty: "medium"
      cve_references: ["CVE-2010-3332"]
      tools: ["padbuster", "paddingoracle.py"]
      
    - name: "JWT JWE Padding Oracle"
      steps:
        - "Identify JWE with A128CBC-HS256"
        - "Intercept encrypted JWT"
        - "Modify ciphertext bytes"
        - "Query token validation endpoint"
        - "Detect padding vs authentication errors"
        - "Decrypt JWT payload"
      difficulty: "hard"
      
    - name: "ROBOT Attack (Bleichenbacher)"
      steps:
        - "Identify RSA encryption with PKCS#1 v1.5"
        - "Send malformed ciphertexts"
        - "Detect different error messages"
        - "Apply Bleichenbacher's attack"
        - "Recover premaster secret"
        - "Decrypt TLS session"
      difficulty: "expert"
      cve_references: ["CVE-2017-6168", "CVE-2017-17382"]
      
  advanced_attacks:
    - name: "Padding Oracle Key Extraction"
      steps:
        - "Use padding oracle for decryption"
        - "Decrypt key exchange messages"
        - "Recover session keys"
        - "Decrypt entire session"
      difficulty: "expert"
      
    - name: "Bidirectional Oracle Exploitation"
      steps:
        - "Use decryption oracle to create encryption oracle"
        - "Encrypt arbitrary messages"
        - "Forge authenticated requests"
        - "Bypass authentication"
      difficulty: "hard"
      
    - name: "Error Oracle Amplification"
      steps:
        - "Identify subtle error differences"
        - "Use machine learning to classify errors"
        - "Amplify weak oracle signal"
        - "Achieve reliable padding detection"
      difficulty: "hard"

# === DEFENSE BYPASS TECHNIQUES (100+) ===
defense_bypass_techniques:
  error_handling_bypass:
    - "Detect subtle HTTP status code differences (400 vs 500)"
    - "Analyze error message content variations"
    - "Measure response body length differences"
    - "Detect connection close vs keep-alive"
    - "Analyze TCP FIN timing"
    - "Detect redirect vs error response"
    - "Analyze error page rendering time"
    - "Detect database error propagation"
    - "Analyze log timing side-effects"
    - "Detect exception handler timing"
    
  timing_bypass:
    - "High-precision timing measurement"
    - "Statistical timing analysis"
    - "Request coalescing for amplification"
    - "Cache timing exploitation"
    - "Memory access timing"
    - "CPU timing side channels"
    - "Network latency normalization"
    - "Parallel timing measurements"
    - "Timing amplification attacks"
    - "Cross-process timing"
    
  response_analysis:
    - "Content-Type header differences"
    - "Set-Cookie header presence"
    - "Cache-Control header differences"
    - "Response compression differences"
    - "Content encoding differences"
    - "Character encoding differences"
    - "JSON vs XML error format"
    - "HTML error page structure"
    - "JavaScript error handling"
    - "API error response format"
    
  protocol_bypass:
    - "Downgrade to vulnerable protocol version"
    - "Negotiate vulnerable cipher suite"
    - "Exploit backwards compatibility"
    - "Use legacy encryption mode"
    - "Exploit fallback mechanisms"
    - "Bypass AEAD via legacy mode"
    - "Exploit version negotiation"
    - "Use deprecated padding mode"
    - "Exploit interoperability issues"
    - "Attack protocol extensions"
    
  implementation_bypass:
    - "Exploit compiler optimization"
    - "Exploit branch prediction"
    - "Exploit memory access patterns"
    - "Exploit exception handling flow"
    - "Exploit garbage collection timing"
    - "Exploit JIT compilation effects"
    - "Exploit logging side effects"
    - "Exploit audit trail timing"
    - "Exploit metrics collection"
    - "Exploit monitoring systems"

# === REAL-WORLD SCENARIOS ===
real_world_scenarios:
  web_applications:
    - scenario: "Session Cookie Encryption"
      description: "AES-CBC encrypted session cookies with visible padding errors"
      complexity: "medium"
      attack_vector: "Decrypt session cookies, impersonate users"
      
    - scenario: "API Token Encryption"
      description: "Encrypted API tokens with distinguishable errors"
      complexity: "medium"
      attack_vector: "Decrypt API tokens, access resources"
      
    - scenario: "Password Reset Token"
      description: "CBC encrypted reset tokens with timing oracle"
      complexity: "hard"
      attack_vector: "Forge password reset tokens"
      
    - scenario: "OAuth State Parameter"
      description: "Encrypted OAuth state with error leakage"
      complexity: "medium"
      attack_vector: "Forge OAuth state, perform attacks"
      
  enterprise_systems:
    - scenario: "Database Field Encryption"
      description: "Application-level encryption of sensitive fields"
      complexity: "high"
      attack_vector: "Decrypt PII data"
      
    - scenario: "Inter-service Communication"
      description: "Encrypted messages between microservices"
      complexity: "high"
      attack_vector: "Decrypt internal communications"
      
    - scenario: "Configuration Encryption"
      description: "Encrypted configuration with error logging"
      complexity: "medium"
      attack_vector: "Decrypt secrets from configuration"
      
  protocols:
    - scenario: "TLS 1.2 CBC Cipher Suites"
      description: "TLS with CBC mode and MAC-then-encrypt"
      complexity: "expert"
      attack_vector: "Lucky Thirteen variant"
      
    - scenario: "IPsec ESP Encryption"
      description: "ESP with CBC mode encryption"
      complexity: "expert"
      attack_vector: "VPN traffic decryption"
      
    - scenario: "SSH Encryption"
      description: "SSH with CBC mode cipher"
      complexity: "expert"
      attack_vector: "SSH session decryption"

# === DIFFICULTY CONFIGURATION ===
difficulty:
  estimated: "extreme"
  time_range: [7200, 28800]
  command_steps: [150, 600]
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "CTF-final level difficulty requiring expert exploitation skills"
      requirements:
        - "7+ interacting vulnerabilities requiring chained exploitation"
        - "Requires understanding of target runtime/compiler internals"
        - "Time estimate: 180+ minutes for senior security researchers"
        - "Multiple protection bypass techniques required"
        - "Requires synthesizing reverse engineering, exploitation, and cryptography"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 172800]
      command_steps: [500, 2000]
      techniques_required: 18
      description: "Real-world 0-day exploitation requiring novel padding oracle discovery and exploitation techniques"
      requirements:
        - "15+ deeply interacting vulnerabilities across cryptographic protocol layers"
        - "Requires discovery of novel timing or error oracle side-channels"
        - "Time estimate: 12-48 hours for senior security researchers with OSCP/OSWE/OSCE certifications"
        - "Custom statistical analysis tools for sub-millisecond timing differentiation"
        - "Must bypass AEAD migration, constant-time implementations, and error normalization"
        - "Requires understanding of CPU cache hierarchy and microarchitectural timing"
        - "Must achieve full plaintext recovery through multiple protection layers"
        - "Network jitter compensation and distributed timing measurement required"
  
  generation_targets:
    minimum_difficulty: "120-360 minutes for senior security researchers with offensive security certifications (OSCP/OSWE/OSCE)"
    quality_requirements: "Must require deep understanding of block cipher modes, padding schemes, and timing analysis techniques"
  
  difficulty_levels:
    beginner:
      description: "Identify obvious error message oracle"
      time_estimate: 600
      prerequisites: ["Basic cryptography"]
      
    intermediate:
      description: "Implement padding oracle attack"
      time_estimate: 1200
      prerequisites: ["CBC mode understanding", "Programming"]
      
    advanced:
      description: "Timing-based padding oracle"
      time_estimate: 2400
      prerequisites: ["Side-channel analysis", "Statistics"]
      
    expert:
      description: "Protocol-level padding oracle"
      time_estimate: 3600
      prerequisites: ["Protocol design", "Network analysis"]

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 8
  coordination_complexity: "extreme"
  
  specialized_agents:
    - name: "crypto_analyst"
      role: "Analyze cryptographic implementations for padding oracle vulnerabilities"
      expertise: ["block ciphers", "padding schemes", "AEAD modes", "MAC-then-encrypt vs encrypt-then-MAC"]
      
    - name: "timing_specialist"
      role: "Develop and execute precise timing measurements"
      expertise: ["statistical timing analysis", "network jitter compensation", "cache timing", "RDTSC measurements"]
      
    - name: "protocol_analyst"
      role: "Analyze protocol-level padding oracle exposure"
      expertise: ["TLS", "IPsec", "SSH", "custom protocols"]
      
    - name: "reverse_engineer"
      role: "Reverse engineer cryptographic libraries and error handling"
      expertise: ["binary analysis", "decompilation", "error path tracing"]
      
    - name: "exploit_developer"
      role: "Develop optimized padding oracle exploitation tools"
      expertise: ["parallel attack optimization", "byte recovery algorithms", "adaptive techniques"]
      
    - name: "network_analyst"
      role: "Execute network-level timing and error oracle attacks"
      expertise: ["packet timing", "connection behavior analysis", "HTTP response analysis"]
      
    - name: "statistician"
      role: "Apply statistical methods to distinguish oracle responses"
      expertise: ["hypothesis testing", "signal detection", "noise filtering", "machine learning classification"]
      
    - name: "defense_bypass_specialist"
      role: "Bypass padding oracle mitigations"
      expertise: ["constant-time bypass", "error normalization evasion", "AEAD downgrade"]
  
  cross_vulnerability_chains:
    - chain: "Error message analysis -> Oracle identification -> Byte-by-byte decryption -> Session hijacking"
      complexity: "high"
      
    - chain: "Timing side-channel -> Statistical analysis -> Key recovery -> Complete compromise"
      complexity: "extreme"
      
    - chain: "Protocol downgrade -> CBC mode forcing -> Padding oracle -> Credential theft"
      complexity: "extreme"
      
    - chain: "Cache timing -> Intermediate state recovery -> Encryption oracle -> Message forgery"
      complexity: "extreme"
      
    - chain: "Connection behavior oracle -> Response length analysis -> Partial decryption -> Privilege escalation"
      complexity: "high"

# === EXPLOIT CHAIN REQUIREMENTS ===
exploit_chain_requirements:
  minimum_chain_length: 5
  required_stages:
    - stage: "oracle_discovery"
      description: "Identify padding oracle side-channel"
      techniques:
        - "Error message differential analysis"
        - "HTTP status code enumeration"
        - "Response timing measurement"
        - "Connection behavior observation"
        - "Response body length analysis"
    
    - stage: "oracle_characterization"
      description: "Characterize oracle behavior and reliability"
      techniques:
        - "Statistical significance testing"
        - "False positive/negative rate estimation"
        - "Oracle consistency verification"
        - "Network condition impact analysis"
    
    - stage: "attack_optimization"
      description: "Optimize attack for target environment"
      techniques:
        - "Parallel query optimization"
        - "Adaptive byte recovery algorithms"
        - "Network latency compensation"
        - "Error recovery strategies"
    
    - stage: "plaintext_recovery"
      description: "Execute full plaintext recovery"
      techniques:
        - "Block-by-block decryption"
        - "Known plaintext optimization"
        - "Partial recovery exploitation"
        - "Multi-block parallelization"
    
    - stage: "exploit_escalation"
      description: "Leverage decrypted data for further attacks"
      techniques:
        - "Session token recovery"
        - "Credential extraction"
        - "Encryption oracle construction"
        - "Message forgery"

# === DEFENSIVE EVASION ===
defensive_evasion:
  security_controls_to_bypass:
    - control: "Constant-Time Implementations"
      bypass_techniques:
        - "Compiler optimization exploitation"
        - "JIT compilation timing variance"
        - "Memory access pattern analysis"
        - "Cache-based timing side-channels"
        - "Branch prediction timing leaks"
      
    - control: "Generic Error Messages"
      bypass_techniques:
        - "Response timing analysis"
        - "Connection termination behavior"
        - "HTTP header differential analysis"
        - "Response body length comparison"
        - "TCP FIN timing observation"
      
    - control: "AEAD Mode Migration"
      bypass_techniques:
        - "Legacy mode fallback forcing"
        - "Protocol version downgrade"
        - "Backwards compatibility exploitation"
        - "Configuration misconfiguration discovery"
      
    - control: "Rate Limiting"
      bypass_techniques:
        - "Distributed oracle queries"
        - "Low-and-slow timing attacks"
        - "Batch request optimization"
        - "Time-delayed query scheduling"
      
    - control: "MAC-then-Encrypt"
      bypass_techniques:
        - "MAC verification timing analysis"
        - "Combined padding-MAC oracle"
        - "Implementation-specific vulnerabilities"
        - "Protocol-level MAC bypass"

# === REAL-WORLD CORRELATION ===
real_world_correlation:
  cve_attack_patterns:
    - cve: "CVE-2010-3332"
      technique: "ASP.NET padding oracle"
      real_world_impact: "Remote code execution via ViewState decryption"
      complexity_factors: ["Error message parsing", "Multi-stage exploitation", "Payload crafting"]
      
    - cve: "CVE-2014-3566"
      technique: "POODLE attack on SSLv3"
      real_world_impact: "TLS session decryption"
      complexity_factors: ["JavaScript positioning", "Block alignment", "Byte recovery"]
      
    - cve: "CVE-2013-0169"
      technique: "Lucky Thirteen timing attack"
      real_world_impact: "TLS CBC plaintext recovery"
      complexity_factors: ["Sub-microsecond timing", "Statistical analysis", "Network jitter"]
      
    - cve: "CVE-2016-2107"
      technique: "OpenSSL AES-NI padding oracle"
      real_world_impact: "TLS session decryption"
      complexity_factors: ["AES-NI specific timing", "MAC check timing", "Implementation details"]

# === TRAP DENSITY ===
trap_configuration:
  total_traps: 14
  trap_interaction_depth: 5
  cross_domain_traps: true
  
  trap_categories:
    error_handling_traps: 4
    timing_traps: 4
    architecture_traps: 3
    implementation_traps: 3

# === LLM TRAP CONFIGURATIONS (50+) ===
traps:
  error_handling_traps:
    - type: "error_differentiation"
      description: "Different errors for padding vs content"
      trigger: "Throwing different exceptions for padding errors"
      detection: "Compare error responses for padding vs other failures"
      
    - type: "verbose_errors"
      description: "Error messages reveal padding state"
      trigger: "Including padding details in error response"
      detection: "Analyze error message content"
      
    - type: "status_code_leak"
      description: "HTTP status varies with error type"
      trigger: "400 for padding, 500 for other errors"
      detection: "Compare HTTP status codes"
      
    - type: "logging_differences"
      description: "Different log entries for error types"
      trigger: "Detailed logging of padding failures"
      detection: "Log timing or error correlation"
      
  timing_traps:
    - type: "timing_leak"
      description: "Padding check takes different time based on validity"
      trigger: "Early return on padding validation"
      detection: "Statistical timing analysis"
      
    - type: "mac_timing"
      description: "MAC verification timing varies"
      trigger: "Non-constant-time MAC comparison"
      detection: "Timing correlation with MAC validity"
      
    - type: "exception_timing"
      description: "Exception handling path is slower"
      trigger: "Try/catch with expensive error handling"
      detection: "Error path timing measurement"
      
  architecture_traps:
    - type: "cbc_without_mac"
      description: "Using CBC mode without authentication"
      trigger: "Decrypting before verifying integrity"
      detection: "Any modification accepted for decryption"
      
    - type: "mac_then_encrypt"
      description: "MAC computed before encryption"
      trigger: "HMAC(plaintext), then encrypt both"
      detection: "Padding errors before MAC verification"
      
    - type: "decrypt_then_verify"
      description: "Decryption attempted before auth"
      trigger: "Decrypt first, then verify signature"
      detection: "Padding errors distinguishable from auth failure"
      
  implementation_traps:
    - type: "partial_block_handling"
      description: "Special handling for incomplete blocks"
      trigger: "Different code path for short ciphertext"
      detection: "Behavior difference with varying lengths"
      
    - type: "double_padding"
      description: "Padding applied twice accidentally"
      trigger: "Library and manual padding"
      detection: "Extra padding byte detection"
      
    - type: "padding_validation_order"
      description: "Padding checked byte by byte"
      trigger: "Early exit on invalid byte"
      detection: "Timing varies with valid padding length"

# === COMPREHENSIVE TASK GENERATION TEMPLATE ===
instruction_template: |
  You are fixing a {{ scenario_type }} with padding oracle vulnerabilities.
  The code is at {{ path }}.
  
  System details:
  - Platform: {{ platform }}
  - Language: {{ language }}
  - Framework: {{ framework }}
  
  Encryption algorithm: {{ algorithm }}
  Padding scheme: {{ padding_scheme }}
  Vulnerable endpoints: {{ endpoint_count }}
  
  Attack model:
  - Attacker has captured: {{ captured_ciphertexts }} ciphertexts
  - Oracle type: {{ oracle_type }}
  - Network latency: {{ network_latency_ms }}ms
  
  Your task:
  {{ task_steps }}
  
  Additional requirements:
  - All padding validation must be constant-time
  - MAC verification must occur BEFORE decryption attempt
  - Error responses must be indistinguishable
  - Migrate to AEAD where possible
  - Legacy data must still be decryptable (safely)

# === REFERENCE SOLUTION (COMPREHENSIVE) ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Padding Oracle Mitigation Library
  
  Demonstrates secure encryption patterns that prevent padding oracle attacks:
  1. Constant-time padding validation
  2. Encrypt-then-MAC construction
  3. Authenticated encryption (AEAD) modes
  4. Proper error handling
  """
  
  import os
  import hmac
  import hashlib
  import struct
  import secrets
  import time
  from typing import Optional, Tuple, Union
  from dataclasses import dataclass
  from enum import Enum
  
  # Use cryptography library for production
  from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
  from cryptography.hazmat.primitives.ciphers.aead import AESGCM, AESCCM, ChaCha20Poly1305
  from cryptography.hazmat.backends import default_backend
  from cryptography.exceptions import InvalidTag
  
  
  # ============================================================
  # CONSTANT-TIME PRIMITIVES
  # ============================================================
  
  def constant_time_compare(a: bytes, b: bytes) -> bool:
      """
      Compare two byte strings in constant time.
      
      Prevents timing attacks by always comparing all bytes.
      """
      if len(a) != len(b):
          return False
      
      result = 0
      for x, y in zip(a, b):
          result |= x ^ y
      
      return result == 0
  
  
  def constant_time_select(condition: bool, if_true: bytes, if_false: bytes) -> bytes:
      """Select between two values in constant time."""
      if len(if_true) != len(if_false):
          raise ValueError("Values must have same length")
      
      mask = -int(condition) & 0xFF
      result = bytearray(len(if_true))
      
      for i in range(len(if_true)):
          result[i] = (if_true[i] & mask) | (if_false[i] & ~mask & 0xFF)
      
      return bytes(result)
  
  
  # ============================================================
  # CONSTANT-TIME PADDING VALIDATION
  # ============================================================
  
  def constant_time_unpad_pkcs7(
      data: bytes, 
      block_size: int = 16
  ) -> Tuple[bool, bytes]:
      """
      Validate and remove PKCS#7 padding in constant time.
      
      This function always processes all bytes to prevent timing attacks.
      It accumulates validity information without early exit.
      
      Args:
          data: Padded data
          block_size: Block size (default 16 for AES)
          
      Returns:
          Tuple of (is_valid, unpadded_data)
          If invalid, returns (False, b'')
      """
      if len(data) == 0:
          return False, b''
      
      if len(data) % block_size != 0:
          return False, b''
      
      # Get padding length (last byte)
      padding_len = data[-1]
      
      # Accumulate validity checks
      valid = True
      
      # Check padding length is valid (1 to block_size)
      if padding_len == 0 or padding_len > block_size:
          valid = False
          padding_len = 1  # Use dummy value for constant-time processing
      
      # Check all padding bytes are correct (constant time)
      # We check ALL possible padding positions
      for i in range(block_size):
          # Is this position within padding?
          in_padding = i < padding_len
          
          # Get byte from end
          byte_idx = len(data) - 1 - i
          byte_val = data[byte_idx] if byte_idx >= 0 else 0
          
          # Should this byte equal padding_len?
          expected = padding_len
          matches = byte_val == expected
          
          # Only count mismatch if in padding region
          if in_padding and not matches:
              valid = False
      
      # Return result
      if valid:
          return True, data[:-data[-1]]
      else:
          return False, b''
  
  
  # ============================================================
  # VULNERABLE IMPLEMENTATION (FOR REFERENCE)
  # ============================================================
  
  """
  # DANGEROUS: DO NOT USE
  # This code demonstrates the vulnerable pattern
  
  def vulnerable_decrypt_cbc(key: bytes, iv: bytes, ciphertext: bytes) -> bytes:
      '''VULNERABLE: Distinguishable padding errors!'''
      
      cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
      decryptor = cipher.decryptor()
      plaintext_padded = decryptor.update(ciphertext) + decryptor.finalize()
      
      # VULNERABLE: Different exceptions reveal padding validity
      padding_len = plaintext_padded[-1]
      if padding_len > 16 or padding_len == 0:
          raise ValueError("Invalid padding length")  # ORACLE: length error
      
      for i in range(padding_len):
          if plaintext_padded[-(i+1)] != padding_len:
              raise ValueError("Invalid padding bytes")  # ORACLE: byte error
      
      return plaintext_padded[:-padding_len]
  
  # Attacker can distinguish:
  # 1. "Invalid padding length" - padding byte > 16 or == 0
  # 2. "Invalid padding bytes" - padding bytes don't all match
  # 3. Success - valid padding
  # This reveals information about the plaintext!
  """
  
  
  # ============================================================
  # SOLUTION 1: CONSTANT-TIME CBC DECRYPTION
  # ============================================================
  
  def decrypt_cbc_safe(
      key: bytes, 
      iv: bytes, 
      ciphertext: bytes
  ) -> Tuple[bool, bytes]:
      """
      CBC decryption with constant-time padding validation.
      
      Returns (success, plaintext) tuple with identical error handling
      regardless of error type.
      
      Args:
          key: AES key (16, 24, or 32 bytes)
          iv: Initialization vector (16 bytes)
          ciphertext: Encrypted data
          
      Returns:
          (True, plaintext) on success
          (False, b'') on any failure (indistinguishable)
      """
      try:
          # Validate input sizes
          if len(ciphertext) == 0 or len(ciphertext) % 16 != 0:
              return False, b''
          
          if len(iv) != 16:
              return False, b''
          
          # Decrypt
          cipher = Cipher(
              algorithms.AES(key), 
              modes.CBC(iv), 
              backend=default_backend()
          )
          decryptor = cipher.decryptor()
          plaintext_padded = decryptor.update(ciphertext) + decryptor.finalize()
          
          # Constant-time padding validation
          is_valid, plaintext = constant_time_unpad_pkcs7(plaintext_padded)
          
          return is_valid, plaintext
          
      except Exception:
          # Generic failure - no information leakage
          return False, b''
  
  
  # ============================================================
  # SOLUTION 2: ENCRYPT-THEN-MAC
  # ============================================================
  
  class EncryptThenMAC:
      """
      Encrypt-then-MAC construction prevents padding oracle entirely.
      
      MAC is computed over ciphertext, verified before decryption.
      Invalid MAC means no decryption is attempted, so no padding
      information can be leaked.
      
      Format: IV (16 bytes) || Ciphertext || MAC (32 bytes)
      """
      
      MAC_SIZE = 32  # HMAC-SHA256
      IV_SIZE = 16
      
      def __init__(self, enc_key: bytes, mac_key: bytes):
          """
          Initialize with separate encryption and MAC keys.
          
          Args:
              enc_key: 32-byte encryption key
              mac_key: 32-byte MAC key
          """
          if len(enc_key) != 32:
              raise ValueError("Encryption key must be 32 bytes")
          if len(mac_key) != 32:
              raise ValueError("MAC key must be 32 bytes")
          
          self.enc_key = enc_key
          self.mac_key = mac_key
      
      @classmethod
      def from_master_key(cls, master_key: bytes) -> 'EncryptThenMAC':
          """
          Derive encryption and MAC keys from master key using HKDF.
          """
          # Simple derivation (use HKDF in production)
          enc_key = hashlib.sha256(master_key + b'encryption').digest()
          mac_key = hashlib.sha256(master_key + b'authentication').digest()
          return cls(enc_key, mac_key)
      
      def encrypt(self, plaintext: bytes) -> bytes:
          """
          Encrypt with authentication.
          
          Args:
              plaintext: Data to encrypt
              
          Returns:
              IV || Ciphertext || MAC
          """
          # Generate random IV
          iv = secrets.token_bytes(self.IV_SIZE)
          
          # Pad plaintext (PKCS#7)
          padding_len = 16 - (len(plaintext) % 16)
          padded = plaintext + bytes([padding_len] * padding_len)
          
          # Encrypt
          cipher = Cipher(
              algorithms.AES(self.enc_key),
              modes.CBC(iv),
              backend=default_backend()
          )
          encryptor = cipher.encryptor()
          ciphertext = encryptor.update(padded) + encryptor.finalize()
          
          # Compute MAC over IV + ciphertext
          mac_data = iv + ciphertext
          mac = hmac.new(self.mac_key, mac_data, hashlib.sha256).digest()
          
          return iv + ciphertext + mac
      
      def decrypt(self, data: bytes) -> Optional[bytes]:
          """
          Decrypt with authentication verification.
          
          MAC is verified BEFORE any decryption attempt.
          Returns None for ANY error (no information leakage).
          
          Args:
              data: IV || Ciphertext || MAC
              
          Returns:
              Plaintext or None on any failure
          """
          # Check minimum size: IV + 1 block + MAC
          min_size = self.IV_SIZE + 16 + self.MAC_SIZE
          if len(data) < min_size:
              return None
          
          # Split components
          iv = data[:self.IV_SIZE]
          mac = data[-self.MAC_SIZE:]
          ciphertext = data[self.IV_SIZE:-self.MAC_SIZE]
          
          # Verify MAC FIRST (before any decryption)
          mac_data = iv + ciphertext
          expected_mac = hmac.new(self.mac_key, mac_data, hashlib.sha256).digest()
          
          if not hmac.compare_digest(mac, expected_mac):
              # MAC invalid - don't even attempt decryption
              return None
          
          # MAC valid - safe to decrypt
          try:
              cipher = Cipher(
                  algorithms.AES(self.enc_key),
                  modes.CBC(iv),
                  backend=default_backend()
              )
              decryptor = cipher.decryptor()
              padded = decryptor.update(ciphertext) + decryptor.finalize()
              
              # Unpad (MAC already verified, padding should be valid)
              # Still use constant-time for defense in depth
              is_valid, plaintext = constant_time_unpad_pkcs7(padded)
              
              return plaintext if is_valid else None
              
          except Exception:
              return None
  
  
  # ============================================================
  # SOLUTION 3: AEAD (BEST PRACTICE)
  # ============================================================
  
  class AEADEncryption:
      """
      Authenticated Encryption with Associated Data.
      
      Uses AES-GCM which provides:
      - Confidentiality
      - Integrity
      - Authentication
      - No padding required (stream cipher internally)
      
      Padding oracle attacks are impossible because:
      - No padding exists
      - Authentication is integral to decryption
      - Invalid ciphertext cannot be partially decrypted
      """
      
      NONCE_SIZE = 12  # 96 bits for GCM (recommended)
      TAG_SIZE = 16    # 128-bit authentication tag
      
      def __init__(self, key: bytes):
          """
          Initialize with AES key.
          
          Args:
              key: 16, 24, or 32 byte AES key
          """
          if len(key) not in (16, 24, 32):
              raise ValueError("Key must be 16, 24, or 32 bytes")
          
          self.aesgcm = AESGCM(key)
      
      def encrypt(
          self, 
          plaintext: bytes, 
          associated_data: bytes = b''
      ) -> bytes:
          """
          Encrypt with AEAD.
          
          Args:
              plaintext: Data to encrypt
              associated_data: Additional authenticated data (not encrypted)
              
          Returns:
              Nonce || Ciphertext || Tag
          """
          nonce = secrets.token_bytes(self.NONCE_SIZE)
          ciphertext = self.aesgcm.encrypt(nonce, plaintext, associated_data)
          return nonce + ciphertext
      
      def decrypt(
          self, 
          data: bytes, 
          associated_data: bytes = b''
      ) -> Optional[bytes]:
          """
          Decrypt with AEAD.
          
          Returns None for ANY failure (authentication or otherwise).
          
          Args:
              data: Nonce || Ciphertext || Tag
              associated_data: Additional authenticated data
              
          Returns:
              Plaintext or None on failure
          """
          if len(data) < self.NONCE_SIZE + self.TAG_SIZE:
              return None
          
          nonce = data[:self.NONCE_SIZE]
          ciphertext = data[self.NONCE_SIZE:]
          
          try:
              return self.aesgcm.decrypt(nonce, ciphertext, associated_data)
          except InvalidTag:
              return None
          except Exception:
              return None
  
  
  class ChaCha20Poly1305Encryption:
      """
      ChaCha20-Poly1305 AEAD.
      
      Alternative to AES-GCM, especially for systems without AES hardware.
      Same security properties as AES-GCM.
      """
      
      NONCE_SIZE = 12
      
      def __init__(self, key: bytes):
          if len(key) != 32:
              raise ValueError("Key must be 32 bytes")
          
          self.cipher = ChaCha20Poly1305(key)
      
      def encrypt(
          self, 
          plaintext: bytes, 
          associated_data: bytes = b''
      ) -> bytes:
          nonce = secrets.token_bytes(self.NONCE_SIZE)
          ciphertext = self.cipher.encrypt(nonce, plaintext, associated_data)
          return nonce + ciphertext
      
      def decrypt(
          self, 
          data: bytes, 
          associated_data: bytes = b''
      ) -> Optional[bytes]:
          if len(data) < self.NONCE_SIZE + 16:
              return None
          
          nonce = data[:self.NONCE_SIZE]
          ciphertext = data[self.NONCE_SIZE:]
          
          try:
              return self.cipher.decrypt(nonce, ciphertext, associated_data)
          except Exception:
              return None
  
  
  # ============================================================
  # MIGRATION UTILITIES
  # ============================================================
  
  class VersionedEncryption:
      """
      Support multiple encryption versions for migration.
      
      Allows gradual migration from vulnerable to secure encryption
      while maintaining backwards compatibility.
      """
      
      VERSION_LEGACY_CBC = 0x01
      VERSION_ETM = 0x02
      VERSION_AESGCM = 0x03
      
      def __init__(self, key: bytes):
          self.key = key
          self.etm = EncryptThenMAC.from_master_key(key)
          self.aead = AEADEncryption(hashlib.sha256(key).digest())
      
      def encrypt(self, plaintext: bytes, version: int = None) -> bytes:
          """
          Encrypt with specified version (default: latest).
          """
          if version is None:
              version = self.VERSION_AESGCM
          
          if version == self.VERSION_AESGCM:
              ciphertext = self.aead.encrypt(plaintext)
          elif version == self.VERSION_ETM:
              ciphertext = self.etm.encrypt(plaintext)
          else:
              raise ValueError(f"Unsupported encryption version: {version}")
          
          return bytes([version]) + ciphertext
      
      def decrypt(self, data: bytes) -> Optional[bytes]:
          """
          Decrypt based on version prefix.
          
          Returns None for any failure.
          """
          if len(data) < 1:
              return None
          
          version = data[0]
          ciphertext = data[1:]
          
          if version == self.VERSION_AESGCM:
              return self.aead.decrypt(ciphertext)
          elif version == self.VERSION_ETM:
              return self.etm.decrypt(ciphertext)
          elif version == self.VERSION_LEGACY_CBC:
              # Legacy support - log warning, decrypt carefully
              # In production: add monitoring, plan deprecation
              return self._decrypt_legacy(ciphertext)
          else:
              return None
      
      def _decrypt_legacy(self, data: bytes) -> Optional[bytes]:
          """
          Decrypt legacy CBC format with constant-time padding.
          
          Used only for backwards compatibility.
          """
          if len(data) < 32:
              return None
          
          iv = data[:16]
          ciphertext = data[16:]
          
          # Use constant-time decryption even for legacy
          success, plaintext = decrypt_cbc_safe(
              hashlib.sha256(self.key).digest(), 
              iv, 
              ciphertext
          )
          
          return plaintext if success else None

# === TEST CASES ===
fail_to_pass:
  - "test_no_padding_oracle_via_errors"
  - "test_no_padding_oracle_via_timing"
  - "test_constant_time_padding_validation"
  - "test_mac_verified_before_decrypt"
  - "test_generic_error_responses"
  - "test_aead_mode_used"
  - "test_no_cbc_without_mac"
  - "test_encrypt_then_mac_construction"
  - "test_legacy_migration_secure"
  - "test_no_information_leakage"

pass_to_pass:
  - "test_basic_encryption_roundtrip"
  - "test_decryption_of_valid_ciphertext"
  - "test_authenticated_data_verification"
  - "test_key_derivation"

# === VARIABLES FOR TASK GENERATION ===
variables:
  scenario_type:
    type: string
    options:
      - "session token encryption"
      - "API payload encryption"
      - "file encryption service"
      - "message encryption"
      - "database field encryption"
      - "configuration encryption"
      - "cookie encryption"
      - "token encryption"
      - "inter-service encryption"
      - "backup encryption"
      
  path:
    type: path
    generator: random_path
    
  platform:
    type: string
    options:
      - "Linux x86_64"
      - "Windows Server"
      - "AWS Lambda"
      - "Kubernetes"
      
  language:
    type: string
    options:
      - "Python"
      - "Java"
      - "Node.js"
      - "Go"
      - "C#"
      
  framework:
    type: string
    options:
      - "Django"
      - "Spring Boot"
      - "Express"
      - "ASP.NET Core"
      
  algorithm:
    type: string
    options:
      - "AES-128-CBC"
      - "AES-256-CBC"
      - "3DES-CBC"
      - "AES-128-ECB"
      
  padding_scheme:
    type: string
    options:
      - "PKCS#7"
      - "PKCS#5"
      - "Zero padding"
      - "ISO 10126"
      
  endpoint_count:
    type: int
    min: 1
    max: 20
    
  captured_ciphertexts:
    type: int
    min: 1
    max: 1000
    
  oracle_type:
    type: string
    options:
      - "Error message differentiation"
      - "HTTP status code"
      - "Response timing"
      - "Connection behavior"
      
  network_latency_ms:
    type: int
    min: 1
    max: 500
    
  task_steps:
    type: template
    value: |
      1. Identify all encryption/decryption endpoints
      2. Analyze error handling for information leakage
      3. Check for timing differences in error paths
      4. Implement constant-time padding validation
      5. Add MAC verification before decryption (EtM)
      6. Migrate to AEAD mode (AES-GCM preferred)
      7. Normalize all error responses
      8. Add version negotiation for migration
      9. Test for timing side channels
      10. Verify no padding oracle remains

# === ANTI-PATTERNS AND LLM FAILURE MODES ===
anti_patterns:
  llm_failure_modes:
    - "Applying textbook attack patterns without considering mitigations"
    - "Missing WAF/IDS bypass techniques for exploitation"
    - "Ignoring ASLR/PIE/NX and other modern protections"
    - "Not considering timing side-channel in crypto implementations"
    - "Missing second-order and stored attack vectors"
    - "Overlooking race conditions in authentication flows"
    - "Assuming standard libraries are secure without version checking"
    - "Missing JWT algorithm confusion and key confusion attacks"
    - "Ignoring deserialization gadget chain discovery complexity"
    - "Not recognizing compiler optimizations that break constant-time code"
    - "Missing JIT compilation timing variance in managed languages"
    - "Overlooking CPU cache hierarchy timing differences"
    - "Failing to account for network jitter in remote timing attacks"
    - "Not considering AEAD mode implementation-specific vulnerabilities"
    - "Missing protocol version negotiation as attack surface"
    - "Ignoring MAC verification timing in MAC-then-encrypt schemes"
    - "Not recognizing response body length as side-channel"
    - "Overlooking TCP connection behavior as oracle"
    - "Missing parallel query optimization opportunities"
    - "Failing to identify partial plaintext recovery value"
    - "Not considering encryption oracle construction from decryption oracle"
    - "Ignoring hardware acceleration (AES-NI) timing differences"
    - "Missing memory allocation timing in padding validation"
    - "Not recognizing garbage collection timing impacts"
    - "Overlooking exception handling path timing differences"
    - "Failing to identify logging-induced timing variations"
    - "Not considering database error propagation as oracle"
    - "Missing CDN/proxy layer timing normalization bypass"
    - "Ignoring HTTP/2 multiplexing effects on timing measurement"

# === ANTI-HARDCODING MEASURES ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  oracle_sources:
    - "error_message_differentiation"
    - "http_status_codes"
    - "response_timing_differences"
    - "exception_type_leakage"
    - "connection_behavior"
    - "response_length"
    - "logging_differences"
    
  verification_requirements:
    - "Timing analysis shows no correlation"
    - "Error responses are identical"
    - "MAC verification occurs first"
    - "AEAD mode is used where possible"

# === CVE REFERENCES ===
cve_references:
  - id: "CVE-2010-3332"
    description: "ASP.NET padding oracle"
    relevance: "Classic web application padding oracle"
    
  - id: "CVE-2014-3566"
    description: "POODLE attack"
    relevance: "SSLv3 CBC padding vulnerability"
    
  - id: "CVE-2013-0169"
    description: "Lucky Thirteen"
    relevance: "TLS CBC timing attack"
    
  - id: "CVE-2017-6168"
    description: "ROBOT attack"
    relevance: "RSA PKCS#1 v1.5 padding oracle"
    
  - id: "CVE-2016-2107"
    description: "OpenSSL padding oracle"
    relevance: "AES-NI CBC MAC check padding oracle"

# === TOOL RECOMMENDATIONS ===
tools:
  attack_tools:
    - "PadBuster (Perl)"
    - "paddingoracle.py"
    - "padding-oracle-attacker"
    - "POET (Padding Oracle Exploitation Tool)"
    - "Burp Suite Intruder"
    
  detection_tools:
    - "OWASP ZAP"
    - "Burp Suite Scanner"
    - "Custom timing scripts"
    - "Wireshark for protocol analysis"
    
  verification_tools:
    - "timing-safe-compare benchmarks"
    - "Statistical timing analysis"
    - "Fuzzing with invalid padding"
