id: "sec-auth-jwt-confusion-001"
version: "2.0.0"
category: "security"
subcategory: "authentication"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research advanced JWT attack vectors, algorithm confusion, and header injection techniques"
    phase_2_creation: "Create multi-layered JWT security challenge with hidden exploitation paths"
    phase_3_amplification: "Add key confusion scenarios, claim manipulation, and library-specific bypasses"
    phase_4_verification:
      base_validation: "Validate task requires comprehensive JWT security implementation"
      enhanced_criteria:
        - "Has at least 5 interacting vulnerability chains"
        - "Has cascading exploitation paths that require chained attacks"
        - "Requires knowledge of compiler/interpreter internals for exploitation"
        - "Would take experienced security researchers 45+ minutes"
  
  complexity_targets:
    min_steps: 15
    max_steps: 45
    required_expertise:
      - "JWT structure and specification"
      - "Cryptographic algorithm selection"
      - "Key management and validation"
      - "Claims validation logic"
      - "Library-specific vulnerabilities"
    
  anti_shortcut_measures:
    - "Require explicit algorithm validation"
    - "Demand key-algorithm binding"
    - "Test against header injection attacks"
    - "Verify comprehensive claim validation"

# SWE-bench_Pro style fields
problem_statement: |
  A JWT-based authentication system is vulnerable to several attack vectors:
  
  1. Algorithm confusion ("none" or RS256 to HS256 switch)
  2. Key confusion (using public key as HMAC secret)
  3. kid header injection (path traversal, SQL injection)
  4. JWK/JKU header injection (attacker's public key)
  5. Weak secret allowing brute force
  6. Missing or improper claim validation
  7. Token replay after expiration
  8. Cross-service token abuse
  9. Signature stripping attacks
  10. JWT ID (jti) collision/prediction

requirements: |
  - Prevent all algorithm confusion attacks
  - Validate algorithm BEFORE verification
  - Secure key lookup preventing injection
  - Reject JWK/JKU header manipulation (or validate strictly)
  - Enforce strong secrets (256+ bits)
  - Implement comprehensive claim validation
  - Add token binding and replay prevention
  - Implement proper key rotation
  - Add audience and issuer validation
  - Implement token revocation capability

interface: |
  Input: JWT authentication code
  Output: Hardened JWT verification implementation
  Validation: All known JWT attacks blocked

# === TOPIC UNIVERSE (100+ topics) ===
topic_universe:
  jwt_fundamentals:
    - "JWT structure (header.payload.signature)"
    - "Base64URL encoding"
    - "JOSE (JSON Object Signing and Encryption)"
    - "JWS (JSON Web Signature)"
    - "JWE (JSON Web Encryption)"
    - "JWT claims (registered, public, private)"
    - "JWT best practices (RFC 8725)"
    - "Access tokens vs ID tokens"
    - "Refresh token patterns"
    - "Token introspection"
    
  signing_algorithms:
    - "HS256 (HMAC-SHA256)"
    - "HS384 (HMAC-SHA384)"
    - "HS512 (HMAC-SHA512)"
    - "RS256 (RSA-SHA256)"
    - "RS384 (RSA-SHA384)"
    - "RS512 (RSA-SHA512)"
    - "PS256 (RSA-PSS-SHA256)"
    - "PS384 (RSA-PSS-SHA384)"
    - "PS512 (RSA-PSS-SHA512)"
    - "ES256 (ECDSA-P256-SHA256)"
    - "ES384 (ECDSA-P384-SHA384)"
    - "ES512 (ECDSA-P521-SHA512)"
    - "EdDSA (Ed25519/Ed448)"
    - "None algorithm"
    
  header_attacks:
    - "alg:none attack"
    - "Algorithm switching (RS256->HS256)"
    - "kid header injection"
    - "kid SQL injection"
    - "kid path traversal"
    - "kid command injection"
    - "jku header injection"
    - "jwk header injection"
    - "x5u header injection"
    - "x5c header injection"
    - "crit header bypass"
    - "typ header manipulation"
    - "cty header attacks"
    - "zip header attacks"
    
  claim_vulnerabilities:
    - "Missing exp validation"
    - "Missing nbf validation"
    - "Missing iat validation"
    - "iss (issuer) bypass"
    - "aud (audience) confusion"
    - "sub (subject) manipulation"
    - "jti (JWT ID) prediction"
    - "Custom claim injection"
    - "Claim type confusion"
    - "Array claim bypass"
    
  key_management:
    - "Weak symmetric keys"
    - "Key brute-forcing"
    - "Key leakage in source"
    - "Key confusion (public as secret)"
    - "Key rotation issues"
    - "JWKS endpoint security"
    - "Key caching problems"
    - "Multi-tenant key isolation"
    - "Key derivation issues"
    - "Hardware security modules"
    
  library_vulnerabilities:
    - "PyJWT vulnerabilities"
    - "jsonwebtoken (Node.js) issues"
    - "jose4j vulnerabilities"
    - "nimbus-jose-jwt issues"
    - "ruby-jwt vulnerabilities"
    - "php-jwt issues"
    - "System.IdentityModel.Tokens.Jwt"
    - "go-jose vulnerabilities"
    - "jjwt issues"
    - "Library version-specific bugs"
    
  advanced_attacks:
    - "Embedded JWT attacks"
    - "JWT parsing differentials"
    - "Signature exclusion"
    - "Cross-JWT attacks"
    - "Token substitution"
    - "Token sidejacking"
    - "Refresh token theft"
    - "Token replay"
    - "Claim escalation"
    - "Multi-service confusion"
    
  encryption_topics:
    - "JWE structure"
    - "Key encryption algorithms (RSA-OAEP, A256KW)"
    - "Content encryption (A256GCM)"
    - "Nested JWT (sign then encrypt)"
    - "JWE header attacks"
    - "Key wrap vulnerabilities"
    - "AAD manipulation"
    - "IV reuse issues"
    - "Compression oracle (CRIME-like)"
    - "JWE decryption oracle"

# === ATTACK CHAINS (50+ chains) ===
attack_chains:
  algorithm_confusion:
    - name: "Algorithm None Attack"
      steps:
        - "Obtain valid JWT"
        - "Decode header and payload"
        - "Change header to {\"alg\":\"none\",\"typ\":\"JWT\"}"
        - "Remove signature (leave trailing dot)"
        - "Submit token: header.payload."
        - "Server accepts unsigned token"
      difficulty: "easy"
      payload: "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9."
      cve_references: ["CVE-2015-9235", "CVE-2018-0114"]
      
    - name: "RS256 to HS256 Confusion"
      steps:
        - "Identify RS256 signed token"
        - "Obtain server's public key (often in JWKS)"
        - "Change header alg to HS256"
        - "Sign payload using public key as HMAC secret"
        - "Submit modified token"
        - "Server uses public key for HMAC verification"
        - "Signature validates, token accepted"
      difficulty: "hard"
      cve_references: ["CVE-2016-10555", "CVE-2016-5431"]
      
    - name: "ES256 to HS256 Confusion"
      steps:
        - "Similar to RS256 attack"
        - "Use ECDSA public key as HMAC secret"
        - "Public key may need format conversion"
      difficulty: "hard"
      
  header_injection:
    - name: "kid Path Traversal"
      steps:
        - "Identify JWT with kid header"
        - "Analyze key loading mechanism"
        - "Set kid to ../../../../../../dev/null"
        - "Sign with empty key"
        - "Or: kid points to predictable file"
      difficulty: "medium"
      payload: |
        {"alg":"HS256","typ":"JWT","kid":"../../../../../../dev/null"}
      cve_references: ["CVE-2017-17405"]
      
    - name: "kid SQL Injection"
      steps:
        - "Identify kid used in database query"
        - "Inject SQL: kid=' OR '1'='1"
        - "Bypass key validation"
        - "Or extract keys via error-based SQLi"
      difficulty: "medium"
      payload: |
        {"alg":"HS256","kid":"' UNION SELECT 'secret' -- "}
        
    - name: "JWK Header Injection"
      steps:
        - "Generate attacker keypair"
        - "Embed public key in JWT header"
        - "Sign with attacker's private key"
        - "Server uses embedded JWK for verification"
        - "Attacker's signature validates"
      difficulty: "medium"
      cve_references: ["CVE-2018-0114"]
      
    - name: "JKU Header Injection"
      steps:
        - "Set jku to attacker-controlled URL"
        - "Host JWKS with attacker's public key"
        - "Sign token with attacker's private key"
        - "Server fetches attacker's JWKS"
        - "Signature validates"
      difficulty: "medium"
      
  key_attacks:
    - name: "Weak Secret Brute Force"
      steps:
        - "Obtain valid JWT"
        - "Identify HS256 algorithm"
        - "Run hashcat/john with wordlist"
        - "hashcat -m 16500 jwt.txt wordlist.txt"
        - "Recover secret"
        - "Forge tokens with recovered secret"
      difficulty: "easy"
      tools: ["hashcat", "john", "jwt-cracker"]
      
    - name: "Public Key as Secret"
      steps:
        - "Server uses public key for both RS and HS"
        - "Public key is public (obtainable)"
        - "Use public key to sign HS256 token"
        - "Server accepts token"
      difficulty: "hard"
      
  claim_manipulation:
    - name: "Expired Token Acceptance"
      steps:
        - "Obtain expired valid token"
        - "Test if exp claim is validated"
        - "Use expired token"
        - "Server accepts despite expiration"
      difficulty: "easy"
      
    - name: "Audience Confusion"
      steps:
        - "Token issued for service A"
        - "Use token against service B"
        - "Services share signing key"
        - "Service B accepts token meant for A"
      difficulty: "medium"
      
    - name: "Claim Escalation"
      steps:
        - "Obtain token with user role"
        - "Decode and modify role claim to admin"
        - "Re-sign (if key known or algorithm attack)"
        - "Achieve privilege escalation"
      difficulty: "varies"
      
  refresh_token_attacks:
    - name: "Refresh Token Theft"
      steps:
        - "Steal refresh token (XSS, log, etc.)"
        - "Use refresh token to get new access tokens"
        - "Maintain persistent access"
      difficulty: "medium"
      
    - name: "Refresh Token Replay"
      steps:
        - "Capture refresh token"
        - "Token rotated by legitimate user"
        - "Old refresh token still works"
        - "Multiple valid token sets"
      difficulty: "medium"

# === DEFENSE BYPASS TECHNIQUES (100+) ===
defense_bypass_techniques:
  algorithm_validation_bypass:
    - "Case variation: None, NONE, nOnE"
    - "Whitespace in algorithm: \" none \""
    - "Unicode characters in alg"
    - "Nested algorithm specification"
    - "Algorithm in unexpected field"
    - "Algorithm with extra parameters"
    - "Multiple algorithm headers"
    - "Empty algorithm string"
    - "Null byte in algorithm"
    - "Algorithm in JWT payload"
    
  key_validation_bypass:
    - "kid with null bytes"
    - "kid with path components"
    - "kid URL encoding"
    - "kid double encoding"
    - "kid array instead of string"
    - "kid empty string"
    - "kid pointing to /dev/null"
    - "kid pointing to empty file"
    - "kid with SSRF payload"
    - "kid with command injection"
    
  signature_bypass:
    - "Truncated signature"
    - "Empty signature"
    - "Wrong signature encoding"
    - "Signature length manipulation"
    - "Multiple signatures"
    - "Signature in header"
    - "Detached signature"
    - "Flattened JWS issues"
    - "General JWS issues"
    - "JWS compact vs JSON"
    
  claim_validation_bypass:
    - "exp as string vs number"
    - "exp in milliseconds vs seconds"
    - "Large exp value overflow"
    - "Negative nbf"
    - "aud as string vs array"
    - "Multiple aud claims"
    - "iss with trailing slash"
    - "sub with special characters"
    - "jti prediction"
    - "Custom claim type confusion"

# === REAL-WORLD SCENARIOS ===
real_world_scenarios:
  api_authentication:
    - scenario: "API Gateway JWT Validation"
      description: "API gateway validates JWTs for microservices"
      complexity: "high"
      attack_surface: ["algorithm confusion", "audience confusion", "key management"]
      
    - scenario: "Mobile App Authentication"
      description: "Mobile app uses JWTs for API access"
      complexity: "medium"
      attack_surface: ["token storage", "refresh token handling"]
      
  sso_systems:
    - scenario: "OIDC Identity Provider"
      description: "OpenID Connect provider issuing ID tokens"
      complexity: "high"
      attack_surface: ["key rotation", "multi-tenant", "claim validation"]
      
    - scenario: "Enterprise SSO"
      description: "Internal SSO with JWT tokens"
      complexity: "high"
      attack_surface: ["cross-service attacks", "privilege escalation"]
      
  microservices:
    - scenario: "Service-to-Service Auth"
      description: "JWTs for inter-service communication"
      complexity: "high"
      attack_surface: ["audience validation", "key distribution"]

# === DIFFICULTY CONFIGURATION ===
difficulty:
  estimated: "extreme"
  time_range: [7200, 21600]
  command_steps: [150, 500]
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "CTF-final level difficulty requiring expert exploitation skills"
      requirements:
        - "7+ interacting vulnerabilities requiring chained exploitation"
        - "Requires understanding of target runtime/compiler internals"
        - "Time estimate: 180+ minutes for senior security researchers"
        - "Multiple protection bypass techniques required"
        - "Requires synthesizing reverse engineering, exploitation, and cryptography"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 172800]
      command_steps: [500, 2000]
      techniques_required: 15
      description: "Real-world 0-day exploitation difficulty requiring novel bypass techniques and custom tooling"
      requirements:
        - "12+ deeply interacting vulnerabilities across authentication, cryptography, and protocol layers"
        - "Requires discovery of novel attack vectors not documented in public research"
        - "Time estimate: 12-48 hours for senior security researchers with OSCP/OSWE/OSCE certifications"
        - "Custom exploit development and gadget chain discovery required"
        - "Requires bypassing multiple security controls simultaneously (WAF, rate limiting, HSTS, certificate pinning)"
        - "Must demonstrate complete authentication bypass leading to arbitrary account takeover"
        - "Requires understanding of JVM/V8/CPython internals for exploitation"
  
  generation_targets:
    minimum_difficulty: "120-360 minutes for senior security researchers with offensive security certifications (OSCP/OSWE/OSCE)"
    quality_requirements: "Must require deep understanding of JWT RFC specifications, cryptographic primitives, and library-specific implementation details"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 8
  coordination_complexity: "extreme"
  
  specialized_agents:
    - name: "jwt_cryptanalyst"
      role: "Analyze JWT cryptographic weaknesses and key confusion attacks"
      expertise: ["JOSE standards", "algorithm confusion", "key management", "cryptographic oracle attacks"]
      
    - name: "reverse_engineer"
      role: "Reverse engineer JWT library implementations to find vulnerabilities"
      expertise: ["binary analysis", "source code review", "dependency analysis", "version-specific bugs"]
      
    - name: "exploit_developer"
      role: "Develop working exploits for identified vulnerabilities"
      expertise: ["payload crafting", "encoding bypass", "WAF evasion", "polyglot tokens"]
      
    - name: "protocol_analyst"
      role: "Analyze OAuth/OIDC protocol flows for JWT abuse"
      expertise: ["OAuth 2.0", "OpenID Connect", "token exchange", "federation attacks"]
      
    - name: "web_security_specialist"
      role: "Identify web-layer attack vectors for JWT delivery and extraction"
      expertise: ["XSS", "CSRF", "header injection", "cookie security"]
      
    - name: "infrastructure_analyst"
      role: "Analyze deployment and infrastructure for JWT-related weaknesses"
      expertise: ["JWKS endpoints", "key rotation", "caching", "microservice communication"]
      
    - name: "timing_analyst"
      role: "Identify and exploit timing side-channels in JWT verification"
      expertise: ["timing attacks", "cache timing", "statistical analysis"]
      
    - name: "fuzzer_specialist"
      role: "Fuzz JWT parsing and validation for edge cases"
      expertise: ["grammar-based fuzzing", "mutation fuzzing", "differential fuzzing"]
  
  cross_vulnerability_chains:
    - chain: "JWKS endpoint SSRF -> Internal key extraction -> Token forgery -> Admin access"
      complexity: "extreme"
      
    - chain: "Algorithm confusion -> Key confusion -> Signature bypass -> Privilege escalation"
      complexity: "high"
      
    - chain: "kid header injection -> SQL injection -> Key extraction -> Full compromise"
      complexity: "extreme"
      
    - chain: "JKU header manipulation -> Malicious JWKS hosting -> Token signing -> Account takeover"
      complexity: "high"
      
    - chain: "Timing attack on HMAC verification -> Byte-by-byte signature recovery -> Token forgery"
      complexity: "extreme"
  
  parallel_discovery_requirements:
    - "Simultaneous fuzzing of multiple JWT libraries for parsing differentials"
    - "Parallel analysis of JWKS caching behavior across CDN edge nodes"
    - "Concurrent timing measurements across geographic regions for side-channel amplification"
    - "Multi-library differential testing for algorithm negotiation vulnerabilities"

# === EXPLOIT CHAIN REQUIREMENTS ===
exploit_chain_requirements:
  minimum_chain_length: 4
  required_stages:
    - stage: "reconnaissance"
      description: "Identify JWT implementation, library versions, and key infrastructure"
      techniques:
        - "JWKS endpoint discovery and analysis"
        - "JWT library fingerprinting via error messages"
        - "Algorithm enumeration through token manipulation"
        - "Key type inference from public key endpoints"
    
    - stage: "vulnerability_identification"
      description: "Discover exploitable weaknesses in JWT handling"
      techniques:
        - "Algorithm confusion testing (RS256->HS256)"
        - "Key confusion attack surface mapping"
        - "Header injection vector analysis"
        - "Claim validation bypass enumeration"
    
    - stage: "exploit_development"
      description: "Develop working exploits for identified vulnerabilities"
      techniques:
        - "Custom JWT forging with algorithm manipulation"
        - "Key extraction via side-channels or leakage"
        - "Gadget chain construction for claim injection"
        - "Polyglot token crafting for multi-context exploitation"
    
    - stage: "privilege_escalation"
      description: "Escalate from initial access to full compromise"
      techniques:
        - "Horizontal privilege escalation via user impersonation"
        - "Vertical privilege escalation via role claim manipulation"
        - "Cross-service token abuse in microservice architectures"
        - "Persistent access via refresh token compromise"

# === DEFENSIVE EVASION ===
defensive_evasion:
  security_controls_to_bypass:
    - control: "Web Application Firewall (WAF)"
      bypass_techniques:
        - "Unicode normalization bypass for JWT header values"
        - "Chunked encoding for large token transmission"
        - "Parameter pollution to confuse WAF token parsing"
        - "HTTP/2 specific header injection"
      
    - control: "Rate Limiting"
      bypass_techniques:
        - "Distributed timing attack across multiple IP sources"
        - "Token caching exploitation to reduce verification calls"
        - "Batch verification endpoint abuse"
        - "WebSocket-based continuous token submission"
      
    - control: "Intrusion Detection Systems (IDS)"
      bypass_techniques:
        - "Low-and-slow timing attacks below detection threshold"
        - "Legitimate-looking token patterns with embedded payloads"
        - "Traffic blending with normal authentication flows"
        - "Encrypted channel abuse for attack obfuscation"
      
    - control: "Token Blacklisting/Revocation"
      bypass_techniques:
        - "Race condition between token use and revocation"
        - "Blacklist cache poisoning"
        - "JTI collision to confuse revocation checks"
        - "Refresh token abuse before access token revocation propagates"
      
    - control: "Certificate Pinning"
      bypass_techniques:
        - "JWKS endpoint on unpinned domain"
        - "Alternative token delivery via WebSocket"
        - "Server-side token validation bypass"
      
    - control: "Content Security Policy"
      bypass_techniques:
        - "Token exfiltration via allowed external domains"
        - "JSONP callback abuse on whitelisted endpoints"
        - "DNS prefetch for token leakage"

# === REAL-WORLD CORRELATION ===
real_world_correlation:
  cve_attack_patterns:
    - cve: "CVE-2015-9235"
      technique: "Algorithm none attack"
      real_world_impact: "Authentication bypass in multiple JWT libraries"
      complexity_factors: ["Library version detection", "Error message analysis", "Fallback handling"]
      
    - cve: "CVE-2016-10555"
      technique: "RS256 to HS256 algorithm confusion"
      real_world_impact: "Complete authentication bypass using public key as HMAC secret"
      complexity_factors: ["Public key extraction", "Key format conversion", "Signature crafting"]
      
    - cve: "CVE-2018-0114"
      technique: "JWK embedded key injection"
      real_world_impact: "Attacker-controlled key acceptance"
      complexity_factors: ["JWK format crafting", "Header injection", "Key validation bypass"]
      
    - cve: "CVE-2020-28042"
      technique: "Algorithm confusion in ServiceStack"
      real_world_impact: "Authentication bypass in .NET applications"
      complexity_factors: ["Framework-specific behavior", "Configuration analysis", "Payload adaptation"]
  
  threat_actor_techniques:
    - technique: "APT-style JWT infrastructure compromise"
      description: "Long-term access via compromised key management infrastructure"
      indicators: ["Unusual JWKS requests", "Key rotation anomalies", "Token pattern changes"]
      
    - technique: "Supply chain JWT library compromise"
      description: "Backdoored JWT library in dependency chain"
      indicators: ["Unexpected library behavior", "Hidden algorithm support", "Covert channels in tokens"]

# === TRAP DENSITY ===
trap_configuration:
  total_traps: 15
  trap_interaction_depth: 5
  cross_domain_traps: true
  
  trap_categories:
    algorithm_traps: 4
    header_injection_traps: 3
    claim_validation_traps: 3
    key_management_traps: 3
    timing_traps: 2

# === LLM TRAP CONFIGURATIONS (50+) ===
traps:
  algorithm_traps:
    - type: "alg_none"
      description: "JWT with alg:none bypasses signature verification"
      trigger: "Not validating algorithm before verification"
      example: |
        # WRONG
        jwt.decode(token, key)  # Library may accept "none"
        
        # RIGHT
        jwt.decode(token, key, algorithms=['HS256'])
        
    - type: "rs_hs_confusion"
      description: "RS256 public key used as HS256 secret"
      trigger: "Using same verification for symmetric/asymmetric"
      
  header_traps:
    - type: "kid_injection"
      description: "kid header used in file path without sanitization"
      trigger: "Trusting kid header for key lookup"
      example: |
        # WRONG
        key = load_key(f"/keys/{jwt_header['kid']}.pem")
        
        # RIGHT
        if not re.match(r'^[a-zA-Z0-9_-]+$', jwt_header['kid']):
            raise ValueError("Invalid kid")
        key = REGISTERED_KEYS.get(jwt_header['kid'])
        
    - type: "jwk_header"
      description: "Attacker embeds their own public key in JWT header"
      trigger: "Using key from JWK/JKU header without validation"
      
  claim_traps:
    - type: "missing_exp"
      description: "Not checking token expiration"
      trigger: "Omitting exp validation"
      
    - type: "missing_aud"
      description: "Not validating audience"
      trigger: "Token accepted for wrong service"

# === REFERENCE SOLUTION (COMPREHENSIVE) ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Secure JWT Verification Library
  
  Comprehensive protection against JWT attacks:
  1. Strict algorithm validation
  2. Key-algorithm binding
  3. Secure kid handling
  4. Comprehensive claim validation
  5. Token replay prevention
  """
  
  import json
  import hmac
  import hashlib
  import base64
  import time
  import re
  from typing import Dict, Optional, Tuple, Set, List, Any
  from dataclasses import dataclass
  from enum import Enum
  
  
  class Algorithm(Enum):
      HS256 = "HS256"
      HS384 = "HS384"
      HS512 = "HS512"
      RS256 = "RS256"
      RS384 = "RS384"
      RS512 = "RS512"
      ES256 = "ES256"
      ES384 = "ES384"
      ES512 = "ES512"
      PS256 = "PS256"
      PS384 = "PS384"
      PS512 = "PS512"
      EDDSA = "EdDSA"
  
  
  SYMMETRIC_ALGORITHMS = {Algorithm.HS256, Algorithm.HS384, Algorithm.HS512}
  ASYMMETRIC_ALGORITHMS = {Algorithm.RS256, Algorithm.RS384, Algorithm.RS512,
                           Algorithm.ES256, Algorithm.ES384, Algorithm.ES512,
                           Algorithm.PS256, Algorithm.PS384, Algorithm.PS512,
                           Algorithm.EDDSA}
  
  
  @dataclass
  class JWTSecurityConfig:
      """Configuration for secure JWT verification."""
      allowed_algorithms: Set[Algorithm]
      required_claims: Set[str] = None
      require_exp: bool = True
      require_iat: bool = True
      require_nbf: bool = False
      max_age_seconds: int = 3600
      clock_skew_seconds: int = 60
      min_secret_length: int = 32
      allowed_issuers: Set[str] = None
      allowed_audiences: Set[str] = None
      allow_jwk_header: bool = False
      allow_jku_header: bool = False
      
      def __post_init__(self):
          if self.required_claims is None:
              self.required_claims = {'exp', 'iat', 'sub'}
  
  
  def b64url_decode(data: str) -> bytes:
      """URL-safe base64 decode with padding."""
      padding = 4 - len(data) % 4
      if padding != 4:
          data += '=' * padding
      return base64.urlsafe_b64decode(data)
  
  
  def b64url_encode(data: bytes) -> str:
      """URL-safe base64 encode without padding."""
      return base64.urlsafe_b64encode(data).rstrip(b'=').decode('ascii')
  
  
  class SecureJWTVerifier:
      """
      Secure JWT verification with all attack protections.
      """
      
      def __init__(self, config: JWTSecurityConfig):
          self.config = config
          self._keys: Dict[str, Tuple[bytes, Algorithm]] = {}
          self._used_tokens: Set[str] = set()  # For replay prevention
      
      def register_key(self, kid: str, key: bytes, algorithm: Algorithm):
          """
          Register key with EXPLICIT algorithm binding.
          
          CRITICAL: Key is bound to specific algorithm.
          This prevents algorithm confusion attacks.
          """
          # Validate kid format
          if not self._validate_kid(kid):
              raise ValueError(f"Invalid kid format: {kid}")
          
          # Validate secret strength for symmetric
          if algorithm in SYMMETRIC_ALGORITHMS:
              if len(key) < self.config.min_secret_length:
                  raise ValueError(
                      f"Secret too short: {len(key)} < {self.config.min_secret_length}"
                  )
          
          # Bind key to algorithm (prevents confusion!)
          self._keys[kid] = (key, algorithm)
      
      def verify(self, token: str) -> Tuple[bool, Optional[Dict], str]:
          """
          Verify JWT with comprehensive security checks.
          
          Returns:
              (is_valid, payload, error_message)
          """
          try:
              # Split token
              parts = token.split('.')
              if len(parts) != 3:
                  return False, None, "Invalid token format"
              
              header_b64, payload_b64, signature_b64 = parts
              
              # Decode header
              try:
                  header = json.loads(b64url_decode(header_b64))
              except Exception:
                  return False, None, "Invalid header encoding"
              
              # === ALGORITHM VALIDATION (CRITICAL) ===
              alg_str = header.get('alg', '')
              
              # Reject "none" algorithm (case-insensitive)
              if alg_str.lower().strip() == 'none':
                  return False, None, "Algorithm 'none' not allowed"
              
              # Validate algorithm is known
              try:
                  algorithm = Algorithm(alg_str)
              except ValueError:
                  return False, None, f"Unknown algorithm: {alg_str}"
              
              # Check against allowlist
              if algorithm not in self.config.allowed_algorithms:
                  return False, None, f"Algorithm not allowed: {alg_str}"
              
              # === HEADER INJECTION PROTECTION ===
              
              # Reject JWK header
              if 'jwk' in header:
                  if not self.config.allow_jwk_header:
                      return False, None, "JWK header not allowed"
              
              # Reject JKU header
              if 'jku' in header:
                  if not self.config.allow_jku_header:
                      return False, None, "JKU header not allowed"
              
              # Reject x5u header (certificate URL)
              if 'x5u' in header:
                  return False, None, "x5u header not allowed"
              
              # === KEY LOOKUP ===
              kid = header.get('kid', 'default')
              
              # Validate kid (prevent injection)
              if not self._validate_kid(kid):
                  return False, None, "Invalid key ID format"
              
              if kid not in self._keys:
                  return False, None, f"Unknown key ID: {kid}"
              
              key, registered_algorithm = self._keys[kid]
              
              # === ALGORITHM-KEY BINDING (CRITICAL) ===
              # Token's algorithm must match key's registered algorithm
              if algorithm != registered_algorithm:
                  return False, None, (
                      f"Algorithm mismatch: token={algorithm.value}, "
                      f"key registered for={registered_algorithm.value}"
                  )
              
              # === SIGNATURE VERIFICATION ===
              signing_input = f"{header_b64}.{payload_b64}"
              
              try:
                  signature = b64url_decode(signature_b64)
              except Exception:
                  return False, None, "Invalid signature encoding"
              
              if not self._verify_signature(
                  signing_input.encode(), signature, key, algorithm
              ):
                  return False, None, "Invalid signature"
              
              # === PAYLOAD VALIDATION ===
              try:
                  payload = json.loads(b64url_decode(payload_b64))
              except Exception:
                  return False, None, "Invalid payload encoding"
              
              # Validate required claims
              claim_error = self._validate_claims(payload)
              if claim_error:
                  return False, None, claim_error
              
              # Check for replay (if jti present)
              if 'jti' in payload:
                  jti = payload['jti']
                  if jti in self._used_tokens:
                      return False, None, "Token already used (replay detected)"
                  self._used_tokens.add(jti)
              
              return True, payload, ""
              
          except Exception as e:
              return False, None, f"Verification error: {str(e)}"
      
      def _validate_kid(self, kid: str) -> bool:
          """
          Validate key ID to prevent injection.
          
          Only allow safe alphanumeric characters.
          """
          if not kid or len(kid) > 128:
              return False
          
          # Strict allowlist: alphanumeric, underscore, hyphen
          if not re.match(r'^[a-zA-Z0-9_-]+$', kid):
              return False
          
          # No path traversal
          if '..' in kid or '/' in kid or '\\' in kid:
              return False
          
          return True
      
      def _verify_signature(
          self, 
          data: bytes, 
          signature: bytes, 
          key: bytes,
          algorithm: Algorithm
      ) -> bool:
          """Verify signature using correct algorithm."""
          if algorithm == Algorithm.HS256:
              expected = hmac.new(key, data, hashlib.sha256).digest()
              return hmac.compare_digest(signature, expected)
          elif algorithm == Algorithm.HS384:
              expected = hmac.new(key, data, hashlib.sha384).digest()
              return hmac.compare_digest(signature, expected)
          elif algorithm == Algorithm.HS512:
              expected = hmac.new(key, data, hashlib.sha512).digest()
              return hmac.compare_digest(signature, expected)
          else:
              # For RS/ES/PS, use cryptography library
              raise NotImplementedError(f"Implement {algorithm} verification")
      
      def _validate_claims(self, payload: Dict) -> Optional[str]:
          """Validate all JWT claims."""
          now = time.time()
          
          # Check required claims present
          for claim in self.config.required_claims:
              if claim not in payload:
                  return f"Missing required claim: {claim}"
          
          # exp - Expiration
          if self.config.require_exp:
              exp = payload.get('exp')
              if exp is None:
                  return "Missing exp claim"
              if not isinstance(exp, (int, float)):
                  return "Invalid exp type"
              if now > exp + self.config.clock_skew_seconds:
                  return "Token expired"
          
          # iat - Issued At
          if self.config.require_iat:
              iat = payload.get('iat')
              if iat is None:
                  return "Missing iat claim"
              if not isinstance(iat, (int, float)):
                  return "Invalid iat type"
              # Token from future?
              if iat > now + self.config.clock_skew_seconds:
                  return "Token issued in future"
              # Token too old?
              if now - iat > self.config.max_age_seconds:
                  return "Token too old"
          
          # nbf - Not Before
          if self.config.require_nbf or 'nbf' in payload:
              nbf = payload.get('nbf')
              if nbf is not None:
                  if not isinstance(nbf, (int, float)):
                      return "Invalid nbf type"
                  if now < nbf - self.config.clock_skew_seconds:
                      return "Token not yet valid"
          
          # iss - Issuer
          if self.config.allowed_issuers:
              iss = payload.get('iss')
              if iss not in self.config.allowed_issuers:
                  return f"Invalid issuer: {iss}"
          
          # aud - Audience
          if self.config.allowed_audiences:
              aud = payload.get('aud')
              if aud is None:
                  return "Missing aud claim"
              
              # Handle both string and array
              if isinstance(aud, str):
                  audiences = {aud}
              elif isinstance(aud, list):
                  audiences = set(aud)
              else:
                  return "Invalid aud type"
              
              if not audiences & self.config.allowed_audiences:
                  return "Invalid audience"
          
          return None

# === TEST CASES ===
fail_to_pass:
  - "test_alg_none_rejected"
  - "test_rs_hs_confusion_blocked"
  - "test_kid_injection_blocked"
  - "test_jwk_header_rejected"
  - "test_weak_secret_rejected"
  - "test_expired_token_rejected"
  - "test_missing_claims_rejected"
  - "test_invalid_issuer_rejected"
  - "test_invalid_audience_rejected"
  - "test_replay_detected"

pass_to_pass:
  - "test_valid_token_accepted"
  - "test_proper_claim_validation"

# === VARIABLES FOR TASK GENERATION ===
variables:
  scenario_type:
    type: string
    options:
      - "API gateway"
      - "microservice auth"
      - "SSO provider"
      - "mobile backend"
      - "SPA authentication"
      
  path:
    type: path
    generator: random_path
    
  platform:
    type: string
    options:
      - "Node.js"
      - "Python"
      - "Java"
      - "Go"
      - ".NET"
      
  token_count:
    type: int
    min: 1000
    max: 10000000
    
  vuln_count:
    type: int
    min: 3
    max: 10
    
  task_steps:
    type: template
    value: |
      1. Audit JWT verification code
      2. Check for algorithm none vulnerability
      3. Test RS256/HS256 confusion
      4. Validate kid handling
      5. Check JWK/JKU header handling
      6. Verify secret strength
      7. Test claim validation
      8. Implement token replay prevention
      9. Test all attack vectors
      10. Document secure configuration

# === CVE REFERENCES ===
cve_references:
  - id: "CVE-2015-9235"
    description: "JWT algorithm none vulnerability"
    relevance: "Classic algorithm confusion"
    
  - id: "CVE-2016-10555"
    description: "Auth0 RS256/HS256 confusion"
    relevance: "Key confusion attack"
    
  - id: "CVE-2018-0114"
    description: "node-jose JWK injection"
    relevance: "Header injection attack"
    
  - id: "CVE-2017-17405"
    description: "JWT kid path traversal"
    relevance: "Header injection leading to key bypass"
    
  - id: "CVE-2019-20933"
    description: "InfluxDB JWT authentication bypass"
    relevance: "Empty shared secret"
    
  - id: "CVE-2020-28042"
    description: "ServiceStack JWT signature bypass"
    relevance: "Algorithm confusion"

# === ANTI-PATTERNS AND LLM FAILURE MODES ===
anti_patterns:
  llm_failure_modes:
    - "Applying textbook attack patterns without considering mitigations"
    - "Missing WAF/IDS bypass techniques for exploitation"
    - "Ignoring ASLR/PIE/NX and other modern protections"
    - "Not considering timing side-channel in crypto implementations"
    - "Missing second-order and stored attack vectors"
    - "Overlooking race conditions in authentication flows"
    - "Assuming standard libraries are secure without version checking"
    - "Missing JWT algorithm confusion and key confusion attacks"
    - "Ignoring deserialization gadget chain discovery complexity"
    - "Failing to identify library-specific JWT parsing differentials"
    - "Not recognizing JWKS caching as an attack surface"
    - "Missing kid header injection variants (SQL, LDAP, file path)"
    - "Overlooking JWE (encrypted JWT) attack vectors"
    - "Ignoring token binding and DPoP bypass techniques"
    - "Not considering cross-tenant token abuse in multi-tenant systems"
    - "Missing nested JWT attack chains"
    - "Failing to identify refresh token rotation vulnerabilities"
    - "Overlooking JWT claim type confusion attacks"
    - "Not recognizing subtle timing differences in signature verification"
    - "Missing SSRF via jku/x5u header parameters"
    - "Ignoring JWT size limits as DoS vectors"
    - "Not identifying unvalidated redirect in OAuth JWT flows"
    - "Missing JWT replay in distributed systems with clock skew"
    - "Failing to exploit JWT caching behavior differences"
    - "Overlooking JWT parsing in non-standard contexts (GraphQL, WebSocket)"
    - "Not recognizing JWT compression oracle attacks (CRIME-like)"
    - "Missing cross-origin JWT leakage via CORS misconfiguration"
    - "Ignoring JWT in URL parameters (Referer leakage)"
    - "Not identifying weak entropy in jti (JWT ID) generation"

# === ANTI-HARDCODING MEASURES ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  jwt_attack_vectors:
    - "algorithm_none"
    - "algorithm_confusion"
    - "kid_injection"
    - "jwk_header_injection"
    - "weak_secret"
    - "missing_claims"
    - "expired_token"
    - "audience_confusion"
    - "issuer_bypass"
    - "replay_attack"
    
  verification_requirements:
    - "Algorithm explicitly validated"
    - "Key-algorithm binding enforced"
    - "All registered claims validated"
    - "Strong secret requirements met"
    - "Header injection prevented"

# === LANGUAGE-SPECIFIC VULNERABILITIES ===
language_specific_vulnerabilities:
  python:
    pyjwt:
      - version: "< 2.0.0"
        vulnerability: "Algorithm confusion possible"
        fix: "Always specify algorithms parameter"
        code_example: |
          # Vulnerable
          jwt.decode(token, key)
          
          # Fixed
          jwt.decode(token, key, algorithms=['HS256'])
          
    python_jose:
      - version: "< 3.3.0"
        vulnerability: "Algorithm confusion"
        fix: "Update and specify algorithms"
        
  javascript:
    jsonwebtoken:
      - version: "< 9.0.0"
        vulnerability: "Various algorithm issues"
        fix: "Update and use allowlists"
        code_example: |
          // Vulnerable
          jwt.verify(token, publicKey);
          
          // Fixed
          jwt.verify(token, publicKey, { algorithms: ['RS256'] });
          
    jose:
      - version: "< 4.0.0"
        vulnerability: "JWK embedding issues"
        fix: "Disable JWK header acceptance"
        
  java:
    jjwt:
      - version: "< 0.12.0"
        vulnerability: "Weak key handling"
        fix: "Use SecretKeySpec with proper key length"
        
    nimbus_jose_jwt:
      - version: "< 9.0"
        vulnerability: "Algorithm confusion possible"
        fix: "Explicit algorithm validation"
        
  go:
    golang_jwt:
      - version: "v3 and below"
        vulnerability: "Algorithm confusion in some configurations"
        fix: "Migrate to v5, use explicit validation"
        
  dotnet:
    system_identitymodel:
      - version: "< 6.0"
        vulnerability: "Various JWT handling issues"
        fix: "Update and configure TokenValidationParameters"

# === TOKEN STORAGE SECURITY ===
token_storage_security:
  browser:
    localStorage:
      risk: "High - accessible via XSS"
      recommendation: "Avoid for access tokens"
      
    sessionStorage:
      risk: "Medium - accessible via XSS, cleared on tab close"
      recommendation: "Better than localStorage but still XSS vulnerable"
      
    httpOnly_cookie:
      risk: "Low - not accessible via JavaScript"
      recommendation: "Preferred for web applications"
      additional: "Set Secure, SameSite=Strict"
      
    memory:
      risk: "Low - cleared on page refresh"
      recommendation: "Good for SPAs with refresh token rotation"
      
  mobile:
    keychain_keystore:
      risk: "Low - hardware-backed security"
      recommendation: "Preferred for mobile apps"
      
    shared_preferences:
      risk: "Medium - accessible with root/jailbreak"
      recommendation: "Encrypt if used"
      
  server:
    redis:
      risk: "Low with proper configuration"
      recommendation: "Use for token revocation lists"
      
    database:
      risk: "Low with proper access control"
      recommendation: "Store hashed refresh tokens only"

# === TOKEN LIFECYCLE MANAGEMENT ===
token_lifecycle:
  access_token:
    recommended_lifetime: "5-15 minutes"
    max_lifetime: "1 hour"
    storage: "Memory or short-lived cookie"
    refresh: "Via refresh token"
    revocation: "Short lifetime makes explicit revocation optional"
    
  refresh_token:
    recommended_lifetime: "7-30 days"
    max_lifetime: "90 days"
    storage: "Secure, HttpOnly cookie or secure storage"
    rotation: "Rotate on each use"
    revocation: "Store in revocation list or database"
    
  id_token:
    recommended_lifetime: "5-60 minutes"
    usage: "One-time use for initial authentication"
    storage: "Do not store long-term"
    validation: "Validate immediately, then discard"

# === JWKS SECURITY ===
jwks_security:
  endpoint_protection:
    - "Serve over HTTPS only"
    - "Set appropriate cache headers"
    - "Consider rate limiting"
    - "Monitor for abuse"
    
  key_rotation:
    frequency: "30-90 days recommended"
    overlap: "Keep old keys valid during transition"
    kid_usage: "Always use kid to identify keys"
    announcement: "Update jwks before retiring keys"
    
  client_validation:
    - "Cache JWKS with appropriate TTL"
    - "Validate JWKS URL against allowlist"
    - "Don't follow redirects"
    - "Set request timeout"
    - "Validate response structure"

# === TESTING METHODOLOGY ===
testing_methodology:
  automated_tools:
    - name: "jwt_tool"
      description: "Python toolkit for testing JWTs"
      url: "https://github.com/ticarpi/jwt_tool"
      tests:
        - "Algorithm none"
        - "Algorithm confusion"
        - "Key confusion"
        - "Claim tampering"
        
    - name: "jwt-cracker"
      description: "Brute force weak secrets"
      url: "https://github.com/lmammino/jwt-cracker"
      
    - name: "hashcat"
      description: "GPU-accelerated JWT cracking"
      mode: "16500"
      
  manual_testing:
    - step: "Capture valid JWT"
      tool: "Burp Suite, browser dev tools"
      
    - step: "Decode and analyze"
      tool: "jwt.io, jwt_tool"
      
    - step: "Test algorithm none"
      payload: '{"alg":"none","typ":"JWT"}'
      
    - step: "Test algorithm confusion"
      from: "RS256"
      to: "HS256"
      secret: "Use public key"
      
    - step: "Test kid injection"
      payloads:
        - "../../../dev/null"
        - "' OR '1'='1"
        - "'; DROP TABLE keys; --"
        
    - step: "Test claim manipulation"
      claims: ["exp", "aud", "iss", "sub", "role"]
      
  checklist:
    - "Verify algorithm is validated before decoding"
    - "Verify algorithm allowlist is configured"
    - "Verify key-algorithm binding"
    - "Verify kid injection prevention"
    - "Verify jwk/jku header rejection"
    - "Verify exp claim is validated"
    - "Verify aud claim is validated"
    - "Verify iss claim is validated"
    - "Verify secret meets minimum length"
    - "Verify token replay is prevented"

# === COMMON MISCONFIGURATIONS ===
common_misconfigurations:
  development_keys_in_production:
    risk: "Critical"
    description: "Using development/test keys in production"
    detection: "Check for common weak secrets"
    fix: "Rotate keys, use strong secrets"
    
  disabled_verification:
    risk: "Critical"
    description: "Signature verification disabled for testing"
    detection: "Review configuration"
    fix: "Enable verification, remove test code"
    
  permissive_algorithm_list:
    risk: "High"
    description: "Accepting all algorithms including none"
    detection: "Test with alg:none"
    fix: "Explicit allowlist"
    
  missing_audience_validation:
    risk: "High"
    description: "Token from one service accepted by another"
    detection: "Test cross-service token use"
    fix: "Validate aud claim"
    
  long_lived_tokens:
    risk: "Medium"
    description: "Access tokens with multi-day expiry"
    detection: "Check exp claim values"
    fix: "Short-lived access tokens with refresh"
    
  tokens_in_logs:
    risk: "High"
    description: "JWTs logged in application logs"
    detection: "Review logging configuration"
    fix: "Filter sensitive data from logs"

# === COMPLIANCE REQUIREMENTS ===
compliance_requirements:
  pci_dss:
    - requirement: "Strong cryptography"
      jwt_impact: "Use HS256 minimum, prefer RS256/ES256"
    - requirement: "Key management"
      jwt_impact: "Secure key storage, rotation"
      
  oauth_security_bcp:
    - requirement: "Short-lived tokens"
      jwt_impact: "5-15 minute access tokens"
    - requirement: "Refresh token rotation"
      jwt_impact: "Rotate refresh tokens on use"
    - requirement: "Sender-constrained tokens"
      jwt_impact: "Consider DPoP or mTLS binding"
      
  openid_connect:
    - requirement: "ID token validation"
      jwt_impact: "Validate iss, aud, exp, iat"
    - requirement: "Nonce validation"
      jwt_impact: "Include and validate nonce claim"
