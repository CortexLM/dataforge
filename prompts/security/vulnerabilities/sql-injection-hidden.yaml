id: "sec-vuln-sqli-hidden-001"
version: "2.0.0"
category: "security"
subcategory: "vulnerabilities"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research obscure SQL injection patterns, second-order attacks, and ORM bypasses"
    phase_2_creation: "Create multi-layered SQL injection challenge with hidden injection points"
    phase_3_amplification: "Add WAF bypass, identifier injection, and stored procedure exploitation"
    phase_4_verification:
      base_validation: "Validate task requires advanced SQL injection detection and remediation"
      enhanced_criteria:
        - "Has at least 5 interacting vulnerability chains"
        - "Has cascading exploitation paths that require chained attacks"
        - "Requires knowledge of compiler/interpreter internals for exploitation"
        - "Would take experienced security researchers 45+ minutes"
  
  complexity_targets:
    min_steps: 15
    max_steps: 50
    required_expertise:
      - "SQL syntax across multiple databases"
      - "ORM internals and bypass techniques"
      - "Second-order injection patterns"
      - "Identifier injection handling"
      - "Stored procedure security"
    
  anti_shortcut_measures:
    - "Require identification of non-obvious injection points"
    - "Demand handling of identifier (table/column) injection"
    - "Test against second-order attack patterns"
    - "Verify ORM usage patterns"

# SWE-bench_Pro style fields
problem_statement: |
  A web application has passed basic SQL injection scans but still contains 
  injectable endpoints. The vulnerabilities are hidden through:
  
  1. Second-order injection (data stored then used unsafely later)
  2. Injection in ORDER BY / GROUP BY / table names (not parameterizable)
  3. Batch queries with statement concatenation
  4. ORM methods that bypass parameterization
  5. Stored procedure parameter injection
  6. Identifier injection (column/table names)
  7. LIKE clause injection
  8. IN clause construction vulnerabilities
  9. Dynamic query builders with unsafe inputs
  10. NoSQL injection in hybrid systems

requirements: |
  - Identify ALL SQL injection vectors (obvious and hidden)
  - Fix both first-order and second-order injections
  - Safely handle dynamic identifiers with allowlists
  - Use ORM correctly with parameterization
  - Secure stored procedure calls
  - Handle LIKE and IN clauses safely
  - Implement query builder security
  - Add input validation layer
  - Implement SQL query logging for monitoring
  - Handle NoSQL injection if applicable

interface: |
  Input: Application code with database queries
  Output: Injection-free code with comprehensive audit report
  Validation: No injection possible with sqlmap testing

# === TOPIC UNIVERSE (100+ topics) ===
topic_universe:
  injection_types:
    - "Classic (in-band) SQL injection"
    - "Union-based injection"
    - "Error-based injection"
    - "Blind boolean-based injection"
    - "Blind time-based injection"
    - "Out-of-band (OOB) injection"
    - "Second-order injection"
    - "Stored procedure injection"
    - "Batch query injection"
    - "Stacked queries injection"
    
  injection_locations:
    - "WHERE clause injection"
    - "ORDER BY injection"
    - "GROUP BY injection"
    - "HAVING clause injection"
    - "LIMIT/OFFSET injection"
    - "Table name injection"
    - "Column name injection"
    - "INSERT VALUES injection"
    - "UPDATE SET injection"
    - "Function parameter injection"
    
  database_specific:
    - "MySQL specific syntax"
    - "PostgreSQL specific features"
    - "Microsoft SQL Server"
    - "Oracle Database"
    - "SQLite specifics"
    - "MariaDB"
    - "Amazon Aurora"
    - "Google Cloud SQL"
    - "Azure SQL"
    - "CockroachDB"
    
  nosql_injection:
    - "MongoDB operator injection"
    - "MongoDB JavaScript injection"
    - "CouchDB injection"
    - "Redis command injection"
    - "Elasticsearch query injection"
    - "Cassandra CQL injection"
    - "DynamoDB filter injection"
    - "Neo4j Cypher injection"
    - "Firebase query manipulation"
    - "InfluxDB injection"
    
  orm_vulnerabilities:
    - "Raw query methods"
    - "Dynamic finder methods"
    - "Query builder concatenation"
    - "Unsafe interpolation"
    - "Criteria API misuse"
    - "HQL/JPQL injection"
    - "LINQ injection"
    - "ActiveRecord issues"
    - "SQLAlchemy raw queries"
    - "Sequelize literal usage"
    
  bypass_techniques:
    - "Case variation"
    - "Comment injection"
    - "Whitespace manipulation"
    - "Encoding (URL, Unicode, hex)"
    - "Alternative operators"
    - "Function-based bypass"
    - "Scientific notation"
    - "NULL byte injection"
    - "Buffer overflow in filters"
    - "Keyword fragmentation"
    
  advanced_techniques:
    - "DNS exfiltration"
    - "HTTP exfiltration"
    - "File read/write"
    - "Command execution"
    - "Privilege escalation"
    - "Hash extraction"
    - "Schema enumeration"
    - "Data exfiltration"
    - "Trigger manipulation"
    - "User creation"
    
  defense_mechanisms:
    - "Prepared statements"
    - "Parameterized queries"
    - "Stored procedures"
    - "Input validation"
    - "Allowlisting"
    - "Web Application Firewalls"
    - "Query analysis"
    - "Anomaly detection"
    - "Rate limiting"
    - "Principle of least privilege"

# === ATTACK CHAINS (50+ chains) ===
attack_chains:
  basic_injection:
    - name: "Union-Based Data Extraction"
      steps:
        - "Identify injectable parameter"
        - "Determine number of columns (ORDER BY or UNION)"
        - "Find columns displayed in output"
        - "Extract database version"
        - "Enumerate databases, tables, columns"
        - "Extract target data"
      difficulty: "medium"
      payload: "' UNION SELECT null,username,password FROM users--"
      
    - name: "Error-Based Extraction"
      steps:
        - "Identify error messages displayed"
        - "Craft payload to cause informative error"
        - "Extract data through error messages"
        - "Use EXTRACTVALUE, UPDATEXML (MySQL)"
        - "Use CONVERT for SQL Server"
      difficulty: "medium"
      payload: "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT password FROM users LIMIT 1)))--"
      
    - name: "Blind Boolean-Based"
      steps:
        - "Identify blind injection point"
        - "Create true/false conditions"
        - "Use binary search for character extraction"
        - "Automate with scripting"
        - "Extract data character by character"
      difficulty: "hard"
      payload: "' AND (SELECT SUBSTRING(password,1,1) FROM users)='a'--"
      
    - name: "Blind Time-Based"
      steps:
        - "Identify injection with no visible output"
        - "Use SLEEP/WAITFOR/pg_sleep"
        - "Measure response time differences"
        - "Extract data via timing"
      difficulty: "hard"
      payload: "' AND IF(1=1,SLEEP(5),0)--"
      
  second_order_attacks:
    - name: "Stored Username Attack"
      steps:
        - "Register with malicious username"
        - "Username stored safely"
        - "Later query uses username unsafely"
        - "Payload executes when username retrieved"
      difficulty: "hard"
      example: |
        -- Register as: admin'--
        -- Later: SELECT * FROM data WHERE creator = '$username'
        -- Becomes: SELECT * FROM data WHERE creator = 'admin'--'
        
    - name: "Profile Update Attack"
      steps:
        - "Update profile with payload in 'safe' field"
        - "Field stored in database"
        - "Another feature uses field unsafely"
        - "Injection executes in different context"
      difficulty: "hard"
      
    - name: "Password Reset Token Attack"
      steps:
        - "Inject payload in email field"
        - "Token generation uses email unsafely"
        - "Payload in reset email query"
        - "Extract tokens or data"
      difficulty: "hard"
      
  identifier_injection:
    - name: "ORDER BY Column Injection"
      steps:
        - "Identify sortable column parameter"
        - "Test for injection: ?sort=name,(SELECT...)"
        - "Bypass naive parameterization attempts"
        - "Extract data via conditional ordering"
      difficulty: "medium"
      payload: "name,(SELECT CASE WHEN (1=1) THEN 1 ELSE 1/0 END)"
      
    - name: "Table Name Injection"
      steps:
        - "Identify dynamic table selection"
        - "Inject into table name"
        - "Access unauthorized tables"
        - "Join with sensitive tables"
      difficulty: "medium"
      payload: "users;DROP TABLE users;--"
      
    - name: "Column Name Injection"
      steps:
        - "Identify dynamic column selection"
        - "Inject additional columns"
        - "Add subqueries in column list"
        - "Extract data via selected columns"
      difficulty: "hard"
      
  orm_bypass:
    - name: "Raw Query Method Exploit"
      steps:
        - "Identify ORM raw query usage"
        - "Find user input in raw query"
        - "Exploit as traditional SQL injection"
      difficulty: "medium"
      code_example: |
        # Vulnerable Django
        User.objects.raw('SELECT * FROM users WHERE id = ' + user_id)
        
    - name: "Extra/Annotate Bypass"
      steps:
        - "Identify extra()/annotate() usage"
        - "Find user input in expressions"
        - "Inject through expression parameters"
      difficulty: "hard"
      code_example: |
        # Vulnerable Django
        queryset.extra(where=[f"column = '{user_input}'"])
        
    - name: "HQL/JPQL Injection"
      steps:
        - "Identify Hibernate/JPA queries"
        - "Find string concatenation in HQL"
        - "Exploit similar to SQL injection"
        - "Access additional data"
      difficulty: "hard"
      payload: "' OR '1'='1"
      
  nosql_attacks:
    - name: "MongoDB Operator Injection"
      steps:
        - "Identify MongoDB query construction"
        - "Inject operators via JSON/object"
        - "Use $gt, $ne, $regex, $where"
        - "Bypass authentication or extract data"
      difficulty: "medium"
      payload: '{"$gt": ""}'
      
    - name: "MongoDB JavaScript Injection"
      steps:
        - "Identify $where clause usage"
        - "Inject JavaScript code"
        - "Execute arbitrary server-side JS"
      difficulty: "hard"
      payload: '"; return true; var x="'
      
    - name: "Redis Command Injection"
      steps:
        - "Identify Redis command construction"
        - "Inject additional commands via CRLF"
        - "Execute arbitrary Redis commands"
      difficulty: "medium"

# === DEFENSE BYPASS TECHNIQUES (100+) ===
defense_bypass_techniques:
  filter_bypass:
    - "Case variation: SeLeCt, SELECT, select"
    - "Comment injection: SEL/**/ECT"
    - "Whitespace alternatives: %09, %0A, %0D"
    - "URL encoding: %27 for quote"
    - "Double URL encoding: %2527"
    - "Unicode encoding: \\u0027"
    - "Hex encoding: 0x27"
    - "NULL byte: %00"
    - "Alternative operators: != vs <>"
    - "Scientific notation: 1e0"
    
  keyword_bypass:
    - "UNION ALL vs UNION"
    - "union%0aselect"
    - "/*!UNION*/ (MySQL)"
    - "SELECT%00"
    - "UnIoN SeLeCt"
    - "UN/**/ION SEL/**/ECT"
    - "UNION[whitespace]SELECT"
    - "UNION[comment]SELECT"
    - "0UNION SELECT"
    - "UNION DISTINCTROW SELECT"
    
  quote_bypass:
    - "Numeric injection (no quotes needed)"
    - "Hex encoding: 0x61646D696E"
    - "CHAR(): CHAR(97,100,109,105,110)"
    - "Concatenation: 'adm'||'in'"
    - "Double quotes (MySQL): \"admin\""
    - "Backticks (MySQL): `column`"
    - "Bracket notation (SQL Server): [column]"
    - "No quote with numeric: id=1 OR 1=1"
    - "Wide character bypass"
    - "GBK/Big5 encoding bypass"
    
  waf_bypass:
    - "HTTP Parameter Pollution"
    - "Chunked encoding"
    - "Content-Type manipulation"
    - "Large parameter count"
    - "Request method change"
    - "Path normalization"
    - "Double URL encoding"
    - "Unicode normalization"
    - "Null byte termination"
    - "Multi-part form data"
    
  function_bypass:
    - "Alternative functions: MID() vs SUBSTRING()"
    - "Database-specific functions"
    - "Custom function injection"
    - "Aggregate function abuse"
    - "Window function injection"
    - "String function chaining"
    - "Date function exploitation"
    - "Math function timing"
    - "JSON function abuse"
    - "XML function exploitation"

# === REAL-WORLD SCENARIOS ===
real_world_scenarios:
  web_applications:
    - scenario: "E-commerce Search"
      description: "Product search with sorting and filtering"
      complexity: "high"
      injection_points: ["search term", "sort column", "category filter"]
      
    - scenario: "User Management Dashboard"
      description: "Admin panel with user listing and filtering"
      complexity: "high"
      injection_points: ["search", "role filter", "date range", "export column selection"]
      
    - scenario: "Reporting System"
      description: "Dynamic report generation with custom queries"
      complexity: "high"
      injection_points: ["date range", "group by field", "metric selection"]
      
  api_endpoints:
    - scenario: "REST API with Filtering"
      description: "API supporting complex filter parameters"
      complexity: "medium"
      injection_points: ["filter[field]", "sort", "fields[]"]
      
    - scenario: "GraphQL API"
      description: "GraphQL with dynamic resolvers"
      complexity: "high"
      injection_points: ["filter arguments", "ordering", "custom directives"]
      
    - scenario: "Microservice Data Aggregation"
      description: "Service aggregating data from multiple databases"
      complexity: "high"
      injection_points: ["service parameters", "aggregation criteria"]
      
  legacy_systems:
    - scenario: "Legacy PHP Application"
      description: "Older PHP with mixed mysqli and PDO"
      complexity: "medium"
      injection_points: ["legacy query builders", "direct interpolation"]
      
    - scenario: "Enterprise Java Application"
      description: "Mix of JDBC, JPA, and native queries"
      complexity: "high"
      injection_points: ["native queries", "dynamic JPQL"]

# === DIFFICULTY CONFIGURATION ===
difficulty:
  estimated: "extreme"
  time_range: [7200, 28800]
  command_steps: [150, 600]
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "CTF-final level difficulty requiring expert exploitation skills"
      requirements:
        - "7+ interacting vulnerabilities requiring chained exploitation"
        - "Requires understanding of target runtime/compiler internals"
        - "Time estimate: 180+ minutes for senior security researchers"
        - "Multiple protection bypass techniques required"
        - "Requires synthesizing reverse engineering, exploitation, and cryptography"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 172800]
      command_steps: [500, 2000]
      techniques_required: 18
      description: "Real-world 0-day exploitation requiring novel SQL injection discovery and WAF bypass techniques"
      requirements:
        - "15+ deeply interacting vulnerabilities across application, ORM, and database layers"
        - "Requires discovery of second-order and stored injection vectors"
        - "Time estimate: 12-48 hours for senior security researchers with OSCP/OSWE/OSCE certifications"
        - "Custom WAF bypass payload development"
        - "Must bypass parameterized queries, ORM protections, and input validation"
        - "Requires understanding of database-specific SQL dialects and features"
        - "Must achieve full database compromise or RCE through SQL injection"
        - "NoSQL and hybrid database exploitation required"
  
  difficulty_levels:
    beginner:
      description: "Basic WHERE clause injection"
      time_estimate: 900
      prerequisites: ["SQL basics"]
      
    intermediate:
      description: "ORDER BY and identifier injection"
      time_estimate: 1500
      prerequisites: ["SQL advanced", "ORM basics"]
      
    advanced:
      description: "Second-order and ORM bypass"
      time_estimate: 2400
      prerequisites: ["Application architecture", "ORM internals"]
      
    expert:
      description: "Custom gadget discovery, blind exploitation"
      time_estimate: 3600
      prerequisites: ["Deep SQL", "Multiple databases", "WAF bypass"]

  generation_targets:
    minimum_difficulty: "120-360 minutes for senior security researchers with offensive security certifications (OSCP/OSWE/OSCE)"
    quality_requirements: "Must require deep understanding of SQL injection variants, ORM internals, and WAF bypass techniques"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 8
  coordination_complexity: "extreme"
  
  specialized_agents:
    - name: "sql_analyst"
      role: "Analyze SQL query construction and injection points"
      expertise: ["SQL dialects", "query parsing", "injection contexts", "identifier injection"]
      
    - name: "orm_specialist"
      role: "Analyze ORM usage and bypass techniques"
      expertise: ["Django ORM", "SQLAlchemy", "Hibernate", "ActiveRecord", "raw query abuse"]
      
    - name: "waf_bypass_specialist"
      role: "Develop WAF bypass payloads"
      expertise: ["encoding bypass", "comment injection", "case manipulation", "fragmentation"]
      
    - name: "database_specialist"
      role: "Exploit database-specific features"
      expertise: ["MySQL", "PostgreSQL", "MSSQL", "Oracle", "stored procedures"]
      
    - name: "second_order_analyst"
      role: "Identify and exploit second-order injection"
      expertise: ["stored injection", "data flow analysis", "delayed exploitation"]
      
    - name: "nosql_specialist"
      role: "Analyze and exploit NoSQL injection"
      expertise: ["MongoDB", "Redis", "Elasticsearch", "operator injection"]
      
    - name: "blind_exploitation_specialist"
      role: "Execute blind SQL injection attacks"
      expertise: ["boolean-based blind", "time-based blind", "out-of-band extraction"]
      
    - name: "data_exfiltration_specialist"
      role: "Extract and exfiltrate database contents"
      expertise: ["UNION extraction", "error-based extraction", "DNS exfiltration"]
  
  cross_vulnerability_chains:
    - chain: "ORM raw query -> SQL injection -> Stored procedure -> RCE"
      complexity: "extreme"
      
    - chain: "Second-order injection -> Privilege escalation -> Admin takeover"
      complexity: "high"
      
    - chain: "NoSQL operator injection -> Authentication bypass -> Data exfiltration"
      complexity: "high"
      
    - chain: "Identifier injection -> Schema manipulation -> Data theft"
      complexity: "extreme"
      
    - chain: "Blind SQLi -> Password hash extraction -> Offline cracking -> Account compromise"
      complexity: "high"

# === EXPLOIT CHAIN REQUIREMENTS ===
exploit_chain_requirements:
  minimum_chain_length: 4
  required_stages:
    - stage: "injection_discovery"
      description: "Identify all SQL injection entry points"
      techniques:
        - "Input fuzzing"
        - "Error message analysis"
        - "Timing analysis for blind injection"
        - "ORM raw query tracing"
    
    - stage: "context_analysis"
      description: "Determine injection context and capabilities"
      techniques:
        - "Column count enumeration"
        - "Database fingerprinting"
        - "User privilege enumeration"
        - "Available function discovery"
    
    - stage: "waf_bypass"
      description: "Bypass security controls"
      techniques:
        - "Encoding manipulation"
        - "Comment injection"
        - "Payload fragmentation"
        - "HTTP parameter pollution"
    
    - stage: "exploitation"
      description: "Extract data or achieve code execution"
      techniques:
        - "UNION-based extraction"
        - "Error-based extraction"
        - "Out-of-band exfiltration"
        - "Stacked queries for RCE"

# === DEFENSIVE EVASION ===
defensive_evasion:
  security_controls_to_bypass:
    - control: "Web Application Firewall (WAF)"
      bypass_techniques:
        - "Case manipulation: SeLeCt, UNION"
        - "Comment injection: SEL/**/ECT"
        - "Encoding: URL, Unicode, hex"
        - "HTTP parameter pollution"
        - "Chunked transfer encoding"
      
    - control: "Parameterized Queries"
      bypass_techniques:
        - "Identifier injection (ORDER BY, table name)"
        - "LIKE clause wildcard injection"
        - "IN clause construction vulnerabilities"
        - "ORM raw query method abuse"
      
    - control: "Input Validation"
      bypass_techniques:
        - "Unicode normalization bypass"
        - "Double encoding"
        - "Alternative syntax"
        - "Semantic equivalent payloads"
      
    - control: "Least Privilege Database User"
      bypass_techniques:
        - "Privilege escalation via SQL"
        - "Cross-database access"
        - "Stored procedure abuse"
        - "File read/write primitives"

# === REAL-WORLD CORRELATION ===
real_world_correlation:
  cve_attack_patterns:
    - cve: "CVE-2019-8331"
      technique: "Bootstrap SQL injection chain"
      real_world_impact: "Data theft via second-order injection"
      
    - cve: "CVE-2021-42013"
      technique: "Apache path traversal to injection"
      real_world_impact: "RCE through SQL injection chain"

# === TRAP DENSITY ===
trap_configuration:
  total_traps: 14
  trap_interaction_depth: 4
  cross_domain_traps: true
  
  trap_categories:
    obvious_traps: 3
    subtle_traps: 5
    framework_traps: 4
    nosql_traps: 2

# === LLM TRAP CONFIGURATIONS (50+) ===
traps:
  obvious_traps:
    - type: "string_concatenation"
      description: "Direct string concatenation in query"
      trigger: "sql = 'SELECT * FROM users WHERE id = ' + user_id"
      detection: "Static analysis, grep for concatenation"
      
    - type: "format_string"
      description: "Using format string with user input"
      trigger: "sql = f'SELECT * FROM users WHERE name = \"{name}\"'"
      detection: "Static analysis"
      
  subtle_traps:
    - type: "second_order"
      description: "User input stored safely but used unsafely later"
      trigger: "Only checking injection at input point"
      example: |
        # Safe storage
        cursor.execute("INSERT INTO profiles (bio) VALUES (%s)", [user_bio])
        # Unsafe use later
        cursor.execute(f"SELECT * FROM logs WHERE context = '{bio}'")
        
    - type: "identifier_injection"
      description: "Table or column name from user input"
      trigger: "Using parameterized query for identifier"
      example: |
        # WRONG - identifiers can't be parameterized
        cursor.execute("SELECT * FROM %s WHERE id = %s", [table_name, id])
        
    - type: "orm_raw_query"
      description: "ORM's raw query method used with concatenation"
      trigger: "Trusting ORM to always parameterize"
      example: |
        # Django vulnerable
        User.objects.raw('SELECT * FROM users WHERE role = ' + role)
        
    - type: "batch_concatenation"
      description: "Multiple queries concatenated as string"
      trigger: "Building batch queries with string formatting"
      
    - type: "like_clause"
      description: "LIKE clause without escaping wildcards"
      trigger: "User input in LIKE without % and _ escaping"
      example: |
        # Vulnerable: user can inject % to match all
        cursor.execute("SELECT * FROM users WHERE name LIKE %s", [f"%{search}%"])
        
    - type: "in_clause"
      description: "IN clause built by joining array"
      trigger: "','.join(user_ids) in IN clause"
      
    - type: "stored_procedure"
      description: "Stored procedure with internal dynamic SQL"
      trigger: "Parameterized call to proc with unsafe internals"

# === COMPREHENSIVE TASK GENERATION TEMPLATE ===
instruction_template: |
  You are auditing a {{ scenario_type }} for SQL injection vulnerabilities.
  The code is at {{ path }}.
  
  System details:
  - Database: {{ database_type }}
  - Language: {{ language }}
  - Framework: {{ framework }}
  - ORM: {{ orm_name }}
  
  Initial automated scan found: {{ scan_findings }} potential issues
  After manual review: {{ actual_issues }} confirmed vulnerabilities
  
  Attack model:
  - Attacker capability: {{ attacker_capability }}
  - Data sensitivity: {{ data_sensitivity }}
  - Authentication state: {{ auth_state }}
  
  Your task:
  {{ task_steps }}
  
  Additional requirements:
  - All queries must use parameterization
  - Identifiers must use allowlist validation
  - ORM raw queries must be audited
  - Second-order vectors must be identified
  - Input validation must be comprehensive

# === REFERENCE SOLUTION (COMPREHENSIVE) ===
reference_solution: |
  #!/usr/bin/env python3
  """
  SQL Injection Prevention Library
  
  Comprehensive protection against SQL injection:
  1. Parameterized queries
  2. Identifier validation (allowlist)
  3. ORM safe patterns
  4. Input validation
  5. Query logging and monitoring
  """
  
  import re
  from typing import List, Dict, Optional, Any, Tuple, Set, Union
  from dataclasses import dataclass
  from enum import Enum
  import logging
  
  
  class InjectionType(Enum):
      """Types of SQL injection vulnerabilities."""
      FIRST_ORDER = "first_order"
      SECOND_ORDER = "second_order"
      IDENTIFIER = "identifier"
      STORED_PROC = "stored_procedure"
      BATCH = "batch"
      LIKE_CLAUSE = "like_clause"
      IN_CLAUSE = "in_clause"
      ORM_RAW = "orm_raw"
      
      
  @dataclass
  class SQLInjectionFinding:
      """Record of SQL injection finding."""
      injection_type: InjectionType
      location: str
      vulnerable_param: str
      description: str
      fix_suggestion: str
      severity: str
  
  
  # ============================================================
  # IDENTIFIER VALIDATION
  # ============================================================
  
  # Allowlists for identifiers (cannot be parameterized)
  ALLOWED_TABLES: Set[str] = {
      'users', 'orders', 'products', 'categories',
      'reviews', 'inventory', 'customers', 'addresses',
  }
  
  ALLOWED_COLUMNS: Set[str] = {
      'id', 'name', 'email', 'created_at', 'updated_at',
      'status', 'price', 'quantity', 'description',
      'user_id', 'product_id', 'order_id', 'category_id',
  }
  
  ALLOWED_ORDER_DIRECTIONS: Set[str] = {'ASC', 'DESC'}
  
  
  def validate_identifier(identifier: str, allowed: Set[str]) -> bool:
      """
      Validate SQL identifier against allowlist.
      
      Identifiers (table/column names) CANNOT be parameterized.
      The ONLY safe approach is allowlist validation.
      
      Args:
          identifier: Identifier to validate
          allowed: Set of allowed identifiers
          
      Returns:
          True if identifier is in allowlist
      """
      if not identifier:
          return False
      
      # Case-insensitive comparison
      return identifier.lower() in {i.lower() for i in allowed}
  
  
  def safe_identifier(identifier: str, allowed: Set[str], default: str) -> str:
      """
      Return validated identifier or default value.
      
      Args:
          identifier: User-provided identifier
          allowed: Allowlist
          default: Default if validation fails
          
      Returns:
          Safe identifier value
      """
      if validate_identifier(identifier, allowed):
          return identifier
      
      logging.warning(f"Invalid identifier rejected: {identifier}")
      return default
  
  
  def quote_identifier(identifier: str, dialect: str = 'standard') -> str:
      """
      Quote identifier for SQL dialect.
      
      NOTE: Quoting alone is NOT sufficient protection.
      Always use allowlist validation first.
      
      Args:
          identifier: Pre-validated identifier
          dialect: SQL dialect
          
      Returns:
          Quoted identifier
      """
      # First validate against allowlist
      if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', identifier):
          raise ValueError(f"Invalid identifier characters: {identifier}")
      
      if dialect == 'mysql':
          return f'`{identifier}`'
      elif dialect == 'sqlserver':
          return f'[{identifier}]'
      else:  # standard, postgresql
          return f'"{identifier}"'
  
  
  # ============================================================
  # SAFE QUERY BUILDER
  # ============================================================
  
  class SafeQueryBuilder:
      """
      Build SQL queries safely with proper parameterization.
      
      Handles all SQL injection vectors:
      - WHERE clause (parameterized)
      - ORDER BY (allowlist validated)
      - LIMIT/OFFSET (type validated)
      - LIKE (wildcard escaped)
      - IN clause (proper parameterization)
      """
      
      def __init__(self, db_connection, dialect: str = 'standard'):
          """
          Initialize with database connection.
          
          Args:
              db_connection: Database connection object
              dialect: SQL dialect (mysql, postgresql, sqlserver, standard)
          """
          self.conn = db_connection
          self.dialect = dialect
      
      def select(
          self,
          table: str,
          columns: List[str] = None,
          where: Dict[str, Any] = None,
          where_like: Dict[str, str] = None,
          where_in: Dict[str, List] = None,
          order_by: str = None,
          order_dir: str = 'ASC',
          limit: int = None,
          offset: int = None
      ) -> Tuple[str, List]:
          """
          Build safe SELECT query.
          
          Args:
              table: Table name (validated against allowlist)
              columns: Column list (validated against allowlist)
              where: WHERE conditions (parameterized)
              where_like: LIKE conditions (wildcards escaped)
              where_in: IN conditions (properly parameterized)
              order_by: ORDER BY column (validated)
              order_dir: Order direction (validated)
              limit: LIMIT value (type validated)
              offset: OFFSET value (type validated)
              
          Returns:
              Tuple of (query_string, parameters)
          """
          # Validate table name
          if not validate_identifier(table, ALLOWED_TABLES):
              raise ValueError(f"Invalid table: {table}")
          
          # Validate columns
          if columns is None:
              columns = ['*']
          else:
              validated_cols = []
              for col in columns:
                  if col == '*':
                      validated_cols.append('*')
                  elif validate_identifier(col, ALLOWED_COLUMNS):
                      validated_cols.append(col)
                  else:
                      raise ValueError(f"Invalid column: {col}")
              columns = validated_cols
          
          # Build base query
          query = f"SELECT {', '.join(columns)} FROM {table}"
          params = []
          
          # Build WHERE clause
          conditions = []
          
          # Equality conditions (parameterized)
          if where:
              for key, value in where.items():
                  if not validate_identifier(key, ALLOWED_COLUMNS):
                      raise ValueError(f"Invalid column in WHERE: {key}")
                  conditions.append(f"{key} = %s")
                  params.append(value)
          
          # LIKE conditions (wildcards escaped)
          if where_like:
              for key, value in where_like.items():
                  if not validate_identifier(key, ALLOWED_COLUMNS):
                      raise ValueError(f"Invalid column in LIKE: {key}")
                  # Escape wildcards in user input
                  escaped = self._escape_like(value)
                  conditions.append(f"{key} LIKE %s")
                  params.append(f"%{escaped}%")
          
          # IN conditions
          if where_in:
              for key, values in where_in.items():
                  if not validate_identifier(key, ALLOWED_COLUMNS):
                      raise ValueError(f"Invalid column in IN: {key}")
                  if not values:
                      # Empty IN = no results
                      conditions.append("1=0")
                  else:
                      placeholders = ', '.join(['%s'] * len(values))
                      conditions.append(f"{key} IN ({placeholders})")
                      params.extend(values)
          
          if conditions:
              query += " WHERE " + " AND ".join(conditions)
          
          # ORDER BY (identifier validated)
          if order_by:
              if not validate_identifier(order_by, ALLOWED_COLUMNS):
                  raise ValueError(f"Invalid ORDER BY column: {order_by}")
              order_dir = safe_identifier(
                  order_dir.upper(), 
                  ALLOWED_ORDER_DIRECTIONS, 
                  'ASC'
              )
              query += f" ORDER BY {order_by} {order_dir}"
          
          # LIMIT and OFFSET (type validated)
          if limit is not None:
              query += " LIMIT %s"
              params.append(int(limit))
          
          if offset is not None:
              query += " OFFSET %s"
              params.append(int(offset))
          
          return query, params
      
      def insert(
          self,
          table: str,
          data: Dict[str, Any]
      ) -> Tuple[str, List]:
          """Build safe INSERT query."""
          if not validate_identifier(table, ALLOWED_TABLES):
              raise ValueError(f"Invalid table: {table}")
          
          columns = []
          placeholders = []
          params = []
          
          for key, value in data.items():
              if not validate_identifier(key, ALLOWED_COLUMNS):
                  raise ValueError(f"Invalid column: {key}")
              columns.append(key)
              placeholders.append('%s')
              params.append(value)
          
          query = f"INSERT INTO {table} ({', '.join(columns)}) VALUES ({', '.join(placeholders)})"
          return query, params
      
      def update(
          self,
          table: str,
          data: Dict[str, Any],
          where: Dict[str, Any]
      ) -> Tuple[str, List]:
          """Build safe UPDATE query."""
          if not validate_identifier(table, ALLOWED_TABLES):
              raise ValueError(f"Invalid table: {table}")
          
          if not where:
              raise ValueError("UPDATE without WHERE is dangerous")
          
          set_clause = []
          params = []
          
          for key, value in data.items():
              if not validate_identifier(key, ALLOWED_COLUMNS):
                  raise ValueError(f"Invalid column: {key}")
              set_clause.append(f"{key} = %s")
              params.append(value)
          
          where_clause = []
          for key, value in where.items():
              if not validate_identifier(key, ALLOWED_COLUMNS):
                  raise ValueError(f"Invalid column in WHERE: {key}")
              where_clause.append(f"{key} = %s")
              params.append(value)
          
          query = f"UPDATE {table} SET {', '.join(set_clause)} WHERE {' AND '.join(where_clause)}"
          return query, params
      
      def delete(
          self,
          table: str,
          where: Dict[str, Any]
      ) -> Tuple[str, List]:
          """Build safe DELETE query."""
          if not validate_identifier(table, ALLOWED_TABLES):
              raise ValueError(f"Invalid table: {table}")
          
          if not where:
              raise ValueError("DELETE without WHERE is dangerous")
          
          where_clause = []
          params = []
          
          for key, value in where.items():
              if not validate_identifier(key, ALLOWED_COLUMNS):
                  raise ValueError(f"Invalid column in WHERE: {key}")
              where_clause.append(f"{key} = %s")
              params.append(value)
          
          query = f"DELETE FROM {table} WHERE {' AND '.join(where_clause)}"
          return query, params
      
      def _escape_like(self, value: str) -> str:
          """
          Escape LIKE wildcards in user input.
          
          Prevents users from using % and _ to match arbitrary patterns.
          """
          return value.replace('\\', '\\\\').replace('%', '\\%').replace('_', '\\_')
  
  
  # ============================================================
  # SECOND-ORDER INJECTION PROTECTION
  # ============================================================
  
  class TaintTracker:
      """
      Track tainted data through application.
      
      Helps identify second-order injection risks by marking
      data that originated from user input.
      """
      
      def __init__(self):
          self._tainted: Dict[int, str] = {}  # id -> source
      
      def mark_tainted(self, value: str, source: str) -> str:
          """
          Mark data as tainted.
          
          Args:
              value: Data value
              source: Source of data (e.g., "user_input", "database")
              
          Returns:
              The same value (for chaining)
          """
          self._tainted[id(value)] = source
          return value
      
      def is_tainted(self, value: str) -> bool:
          """Check if data is tainted."""
          return id(value) in self._tainted
      
      def get_source(self, value: str) -> Optional[str]:
          """Get taint source."""
          return self._tainted.get(id(value))
      
      def validate_for_identifier(self, value: str, allowed: Set[str]) -> Optional[str]:
          """
          Validate potentially tainted data for use as identifier.
          
          Returns None if not in allowlist.
          """
          if validate_identifier(value, allowed):
              return value
          
          if self.is_tainted(value):
              logging.warning(
                  f"Tainted data rejected for identifier use: "
                  f"value={value}, source={self.get_source(value)}"
              )
          
          return None
  
  
  # ============================================================
  # STORED PROCEDURE SECURITY
  # ============================================================
  
  # Allowed stored procedures
  ALLOWED_PROCEDURES: Set[str] = {
      'get_user_orders',
      'update_status',
      'calculate_total',
      'search_products',
  }
  
  
  def safe_stored_procedure_call(
      conn,
      proc_name: str,
      params: Dict[str, Any]
  ) -> Any:
      """
      Safely call stored procedure.
      
      Args:
          conn: Database connection
          proc_name: Procedure name (validated against allowlist)
          params: Parameters (parameterized)
          
      Returns:
          Procedure result
      """
      # Validate procedure name
      if proc_name not in ALLOWED_PROCEDURES:
          raise ValueError(f"Invalid procedure: {proc_name}")
      
      # Build parameterized CALL
      param_placeholders = ', '.join(['%s'] * len(params))
      query = f"CALL {proc_name}({param_placeholders})"
      
      cursor = conn.cursor()
      cursor.execute(query, list(params.values()))
      return cursor.fetchall()
  
  
  # ============================================================
  # INPUT VALIDATION
  # ============================================================
  
  class InputValidator:
      """
      Validate and sanitize user input before database operations.
      
      Defense in depth - even with parameterized queries,
      input validation provides additional protection.
      """
      
      # Common patterns
      PATTERNS = {
          'email': r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
          'username': r'^[a-zA-Z0-9_-]{3,32}$',
          'uuid': r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
          'integer': r'^-?\d+$',
          'positive_integer': r'^\d+$',
          'alphanumeric': r'^[a-zA-Z0-9]+$',
      }
      
      @classmethod
      def validate(cls, value: str, pattern_name: str) -> bool:
          """Validate value against named pattern."""
          pattern = cls.PATTERNS.get(pattern_name)
          if not pattern:
              raise ValueError(f"Unknown pattern: {pattern_name}")
          
          return bool(re.match(pattern, value))
      
      @classmethod
      def validate_length(
          cls, 
          value: str, 
          min_len: int = 0, 
          max_len: int = 1000
      ) -> bool:
          """Validate string length."""
          return min_len <= len(value) <= max_len
      
      @classmethod
      def sanitize_search(cls, value: str) -> str:
          """
          Sanitize search input.
          
          Remove potentially dangerous characters while preserving
          useful search functionality.
          """
          # Remove control characters
          value = re.sub(r'[\x00-\x1f\x7f]', '', value)
          
          # Limit length
          value = value[:200]
          
          # Remove SQL comment sequences
          value = re.sub(r'--', '', value)
          value = re.sub(r'/\*.*?\*/', '', value)
          
          return value.strip()
  
  
  # ============================================================
  # SQL AUDIT UTILITIES
  # ============================================================
  
  def detect_sqli_patterns(code: str) -> List[SQLInjectionFinding]:
      """
      Detect SQL injection patterns in code.
      
      Static analysis for common vulnerabilities.
      """
      findings = []
      
      patterns = [
          # String formatting in SQL
          (r'f"[^"]*SELECT[^"]*{[^}]+}', InjectionType.FIRST_ORDER,
           "F-string in SQL query", "high"),
          (r'f\'[^\']*SELECT[^\']*{[^}]+}', InjectionType.FIRST_ORDER,
           "F-string in SQL query", "high"),
          (r'\.format\([^)]*\).*SELECT', InjectionType.FIRST_ORDER,
           "String format in SQL", "high"),
          (r'%\s*\([^)]+\).*SELECT', InjectionType.FIRST_ORDER,
           "% formatting in SQL", "high"),
          
          # Concatenation
          (r'SELECT.*\+\s*[\'"]', InjectionType.FIRST_ORDER,
           "String concatenation in SELECT", "high"),
          (r'WHERE.*\+\s*[\'"]', InjectionType.FIRST_ORDER,
           "String concatenation in WHERE", "high"),
          
          # ORDER BY issues
          (r'ORDER\s+BY\s*[\'"]?\s*\+', InjectionType.IDENTIFIER,
           "Concatenation in ORDER BY", "medium"),
          (r'ORDER\s+BY\s*%s', InjectionType.IDENTIFIER,
           "Parameterized ORDER BY (identifiers cannot be parameterized)", "medium"),
          
          # Raw ORM queries
          (r'\.raw\([^)]*%', InjectionType.ORM_RAW,
           "ORM raw query with formatting", "high"),
          (r'\.raw\([^)]*\+', InjectionType.ORM_RAW,
           "ORM raw query with concatenation", "high"),
          (r'\.extra\(.*where.*%', InjectionType.ORM_RAW,
           "Django extra() with formatting", "high"),
      ]
      
      for pattern, inj_type, desc, severity in patterns:
          if re.search(pattern, code, re.IGNORECASE):
              findings.append(SQLInjectionFinding(
                  injection_type=inj_type,
                  location="detected",
                  vulnerable_param="unknown",
                  description=desc,
                  fix_suggestion="Use parameterized queries",
                  severity=severity
              ))
      
      return findings

# === TEST CASES ===
fail_to_pass:
  - "test_second_order_injection_blocked"
  - "test_identifier_injection_blocked"
  - "test_orm_raw_query_safe"
  - "test_stored_procedure_safe"
  - "test_like_clause_escaped"
  - "test_in_clause_parameterized"
  - "test_order_by_validated"
  - "test_no_string_concatenation"
  - "test_batch_queries_safe"
  - "test_nosql_injection_blocked"

pass_to_pass:
  - "test_basic_parameterized_query"
  - "test_select_with_where"
  - "test_insert_with_params"
  - "test_update_with_params"

# === VARIABLES FOR TASK GENERATION ===
variables:
  scenario_type:
    type: string
    options:
      - "e-commerce platform"
      - "content management system"
      - "user management portal"
      - "reporting dashboard"
      - "API backend"
      - "data analytics platform"
      - "inventory system"
      - "booking system"
      
  path:
    type: path
    generator: random_path
    
  database_type:
    type: string
    options:
      - "MySQL 8.0"
      - "PostgreSQL 15"
      - "SQL Server 2022"
      - "SQLite"
      - "MariaDB"
      - "MongoDB 6"
      
  language:
    type: string
    options:
      - "Python"
      - "Java"
      - "PHP"
      - "Node.js"
      - "Ruby"
      - "C#"
      
  framework:
    type: string
    options:
      - "Django"
      - "Flask"
      - "Spring Boot"
      - "Laravel"
      - "Express.js"
      - "Rails"
      
  orm_name:
    type: string
    options:
      - "Django ORM"
      - "SQLAlchemy"
      - "Hibernate"
      - "Eloquent"
      - "Sequelize"
      - "ActiveRecord"
      - "Entity Framework"
      
  scan_findings:
    type: int
    min: 0
    max: 10
    
  actual_issues:
    type: int
    min: 5
    max: 30
    
  attacker_capability:
    type: string
    options:
      - "Unauthenticated"
      - "Authenticated user"
      - "Admin user"
      
  data_sensitivity:
    type: string
    options:
      - "Public data"
      - "User PII"
      - "Financial data"
      - "Healthcare data"
      
  auth_state:
    type: string
    options:
      - "Pre-authentication"
      - "Post-authentication"
      - "Admin context"
      
  task_steps:
    type: template
    value: |
      1. Audit all database query construction
      2. Map user input to query parameters
      3. Find second-order injection vectors
      4. Identify identifier injection points
      5. Check ORM usage for raw queries
      6. Secure stored procedure calls
      7. Implement allowlist for identifiers
      8. Parameterize all value inputs
      9. Add input validation layer
      10. Implement query logging
      11. Test with sqlmap
      12. Verify all fixes

# === ANTI-PATTERNS AND LLM FAILURE MODES ===
anti_patterns:
  llm_failure_modes:
    - "Applying textbook attack patterns without considering mitigations"
    - "Missing WAF/IDS bypass techniques for exploitation"
    - "Ignoring ASLR/PIE/NX and other modern protections"
    - "Not considering timing side-channel in crypto implementations"
    - "Missing second-order and stored attack vectors"
    - "Overlooking race conditions in authentication flows"
    - "Assuming standard libraries are secure without version checking"
    - "Missing JWT algorithm confusion and key confusion attacks"
    - "Ignoring deserialization gadget chain discovery complexity"
    - "Not recognizing ORM raw query methods as injection vectors"
    - "Missing Django extra() and annotate() injection techniques"
    - "Overlooking Hibernate HQL/JPQL injection"
    - "Failing to identify identifier injection (ORDER BY, table names)"
    - "Not considering LIKE clause wildcard injection"
    - "Missing IN clause array construction vulnerabilities"
    - "Ignoring stored procedure parameter injection"
    - "Not recognizing batch query concatenation risks"
    - "Overlooking second-order injection via profile/settings storage"
    - "Missing MongoDB operator injection ($gt, $ne, $regex)"
    - "Failing to identify MongoDB $where JavaScript injection"
    - "Not considering Redis CRLF injection"
    - "Ignoring Elasticsearch query DSL injection"
    - "Missing GraphQL resolver SQL injection"
    - "Not recognizing database-specific syntax bypass (MySQL comments, MSSQL batching)"
    - "Overlooking error-based injection via EXTRACTVALUE/UPDATEXML"
    - "Failing to identify time-based blind via database-specific delays"
    - "Not considering out-of-band extraction via DNS/HTTP"
    - "Missing file read/write primitives (LOAD_FILE, INTO OUTFILE)"
    - "Ignoring privilege escalation via SQL (CREATE USER, GRANT)"

# === ANTI-HARDCODING MEASURES ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  injection_vectors:
    - "stored_then_used"
    - "dynamic_table_name"
    - "order_by_column"
    - "orm_raw_method"
    - "like_wildcard"
    - "in_clause_array"
    - "batch_query"
    - "stored_procedure"
    
  verification_requirements:
    - "All queries parameterized"
    - "Identifiers use allowlist"
    - "ORM raw queries audited"
    - "sqlmap test passes"

# === CVE REFERENCES ===
cve_references:
  - id: "CVE-2019-8331"
    description: "Bootstrap XSS via SQL injection"
    relevance: "Second-order attack"
    
  - id: "CVE-2021-42013"
    description: "Apache HTTPD path traversal to RCE"
    relevance: "Injection leading to RCE"

# === TOOL RECOMMENDATIONS ===
tools:
  exploitation:
    - "sqlmap"
    - "SQLNinja"
    - "Havij"
    - "jSQL Injection"
    - "BBQSQL"
    
  detection:
    - "OWASP ZAP"
    - "Burp Suite"
    - "Nikto"
    - "Acunetix"
    - "SQLi Hunter"
    
  static_analysis:
    - "Semgrep"
    - "CodeQL"
    - "SonarQube"
    - "Bandit (Python)"
    - "Brakeman (Ruby)"
