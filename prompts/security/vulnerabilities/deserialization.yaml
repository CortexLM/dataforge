id: "sec-vuln-deserialization-001"
version: "2.0.0"
category: "security"
subcategory: "vulnerabilities"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research obscure deserialization gadgets, property-oriented programming, and bypass techniques"
    phase_2_creation: "Create multi-layered insecure deserialization challenge with hidden RCE vectors"
    phase_3_amplification: "Add WAF bypass, gadget chain discovery, and polyglot payload requirements"
    phase_4_verification:
      base_validation: "Validate task requires advanced exploitation and remediation expertise"
      enhanced_criteria:
        - "Has at least 5 interacting vulnerability chains"
        - "Has cascading exploitation paths that require chained attacks"
        - "Requires knowledge of compiler/interpreter internals for exploitation"
        - "Would take experienced security researchers 45+ minutes"
  
  complexity_targets:
    min_steps: 15
    max_steps: 50
    required_expertise:
      - "Object serialization internals"
      - "Gadget chain construction"
      - "Property-oriented programming"
      - "Language runtime internals"
      - "Memory corruption via deserialization"
    
  anti_shortcut_measures:
    - "Require identification of non-obvious deserialization sinks"
    - "Demand gadget chain analysis"
    - "Test against allowlist bypass techniques"
    - "Verify defense-in-depth measures"

# SWE-bench_Pro style fields
problem_statement: |
  An application deserializes user-controlled data, leading to remote code execution 
  vulnerabilities. The insecure deserialization occurs in:
  
  1. Python pickle/marshal loading from untrusted sources
  2. Java ObjectInputStream with gadget chains
  3. PHP unserialize with magic methods
  4. YAML/JSON with type coercion and custom constructors
  5. XML external entity (XXE) in XML parsers
  6. .NET BinaryFormatter and related formatters
  7. Ruby Marshal.load exploitation
  8. Node.js node-serialize vulnerabilities
  9. Protobuf with custom message handlers
  10. MessagePack with extension types

requirements: |
  - Identify ALL deserialization entry points (obvious and hidden)
  - Replace unsafe deserializers with safe alternatives
  - Implement strict input validation before deserialization
  - Use type allowlists for permitted classes
  - Add integrity verification (cryptographic signatures)
  - Remove dangerous gadget classes from classpath
  - Implement deserialization firewalls
  - Add logging and alerting for deserialization attempts
  - Handle legacy data migration securely
  - Implement proper error handling without leaking information

interface: |
  Input: Code with deserialization vulnerabilities
  Output: Safe deserialization implementation with defense-in-depth
  Validation: No RCE possible through any deserialization path

# === TOPIC UNIVERSE (100+ topics) ===
topic_universe:
  serialization_formats:
    - "Java ObjectOutputStream/ObjectInputStream"
    - "Python pickle (all protocols)"
    - "Python marshal"
    - "PHP serialize/unserialize"
    - "Ruby Marshal"
    - ".NET BinaryFormatter"
    - ".NET DataContractSerializer"
    - ".NET NetDataContractSerializer"
    - ".NET SoapFormatter"
    - ".NET LosFormatter"
    - ".NET ObjectStateFormatter"
    - "YAML (PyYAML, SnakeYAML, JS-YAML)"
    - "JSON with custom deserializers"
    - "XML with DTD processing"
    - "MessagePack"
    - "Protocol Buffers"
    - "Apache Thrift"
    - "Apache Avro"
    - "BSON (MongoDB)"
    - "CBOR"
    
  java_gadget_chains:
    - "Apache Commons Collections (CC1-CC7)"
    - "Apache Commons Beanutils"
    - "Spring Framework gadgets"
    - "JDK built-in gadgets"
    - "Hibernate gadgets"
    - "Jython gadgets"
    - "Groovy gadgets"
    - "ROME gadgets"
    - "Myfaces gadgets"
    - "Mojarra gadgets"
    - "Vaadin gadgets"
    - "Click gadgets"
    - "Wicket gadgets"
    - "BeanShell gadgets"
    - "C3P0 gadgets"
    - "JNDI injection gadgets"
    - "LDAP gadgets"
    - "RMI gadgets"
    - "JMX gadgets"
    - "AspectJWeaver gadgets"
    
  python_exploitation:
    - "pickle __reduce__ method exploitation"
    - "pickle __reduce_ex__ exploitation"
    - "pickle __getstate__/__setstate__"
    - "marshal code object injection"
    - "PyYAML !!python/object/apply"
    - "PyYAML !!python/object/new"
    - "ruamel.yaml exploitation"
    - "cloudpickle vulnerabilities"
    - "dill pickle extension attacks"
    - "jsonpickle exploitation"
    
  php_exploitation:
    - "PHP object injection via unserialize"
    - "__wakeup magic method abuse"
    - "__destruct magic method chains"
    - "__toString method exploitation"
    - "Phar metadata deserialization"
    - "SoapClient SSRF"
    - "SimpleXMLElement XXE"
    - "PDO connection string injection"
    - "PHP stream wrapper abuse"
    - "GMP type juggling"
    
  dotnet_exploitation:
    - "BinaryFormatter RCE"
    - "TypeNameHandling in JSON.NET"
    - "ObjectDataProvider gadget"
    - "TextFormattingRunProperties"
    - "WindowsIdentity gadget"
    - "ClaimsIdentity gadget"
    - "SessionSecurityToken"
    - "ActivitySurrogateSelector"
    - "PSObject gadget"
    - "XamlReader exploitation"
    
  ruby_exploitation:
    - "Marshal.load exploitation"
    - "YAML.load (Psych) exploitation"
    - "ERB template injection via deserialization"
    - "Gem::Requirement gadget"
    - "Gem::Specification gadget"
    - "Rack::Utils YAML parsing"
    - "ActiveRecord deserialization"
    - "Rails CVE chains"
    - "Draper decorator gadgets"
    - "Delayed::Job exploitation"
    
  javascript_exploitation:
    - "node-serialize RCE"
    - "js-yaml exploitation"
    - "serialize-javascript issues"
    - "cryo.parse exploitation"
    - "funcster exploitation"
    - "MongoDB operator injection"
    - "JSON.parse with reviver abuse"
    - "vm module sandbox escape"
    - "eval-based deserialization"
    - "Function constructor abuse"
    
  attack_techniques:
    - "Property-oriented programming (POP)"
    - "Gadget chain construction"
    - "Magic method exploitation"
    - "Type confusion attacks"
    - "Prototype pollution via deserialization"
    - "JNDI injection"
    - "LDAP attribute injection"
    - "RMI registry exploitation"
    - "JMX exploitation"
    - "Classloader manipulation"
    
  bypass_techniques:
    - "Allowlist bypass via inheritance"
    - "Interface-based bypass"
    - "Proxy class exploitation"
    - "Nested object bypass"
    - "Array type confusion"
    - "Generic type erasure bypass"
    - "Reflection-based bypass"
    - "ClassLoader isolation bypass"
    - "Security manager bypass"
    - "Module system bypass (Java 9+)"
    
  detection_evasion:
    - "Gadget obfuscation"
    - "Payload encoding"
    - "Multi-stage payloads"
    - "Time-delayed execution"
    - "Conditional execution"
    - "DNS-based exfiltration"
    - "OOB data exfiltration"
    - "Blind exploitation"
    - "Polyglot payloads"
    - "Format confusion"

# === ATTACK CHAINS (50+ chains) ===
attack_chains:
  java_rce_chains:
    - name: "Commons Collections InvokerTransformer"
      steps:
        - "Identify Java deserialization endpoint"
        - "Check for Commons Collections in classpath"
        - "Construct InvokerTransformer chain"
        - "Wrap in LazyMap with ChainedTransformer"
        - "Trigger via AnnotationInvocationHandler"
        - "Execute arbitrary commands"
      difficulty: "medium"
      cve_references: ["CVE-2015-4852", "CVE-2015-7501"]
      tools: ["ysoserial", "marshalsec"]
      
    - name: "Commons Beanutils PropertyUtils"
      steps:
        - "Identify Java deserialization endpoint"
        - "Verify Commons Beanutils presence"
        - "Construct BeanComparator chain"
        - "Use TemplatesImpl for bytecode execution"
        - "Trigger code execution"
      difficulty: "medium"
      tools: ["ysoserial CommonsBeanutils1"]
      
    - name: "Spring Framework Gadget Chain"
      steps:
        - "Identify Spring application with deserialization"
        - "Check Spring framework version"
        - "Use Spring specific gadgets"
        - "Exploit via MethodInvokeTypeProvider"
        - "Achieve RCE"
      difficulty: "hard"
      cve_references: ["CVE-2016-1000027"]
      
    - name: "JNDI Injection via Deserialization"
      steps:
        - "Identify JNDI lookup in gadget chain"
        - "Set up malicious LDAP/RMI server"
        - "Craft payload with JNDI reference"
        - "Trigger deserialization"
        - "Server fetches and executes remote class"
      difficulty: "hard"
      cve_references: ["CVE-2021-44228"]
      
  python_rce_chains:
    - name: "Pickle __reduce__ RCE"
      steps:
        - "Identify pickle.load on untrusted data"
        - "Create class with __reduce__ method"
        - "Return (os.system, ('command',)) from __reduce__"
        - "Serialize malicious object"
        - "Send to vulnerable endpoint"
        - "Code executes on deserialization"
      difficulty: "easy"
      code_example: |
        import pickle
        import os
        class Exploit:
            def __reduce__(self):
                return (os.system, ('id > /tmp/pwned',))
        payload = pickle.dumps(Exploit())
        
    - name: "PyYAML Arbitrary Code Execution"
      steps:
        - "Identify yaml.load without safe_load"
        - "Craft YAML with !!python/object/apply tag"
        - "Specify os.system as constructor"
        - "Pass command as argument"
        - "Submit malicious YAML"
      difficulty: "easy"
      payload_example: "!!python/object/apply:os.system ['id']"
      cve_references: ["CVE-2020-1747"]
      
    - name: "Pickle Protocol 0 Exploitation"
      steps:
        - "Target legacy systems with protocol 0"
        - "Craft human-readable pickle payload"
        - "Bypass text-based filters"
        - "Achieve code execution"
      difficulty: "medium"
      
  php_rce_chains:
    - name: "PHP Object Injection to RCE"
      steps:
        - "Identify unserialize on user input"
        - "Analyze codebase for gadget classes"
        - "Find __destruct or __wakeup with dangerous calls"
        - "Construct POP chain"
        - "Serialize and submit payload"
      difficulty: "medium"
      tools: ["PHPGGC"]
      
    - name: "Phar Deserialization"
      steps:
        - "Identify file operation on user-controlled path"
        - "Create Phar archive with malicious metadata"
        - "Use phar:// stream wrapper"
        - "Trigger metadata deserialization"
        - "Execute gadget chain"
      difficulty: "hard"
      cve_references: ["CVE-2018-19518"]
      
    - name: "Laravel/Symfony POP Chain"
      steps:
        - "Identify framework version"
        - "Use framework-specific gadgets"
        - "Chain through multiple classes"
        - "Achieve RCE via Monolog or similar"
      difficulty: "medium"
      tools: ["PHPGGC"]
      
  dotnet_rce_chains:
    - name: "BinaryFormatter TypeConfuseDelegate"
      steps:
        - "Identify BinaryFormatter deserialization"
        - "Construct TypeConfuseDelegate payload"
        - "Use SortedSet to trigger comparison"
        - "Execute arbitrary process"
      difficulty: "medium"
      tools: ["ysoserial.net"]
      
    - name: "JSON.NET TypeNameHandling"
      steps:
        - "Identify JSON.NET with TypeNameHandling enabled"
        - "Craft JSON with $type property"
        - "Specify ObjectDataProvider type"
        - "Execute arbitrary method"
      difficulty: "medium"
      cve_references: ["CVE-2019-0604"]
      
    - name: "ViewState Deserialization"
      steps:
        - "Identify ASP.NET ViewState"
        - "Obtain or crack machine key"
        - "Craft malicious ViewState"
        - "Submit to vulnerable page"
        - "Achieve RCE"
      difficulty: "hard"
      cve_references: ["CVE-2020-0688"]
      
  cross_platform_chains:
    - name: "XXE to SSRF to RCE"
      steps:
        - "Identify XML parsing endpoint"
        - "Exploit XXE for SSRF"
        - "Access internal metadata service"
        - "Retrieve credentials"
        - "Pivot to RCE"
      difficulty: "hard"
      
    - name: "Polyglot Deserialization"
      steps:
        - "Create payload valid in multiple formats"
        - "Bypass format detection"
        - "Trigger deserialization in target format"
        - "Achieve exploitation"
      difficulty: "expert"

# === DEFENSE BYPASS TECHNIQUES (100+) ===
defense_bypass_techniques:
  allowlist_bypass:
    - "Use allowed class as wrapper for dangerous class"
    - "Exploit inheritance from allowed base class"
    - "Use interface implementations"
    - "Exploit generic type parameters"
    - "Use proxy classes"
    - "Exploit inner/nested classes"
    - "Array of allowed type containing dangerous objects"
    - "Wrapper object with dangerous field"
    - "Exploit class hierarchy traversal"
    - "Use reflection to access non-allowed classes"
    
  filter_bypass:
    - "Encoding payload (base64, hex, URL)"
    - "Unicode normalization bypass"
    - "Case variation bypass"
    - "Whitespace injection"
    - "Comment injection"
    - "Null byte injection"
    - "Newline injection"
    - "Format string manipulation"
    - "Character set confusion"
    - "Multi-byte character bypass"
    
  deserialization_filter_bypass:
    - "Object graph complexity attacks"
    - "Deep nesting to bypass depth limits"
    - "Wide objects to bypass width limits"
    - "Reference loops for DoS"
    - "Large string allocation"
    - "Memory exhaustion payloads"
    - "CPU exhaustion via hash collisions"
    - "Billion laughs equivalent"
    - "Zip bomb via serialization"
    - "Recursive structure attacks"
    
  waf_bypass:
    - "Fragmented payloads"
    - "HTTP parameter pollution"
    - "Content-Type confusion"
    - "Multipart encoding"
    - "Chunked encoding"
    - "Compression (gzip/deflate)"
    - "Double encoding"
    - "Mixed encoding"
    - "Request smuggling"
    - "Protocol-level bypass"
    
  detection_evasion:
    - "Time-delayed payload execution"
    - "Conditional payload activation"
    - "Environment-specific triggers"
    - "Anti-debugging techniques"
    - "Sandbox detection"
    - "VM detection"
    - "Honeypot detection"
    - "Logging evasion"
    - "Rate limiting bypass"
    - "IP reputation bypass"

# === REAL-WORLD SCENARIOS ===
real_world_scenarios:
  enterprise_applications:
    - scenario: "Java Enterprise Application"
      description: "RMI/JNDI deserialization in enterprise app"
      complexity: "high"
      attack_vector: "Network-accessible RMI endpoint"
      cve_examples: ["CVE-2016-3427", "CVE-2017-3248"]
      
    - scenario: "Spring Boot Application"
      description: "Actuator endpoint with deserialization"
      complexity: "medium"
      attack_vector: "HTTP endpoint accepting serialized objects"
      
    - scenario: ".NET Web Application"
      description: "ViewState or session deserialization"
      complexity: "medium"
      attack_vector: "Crafted ViewState parameter"
      
  web_frameworks:
    - scenario: "Django/Flask Session"
      description: "Pickle-based session with weak secret"
      complexity: "medium"
      attack_vector: "Forge session cookie with RCE payload"
      
    - scenario: "Rails Application"
      description: "YAML deserialization in cookies"
      complexity: "medium"
      attack_vector: "Crafted cookie value"
      cve_examples: ["CVE-2013-0156"]
      
    - scenario: "PHP CMS/Framework"
      description: "Object injection via user input"
      complexity: "medium"
      attack_vector: "Serialized PHP object in parameter"
      
  message_queues:
    - scenario: "RabbitMQ Consumer"
      description: "Message deserialization without validation"
      complexity: "high"
      attack_vector: "Malicious message in queue"
      
    - scenario: "Kafka Consumer"
      description: "Deserialization of untrusted messages"
      complexity: "high"
      attack_vector: "Crafted Kafka message"
      
    - scenario: "Redis Session Store"
      description: "Pickle-based session storage"
      complexity: "medium"
      attack_vector: "Redis access leads to session manipulation"
      
  caching_systems:
    - scenario: "Memcached Deserialization"
      description: "Cached objects deserialized unsafely"
      complexity: "medium"
      attack_vector: "Cache poisoning"
      
    - scenario: "Application Cache"
      description: "File-based cache with serialization"
      complexity: "medium"
      attack_vector: "Cache file manipulation"

# === DIFFICULTY CONFIGURATION ===
difficulty:
  estimated: "extreme"
  time_range: [7200, 32400]
  command_steps: [150, 700]
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "CTF-final level difficulty requiring expert exploitation skills"
      requirements:
        - "7+ interacting vulnerabilities requiring chained exploitation"
        - "Requires understanding of target runtime/compiler internals"
        - "Time estimate: 180+ minutes for senior security researchers"
        - "Multiple protection bypass techniques required"
        - "Requires synthesizing reverse engineering, exploitation, and cryptography"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 172800]
      command_steps: [500, 2000]
      techniques_required: 20
      description: "Real-world 0-day exploitation requiring novel gadget chain discovery and allowlist bypass"
      requirements:
        - "16+ deeply interacting vulnerabilities across serialization, runtime, and application layers"
        - "Requires custom gadget chain discovery in target dependencies"
        - "Time estimate: 12-48 hours for senior security researchers with OSCP/OSWE/OSCE certifications"
        - "Must bypass type allowlists, integrity verification, and deserialization firewalls"
        - "Requires understanding of JVM/CLR/.NET/Python runtime internals"
        - "Must achieve RCE through multiple layers of deserialization protection"
        - "Custom POP (Property-Oriented Programming) chain construction required"
        - "Cross-format polyglot payload development for multi-context exploitation"
  
  generation_targets:
    minimum_difficulty: "120-360 minutes for senior security researchers with offensive security certifications (OSCP/OSWE/OSCE)"
    quality_requirements: "Must require deep understanding of serialization internals, gadget chain construction, and runtime exploitation"
  
  difficulty_levels:
    beginner:
      description: "Identify obvious pickle.load vulnerability"
      time_estimate: 600
      prerequisites: ["Basic Python"]
      
    intermediate:
      description: "Exploit YAML deserialization"
      time_estimate: 1200
      prerequisites: ["Serialization concepts", "Basic exploitation"]
      
    advanced:
      description: "Java gadget chain exploitation"
      time_estimate: 2400
      prerequisites: ["Java internals", "Gadget chain analysis"]
      
    expert:
      description: "Custom gadget chain discovery"
      time_estimate: 3600
      prerequisites: ["Deep language internals", "Reverse engineering"]

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 8
  coordination_complexity: "extreme"
  
  specialized_agents:
    - name: "serialization_analyst"
      role: "Analyze serialization formats and entry points"
      expertise: ["pickle", "Java serialization", "PHP serialize", "YAML", "JSON"]
      
    - name: "gadget_hunter"
      role: "Discover gadget chains in target classpath/dependencies"
      expertise: ["ysoserial", "PHPGGC", "gadget chain analysis", "POP chains"]
      
    - name: "java_specialist"
      role: "Exploit Java deserialization vulnerabilities"
      expertise: ["ObjectInputStream", "Commons Collections", "JNDI injection", "RMI"]
      
    - name: "dotnet_specialist"
      role: "Exploit .NET deserialization vulnerabilities"
      expertise: ["BinaryFormatter", "TypeNameHandling", "ViewState", "XAML"]
      
    - name: "python_specialist"
      role: "Exploit Python deserialization vulnerabilities"
      expertise: ["pickle", "PyYAML", "marshal", "__reduce__"]
      
    - name: "php_specialist"
      role: "Exploit PHP deserialization vulnerabilities"
      expertise: ["unserialize", "Phar", "magic methods", "POP chains"]
      
    - name: "bypass_specialist"
      role: "Bypass deserialization protections"
      expertise: ["allowlist bypass", "filter evasion", "integrity bypass"]
      
    - name: "xxe_specialist"
      role: "Exploit XML external entity vulnerabilities"
      expertise: ["XXE", "DTD processing", "SSRF via XXE", "file disclosure"]
  
  cross_vulnerability_chains:
    - chain: "XXE -> SSRF -> Internal deserialization -> RCE"
      complexity: "extreme"
      
    - chain: "JSON TypeNameHandling -> Gadget chain -> Code execution"
      complexity: "high"
      
    - chain: "YAML parsing -> Python code execution -> Persistent backdoor"
      complexity: "high"
      
    - chain: "Phar metadata -> PHP object injection -> Web shell"
      complexity: "extreme"
      
    - chain: "JNDI injection -> Remote class loading -> RCE"
      complexity: "extreme"

# === EXPLOIT CHAIN REQUIREMENTS ===
exploit_chain_requirements:
  minimum_chain_length: 4
  required_stages:
    - stage: "entry_point_discovery"
      description: "Identify deserialization entry points"
      techniques:
        - "Input parameter analysis"
        - "Cookie/session inspection"
        - "Message queue monitoring"
        - "File upload analysis"
    
    - stage: "format_identification"
      description: "Determine serialization format and library"
      techniques:
        - "Magic byte analysis"
        - "Error message fingerprinting"
        - "Library version detection"
        - "Feature enumeration"
    
    - stage: "gadget_chain_construction"
      description: "Build working gadget chain"
      techniques:
        - "Classpath enumeration"
        - "Gadget compatibility analysis"
        - "Chain assembly"
        - "Payload encoding"
    
    - stage: "exploitation"
      description: "Achieve code execution"
      techniques:
        - "Direct RCE via gadget"
        - "JNDI/LDAP injection"
        - "File write for web shell"
        - "Reverse shell establishment"

# === DEFENSIVE EVASION ===
defensive_evasion:
  security_controls_to_bypass:
    - control: "Type Allowlists"
      bypass_techniques:
        - "Allowed class inheritance exploitation"
        - "Interface-based bypass"
        - "Proxy class abuse"
        - "Generic type erasure exploitation"
      
    - control: "Deserialization Firewalls"
      bypass_techniques:
        - "Nested object bypass"
        - "Array type confusion"
        - "Reference loop exploitation"
        - "Depth limit bypass"
      
    - control: "Signature/HMAC Verification"
      bypass_techniques:
        - "Key extraction via side-channel"
        - "Weak key brute-force"
        - "Signature oracle exploitation"
        - "Race condition in verification"
      
    - control: "Sandbox/ClassLoader Isolation"
      bypass_techniques:
        - "ClassLoader manipulation"
        - "Reflection-based bypass"
        - "Native method invocation"
        - "Security manager bypass"

# === REAL-WORLD CORRELATION ===
real_world_correlation:
  cve_attack_patterns:
    - cve: "CVE-2015-4852"
      technique: "WebLogic Commons Collections"
      real_world_impact: "Mass exploitation of enterprise Java apps"
      
    - cve: "CVE-2017-9805"
      technique: "Struts2 REST plugin"
      real_world_impact: "RCE via XML deserialization"
      
    - cve: "CVE-2020-1747"
      technique: "PyYAML arbitrary code execution"
      real_world_impact: "Python application compromise"
      
    - cve: "CVE-2021-44228"
      technique: "Log4j JNDI injection"
      real_world_impact: "Widespread Java ecosystem compromise"

# === TRAP DENSITY ===
trap_configuration:
  total_traps: 15
  trap_interaction_depth: 5
  cross_domain_traps: true
  
  trap_categories:
    obvious_traps: 3
    subtle_traps: 4
    framework_traps: 4
    java_traps: 4

# === LLM TRAP CONFIGURATIONS (50+) ===
traps:
  obvious_traps:
    - type: "pickle_load"
      description: "pickle.load on untrusted data executes arbitrary code"
      trigger: "Loading pickle from user input or network"
      exploit: "class Exploit: def __reduce__(self): return (os.system, ('cmd',))"
      
    - type: "yaml_load"
      description: "yaml.load without Loader allows code execution"
      trigger: "Using yaml.load instead of yaml.safe_load"
      exploit: "!!python/object/apply:os.system ['cmd']"
      
    - type: "marshal_load"
      description: "marshal can execute code via code objects"
      trigger: "marshal.load on untrusted data"
      
  subtle_traps:
    - type: "json_type_coercion"
      description: "Custom JSON decoder creates arbitrary objects"
      trigger: "JSON object_hook instantiating classes from type field"
      
    - type: "xxe_injection"
      description: "XML parser processes external entities"
      trigger: "XML parsing without disabling external entities"
      
    - type: "template_injection"
      description: "Deserialized object used in template"
      trigger: "Object __str__ or __repr__ in template context"
      
    - type: "second_order_deser"
      description: "Deserialized data stored and processed later"
      trigger: "Database stores serialized data, retrieved and deserialized"
      
  framework_traps:
    - type: "django_session"
      description: "Django PickleSerializer for sessions"
      trigger: "SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'"
      
    - type: "flask_session"
      description: "Flask-Session with pickle backend"
      trigger: "SESSION_TYPE = 'redis' with default serializer"
      
    - type: "celery_task"
      description: "Celery task arguments deserialized"
      trigger: "CELERY_TASK_SERIALIZER = 'pickle'"
      
  java_traps:
    - type: "readObject_override"
      description: "Custom readObject with dangerous operations"
      trigger: "readObject calling Runtime.exec or similar"
      
    - type: "readResolve_gadget"
      description: "readResolve returns dangerous object"
      trigger: "Singleton pattern with gadget chain"
      
    - type: "finalize_gadget"
      description: "Finalize method executes on GC"
      trigger: "Gadget chain through finalizer"

# === COMPREHENSIVE TASK GENERATION TEMPLATE ===
instruction_template: |
  You are fixing a {{ scenario_type }} with insecure deserialization.
  The code is at {{ path }}.
  
  System details:
  - Platform: {{ platform }}
  - Language: {{ language }}
  - Framework: {{ framework }}
  
  Deserialization points identified: {{ deser_count }}
  Untrusted data sources: {{ untrusted_sources }}
  Known gadget classes available: {{ gadget_count }}
  
  Attack model:
  - Attacker controls: {{ attacker_control }}
  - Network position: {{ network_position }}
  - Authentication state: {{ auth_state }}
  
  Your task:
  {{ task_steps }}
  
  Additional requirements:
  - All deserialization must validate input before processing
  - Use allowlists for permitted types
  - Add cryptographic integrity verification
  - Implement proper error handling
  - Log deserialization attempts for monitoring

# === REFERENCE SOLUTION (COMPREHENSIVE) ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Secure Deserialization Patterns
  
  This module demonstrates safe alternatives to dangerous deserialization:
  1. Safe JSON parsing with type validation
  2. Signed serialization with integrity verification
  3. Schema-based validation
  4. Type allowlisting
  5. Input sanitization
  """
  
  import json
  import hmac
  import hashlib
  import base64
  import struct
  from typing import Dict, Any, Optional, Type, Set, List, Union
  from dataclasses import dataclass, fields, is_dataclass
  from enum import Enum
  import logging
  
  # For XML parsing (if needed)
  from defusedxml import ElementTree as DefusedET
  import xml.etree.ElementTree as ET
  
  # ============================================================
  # DANGEROUS PATTERNS (FOR REFERENCE)
  # ============================================================
  
  """
  NEVER DO THIS - Examples of vulnerable code:
  
  # Python pickle - arbitrary code execution
  import pickle
  user_data = request.get_data()
  obj = pickle.loads(user_data)  # RCE!
  
  # Python YAML - arbitrary code execution  
  import yaml
  config = yaml.load(user_input)  # RCE!
  
  # Python marshal - code object injection
  import marshal
  code = marshal.loads(user_data)  # RCE!
  
  # PHP unserialize - object injection
  $obj = unserialize($_GET['data']);  // RCE via POP chain
  
  # Java ObjectInputStream - gadget chains
  ObjectInputStream ois = new ObjectInputStream(userInputStream);
  Object obj = ois.readObject();  // RCE via gadgets
  
  # .NET BinaryFormatter - arbitrary type instantiation
  BinaryFormatter bf = new BinaryFormatter();
  object obj = bf.Deserialize(userStream);  // RCE!
  """
  
  # ============================================================
  # SECURE JSON SERIALIZATION
  # ============================================================
  
  class SecureSerializer:
      """
      Secure serialization with HMAC integrity verification.
      
      Only allows JSON-serializable data types.
      Prevents tampering via cryptographic signature.
      """
      
      def __init__(self, secret_key: bytes):
          """
          Initialize with secret key for signing.
          
          Args:
              secret_key: Key for HMAC (at least 32 bytes recommended)
          """
          if len(secret_key) < 16:
              raise ValueError("Secret key too short (min 16 bytes)")
          
          self.secret_key = secret_key
      
      def serialize(self, data: Dict[str, Any]) -> bytes:
          """
          Serialize data with integrity signature.
          
          Args:
              data: Dictionary to serialize
              
          Returns:
              Signed serialized bytes
          """
          # Serialize to JSON (deterministic for consistent signatures)
          json_bytes = json.dumps(data, sort_keys=True, separators=(',', ':')).encode('utf-8')
          
          # Compute HMAC signature
          signature = hmac.new(
              self.secret_key,
              json_bytes,
              hashlib.sha256
          ).digest()
          
          # Return: signature || json_data
          return signature + json_bytes
      
      def deserialize(self, payload: bytes) -> Optional[Dict[str, Any]]:
          """
          Deserialize and verify integrity.
          
          Args:
              payload: Signed serialized bytes
              
          Returns:
              Deserialized data or None if verification fails
          """
          if len(payload) < 32:  # Minimum: 32-byte signature
              return None
          
          # Split signature and data
          signature = payload[:32]
          json_bytes = payload[32:]
          
          # Verify signature (constant-time comparison)
          expected_signature = hmac.new(
              self.secret_key,
              json_bytes,
              hashlib.sha256
          ).digest()
          
          if not hmac.compare_digest(signature, expected_signature):
              logging.warning("Deserialization signature verification failed")
              return None
          
          # Parse JSON (safe - no code execution)
          try:
              return json.loads(json_bytes)
          except json.JSONDecodeError as e:
              logging.warning(f"Invalid JSON in signed payload: {e}")
              return None
  
  
  # ============================================================
  # TYPE-SAFE DESERIALIZATION
  # ============================================================
  
  @dataclass
  class User:
      """Example allowed type."""
      id: int
      name: str
      email: str
  
  
  @dataclass
  class Product:
      """Example allowed type."""
      id: int
      name: str
      price: float
      
      
  @dataclass
  class Order:
      """Example allowed type with nested objects."""
      id: int
      user_id: int
      products: List[int]
      total: float
  
  
  class TypeSafeDeserializer:
      """
      Deserializer with strict type allowlist.
      
      Only permits instantiation of explicitly allowed types.
      Validates all fields against expected types.
      """
      
      # Explicit allowlist of safe types
      ALLOWED_TYPES: Dict[str, Type] = {
          'User': User,
          'Product': Product,
          'Order': Order,
      }
      
      # Primitive types that are always safe
      SAFE_PRIMITIVES = (str, int, float, bool, type(None))
      
      @classmethod
      def register_type(cls, type_name: str, type_class: Type):
          """Register a new allowed type."""
          if not is_dataclass(type_class):
              raise ValueError("Only dataclasses are allowed")
          cls.ALLOWED_TYPES[type_name] = type_class
      
      @classmethod
      def deserialize(cls, json_string: str) -> Any:
          """
          Safely deserialize JSON with type information.
          
          Args:
              json_string: JSON string with optional __type__ field
              
          Returns:
              Deserialized object (dataclass instance or primitive)
          """
          data = json.loads(json_string)
          return cls._convert(data)
      
      @classmethod
      def _convert(cls, data: Any) -> Any:
          """Recursively convert data to typed objects."""
          if data is None:
              return None
          
          if isinstance(data, cls.SAFE_PRIMITIVES):
              return data
          
          if isinstance(data, list):
              return [cls._convert(item) for item in data]
          
          if isinstance(data, dict):
              # Check for type specification
              if '__type__' in data:
                  return cls._convert_typed(data)
              
              # Plain dict - convert values recursively
              return {k: cls._convert(v) for k, v in data.items()}
          
          raise ValueError(f"Unexpected type: {type(data)}")
      
      @classmethod
      def _convert_typed(cls, data: Dict) -> Any:
          """Convert typed object with validation."""
          type_name = data.pop('__type__')
          
          # Check allowlist
          if type_name not in cls.ALLOWED_TYPES:
              raise ValueError(f"Type not allowed: {type_name}")
          
          target_class = cls.ALLOWED_TYPES[type_name]
          
          # Validate fields match dataclass
          if is_dataclass(target_class):
              expected_fields = {f.name for f in fields(target_class)}
              provided_fields = set(data.keys())
              
              # Check for unexpected fields
              extra_fields = provided_fields - expected_fields
              if extra_fields:
                  raise ValueError(f"Unexpected fields for {type_name}: {extra_fields}")
              
              # Check for missing required fields
              missing_fields = expected_fields - provided_fields
              if missing_fields:
                  raise ValueError(f"Missing fields for {type_name}: {missing_fields}")
          
          # Convert nested values
          converted_data = {k: cls._convert(v) for k, v in data.items()}
          
          # Instantiate the allowed class
          return target_class(**converted_data)
  
  
  # ============================================================
  # SAFE YAML LOADING
  # ============================================================
  
  def safe_yaml_load(yaml_string: str) -> Dict:
      """
      Load YAML safely without code execution.
      
      Always use yaml.safe_load, never yaml.load.
      
      Args:
          yaml_string: YAML content
          
      Returns:
          Parsed YAML as dictionary
      """
      import yaml
      return yaml.safe_load(yaml_string)
  
  
  def strict_yaml_load(yaml_string: str, allowed_keys: Set[str]) -> Dict:
      """
      Load YAML with strict key validation.
      
      Args:
          yaml_string: YAML content
          allowed_keys: Set of permitted top-level keys
          
      Returns:
          Validated YAML dictionary
      """
      import yaml
      
      data = yaml.safe_load(yaml_string)
      
      if not isinstance(data, dict):
          raise ValueError("Expected dictionary at top level")
      
      # Validate keys
      for key in data.keys():
          if key not in allowed_keys:
              raise ValueError(f"Unexpected key: {key}")
      
      return data
  
  
  # ============================================================
  # SAFE XML PARSING
  # ============================================================
  
  def safe_parse_xml(xml_string: str) -> ET.Element:
      """
      Parse XML safely without XXE vulnerabilities.
      
      Uses defusedxml which disables:
      - External entities
      - DTD processing
      - Network access
      
      Args:
          xml_string: XML content
          
      Returns:
          Parsed XML element
      """
      return DefusedET.fromstring(xml_string)
  
  
  def parse_xml_to_dict(xml_string: str) -> Dict:
      """
      Parse XML to dictionary safely.
      
      Args:
          xml_string: XML content
          
      Returns:
          Dictionary representation
      """
      root = safe_parse_xml(xml_string)
      
      def element_to_dict(element):
          result = {}
          
          # Add attributes
          if element.attrib:
              result['@attributes'] = dict(element.attrib)
          
          # Add child elements
          for child in element:
              child_data = element_to_dict(child)
              if child.tag in result:
                  # Convert to list if multiple same-named children
                  if not isinstance(result[child.tag], list):
                      result[child.tag] = [result[child.tag]]
                  result[child.tag].append(child_data)
              else:
                  result[child.tag] = child_data
          
          # Add text content
          if element.text and element.text.strip():
              if result:
                  result['#text'] = element.text.strip()
              else:
                  return element.text.strip()
          
          return result
      
      return {root.tag: element_to_dict(root)}
  
  
  # ============================================================
  # INPUT VALIDATION FRAMEWORK
  # ============================================================
  
  class DeserializationFirewall:
      """
      Firewall for deserialization attempts.
      
      Provides:
      - Size limits
      - Depth limits
      - Type validation
      - Logging and alerting
      """
      
      DEFAULT_MAX_SIZE = 1024 * 1024  # 1 MB
      DEFAULT_MAX_DEPTH = 20
      DEFAULT_MAX_KEYS = 1000
      
      def __init__(
          self,
          max_size: int = DEFAULT_MAX_SIZE,
          max_depth: int = DEFAULT_MAX_DEPTH,
          max_keys: int = DEFAULT_MAX_KEYS,
          allowed_types: Optional[Set[str]] = None
      ):
          self.max_size = max_size
          self.max_depth = max_depth
          self.max_keys = max_keys
          self.allowed_types = allowed_types or set()
      
      def validate(self, data: bytes) -> bool:
          """
          Validate data before deserialization.
          
          Args:
              data: Raw bytes to validate
              
          Returns:
              True if validation passes
              
          Raises:
              ValueError: If validation fails
          """
          # Size check
          if len(data) > self.max_size:
              logging.warning(f"Deserialization rejected: size {len(data)} > {self.max_size}")
              raise ValueError(f"Data too large: {len(data)} bytes")
          
          return True
      
      def validate_structure(self, obj: Any, depth: int = 0) -> int:
          """
          Validate deserialized structure.
          
          Args:
              obj: Deserialized object
              depth: Current nesting depth
              
          Returns:
              Total key count
              
          Raises:
              ValueError: If validation fails
          """
          if depth > self.max_depth:
              raise ValueError(f"Nesting too deep: {depth} > {self.max_depth}")
          
          key_count = 0
          
          if isinstance(obj, dict):
              key_count += len(obj)
              if key_count > self.max_keys:
                  raise ValueError(f"Too many keys: {key_count} > {self.max_keys}")
              
              for key, value in obj.items():
                  key_count += self.validate_structure(value, depth + 1)
          
          elif isinstance(obj, list):
              for item in obj:
                  key_count += self.validate_structure(item, depth + 1)
          
          return key_count
      
      def safe_deserialize(self, data: bytes) -> Optional[Dict]:
          """
          Safely deserialize with all validations.
          
          Args:
              data: Raw bytes to deserialize
              
          Returns:
              Deserialized dictionary or None on failure
          """
          try:
              # Pre-deserialization validation
              self.validate(data)
              
              # Parse as JSON (safe)
              obj = json.loads(data)
              
              # Post-deserialization validation
              self.validate_structure(obj)
              
              # Type validation if configured
              if self.allowed_types:
                  self._check_types(obj)
              
              return obj
              
          except Exception as e:
              logging.warning(f"Safe deserialization failed: {e}")
              return None
      
      def _check_types(self, obj: Any):
          """Check for type specifications and validate."""
          if isinstance(obj, dict):
              if '__type__' in obj:
                  type_name = obj['__type__']
                  if type_name not in self.allowed_types:
                      raise ValueError(f"Type not allowed: {type_name}")
              
              for value in obj.values():
                  self._check_types(value)
          
          elif isinstance(obj, list):
              for item in obj:
                  self._check_types(item)
  
  
  # ============================================================
  # MIGRATION UTILITIES
  # ============================================================
  
  def migrate_pickle_to_json(pickle_data: bytes, secret_key: bytes) -> bytes:
      """
      Migrate data from pickle format to secure JSON.
      
      WARNING: Only use this for trusted data during migration.
      Do NOT use on untrusted pickle data.
      
      Args:
          pickle_data: Existing pickle data (must be trusted)
          secret_key: Key for new secure format
          
      Returns:
          Securely serialized JSON data
      """
      import pickle
      
      # This should only be used in controlled migration scenario
      # Never deserialize untrusted pickle!
      logging.warning("Migrating from pickle - ensure data source is trusted")
      
      # Deserialize (only trusted data!)
      obj = pickle.loads(pickle_data)
      
      # Convert to JSON-serializable format
      if hasattr(obj, '__dict__'):
          json_data = {
              '__type__': type(obj).__name__,
              **{k: v for k, v in obj.__dict__.items() 
                 if isinstance(v, (str, int, float, bool, type(None), list, dict))}
          }
      else:
          json_data = obj
      
      # Re-serialize with secure serializer
      secure = SecureSerializer(secret_key)
      return secure.serialize(json_data)

# === TEST CASES ===
fail_to_pass:
  - "test_no_pickle_on_untrusted_data"
  - "test_yaml_uses_safe_load"
  - "test_json_type_uses_allowlist"
  - "test_xxe_blocked"
  - "test_deserialization_signature_verified"
  - "test_type_allowlist_enforced"
  - "test_no_dangerous_gadgets"
  - "test_input_size_limited"
  - "test_nesting_depth_limited"
  - "test_error_handling_no_leak"

pass_to_pass:
  - "test_safe_json_parsing"
  - "test_signed_serialization_roundtrip"
  - "test_typed_deserialization"
  - "test_xml_parsing_safe"

# === VARIABLES FOR TASK GENERATION ===
variables:
  scenario_type:
    type: string
    options:
      - "session storage"
      - "cache layer"
      - "configuration loader"
      - "message processor"
      - "RPC endpoint"
      - "job queue worker"
      - "data import service"
      - "API endpoint"
      - "file parser"
      - "database ORM"
      
  path:
    type: path
    generator: random_path
    
  platform:
    type: string
    options:
      - "Linux x86_64"
      - "Windows Server"
      - "Docker container"
      - "Kubernetes pod"
      
  language:
    type: string
    options:
      - "Python 3.11"
      - "Java 17"
      - "PHP 8.2"
      - "Ruby 3.2"
      - "Node.js 20"
      - "C# .NET 8"
      
  framework:
    type: string
    options:
      - "Django"
      - "Flask"
      - "Spring Boot"
      - "Laravel"
      - "Rails"
      - "Express"
      - "ASP.NET Core"
      
  deser_count:
    type: int
    min: 1
    max: 20
    
  untrusted_sources:
    type: string
    options:
      - "HTTP request body"
      - "HTTP cookies"
      - "Message queue"
      - "File upload"
      - "Database BLOB"
      - "Redis cache"
      - "External API response"
      
  gadget_count:
    type: int
    min: 0
    max: 50
    
  attacker_control:
    type: string
    options:
      - "Full serialized data"
      - "Partial object fields"
      - "Type field only"
      - "Nested object content"
      
  network_position:
    type: string
    options:
      - "External/Internet"
      - "Internal network"
      - "Same host"
      
  auth_state:
    type: string
    options:
      - "Unauthenticated"
      - "Authenticated user"
      - "Admin user"
      
  task_steps:
    type: template
    value: |
      1. Identify all deserialization entry points
      2. Map untrusted data sources to deserializers
      3. Analyze gadget chain availability
      4. Replace pickle with JSON
      5. Use yaml.safe_load for YAML
      6. Disable XXE in XML parsers
      7. Implement type allowlisting
      8. Add integrity verification (HMAC)
      9. Implement deserialization firewall
      10. Add logging and monitoring
      11. Test with known payloads
      12. Verify defense-in-depth

# === ANTI-PATTERNS AND LLM FAILURE MODES ===
anti_patterns:
  llm_failure_modes:
    - "Applying textbook attack patterns without considering mitigations"
    - "Missing WAF/IDS bypass techniques for exploitation"
    - "Ignoring ASLR/PIE/NX and other modern protections"
    - "Not considering timing side-channel in crypto implementations"
    - "Missing second-order and stored attack vectors"
    - "Overlooking race conditions in authentication flows"
    - "Assuming standard libraries are secure without version checking"
    - "Missing JWT algorithm confusion and key confusion attacks"
    - "Ignoring deserialization gadget chain discovery complexity"
    - "Not recognizing Commons Collections version-specific gadgets"
    - "Missing JNDI injection via RMI/LDAP as exploitation vector"
    - "Overlooking Spring Framework-specific gadget chains"
    - "Failing to identify JDK built-in gadgets (JDK7u21, etc.)"
    - "Not considering TemplatesImpl bytecode execution"
    - "Missing Python pickle protocol differences (0-5)"
    - "Ignoring __reduce_ex__ as alternative to __reduce__"
    - "Not recognizing PyYAML !!python/object/new syntax"
    - "Overlooking PHP Phar metadata deserialization"
    - "Missing PHP __wakeup and __destruct chain construction"
    - "Failing to identify .NET TypeNameHandling.All vulnerability"
    - "Not considering ObjectDataProvider gadget in .NET"
    - "Ignoring ViewState machine key extraction techniques"
    - "Missing Ruby YAML.load (Psych) exploitation"
    - "Not recognizing node-serialize IIFE execution"
    - "Overlooking MessagePack extension type abuse"
    - "Failing to identify JSON with custom reviver exploitation"
    - "Not considering allowlist bypass via inheritance hierarchy"
    - "Missing deserialization filter depth/complexity bypass"
    - "Ignoring second-order deserialization from database storage"

# === ANTI-HARDCODING MEASURES ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  deserialization_risks:
    - "pickle_rce"
    - "yaml_code_execution"
    - "json_type_confusion"
    - "xxe_file_read"
    - "java_gadget_chains"
    - "php_object_injection"
    - "dotnet_formatter_rce"
    
  verification_requirements:
    - "No dangerous deserializer usage"
    - "All types validated against allowlist"
    - "Cryptographic integrity verification"
    - "Input size and depth limits"

# === CVE REFERENCES ===
cve_references:
  - id: "CVE-2015-4852"
    description: "Oracle WebLogic RCE via deserialization"
    relevance: "Java gadget chain exploitation"
    
  - id: "CVE-2017-9805"
    description: "Apache Struts2 REST plugin RCE"
    relevance: "XML deserialization vulnerability"
    
  - id: "CVE-2020-1747"
    description: "PyYAML arbitrary code execution"
    relevance: "Python YAML vulnerability"
    
  - id: "CVE-2013-0156"
    description: "Ruby on Rails YAML parsing RCE"
    relevance: "Rails YAML vulnerability"
    
  - id: "CVE-2021-44228"
    description: "Log4j JNDI injection"
    relevance: "JNDI-based deserialization attack"
    
  - id: "CVE-2019-0604"
    description: "SharePoint deserialization RCE"
    relevance: ".NET TypeNameHandling vulnerability"

# === TOOL RECOMMENDATIONS ===
tools:
  exploitation:
    - "ysoserial (Java)"
    - "ysoserial.net (.NET)"
    - "PHPGGC (PHP)"
    - "marshalsec (Java)"
    - "peas (Python)"
    
  detection:
    - "Contrast Security"
    - "OWASP Dependency Check"
    - "Snyk"
    - "Semgrep rules"
    - "CodeQL queries"
    
  testing:
    - "Burp Suite"
    - "Custom payloads"
    - "Fuzzing frameworks"
