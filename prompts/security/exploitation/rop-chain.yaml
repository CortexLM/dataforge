id: "sec-exploit-rop-chain-001"
version: "2.0.0"
category: "security"
subcategory: "exploitation"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research advanced ROP/JOP techniques, gadget discovery, and mitigation bypasses"
    phase_2_creation: "Create multi-layered ROP defense challenge with modern protection mechanisms"
    phase_3_amplification: "Add CFI bypass, ASLR defeat, and advanced mitigation requirements"
    phase_4_verification:
      base_validation: "Validate task requires expert binary exploitation and defense knowledge"
      enhanced_criteria:
        - "Has at least 5 interacting vulnerability chains"
        - "Has cascading exploitation paths that require chained attacks"
        - "Requires knowledge of compiler/interpreter internals for exploitation"
        - "Would take experienced security researchers 45+ minutes"
  
  complexity_targets:
    min_steps: 20
    max_steps: 60
    required_expertise:
      - "x86/x64 assembly and calling conventions"
      - "Memory layout and protection mechanisms"
      - "ROP gadget identification and chaining"
      - "Control Flow Integrity concepts"
      - "Modern CPU security features"
    
  anti_shortcut_measures:
    - "Require understanding of gadget semantics"
    - "Demand comprehensive mitigation deployment"
    - "Test against multiple bypass techniques"
    - "Verify stack canary and CFI effectiveness"

# SWE-bench_Pro style fields
problem_statement: |
  An application with DEP/NX enabled is still vulnerable to code execution through 
  Return-Oriented Programming (ROP). The task involves understanding and mitigating:
  
  1. Identifying useful gadgets in binary and libraries
  2. Understanding ROP chain construction methodology
  3. Implementing Control Flow Integrity (CFI)
  4. Enabling and verifying ASLR effectiveness
  5. Detecting ROP attack patterns at runtime
  6. Implementing Shadow Stack protection
  7. Hardening compiler options
  8. Reducing gadget surface area
  9. Implementing return address protection
  10. Deploying hardware-based mitigations (CET)

requirements: |
  - Analyze binary for ROP gadget availability
  - Implement comprehensive Control Flow Integrity
  - Enable full ASLR with PIE
  - Deploy stack canaries effectively
  - Implement Shadow Stack (hardware or software)
  - Minimize gadget surface through code optimization
  - Add ROP detection mechanisms
  - Configure compiler security flags properly
  - Test against known ROP techniques
  - Document defense-in-depth approach

interface: |
  Input: Binary with potential ROP vulnerabilities
  Output: Hardened binary with ROP mitigations, analysis report
  Validation: ROP chain construction fails due to mitigations

# === TOPIC UNIVERSE (100+ topics) ===
topic_universe:
  rop_fundamentals:
    - "Return-oriented programming basics"
    - "Gadget definition and semantics"
    - "Stack pivoting"
    - "Gadget chaining methodology"
    - "Return-to-libc attacks"
    - "Ret2plt attacks"
    - "Ret2syscall"
    - "Ret2csu"
    - "One-gadget RCE"
    - "Magic gadgets"
    
  advanced_rop:
    - "Jump-Oriented Programming (JOP)"
    - "Call-Oriented Programming (COP)"
    - "Sigreturn-Oriented Programming (SROP)"
    - "Data-Oriented Programming (DOP)"
    - "Blind ROP (BROP)"
    - "JIT-ROP"
    - "Counterfeit Object-oriented Programming (COOP)"
    - "Control-Flow Bending"
    - "Non-control-data attacks"
    - "Speculative ROP"
    
  gadget_types:
    - "Pop/ret gadgets"
    - "Mov/ret gadgets"
    - "Arithmetic gadgets"
    - "Memory read gadgets"
    - "Memory write gadgets"
    - "Syscall gadgets"
    - "Call reg gadgets"
    - "Jmp reg gadgets"
    - "Stack pivot gadgets"
    - "Conditional gadgets"
    
  memory_protections:
    - "DEP/NX (Data Execution Prevention)"
    - "ASLR (Address Space Layout Randomization)"
    - "Stack canaries/cookies"
    - "RELRO (Relocation Read-Only)"
    - "PIE (Position Independent Executable)"
    - "FORTIFY_SOURCE"
    - "Stack Clash Protection"
    - "Safe Stack"
    - "Shadow Stack"
    - "Control Flow Guard (CFG)"
    
  hardware_mitigations:
    - "Intel CET (Control-flow Enforcement Technology)"
    - "ARM BTI (Branch Target Identification)"
    - "ARM PAC (Pointer Authentication Codes)"
    - "AMD Shadow Stack"
    - "Intel IBT (Indirect Branch Tracking)"
    - "SMEP/SMAP"
    - "MPX (Memory Protection Extensions)"
    - "Intel MPK"
    - "ARM MTE (Memory Tagging Extension)"
    - "RISC-V CFI extensions"
    
  cfi_implementations:
    - "Clang CFI"
    - "GCC VTV (Virtual Table Verification)"
    - "Microsoft CFG"
    - "RAP (Return Address Protection)"
    - "MCFI"
    - "O-CFI"
    - "μCFI"
    - "PT-CFI"
    - "Context-sensitive CFI"
    - "Hardware-assisted CFI"
    
  aslr_topics:
    - "User-space ASLR"
    - "Kernel ASLR (KASLR)"
    - "ASLR entropy levels"
    - "ASLR bypass techniques"
    - "Information leaks"
    - "Partial overwrite attacks"
    - "Brute-force attacks"
    - "ASLR cache timing attacks"
    - "JIT spray for ASLR bypass"
    - "Thread spray attacks"
    
  binary_analysis:
    - "Static gadget analysis"
    - "Dynamic gadget discovery"
    - "Symbolic execution for gadgets"
    - "Automated exploit generation"
    - "Gadget quality assessment"
    - "Gadget catalog construction"
    - "Cross-reference analysis"
    - "Control flow graph analysis"
    - "Call graph analysis"
    - "Turing completeness analysis"

# === ATTACK CHAINS (50+ chains) ===
attack_chains:
  classic_rop:
    - name: "Basic ROP to System Call"
      steps:
        - "Find stack buffer overflow vulnerability"
        - "Locate 'pop rdi; ret' gadget"
        - "Locate 'pop rsi; ret' gadget"
        - "Locate '/bin/sh' string or writable memory"
        - "Locate syscall gadget"
        - "Chain: pop rdi -> '/bin/sh' -> pop rsi -> 0 -> pop rdx -> 0 -> syscall"
        - "Execute execve('/bin/sh', NULL, NULL)"
      difficulty: "medium"
      mitigations: ["ASLR", "Stack canaries", "CFI"]
      
    - name: "Return-to-libc"
      steps:
        - "Overflow buffer to control return address"
        - "Locate system() in libc"
        - "Locate '/bin/sh' string in libc"
        - "Set up: system('/bin/sh')"
        - "Bypass NX without custom shellcode"
      difficulty: "easy"
      
    - name: "Ret2csu Universal Gadget"
      steps:
        - "Locate __libc_csu_init gadgets"
        - "Use csu gadget to set rbx, rbp, r12-r15"
        - "Use second csu gadget to call [r12+rbx*8]"
        - "Control 3 arguments via call"
        - "Chain multiple calls"
      difficulty: "medium"
      
    - name: "Stack Pivot Attack"
      steps:
        - "Find limited overflow"
        - "Locate 'xchg rsp, rax; ret' or 'leave; ret'"
        - "Spray ROP chain to heap/known address"
        - "Pivot stack to ROP chain"
        - "Execute full ROP chain"
      difficulty: "hard"
      
  advanced_techniques:
    - name: "SROP (Sigreturn-Oriented Programming)"
      steps:
        - "Locate sigreturn syscall gadget"
        - "Construct fake sigcontext frame on stack"
        - "Set all registers via sigreturn"
        - "Minimal gadgets needed"
      difficulty: "hard"
      
    - name: "JOP (Jump-Oriented Programming)"
      steps:
        - "Use indirect jumps instead of returns"
        - "Avoid return-based detection"
        - "Build dispatcher gadget"
        - "Chain functional gadgets"
      difficulty: "hard"
      
    - name: "BROP (Blind ROP)"
      steps:
        - "No binary access available"
        - "Probe for stack canary presence"
        - "Find return address location"
        - "Scan for gadgets via crash oracle"
        - "Build chain incrementally"
      difficulty: "expert"
      reference: "Bittau et al., 2014"
      
    - name: "JIT-ROP"
      steps:
        - "Exploit memory disclosure vulnerability"
        - "Map code pages at runtime"
        - "Discover gadgets dynamically"
        - "Build ROP chain on the fly"
        - "Defeats fine-grained ASLR"
      difficulty: "expert"
      
  mitigation_bypass:
    - name: "ASLR Bypass via Information Leak"
      steps:
        - "Find format string or other info leak"
        - "Leak libc/binary address"
        - "Calculate base addresses"
        - "Execute standard ROP with known addresses"
      difficulty: "medium"
      
    - name: "Stack Canary Bypass"
      steps:
        - "Leak canary via format string"
        - "Or: brute-force canary (fork server)"
        - "Include correct canary in overflow"
        - "Proceed with ROP chain"
      difficulty: "medium"
      
    - name: "CFI Bypass via COOP"
      steps:
        - "Identify virtual function calls"
        - "Create counterfeit objects"
        - "Chain virtual function calls"
        - "Achieve arbitrary code execution"
        - "Bypass forward-edge CFI"
      difficulty: "expert"

# === DEFENSE IMPLEMENTATION ===
defense_implementation:
  compiler_flags:
    gcc:
      - "-fstack-protector-strong: Stack canaries for functions with arrays"
      - "-fstack-clash-protection: Probe stack on large allocations"
      - "-fcf-protection=full: Enable Intel CET"
      - "-D_FORTIFY_SOURCE=2: Runtime buffer checks"
      - "-pie: Position independent executable"
      - "-fPIC: Position independent code"
      - "-Wl,-z,relro,-z,now: Full RELRO"
      - "-Wl,-z,noexecstack: Non-executable stack"
      - "-fsanitize=cfi: Clang CFI"
      - "-fsanitize=safe-stack: Safe stack separation"
      
    clang:
      - "-fsanitize=cfi: Control Flow Integrity"
      - "-fsanitize=cfi-vcall: Virtual call CFI"
      - "-fsanitize=cfi-derived-cast: Derived cast CFI"
      - "-fsanitize=cfi-icall: Indirect call CFI"
      - "-fsanitize=safe-stack: Safe stack"
      - "-mretpoline: Spectre v2 mitigation"
      
  runtime_protections:
    - "ASLR (echo 2 > /proc/sys/kernel/randomize_va_space)"
    - "seccomp sandboxing"
    - "AppArmor/SELinux confinement"
    - "Namespaces isolation"
    - "Seccomp-BPF filtering"
    - "Landlock LSM"

# === REAL-WORLD SCENARIOS ===
real_world_scenarios:
  targets:
    - scenario: "Network Daemon"
      description: "Long-running network service with buffer overflow"
      complexity: "high"
      attack_surface: ["stack overflow", "heap corruption", "info leak"]
      
    - scenario: "File Parser"
      description: "Media file parser with format parsing bugs"
      complexity: "high"
      attack_surface: ["heap overflow", "type confusion"]
      
    - scenario: "Web Server"
      description: "HTTP server with request handling vulnerabilities"
      complexity: "high"
      attack_surface: ["stack overflow", "UAF"]

# === DIFFICULTY CONFIGURATION ===
difficulty:
  estimated: "extreme"
  time_range: [10800, 43200]
  command_steps: [200, 800]
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "CTF-final level difficulty requiring expert exploitation skills"
      requirements:
        - "7+ interacting vulnerabilities requiring chained exploitation"
        - "Requires understanding of target runtime/compiler internals"
        - "Time estimate: 180+ minutes for senior security researchers"
        - "Multiple protection bypass techniques required"
        - "Requires synthesizing reverse engineering, exploitation, and cryptography"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 172800]
      command_steps: [500, 2000]
      techniques_required: 22
      description: "Real-world 0-day exploitation requiring novel ROP/JOP gadget discovery and mitigation bypass"
      requirements:
        - "18+ deeply interacting vulnerabilities across memory, binary, and system layers"
        - "Requires novel gadget chain construction bypassing modern CFI/CET"
        - "Time estimate: 12-48 hours for senior security researchers with OSCP/OSWE/OSCE certifications"
        - "Custom gadget discovery and Turing-complete chain verification"
        - "Must bypass ASLR, PIE, NX, stack canaries, CFI, CET, and PAC simultaneously"
        - "Requires understanding of compiler internals, linker behavior, and binary layout"
        - "Must achieve reliable code execution across randomized memory layouts"
        - "Hardware-assisted control flow integrity bypass required"
  
  generation_targets:
    minimum_difficulty: "120-360 minutes for senior security researchers with offensive security certifications (OSCP/OSWE/OSCE)"
    quality_requirements: "Must require deep understanding of binary exploitation, gadget chain construction, and modern mitigation bypass"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 8
  coordination_complexity: "extreme"
  
  specialized_agents:
    - name: "binary_analyst"
      role: "Analyze binary for gadgets and vulnerabilities"
      expertise: ["disassembly", "gadget discovery", "binary structure", "symbol analysis"]
      
    - name: "gadget_specialist"
      role: "Discover and catalog useful ROP/JOP gadgets"
      expertise: ["gadget semantics", "register control", "memory operations", "syscall gadgets"]
      
    - name: "exploit_developer"
      role: "Construct working ROP/JOP chains"
      expertise: ["chain construction", "stack pivoting", "SROP", "ret2csu"]
      
    - name: "mitigation_bypass_specialist"
      role: "Bypass modern exploitation mitigations"
      expertise: ["ASLR bypass", "CFI bypass", "CET bypass", "PAC bypass"]
      
    - name: "reverse_engineer"
      role: "Deep binary and library analysis"
      expertise: ["IDA Pro", "Ghidra", "dynamic analysis", "heap analysis"]
      
    - name: "memory_corruption_specialist"
      role: "Identify and exploit memory corruption primitives"
      expertise: ["buffer overflow", "heap exploitation", "use-after-free", "type confusion"]
      
    - name: "shellcode_developer"
      role: "Develop position-independent payloads"
      expertise: ["shellcode", "alphanumeric encoding", "polymorphism", "egg hunting"]
      
    - name: "kernel_specialist"
      role: "Kernel-level exploitation and privilege escalation"
      expertise: ["kernel ROP", "SMEP/SMAP bypass", "kernel ASLR", "privilege escalation"]
  
  cross_vulnerability_chains:
    - chain: "Info leak -> ASLR bypass -> ROP chain -> Arbitrary code execution -> Privilege escalation"
      complexity: "extreme"
      
    - chain: "Heap corruption -> GOT overwrite -> Control flow hijack -> ROP -> Shell"
      complexity: "high"
      
    - chain: "Stack buffer overflow -> Canary leak -> ROP chain -> mprotect -> Shellcode execution"
      complexity: "extreme"
      
    - chain: "Format string -> Memory leak -> Stack pivot -> SROP -> Kernel compromise"
      complexity: "extreme"
      
    - chain: "Use-after-free -> VTable hijack -> JOP chain -> CFI bypass -> RCE"
      complexity: "extreme"

# === EXPLOIT CHAIN REQUIREMENTS ===
exploit_chain_requirements:
  minimum_chain_length: 6
  required_stages:
    - stage: "vulnerability_identification"
      description: "Identify exploitable memory corruption"
      techniques:
        - "Fuzzing for crashes"
        - "Static analysis for unsafe operations"
        - "Memory sanitizer output analysis"
        - "Symbolic execution for path discovery"
    
    - stage: "mitigation_analysis"
      description: "Analyze active mitigations"
      techniques:
        - "checksec verification"
        - "Runtime protection detection"
        - "Memory layout analysis"
        - "Compiler flag identification"
    
    - stage: "information_leakage"
      description: "Defeat ASLR through information disclosure"
      techniques:
        - "Format string address leakage"
        - "Heap metadata disclosure"
        - "Stack address recovery"
        - "Library base calculation"
    
    - stage: "gadget_discovery"
      description: "Find and catalog useful gadgets"
      techniques:
        - "Automated gadget scanning"
        - "Semantic gadget analysis"
        - "Cross-library gadget collection"
        - "Custom gadget construction"
    
    - stage: "chain_construction"
      description: "Build working ROP/JOP chain"
      techniques:
        - "Register setup sequences"
        - "Memory write primitives"
        - "Syscall preparation"
        - "Stack management"
    
    - stage: "execution"
      description: "Achieve reliable code execution"
      techniques:
        - "Payload delivery"
        - "Return-to-shellcode after mprotect"
        - "Reverse shell establishment"
        - "Persistence mechanism"

# === DEFENSIVE EVASION ===
defensive_evasion:
  security_controls_to_bypass:
    - control: "ASLR (Address Space Layout Randomization)"
      bypass_techniques:
        - "Information leak to recover base addresses"
        - "Partial overwrite with low entropy"
        - "Brute force on 32-bit systems"
        - "Return-to-PLT for initial leak"
        - "Side-channel address recovery"
      
    - control: "Stack Canaries"
      bypass_techniques:
        - "Canary value leakage"
        - "Brute force in fork servers"
        - "__stack_chk_fail overwrite"
        - "Canary bypass via format string"
      
    - control: "NX/DEP (Non-Executable Stack)"
      bypass_techniques:
        - "Return-oriented programming"
        - "Jump-oriented programming"
        - "mprotect to enable execution"
        - "JIT spray for executable memory"
      
    - control: "CFI (Control Flow Integrity)"
      bypass_techniques:
        - "Valid target gadget chaining"
        - "COOP (Counterfeit OOP)"
        - "Data-only attacks"
        - "CFI label collision"
      
    - control: "Intel CET (Shadow Stack + IBT)"
      bypass_techniques:
        - "Shadow stack desynchronization"
        - "ENDBRANCH to valid targets"
        - "Legacy code exploitation"
        - "CET bypass via kernel vulnerability"
      
    - control: "ARM PAC (Pointer Authentication)"
      bypass_techniques:
        - "PAC oracle attacks"
        - "Key recovery via speculation"
        - "Signing gadget abuse"
        - "PAC bypass via kernel"

# === REAL-WORLD CORRELATION ===
real_world_correlation:
  cve_attack_patterns:
    - cve: "CVE-2016-0728"
      technique: "Linux keyring UAF to ROP"
      real_world_impact: "Privilege escalation"
      complexity_factors: ["Heap manipulation", "ROP chain", "SMEP bypass"]
      
    - cve: "CVE-2017-5753"
      technique: "Spectre for ASLR bypass"
      real_world_impact: "Memory disclosure enabling exploitation"
      
    - cve: "CVE-2021-22555"
      technique: "Netfilter heap overflow to ROP"
      real_world_impact: "Container escape and privilege escalation"

# === TRAP DENSITY ===
trap_configuration:
  total_traps: 14
  trap_interaction_depth: 5
  cross_domain_traps: true
  
  trap_categories:
    gadget_traps: 4
    mitigation_traps: 4
    chain_construction_traps: 3
    payload_traps: 3

# === REFERENCE SOLUTION ===
reference_solution: |
  #!/usr/bin/env python3
  """
  ROP Attack Analysis and Mitigation Tools
  
  Provides:
  1. Gadget surface analysis
  2. Mitigation verification
  3. Compiler flag recommendations
  4. ROP detection mechanisms
  """
  
  import struct
  from typing import List, Dict, Tuple, Optional, Set
  from dataclasses import dataclass
  from enum import Enum
  
  
  class GadgetType(Enum):
      POP_REG = "pop_reg"
      MOV_REG = "mov_reg"
      WRITE_MEM = "write_mem"
      READ_MEM = "read_mem"
      SYSCALL = "syscall"
      CALL = "call"
      JMP = "jmp"
      STACK_PIVOT = "stack_pivot"
      ARITHMETIC = "arithmetic"
      CONDITIONAL = "conditional"
  
  
  @dataclass
  class ROPGadget:
      address: int
      gadget_type: GadgetType
      instructions: List[str]
      registers_affected: List[str]
      bytes_data: bytes
      quality_score: float  # Higher = more useful for attacks
  
  
  class ROPMitigationVerifier:
      """Verify ROP mitigations are properly deployed."""
      
      @staticmethod
      def check_mitigations(binary_path: str) -> Dict[str, bool]:
          """Check binary for security mitigations."""
          # Would use checksec or similar
          return {
              'NX': True,
              'ASLR': True,
              'PIE': True,
              'RELRO': 'Full',
              'Stack_Canary': True,
              'CFI': False,
              'CET': False,
          }
      
      @staticmethod
      def get_hardening_recommendations() -> Dict[str, str]:
          """Get compiler flags for hardening."""
          return {
              'Stack Protection': '-fstack-protector-strong',
              'FORTIFY': '-D_FORTIFY_SOURCE=2',
              'PIE': '-pie -fPIC',
              'RELRO': '-Wl,-z,relro,-z,now',
              'NX Stack': '-Wl,-z,noexecstack',
              'CFI': '-fsanitize=cfi (Clang)',
              'CET': '-fcf-protection=full',
              'Safe Stack': '-fsanitize=safe-stack',
          }

# === VARIABLES ===
variables:
  scenario_type:
    type: string
    options:
      - "network service"
      - "file parser"
      - "interpreter"
      - "crypto library"
      - "kernel module"
      
  binary_size_kb:
    type: int
    min: 100
    max: 50000
    
  gadget_count:
    type: int
    min: 50
    max: 50000
    
  task_steps:
    type: template
    value: |
      1. Analyze binary for ROP gadgets
      2. Identify dangerous gadget patterns
      3. Verify ASLR is fully enabled
      4. Check stack canary deployment
      5. Implement/verify CFI
      6. Enable hardware mitigations (CET)
      7. Reduce gadget surface
      8. Add ROP detection
      9. Test bypass attempts
      10. Document defenses

# === CVE REFERENCES ===
cve_references:
  - id: "CVE-2017-5753"
    description: "Spectre Variant 1"
    relevance: "Speculative execution for ROP"
    
  - id: "CVE-2017-5715"
    description: "Spectre Variant 2 (BTI)"
    relevance: "Branch target injection"
    
  - id: "CVE-2017-5754"
    description: "Meltdown"
    relevance: "Kernel memory disclosure"
    
  - id: "CVE-2018-3639"
    description: "Speculative Store Bypass"
    relevance: "Speculative execution side channel"
    
  - id: "CVE-2020-0601"
    description: "CurveBall"
    relevance: "Certificate chain validation bypass"

# === EXTENDED GADGET ANALYSIS ===
extended_gadget_analysis:
  common_gadget_patterns:
    x86_64:
      pop_rdi:
        - "5f c3"  # pop rdi; ret
        - "41 5f c3"  # pop r15; ret (alternative)
      pop_rsi:
        - "5e c3"  # pop rsi; ret
      pop_rdx:
        - "5a c3"  # pop rdx; ret
      pop_rax:
        - "58 c3"  # pop rax; ret
      syscall:
        - "0f 05"  # syscall
        - "0f 05 c3"  # syscall; ret
      leave_ret:
        - "c9 c3"  # leave; ret (stack pivot)
      xchg_rsp:
        - "94 c3"  # xchg esp, eax; ret
        - "48 94 c3"  # xchg rsp, rax; ret
        
    x86:
      pop_eax:
        - "58 c3"  # pop eax; ret
      pop_ebx:
        - "5b c3"  # pop ebx; ret
      int_80:
        - "cd 80"  # int 0x80
        - "cd 80 c3"  # int 0x80; ret
        
    arm64:
      load_x0:
        - "ldp x0, x1, [sp], #16; ret"
      blr:
        - "blr x8"  # Branch to x8
        
  gadget_quality_metrics:
    high_quality:
      - "Single instruction before ret"
      - "No side effects"
      - "Controls key register"
      - "No conditional branches"
      
    medium_quality:
      - "2-3 instructions"
      - "Minor side effects"
      - "Useful for setup"
      
    low_quality:
      - "Many instructions"
      - "Complex side effects"
      - "Conditional logic"

# === TESTING AND VERIFICATION ===
testing_verification:
  tools:
    gadget_finders:
      - name: "ROPgadget"
        command: "ROPgadget --binary ./target --depth 10"
        
      - name: "ropper"
        command: "ropper -f ./target --search 'pop rdi'"
        
      - name: "rp++"
        command: "rp-lin -f ./target -r 5"
        
      - name: "angrop"
        description: "Part of angr framework"
        
    exploit_development:
      - name: "pwntools"
        example: |
          from pwn import *
          elf = ELF('./binary')
          rop = ROP(elf)
          rop.call('puts', [elf.got['puts']])
          rop.call('main')
          print(rop.dump())
          
      - name: "gef/pwndbg"
        description: "GDB extensions for exploit development"
        
    mitigation_check:
      - name: "checksec"
        command: "checksec --file=./target"
        output_example: |
          RELRO           FULL
          Stack Canary    YES
          NX              YES
          PIE             YES
          FORTIFY         YES
          
  verification_checklist:
    - "All mitigations shown as enabled"
    - "Gadget count minimized"
    - "No dangerous gadget combinations"
    - "ASLR entropy is maximum"
    - "Stack canary entropy is sufficient"
    - "CFI violations cause abort"

# === DEFENSE IN DEPTH ===
defense_in_depth:
  layer_1_compilation:
    description: "Compile-time protections"
    measures:
      - "-fstack-protector-strong"
      - "-D_FORTIFY_SOURCE=2"
      - "-pie -fPIC"
      - "-Wl,-z,relro,-z,now"
      - "-fsanitize=cfi (Clang)"
      - "-fcf-protection=full"
      
  layer_2_runtime:
    description: "OS-level protections"
    measures:
      - "Full ASLR enabled"
      - "Seccomp-BPF filtering"
      - "AppArmor/SELinux policies"
      - "Namespace isolation"
      
  layer_3_hardware:
    description: "Hardware-assisted protections"
    measures:
      - "Intel CET (Shadow Stack + IBT)"
      - "ARM PAC (Pointer Authentication)"
      - "ARM BTI (Branch Target Identification)"
      - "SMEP/SMAP for kernel"
      
  layer_4_monitoring:
    description: "Detection and response"
    measures:
      - "Runtime ROP detection"
      - "Anomaly-based monitoring"
      - "Crash reporting and analysis"
      - "Security event logging"

# === EXPLOIT DEVELOPMENT METHODOLOGY ===
exploit_development_methodology:
  step_1_reconnaissance:
    - "Identify target binary and version"
    - "Check enabled mitigations"
    - "Analyze vulnerability type"
    - "Determine overflow size/control"
    
  step_2_information_gathering:
    - "Extract gadgets from binary"
    - "Extract gadgets from loaded libraries"
    - "Identify useful functions (system, execve)"
    - "Find string references (/bin/sh)"
    
  step_3_chain_construction:
    - "Plan register setup sequence"
    - "Account for calling convention"
    - "Handle stack alignment requirements"
    - "Consider null byte restrictions"
    
  step_4_aslr_handling:
    - "Find information leak"
    - "Calculate base addresses"
    - "Adjust gadget addresses"
    - "Or: use partial overwrite technique"
    
  step_5_testing:
    - "Test in controlled environment"
    - "Verify each gadget execution"
    - "Debug chain failures"
    - "Adapt to target environment"

# === ANTI-PATTERNS AND LLM FAILURE MODES ===
anti_patterns:
  llm_failure_modes:
    - "Applying textbook attack patterns without considering mitigations"
    - "Missing WAF/IDS bypass techniques for exploitation"
    - "Ignoring ASLR/PIE/NX and other modern protections"
    - "Not considering timing side-channel in crypto implementations"
    - "Missing second-order and stored attack vectors"
    - "Overlooking race conditions in authentication flows"
    - "Assuming standard libraries are secure without version checking"
    - "Missing JWT algorithm confusion and key confusion attacks"
    - "Ignoring deserialization gadget chain discovery complexity"
    - "Not recognizing Intel CET shadow stack enforcement"
    - "Missing ARM PAC (Pointer Authentication) bypass techniques"
    - "Overlooking CFI (Control Flow Integrity) enforcement"
    - "Failing to identify ASLR entropy and brute-force feasibility"
    - "Not considering PIE implications for gadget addresses"
    - "Missing stack canary leak techniques"
    - "Ignoring RELRO and GOT protection status"
    - "Not recognizing ret2csu universal gadget availability"
    - "Overlooking SROP (Sigreturn-Oriented Programming) techniques"
    - "Missing JOP (Jump-Oriented Programming) for ret-less chains"
    - "Failing to identify stack pivot gadgets"
    - "Not considering one-gadget RCE opportunities"
    - "Ignoring libc version-specific gadget availability"
    - "Missing BROP (Blind ROP) techniques for remote exploitation"
    - "Not recognizing JIT-ROP for fine-grained ASLR bypass"
    - "Overlooking COOP attacks against C++ virtual tables"
    - "Failing to account for seccomp sandbox restrictions"
    - "Not considering kernel ASLR (KASLR) in privilege escalation"
    - "Missing SMEP/SMAP bypass for kernel exploitation"
    - "Ignoring hardware debug register exploitation"

# === ANTI-HARDCODING MEASURES ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  attack_vectors:
    - "classic_rop"
    - "ret2libc"
    - "ret2csu"
    - "srop"
    - "jop"
    - "brop"
    - "jit_rop"
    - "coop"
    
  bypass_techniques:
    - "info_leak_aslr"
    - "canary_leak"
    - "partial_overwrite"
    - "brute_force"
    - "cfi_bypass"
    
  verification_requirements:
    - "All compile-time mitigations enabled"
    - "Runtime detection active"
    - "Hardware features utilized"
    - "Gadget surface minimized"

# === COMPLIANCE MAPPING ===
compliance_mapping:
  cis_controls:
    - "Control 16: Application Software Security"
    - "Control 18: Penetration Testing"
    
  nist_800_53:
    - "SI-16: Memory Protection"
    - "SI-17: Fail-Safe Procedures"
    
  owasp:
    - "A03:2021 – Injection"
    - "A05:2021 – Security Misconfiguration"

# === ADDITIONAL TEST CASES ===
additional_test_cases:
  gadget_surface:
    - "test_gadget_count_reduced"
    - "test_no_syscall_gadgets"
    - "test_no_stack_pivot_gadgets"
    
  mitigation_verification:
    - "test_aslr_full_entropy"
    - "test_stack_canary_present"
    - "test_nx_enabled"
    - "test_pie_enabled"
    - "test_relro_full"
    
  runtime_detection:
    - "test_rop_chain_detected"
    - "test_abnormal_returns_flagged"
    - "test_shadow_stack_mismatch"
    
  bypass_prevention:
    - "test_info_leak_fixed"
    - "test_canary_not_leakable"
    - "test_partial_overwrite_blocked"

# === COMPREHENSIVE ROP GADGET DATABASE ===
comprehensive_gadget_database:
  x86_64_gadgets:
    register_control:
      rdi:
        - pattern: "5f c3"
          asm: "pop rdi; ret"
          usage: "First argument (System V AMD64)"
          
        - pattern: "48 8b 7c 24 XX c3"
          asm: "mov rdi, [rsp+XX]; ret"
          usage: "Load rdi from stack offset"
          
      rsi:
        - pattern: "5e c3"
          asm: "pop rsi; ret"
          usage: "Second argument"
          
        - pattern: "48 89 f7 c3"
          asm: "mov rdi, rsi; ret"
          usage: "Copy rsi to rdi"
          
      rdx:
        - pattern: "5a c3"
          asm: "pop rdx; ret"
          usage: "Third argument"
          
      rcx:
        - pattern: "59 c3"
          asm: "pop rcx; ret"
          usage: "Fourth argument"
          
      r8:
        - pattern: "41 58 c3"
          asm: "pop r8; ret"
          usage: "Fifth argument"
          
      r9:
        - pattern: "41 59 c3"
          asm: "pop r9; ret"
          usage: "Sixth argument"
          
      rax:
        - pattern: "58 c3"
          asm: "pop rax; ret"
          usage: "System call number"
          
      rsp:
        - pattern: "5c c3"
          asm: "pop rsp; ret"
          usage: "Stack pivot"
          danger: "HIGH"
          
    syscall_gadgets:
      - pattern: "0f 05 c3"
        asm: "syscall; ret"
        usage: "System call invocation"
        danger: "CRITICAL"
        
      - pattern: "0f 05"
        asm: "syscall"
        usage: "System call (no ret)"
        
    memory_operations:
      read:
        - pattern: "48 8b 00 c3"
          asm: "mov rax, [rax]; ret"
          usage: "Read from address in rax"
          
        - pattern: "48 8b 07 c3"
          asm: "mov rax, [rdi]; ret"
          usage: "Read from address in rdi"
          
      write:
        - pattern: "48 89 07 c3"
          asm: "mov [rdi], rax; ret"
          usage: "Write rax to [rdi]"
          danger: "HIGH"
          
        - pattern: "48 89 17 c3"
          asm: "mov [rdi], rdx; ret"
          usage: "Write rdx to [rdi]"
          
    stack_pivot:
      - pattern: "94 c3"
        asm: "xchg esp, eax; ret"
        usage: "32-bit stack pivot"
        
      - pattern: "48 94 c3"
        asm: "xchg rsp, rax; ret"
        usage: "64-bit stack pivot"
        danger: "CRITICAL"
        
      - pattern: "c9 c3"
        asm: "leave; ret"
        usage: "Stack pivot via saved rbp"
        
    arithmetic:
      - pattern: "48 01 f8 c3"
        asm: "add rax, rdi; ret"
        usage: "Add rdi to rax"
        
      - pattern: "48 29 f8 c3"
        asm: "sub rax, rdi; ret"
        usage: "Subtract rdi from rax"
        
  x86_gadgets:
    register_control:
      eax:
        - pattern: "58 c3"
          asm: "pop eax; ret"
          
      ebx:
        - pattern: "5b c3"
          asm: "pop ebx; ret"
          
      ecx:
        - pattern: "59 c3"
          asm: "pop ecx; ret"
          
      edx:
        - pattern: "5a c3"
          asm: "pop edx; ret"
          
    syscall:
      - pattern: "cd 80 c3"
        asm: "int 0x80; ret"
        usage: "Linux x86 system call"
        
  arm64_gadgets:
    register_control:
      - pattern: "ldp x0, x1, [sp], #0x10; ret"
        usage: "Load x0 and x1 from stack"
        
      - pattern: "ldr x8, [sp], #0x8; ret"
        usage: "Load x8 (syscall number)"
        
    syscall:
      - pattern: "svc #0; ret"
        usage: "ARM64 system call"
        
    branch:
      - pattern: "br x8"
        usage: "Branch to x8"
        
      - pattern: "blr x8"
        usage: "Branch and link to x8"

# === ROP CHAIN TEMPLATES ===
rop_chain_templates:
  execve_x86_64:
    description: "Execute /bin/sh on Linux x86_64"
    prerequisites:
      - "pop rdi; ret gadget"
      - "pop rsi; ret gadget"
      - "pop rdx; ret gadget (or zero rdx)"
      - "pop rax; ret gadget"
      - "syscall; ret gadget"
      - "/bin/sh string address"
    chain: |
      pop_rdi_ret          # Load /bin/sh address
      binsh_addr           # Address of "/bin/sh"
      pop_rsi_ret          # Load NULL for argv
      0                    # NULL
      pop_rdx_ret          # Load NULL for envp
      0                    # NULL
      pop_rax_ret          # Set syscall number
      59                   # execve = 59
      syscall_ret          # Execute syscall
      
  mprotect_x86_64:
    description: "Make memory executable (bypass NX)"
    prerequisites:
      - "pop rdi; ret"
      - "pop rsi; ret"
      - "pop rdx; ret"
      - "pop rax; ret"
      - "syscall; ret"
    chain: |
      pop_rdi_ret          # Address to make executable
      target_addr_aligned  # Page-aligned address
      pop_rsi_ret          # Size
      0x1000               # One page
      pop_rdx_ret          # Permissions
      7                    # PROT_READ | PROT_WRITE | PROT_EXEC
      pop_rax_ret          # Syscall number
      10                   # mprotect = 10
      syscall_ret
      
  leak_libc:
    description: "Leak libc address via puts/printf"
    prerequisites:
      - "pop rdi; ret"
      - "Address of puts@plt or printf@plt"
      - "Address in GOT to leak"
      - "Main function address (for continuation)"
    chain: |
      pop_rdi_ret          # First argument
      got_entry            # Address to leak (e.g., puts@got)
      puts_plt             # Call puts
      main                 # Return to main for second stage

# === MITIGATION DEEP DIVE ===
mitigation_deep_dive:
  intel_cet:
    description: "Intel Control-flow Enforcement Technology"
    components:
      shadow_stack:
        - "Hardware-maintained return address stack"
        - "Push return address on call"
        - "Verify on ret"
        - "Fault on mismatch"
        
      indirect_branch_tracking:
        - "ENDBRANCH instruction required at indirect branch targets"
        - "Fault if missing ENDBRANCH"
        - "Limits valid jump targets"
        
    enabling:
      compile: "-fcf-protection=full"
      requirements:
        - "CPU with CET support"
        - "Linux 5.10+ kernel"
        - "glibc 2.33+"
        
    bypass_considerations:
      - "May be disabled per-function"
      - "Legacy code compatibility mode"
      - "Signal handler considerations"
      
  arm_pac:
    description: "ARM Pointer Authentication Codes"
    mechanism:
      - "Cryptographically sign pointers"
      - "Embed PAC in unused pointer bits"
      - "Verify PAC before use"
      
    instructions:
      - "PACIA: Sign pointer with key A"
      - "AUTIA: Authenticate with key A"
      - "PACIB/AUTIB: Key B variants"
      
    bypass_research:
      - "PAC collision attacks"
      - "Signing oracle attacks"
      - "Key recovery"
      
  cfi_implementations:
    clang_cfi:
      types:
        - "cfi-cast-strict: Type-based cast checks"
        - "cfi-derived-cast: Derived class casts"
        - "cfi-unrelated-cast: Unrelated type casts"
        - "cfi-nvcall: Non-virtual member calls"
        - "cfi-vcall: Virtual function calls"
        - "cfi-icall: Indirect function calls"
        
      compile: "-fsanitize=cfi -flto -fvisibility=hidden"
      
    microsoft_cfg:
      description: "Control Flow Guard"
      mechanism:
        - "Bitmap of valid indirect call targets"
        - "Check before indirect call"
        
      bypass_research:
        - "Calling allowed functions with attacker-controlled arguments"
        - "JIT page manipulation"

# === REAL-WORLD EXPLOITATION CASE STUDIES ===
case_studies:
  - name: "CVE-2016-0728 (keyring UAF to ROP)"
    description: "Linux kernel keyring UAF allowing ROP"
    technique: "Use-after-free to control function pointer"
    mitigations_bypassed:
      - "SMEP (kernel mode)"
      - "SMAP (partially)"
      
  - name: "CVE-2017-7494 (SambaCry)"
    description: "Samba RCE via shared library loading"
    technique: "Write shared library, trigger load"
    
  - name: "Browser JIT-ROP"
    description: "Using JIT spray for ASLR bypass"
    technique: "Embed gadgets in JIT code constants"
    
# === ADVANCED BYPASS TECHNIQUES ===
advanced_bypass_techniques:
  information_leaks:
    format_string:
      - "printf(user_input) leaks stack"
      - "Can leak canary, return addresses, libc"
      
    oob_read:
      - "Out-of-bounds array read"
      - "Leak adjacent memory"
      
    use_after_free:
      - "Read freed memory"
      - "May contain pointers"
      
    side_channels:
      - "Cache timing attacks"
      - "Branch prediction"
      - "Speculative execution"
      
  canary_bypass:
    leak:
      - "Format string leak"
      - "OOB read before canary"
      - "Adjacent buffer leak"
      
    brute_force:
      - "Fork-based: child inherits canary"
      - "Try all 256 values per byte"
      - "Only works with respawning services"
      
    overwrite_check:
      - "Overwrite __stack_chk_fail GOT"
      - "Make canary check benign"
      
  partial_overwrite:
    description: "Overwrite only LSBs of addresses"
    technique:
      - "ASLR randomizes pages, not offsets"
      - "Overwrite 1-2 bytes to change offset"
      - "12-bit of entropy for one byte overwrite"

# === TOOL USAGE EXAMPLES ===
tool_usage_examples:
  pwntools:
    basic_rop: |
      from pwn import *
      
      elf = ELF('./vulnerable')
      rop = ROP(elf)
      
      # Build ROP chain
      rop.raw(rop.ret)  # Stack alignment
      rop.call('puts', [elf.got['puts']])
      rop.call('main')
      
      # Create payload
      payload = b'A' * offset
      payload += rop.chain()
      
    libc_rop: |
      from pwn import *
      
      libc = ELF('./libc.so.6')
      libc.address = leaked_base
      
      rop = ROP(libc)
      rop.call('system', [next(libc.search(b'/bin/sh\x00'))])
      
  ropper:
    commands: |
      # Load binary
      (ropper)> file ./vulnerable
      
      # Search gadgets
      (ropper)> search /1/ pop rdi
      (ropper)> search /1/ syscall
      
      # Generate chain
      (ropper)> chain execve
      
  ROPgadget:
    commands: |
      # Find all gadgets
      ROPgadget --binary ./vulnerable
      
      # Find specific gadget
      ROPgadget --binary ./vulnerable --only "pop|ret"
      
      # Generate chain
      ROPgadget --binary ./vulnerable --ropchain
