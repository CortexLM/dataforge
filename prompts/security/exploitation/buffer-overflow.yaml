id: "sec-exploit-buffer-overflow-001"
version: "2.0.0"
category: "security"
subcategory: "exploitation"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research advanced buffer overflow variants, heap exploitation, and modern mitigations"
    phase_2_creation: "Create multi-layered memory safety challenge with various overflow types"
    phase_3_amplification: "Add mitigation bypass scenarios and secure coding requirements"
    phase_4_verification:
      base_validation: "Validate task requires comprehensive memory safety expertise"
      enhanced_criteria:
        - "Has at least 5 interacting vulnerability chains"
        - "Has cascading exploitation paths that require chained attacks"
        - "Requires knowledge of compiler/interpreter internals for exploitation"
        - "Would take experienced security researchers 45+ minutes"
  
  complexity_targets:
    min_steps: 15
    max_steps: 50
    required_expertise:
      - "C/C++ memory management"
      - "Stack and heap layout"
      - "Compiler security features"
      - "Memory safety tools (ASAN, MSAN)"
      - "Secure coding practices"
    
  anti_shortcut_measures:
    - "Require identification of multiple overflow types"
    - "Demand safe string function usage"
    - "Test against integer overflow leading to buffer overflow"
    - "Verify proper bounds checking implementation"

# SWE-bench_Pro style fields
problem_statement: |
  A C/C++ application has buffer overflow vulnerabilities that could lead to 
  code execution. The vulnerabilities include:
  
  1. Stack-based buffer overflow in string handling
  2. Heap overflow in dynamic allocation
  3. Integer overflow leading to buffer overflow
  4. Off-by-one errors in loop bounds
  5. Format string vulnerabilities
  6. Uninitialized memory usage
  7. Use-after-free vulnerabilities
  8. Double-free vulnerabilities
  9. Type confusion leading to overflow
  10. Out-of-bounds array access

requirements: |
  - Identify ALL buffer overflow vulnerabilities
  - Implement comprehensive bounds checking
  - Use safe string functions (strlcpy, snprintf)
  - Add integer overflow protection
  - Enable compiler security features
  - Use memory safety tools for testing
  - Implement proper memory management
  - Add defensive programming patterns
  - Document all security fixes
  - Verify with AddressSanitizer/Valgrind

interface: |
  Input: C/C++ code with memory safety issues
  Output: Memory-safe code with security audit report
  Validation: No overflow with fuzzing, ASAN/MSAN clean

# === TOPIC UNIVERSE (100+ topics) ===
topic_universe:
  stack_overflows:
    - "Stack buffer overflow basics"
    - "Return address overwrite"
    - "Saved frame pointer overwrite"
    - "Stack-based variable corruption"
    - "strcpy/strcat overflow"
    - "gets() vulnerability"
    - "sprintf overflow"
    - "alloca() issues"
    - "Variable-length array overflow"
    - "Nested function pointer overwrite"
    
  heap_overflows:
    - "Heap buffer overflow"
    - "Heap metadata corruption"
    - "Fastbin attack"
    - "Unsorted bin attack"
    - "Tcache poisoning"
    - "House of Force"
    - "House of Spirit"
    - "House of Lore"
    - "House of Orange"
    - "Unlink exploitation"
    
  integer_issues:
    - "Integer overflow"
    - "Integer underflow"
    - "Signedness bugs"
    - "Width truncation"
    - "Integer coercion"
    - "Size calculation overflow"
    - "Array index overflow"
    - "Length field overflow"
    - "Counter overflow"
    - "Multiplication overflow"
    
  memory_issues:
    - "Use-after-free (UAF)"
    - "Double-free"
    - "Memory leak"
    - "Dangling pointer"
    - "Uninitialized memory read"
    - "Null pointer dereference"
    - "Type confusion"
    - "Object lifetime issues"
    - "RAII violations"
    - "Memory aliasing bugs"
    
  string_functions:
    - "strcpy dangers"
    - "strcat dangers"
    - "sprintf dangers"
    - "gets dangers"
    - "scanf dangers"
    - "strncpy issues"
    - "strncat issues"
    - "Safe alternatives (strlcpy)"
    - "C11 bounds-checking"
    - "snprintf proper usage"
    
  compiler_protections:
    - "Stack canaries/cookies"
    - "FORTIFY_SOURCE"
    - "Stack protector levels"
    - "Safe stack"
    - "Shadow stack"
    - "AddressSanitizer"
    - "MemorySanitizer"
    - "UndefinedBehaviorSanitizer"
    - "ThreadSanitizer"
    - "Bounds checking"
    
  exploitation_techniques:
    - "Shellcode injection"
    - "NOP sled"
    - "Return-to-libc"
    - "ROP chain"
    - "Heap spray"
    - "JIT spray"
    - "Stack pivot"
    - "One gadget"
    - "GOT overwrite"
    - "Virtual table hijacking"
    
  mitigations:
    - "DEP/NX"
    - "ASLR"
    - "PIE"
    - "RELRO"
    - "Seccomp"
    - "Sandboxing"
    - "Privilege separation"
    - "Capability dropping"
    - "CFI"
    - "Memory tagging"

# === ATTACK CHAINS (50+ chains) ===
attack_chains:
  stack_exploitation:
    - name: "Classic Stack Overflow"
      steps:
        - "Find vulnerable strcpy/gets"
        - "Calculate buffer size and return address offset"
        - "Craft payload: padding + return address"
        - "Overwrite return address with shellcode/ROP"
        - "Execute on function return"
      difficulty: "easy"
      
    - name: "Off-by-One Overflow"
      steps:
        - "Find <= instead of < in bounds check"
        - "Overflow by single byte"
        - "Overwrite saved frame pointer LSB"
        - "Control EBP, then EIP"
      difficulty: "medium"
      
  heap_exploitation:
    - name: "Heap Overflow to UAF"
      steps:
        - "Overflow heap buffer into adjacent chunk metadata"
        - "Corrupt size or flags"
        - "Trigger double coalesce"
        - "Achieve arbitrary write"
      difficulty: "hard"
      
    - name: "Tcache Poisoning"
      steps:
        - "Overflow to corrupt tcache fd pointer"
        - "Point fd to target address"
        - "Allocate twice to get arbitrary allocation"
        - "Write to target"
      difficulty: "hard"

# === SECURE CODING PATTERNS ===
secure_coding_patterns:
  string_handling:
    dangerous: ["strcpy", "strcat", "sprintf", "gets", "scanf"]
    safe_alternatives:
      strcpy: "strlcpy(dst, src, sizeof(dst))"
      strcat: "strlcat(dst, src, sizeof(dst))"
      sprintf: "snprintf(buf, sizeof(buf), fmt, ...)"
      gets: "fgets(buf, sizeof(buf), stdin)"
      scanf: "scanf(\"%99s\", buf)"
      
  memory_allocation:
    - "Always check malloc return value"
    - "Use calloc for zeroed memory"
    - "Match malloc/free, new/delete"
    - "Set pointers to NULL after free"
    - "Use smart pointers in C++"
    
  integer_safety:
    - "Check before arithmetic operations"
    - "Use safe integer libraries"
    - "Cast carefully between types"
    - "Validate size parameters"

# === REFERENCE SOLUTION ===
reference_solution: |
  /* Secure Buffer Handling in C */
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <stdint.h>
  #include <limits.h>
  
  /* SAFE: Proper string copy with bounds checking */
  void safe_string_copy(char *dst, size_t dst_size, const char *src) {
      if (dst == NULL || src == NULL || dst_size == 0) {
          return;
      }
      
      size_t src_len = strlen(src);
      
      if (src_len >= dst_size) {
          /* Truncate with warning */
          memcpy(dst, src, dst_size - 1);
          dst[dst_size - 1] = '\0';
      } else {
          memcpy(dst, src, src_len + 1);
      }
  }
  
  /* SAFE: Integer overflow check before allocation */
  void *safe_array_alloc(size_t count, size_t size) {
      /* Check for overflow */
      if (size != 0 && count > SIZE_MAX / size) {
          return NULL;
      }
      
      size_t total = count * size;
      if (total == 0) {
          return NULL;
      }
      
      return calloc(count, size);  /* calloc checks internally */
  }
  
  /* SAFE: Bounds-checked array access */
  int safe_array_get(const int *arr, size_t arr_size, size_t index) {
      if (arr == NULL || index >= arr_size) {
          return -1;  /* Error indicator */
      }
      return arr[index];
  }
  
  /*
   * Compiler flags for protection:
   * gcc -fstack-protector-strong -D_FORTIFY_SOURCE=2 -pie -fPIC
   *     -Wl,-z,relro,-z,now -Wl,-z,noexecstack -fsanitize=address
   */

# === DIFFICULTY CONFIGURATION ===
difficulty:
  estimated: "extreme"
  time_range: [10800, 43200]
  command_steps: [200, 800]
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 4.0
      description: "CTF-final level difficulty requiring expert exploitation skills"
      requirements:
        - "7+ interacting vulnerabilities requiring chained exploitation"
        - "Requires understanding of target runtime/compiler internals"
        - "Time estimate: 180+ minutes for senior security researchers"
        - "Multiple protection bypass techniques required"
        - "Requires synthesizing reverse engineering, exploitation, and cryptography"
    
    nightmare_plus:
      multiplier: 8.0
      estimated_time: [43200, 172800]
      command_steps: [500, 2000]
      techniques_required: 20
      description: "Real-world 0-day exploitation requiring novel memory corruption discovery and modern mitigation bypass"
      requirements:
        - "16+ deeply interacting vulnerabilities across stack, heap, and kernel layers"
        - "Requires heap exploitation techniques (tcache, fastbin, house-of-*)"
        - "Time estimate: 12-48 hours for senior security researchers with OSCP/OSWE/OSCE certifications"
        - "Custom fuzzer development and crash triage"
        - "Must bypass ASAN, MSAN, hardened allocators, and CFI simultaneously"
        - "Requires understanding of glibc heap internals and allocator algorithms"
        - "Must achieve reliable exploitation across different glibc/allocator versions"
        - "Kernel memory corruption and privilege escalation required"
  
  generation_targets:
    minimum_difficulty: "120-360 minutes for senior security researchers with offensive security certifications (OSCP/OSWE/OSCE)"
    quality_requirements: "Must require deep understanding of memory corruption, heap exploitation, and secure coding practices"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 8
  coordination_complexity: "extreme"
  
  specialized_agents:
    - name: "vulnerability_hunter"
      role: "Discover memory corruption vulnerabilities"
      expertise: ["fuzzing", "static analysis", "code review", "crash triage"]
      
    - name: "stack_exploitation_specialist"
      role: "Exploit stack-based buffer overflows"
      expertise: ["stack layout", "return address overwrite", "canary bypass", "frame pointer overwrite"]
      
    - name: "heap_exploitation_specialist"
      role: "Exploit heap-based memory corruption"
      expertise: ["heap internals", "tcache", "fastbin", "house-of techniques", "UAF"]
      
    - name: "integer_overflow_specialist"
      role: "Identify and exploit integer vulnerabilities"
      expertise: ["integer overflow", "size calculation bugs", "signedness issues"]
      
    - name: "format_string_specialist"
      role: "Exploit format string vulnerabilities"
      expertise: ["format string read/write", "GOT overwrite", "stack manipulation"]
      
    - name: "mitigation_bypass_specialist"
      role: "Bypass memory safety mitigations"
      expertise: ["ASLR bypass", "stack protection bypass", "CFI bypass", "MTE bypass"]
      
    - name: "fuzzer_developer"
      role: "Develop and optimize fuzzers for target"
      expertise: ["AFL++", "libFuzzer", "grammar fuzzing", "coverage analysis"]
      
    - name: "secure_coding_analyst"
      role: "Identify secure coding violations"
      expertise: ["CERT C", "MISRA", "code review", "static analysis"]
  
  cross_vulnerability_chains:
    - chain: "Integer overflow -> Heap buffer overflow -> UAF -> Arbitrary write -> RCE"
      complexity: "extreme"
      
    - chain: "Format string -> Stack leak -> Canary bypass -> Stack overflow -> Shell"
      complexity: "high"
      
    - chain: "Off-by-one -> Heap corruption -> Tcache poisoning -> Arbitrary allocation -> Code execution"
      complexity: "extreme"
      
    - chain: "Double-free -> Fastbin attack -> __malloc_hook overwrite -> RCE"
      complexity: "extreme"
      
    - chain: "Type confusion -> OOB read -> Info leak -> OOB write -> Control flow hijack"
      complexity: "extreme"

# === EXPLOIT CHAIN REQUIREMENTS ===
exploit_chain_requirements:
  minimum_chain_length: 5
  required_stages:
    - stage: "vulnerability_discovery"
      description: "Find exploitable memory corruption"
      techniques:
        - "Fuzzing with sanitizers"
        - "Manual code audit"
        - "Static analysis tools"
        - "Dynamic binary instrumentation"
    
    - stage: "root_cause_analysis"
      description: "Understand vulnerability mechanics"
      techniques:
        - "Crash analysis and reproduction"
        - "Memory layout understanding"
        - "Corruption primitive identification"
        - "Exploitability assessment"
    
    - stage: "primitive_development"
      description: "Develop exploitation primitives"
      techniques:
        - "Heap shaping"
        - "Memory layout manipulation"
        - "Information leakage"
        - "Write primitive development"
    
    - stage: "mitigation_bypass"
      description: "Bypass active protections"
      techniques:
        - "ASLR defeat"
        - "Stack canary bypass"
        - "CFI bypass"
        - "Hardened allocator bypass"
    
    - stage: "code_execution"
      description: "Achieve arbitrary code execution"
      techniques:
        - "Control flow hijacking"
        - "ROP chain execution"
        - "Shellcode execution"
        - "Post-exploitation persistence"

# === DEFENSIVE EVASION ===
defensive_evasion:
  security_controls_to_bypass:
    - control: "AddressSanitizer (ASAN)"
      bypass_techniques:
        - "Exploit in non-ASAN build"
        - "ASAN shadow memory manipulation"
        - "Out-of-scope memory access"
        - "Quarantine exhaustion"
      
    - control: "Stack Protection"
      bypass_techniques:
        - "Canary value leakage"
        - "Thread-local storage access"
        - "Format string canary read"
        - "Brute force in fork servers"
      
    - control: "Heap Hardening"
      bypass_techniques:
        - "Safe-linking bypass in glibc 2.32+"
        - "House-of techniques for hardened heaps"
        - "Allocator-specific vulnerabilities"
        - "Large allocation bypass"
      
    - control: "FORTIFY_SOURCE"
      bypass_techniques:
        - "Non-fortified code paths"
        - "Dynamic size calculations"
        - "Object size unknown scenarios"
      
    - control: "Memory Tagging (ARM MTE)"
      bypass_techniques:
        - "Tag oracle attacks"
        - "Tag collision exploitation"
        - "Speculative tag bypass"

# === REAL-WORLD CORRELATION ===
real_world_correlation:
  cve_attack_patterns:
    - cve: "CVE-2023-4863"
      technique: "WebP heap buffer overflow"
      real_world_impact: "RCE via image processing"
      
    - cve: "CVE-2022-0847"
      technique: "Dirty Pipe kernel vulnerability"
      real_world_impact: "Privilege escalation"
      
    - cve: "CVE-2021-3156"
      technique: "Baron Samedit sudo heap overflow"
      real_world_impact: "Local privilege escalation"
      
    - cve: "CVE-2020-0796"
      technique: "SMBGhost integer overflow"
      real_world_impact: "Remote code execution"

# === TRAP DENSITY ===
trap_configuration:
  total_traps: 16
  trap_interaction_depth: 5
  cross_domain_traps: true
  
  trap_categories:
    stack_overflow_traps: 4
    heap_overflow_traps: 4
    integer_overflow_traps: 3
    format_string_traps: 3
    uaf_traps: 2

# === VARIABLES ===
variables:
  scenario_type:
    type: string
    options:
      - "network daemon"
      - "file parser"
      - "input processor"
      - "protocol handler"
      - "embedded system"
      
  loc_count:
    type: int
    min: 100
    max: 100000
    
  cve_count:
    type: int
    min: 1
    max: 100
    
  task_steps:
    type: template
    value: |
      1. Audit code for buffer overflow patterns
      2. Find unsafe string operations
      3. Check for integer overflow in sizes
      4. Find off-by-one errors
      5. Replace with safe alternatives
      6. Add bounds checking
      7. Enable compiler protections
      8. Run AddressSanitizer
      9. Fuzz test
      10. Document fixes

# === TEST CASES ===
fail_to_pass:
  - "test_no_stack_overflow"
  - "test_no_heap_overflow"
  - "test_integer_overflow_checked"
  - "test_format_string_safe"
  - "test_bounds_checking_present"
  - "test_asan_clean"

pass_to_pass:
  - "test_basic_functionality"
  - "test_normal_inputs"

# === CVE REFERENCES ===
cve_references:
  - id: "CVE-2021-44228"
    description: "Log4j (not overflow but shows impact)"
    relevance: "High-profile vulnerability"
    
  - id: "CVE-2014-0160"
    description: "Heartbleed (buffer over-read)"
    relevance: "Classic buffer vulnerability"

# === TOOL RECOMMENDATIONS ===
tools:
  analysis:
    - "AddressSanitizer"
    - "MemorySanitizer"
    - "Valgrind"
    - "Dr. Memory"
    - "Coverity"
    - "Cppcheck"
    
  fuzzing:
    - "AFL++"
    - "libFuzzer"
    - "Honggfuzz"
    
  exploitation:
    - "pwntools"
    - "ROPgadget"
    - "GDB + pwndbg"

# === EXTENDED REFERENCE SOLUTION ===
extended_reference_solution: |
  /* Extended Secure Buffer Handling in C/C++ */
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <stdint.h>
  #include <limits.h>
  #include <stdbool.h>
  
  /*
   * VULNERABILITY PATTERN 1: Stack Buffer Overflow
   * 
   * UNSAFE:
   * void process_input(char *input) {
   *     char buffer[64];
   *     strcpy(buffer, input);  // No bounds check!
   * }
   * 
   * SAFE:
   */
  int process_input_safe(char *dst, size_t dst_size, const char *input) {
      if (dst == NULL || input == NULL || dst_size == 0) {
          return -1;
      }
      
      size_t input_len = strlen(input);
      
      if (input_len >= dst_size) {
          fprintf(stderr, "Input too long: %zu >= %zu\n", input_len, dst_size);
          return -1;
      }
      
      /* snprintf always null-terminates */
      snprintf(dst, dst_size, "%s", input);
      return 0;
  }
  
  /*
   * VULNERABILITY PATTERN 2: Heap Buffer Overflow
   *
   * UNSAFE:
   * char *copy_string(const char *src) {
   *     char *dst = malloc(strlen(src));  // Missing +1 for null!
   *     strcpy(dst, src);
   *     return dst;
   * }
   *
   * SAFE:
   */
  char *copy_string_safe(const char *src) {
      if (src == NULL) {
          return NULL;
      }
      
      size_t len = strlen(src);
      
      /* Check for size_t overflow */
      if (len == SIZE_MAX) {
          return NULL;
      }
      
      /* Allocate with +1 for null terminator */
      char *dst = malloc(len + 1);
      if (dst == NULL) {
          return NULL;
      }
      
      memcpy(dst, src, len + 1);  /* Include null terminator */
      return dst;
  }
  
  /*
   * VULNERABILITY PATTERN 3: Integer Overflow
   *
   * UNSAFE:
   * void *alloc_array(size_t count, size_t size) {
   *     return malloc(count * size);  // Can overflow!
   * }
   *
   * SAFE:
   */
  void *alloc_array_safe(size_t count, size_t size) {
      /* Check for multiplication overflow */
      if (size != 0 && count > SIZE_MAX / size) {
          /* Would overflow */
          return NULL;
      }
      
      size_t total = count * size;
      if (total == 0) {
          return NULL;
      }
      
      return calloc(count, size);  /* calloc is safer */
  }
  
  /*
   * VULNERABILITY PATTERN 4: Off-By-One Error
   *
   * UNSAFE:
   * void fill_buffer(char *buf, size_t size, char c) {
   *     for (size_t i = 0; i <= size; i++) {  // <= is wrong!
   *         buf[i] = c;
   *     }
   * }
   *
   * SAFE:
   */
  void fill_buffer_safe(char *buf, size_t size, char c) {
      if (buf == NULL || size == 0) {
          return;
      }
      
      for (size_t i = 0; i < size; i++) {  /* Use < not <= */
          buf[i] = c;
      }
  }
  
  /*
   * VULNERABILITY PATTERN 5: Format String
   *
   * UNSAFE:
   * void log_message(char *msg) {
   *     printf(msg);  // User controls format string!
   * }
   *
   * SAFE:
   */
  void log_message_safe(const char *msg) {
      printf("%s", msg);  /* Always use format specifier */
  }
  
  /*
   * VULNERABILITY PATTERN 6: Use-After-Free
   *
   * UNSAFE:
   * void process(struct data *d) {
   *     free(d);
   *     d->value = 0;  // UAF!
   * }
   *
   * SAFE:
   */
  void process_safe(struct data **d) {
      if (d == NULL || *d == NULL) {
          return;
      }
      free(*d);
      *d = NULL;  /* Clear pointer after free */
  }
  
  /*
   * Safe string library wrapper
   */
  typedef struct {
      char *data;
      size_t length;
      size_t capacity;
  } SafeString;
  
  SafeString *safe_string_create(size_t initial_capacity) {
      SafeString *str = malloc(sizeof(SafeString));
      if (str == NULL) {
          return NULL;
      }
      
      str->data = malloc(initial_capacity);
      if (str->data == NULL) {
          free(str);
          return NULL;
      }
      
      str->data[0] = '\0';
      str->length = 0;
      str->capacity = initial_capacity;
      return str;
  }
  
  int safe_string_append(SafeString *str, const char *append) {
      if (str == NULL || append == NULL) {
          return -1;
      }
      
      size_t append_len = strlen(append);
      size_t new_length = str->length + append_len;
      
      /* Check for overflow */
      if (new_length < str->length) {
          return -1;
      }
      
      /* Grow buffer if needed */
      if (new_length >= str->capacity) {
          size_t new_capacity = str->capacity * 2;
          if (new_capacity < new_length + 1) {
              new_capacity = new_length + 1;
          }
          
          /* Check for overflow in capacity calculation */
          if (new_capacity < str->capacity) {
              return -1;
          }
          
          char *new_data = realloc(str->data, new_capacity);
          if (new_data == NULL) {
              return -1;
          }
          
          str->data = new_data;
          str->capacity = new_capacity;
      }
      
      memcpy(str->data + str->length, append, append_len + 1);
      str->length = new_length;
      return 0;
  }
  
  void safe_string_free(SafeString *str) {
      if (str != NULL) {
          free(str->data);
          str->data = NULL;
          free(str);
      }
  }

# === ADDITIONAL ATTACK CHAINS ===
additional_attack_chains:
  format_string_attacks:
    - name: "Format String Read"
      steps:
        - "Identify printf(user_input)"
        - "Use %x to read stack values"
        - "Use %s to read memory addresses"
        - "Leak sensitive data or addresses"
      difficulty: "medium"
      payload: "%x.%x.%x.%x"
      
    - name: "Format String Write"
      steps:
        - "Calculate target address"
        - "Use %n to write value"
        - "Overwrite GOT entry or return address"
        - "Redirect execution"
      difficulty: "hard"
      payload: "AAAA%x%x%x%n"
      
  uaf_exploitation:
    - name: "Use-After-Free to RCE"
      steps:
        - "Free an object"
        - "Allocate controlled data in same location"
        - "Use dangling pointer"
        - "Controlled object behavior"
        - "Achieve code execution"
      difficulty: "hard"
      
    - name: "Double-Free Exploitation"
      steps:
        - "Free object twice"
        - "Corrupt heap metadata"
        - "Achieve arbitrary write"
        - "Overwrite function pointer"
      difficulty: "hard"
      
  type_confusion:
    - name: "C++ Virtual Table Hijacking"
      steps:
        - "Identify type confusion bug"
        - "Confuse object types"
        - "Control virtual table pointer"
        - "Execute attacker-controlled method"
      difficulty: "expert"

# === COMPILER SECURITY FLAGS ===
compiler_security_flags:
  gcc:
    stack_protection:
      - flag: "-fstack-protector"
        description: "Basic stack canary for functions with buffers > 8 bytes"
      - flag: "-fstack-protector-strong"
        description: "Stack canary for functions with arrays or address-taken locals"
      - flag: "-fstack-protector-all"
        description: "Stack canary for all functions (performance impact)"
        
    fortify:
      - flag: "-D_FORTIFY_SOURCE=1"
        description: "Compile-time buffer overflow checks"
      - flag: "-D_FORTIFY_SOURCE=2"
        description: "Compile and runtime buffer overflow checks"
      - flag: "-D_FORTIFY_SOURCE=3"
        description: "Additional checks (GCC 12+)"
        
    other:
      - flag: "-fstack-clash-protection"
        description: "Prevent stack clash attacks"
      - flag: "-fcf-protection"
        description: "Enable Intel CET"
      - flag: "-Wformat-security"
        description: "Warn about format string issues"
      - flag: "-Wstringop-overflow"
        description: "Warn about string operation overflows"
        
  clang:
    sanitizers:
      - flag: "-fsanitize=address"
        description: "AddressSanitizer (ASan)"
      - flag: "-fsanitize=memory"
        description: "MemorySanitizer (MSan)"
      - flag: "-fsanitize=undefined"
        description: "UndefinedBehaviorSanitizer (UBSan)"
      - flag: "-fsanitize=safe-stack"
        description: "Safe stack implementation"
      - flag: "-fsanitize=cfi"
        description: "Control Flow Integrity"
        
  linker:
    - flag: "-Wl,-z,relro"
      description: "Partial RELRO"
    - flag: "-Wl,-z,now"
      description: "Full RELRO (immediate binding)"
    - flag: "-Wl,-z,noexecstack"
      description: "Non-executable stack"
    - flag: "-pie"
      description: "Position Independent Executable"

# === STATIC ANALYSIS PATTERNS ===
static_analysis_patterns:
  dangerous_functions:
    critical:
      - function: "gets"
        issue: "No bounds checking"
        fix: "fgets(buf, size, stdin)"
        
      - function: "strcpy"
        issue: "No bounds checking"
        fix: "strlcpy or strncpy with explicit null termination"
        
      - function: "strcat"
        issue: "No bounds checking"
        fix: "strlcat or strncat"
        
      - function: "sprintf"
        issue: "No bounds checking"
        fix: "snprintf(buf, size, fmt, ...)"
        
    high:
      - function: "scanf"
        issue: "Format string without width specifier"
        fix: "scanf(\"%99s\", buf) with width"
        
      - function: "vsprintf"
        issue: "No bounds checking"
        fix: "vsnprintf"
        
      - function: "realpath"
        issue: "Fixed-size buffer"
        fix: "Use NULL as resolved_path"
        
    medium:
      - function: "strncpy"
        issue: "May not null-terminate"
        fix: "Explicit null termination after strncpy"
        
      - function: "strncat"
        issue: "Confusing size parameter"
        fix: "Calculate remaining space correctly"

# === MEMORY SAFETY TESTING ===
memory_safety_testing:
  addresssanitizer:
    compile: "gcc -fsanitize=address -g program.c -o program"
    detects:
      - "Stack buffer overflow"
      - "Heap buffer overflow"
      - "Use after free"
      - "Double free"
      - "Memory leaks (with leak detector)"
      
  memorysanitizer:
    compile: "clang -fsanitize=memory -g program.c -o program"
    detects:
      - "Uninitialized memory read"
      
  valgrind:
    run: "valgrind --leak-check=full ./program"
    detects:
      - "Memory leaks"
      - "Invalid memory access"
      - "Uninitialized values"
      
  fuzzing_workflow:
    - step: "Compile with sanitizers"
      command: "afl-clang-fast -fsanitize=address program.c -o program"
      
    - step: "Create seed corpus"
      command: "mkdir input && echo 'test' > input/seed"
      
    - step: "Run fuzzer"
      command: "afl-fuzz -i input -o output ./program @@"
      
    - step: "Triage crashes"
      command: "Analyze crashes in output/crashes/"

# === ANTI-PATTERNS AND LLM FAILURE MODES ===
anti_patterns:
  llm_failure_modes:
    - "Applying textbook attack patterns without considering mitigations"
    - "Missing WAF/IDS bypass techniques for exploitation"
    - "Ignoring ASLR/PIE/NX and other modern protections"
    - "Not considering timing side-channel in crypto implementations"
    - "Missing second-order and stored attack vectors"
    - "Overlooking race conditions in authentication flows"
    - "Assuming standard libraries are secure without version checking"
    - "Missing JWT algorithm confusion and key confusion attacks"
    - "Ignoring deserialization gadget chain discovery complexity"
    - "Not recognizing glibc safe-linking in heap exploitation"
    - "Missing tcache poisoning techniques for modern glibc"
    - "Overlooking house-of techniques (force, spirit, lore, orange)"
    - "Failing to identify fastbin dup vulnerabilities"
    - "Not considering chunk consolidation attacks"
    - "Missing __malloc_hook and __free_hook overwrites"
    - "Ignoring top chunk manipulation attacks"
    - "Not recognizing unlink macro exploitation"
    - "Overlooking off-by-one null byte overflow impact"
    - "Missing integer overflow in multiplication for allocation sizes"
    - "Failing to identify signedness bugs in size comparisons"
    - "Not considering type confusion leading to OOB access"
    - "Ignoring use-after-free in complex object lifecycles"
    - "Missing double-free with tcache/fastbin"
    - "Not recognizing stack clash attack techniques"
    - "Overlooking variable-length array (VLA) stack overflow"
    - "Failing to identify alloca abuse vulnerabilities"
    - "Not considering FORTIFY_SOURCE bypass techniques"
    - "Missing AddressSanitizer shadow memory manipulation"
    - "Ignoring ARM Memory Tagging Extension (MTE) bypass"

# === ANTI-HARDCODING MEASURES ===
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  vulnerability_patterns:
    - "stack_overflow"
    - "heap_overflow"
    - "integer_overflow"
    - "format_string"
    - "use_after_free"
    - "double_free"
    - "off_by_one"
    - "null_dereference"
    
  verification_requirements:
    - "AddressSanitizer clean"
    - "MemorySanitizer clean"
    - "No dangerous functions"
    - "Bounds checking present"
    - "Integer overflow checked"

# === ADDITIONAL CVE REFERENCES ===
additional_cve_references:
  - id: "CVE-2023-4863"
    description: "WebP heap buffer overflow"
    relevance: "Recent high-profile overflow"
    
  - id: "CVE-2022-0847"
    description: "Dirty Pipe (kernel)"
    relevance: "Privilege escalation via overflow"
    
  - id: "CVE-2021-3156"
    description: "Baron Samedit (sudo)"
    relevance: "Heap overflow in common utility"
    
  - id: "CVE-2020-0796"
    description: "SMBGhost"
    relevance: "Integer overflow in network protocol"
    
  - id: "CVE-2019-14287"
    description: "sudo integer overflow"
    relevance: "Privilege escalation"

# === COMPLIANCE MAPPING ===
compliance_mapping:
  cert_c:
    - "ARR30-C: Do not form or use out-of-bounds pointers"
    - "ARR38-C: Guarantee that library functions do not form invalid pointers"
    - "MEM30-C: Do not access freed memory"
    - "MEM34-C: Only free memory allocated dynamically"
    - "STR31-C: Guarantee storage for strings has sufficient space"
    - "STR32-C: Do not pass a non-null-terminated sequence"
    
  cwe:
    - "CWE-119: Improper Restriction of Operations within Buffer"
    - "CWE-120: Buffer Copy without Checking Size of Input"
    - "CWE-121: Stack-based Buffer Overflow"
    - "CWE-122: Heap-based Buffer Overflow"
    - "CWE-125: Out-of-bounds Read"
    - "CWE-416: Use After Free"
    - "CWE-415: Double Free"
    - "CWE-190: Integer Overflow"

# === REAL-WORLD SCENARIOS EXPANDED ===
real_world_scenarios_expanded:
  network_services:
    - scenario: "HTTP Request Parser"
      description: "Parsing HTTP headers with variable-length fields"
      vulnerabilities:
        - "Content-Length overflow leading to heap corruption"
        - "Header value buffer overflow"
        - "Chunk size integer overflow"
      mitigations:
        - "Maximum header size limit"
        - "Safe integer parsing"
        - "Bounds-checked buffer operations"
        
    - scenario: "DNS Response Handler"
      description: "Processing DNS responses with variable records"
      vulnerabilities:
        - "Label length overflow"
        - "Compression pointer loops"
        - "Record count overflow"
      mitigations:
        - "Strict length validation"
        - "Loop detection"
        - "Maximum response size"
        
  file_parsers:
    - scenario: "Image Format Parser"
      description: "Parsing image headers and pixel data"
      vulnerabilities:
        - "Dimension overflow (width * height * depth)"
        - "Chunk size manipulation"
        - "Palette index out of bounds"
      mitigations:
        - "Maximum dimension limits"
        - "Overflow-safe multiplication"
        - "Bounds-checked palette access"
        
    - scenario: "Document Parser"
      description: "Processing structured documents"
      vulnerabilities:
        - "Nested element stack overflow"
        - "String length overflow"
        - "Object count overflow"
      mitigations:
        - "Maximum nesting depth"
        - "Safe string handling"
        - "Object count limits"

# === DETAILED VULNERABILITY PATTERNS ===
detailed_vulnerability_patterns:
  pattern_1_strcpy_overflow:
    description: "Classic strcpy buffer overflow"
    vulnerable_code: |
      void vuln(char *input) {
          char buf[64];
          strcpy(buf, input);  // No bounds check
      }
    exploitation:
      - "Input > 64 bytes overwrites return address"
      - "Control EIP/RIP on function return"
    secure_code: |
      void secure(char *input) {
          char buf[64];
          size_t len = strlen(input);
          if (len >= sizeof(buf)) {
              fprintf(stderr, "Input too long\n");
              return;
          }
          memcpy(buf, input, len + 1);
      }
    compiler_warning: "-Wstringop-overflow"
    
  pattern_2_sprintf_overflow:
    description: "sprintf without size limit"
    vulnerable_code: |
      void vuln(int value) {
          char buf[16];
          sprintf(buf, "Value: %d", value);  // May overflow
      }
    exploitation:
      - "Large integers create long strings"
      - "INT_MIN = -2147483648 (11 chars)"
    secure_code: |
      void secure(int value) {
          char buf[32];  // Enough for any int
          snprintf(buf, sizeof(buf), "Value: %d", value);
      }
      
  pattern_3_gets_overflow:
    description: "gets() has no bounds checking"
    vulnerable_code: |
      void vuln() {
          char buf[100];
          gets(buf);  // NEVER use gets()
      }
    note: "gets() is removed in C11"
    secure_code: |
      void secure() {
          char buf[100];
          if (fgets(buf, sizeof(buf), stdin) != NULL) {
              buf[strcspn(buf, "\n")] = '\0';  // Remove newline
          }
      }
      
  pattern_4_integer_to_buffer:
    description: "Integer overflow in size calculation"
    vulnerable_code: |
      void vuln(size_t width, size_t height) {
          size_t size = width * height * 4;  // May overflow
          char *buf = malloc(size);
          // Use buf with original dimensions
      }
    exploitation:
      - "width=0x10000, height=0x10000 -> size wraps to 0"
      - "Small allocation, large access"
    secure_code: |
      void secure(size_t width, size_t height) {
          // Check for overflow
          if (width > SIZE_MAX / 4 / height) {
              return;  // Would overflow
          }
          size_t size = width * height * 4;
          char *buf = malloc(size);
          if (buf == NULL) return;
          // Safe to use
      }
      
  pattern_5_off_by_one:
    description: "Off-by-one in loop or comparison"
    vulnerable_code: |
      void vuln(char *src, size_t len) {
          char buf[100];
          for (size_t i = 0; i <= len && i < 100; i++) {
              buf[i] = src[i];  // When len=100, writes buf[100]
          }
      }
    exploitation:
      - "Single byte overwrite of saved frame pointer"
      - "Can redirect execution"
    secure_code: |
      void secure(char *src, size_t len) {
          char buf[100];
          size_t copy_len = (len < sizeof(buf)) ? len : sizeof(buf) - 1;
          for (size_t i = 0; i < copy_len; i++) {
              buf[i] = src[i];
          }
          buf[copy_len] = '\0';
      }

# === HEAP EXPLOITATION TECHNIQUES ===
heap_exploitation_techniques:
  glibc_heap_overview:
    structures:
      chunk_header:
        - "prev_size: Size of previous chunk (if free)"
        - "size: Size of this chunk + flags"
        - "fd: Forward pointer (free chunks)"
        - "bk: Backward pointer (free chunks)"
        
      arenas:
        - "Main arena for main thread"
        - "Per-thread arenas for threads"
        
      bins:
        - "Fast bins: Small chunks, LIFO"
        - "Unsorted bin: Recently freed"
        - "Small bins: Sorted by size"
        - "Large bins: Sorted, ranges"
        - "Tcache: Per-thread cache (glibc 2.26+)"
        
  attack_techniques:
    fastbin_dup:
      description: "Double-free in fastbin"
      steps:
        - "free(A), free(B), free(A)"
        - "fastbin: A -> B -> A"
        - "malloc returns A twice"
        - "Overwrite fd to get arbitrary allocation"
      mitigation: "GLIBC_TUNABLES fastbin double-free check"
      
    tcache_poisoning:
      description: "Corrupt tcache fd pointer"
      steps:
        - "Overflow into freed tcache chunk"
        - "Overwrite fd pointer"
        - "malloc returns arbitrary address"
      glibc_version: "2.26+"
      mitigation: "Safe-linking in glibc 2.32+"
      
    house_of_force:
      description: "Overflow into top chunk size"
      steps:
        - "Overflow to set top chunk size to -1"
        - "Allocate large negative size"
        - "Wrap around, get allocation anywhere"
      requirements: "Heap overflow, known heap address"
      mitigation: "Top chunk size validation"
      
    unlink_attack:
      description: "Corrupt unlink pointers"
      steps:
        - "Create fake chunk"
        - "Set fd and bk for arbitrary write"
        - "Trigger unlink"
      mitigation: "fd->bk and bk->fd validation"

# === MODERN MITIGATIONS ===
modern_mitigations:
  memory_tagging:
    arm_mte:
      description: "ARM Memory Tagging Extension"
      mechanism:
        - "4-bit tags in pointer bits"
        - "Tags stored in memory"
        - "Hardware checks tag on access"
      coverage:
        - "Use-after-free"
        - "Buffer overflow"
        - "Some type confusion"
        
    intel_lat:
      description: "Intel Linear Address Tagging"
      mechanism:
        - "Tags in virtual address space"
        - "Software interpretation"
        
  safe_allocators:
    hardened_malloc:
      features:
        - "Guard pages between allocations"
        - "Randomized allocation"
        - "Immediate free quarantine"
        
    scudo:
      features:
        - "Chunk header integrity"
        - "Quarantine for freed chunks"
        - "Secondary allocator for large"
        
    mimalloc:
      features:
        - "Free-list shredding"
        - "Secure mode available"
        
  fuzzing_for_discovery:
    afl:
      description: "American Fuzzy Lop"
      technique: "Coverage-guided mutation"
      usage: |
        # Compile with AFL
        afl-clang-fast -fsanitize=address vuln.c -o vuln
        
        # Create seed corpus
        mkdir in && echo "test" > in/seed
        
        # Run fuzzer
        afl-fuzz -i in -o out ./vuln @@
        
    libfuzzer:
      description: "In-process coverage-guided fuzzing"
      usage: |
        // Fuzz target
        extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
            process_input(data, size);
            return 0;
        }
        
        // Compile and run
        clang -fsanitize=fuzzer,address fuzz_target.c -o fuzzer
        ./fuzzer corpus/

# === DEBUGGING TECHNIQUES ===
debugging_techniques:
  gdb_with_pwndbg:
    setup: |
      git clone https://github.com/pwndbg/pwndbg
      cd pwndbg && ./setup.sh
      
    commands:
      - "checksec: Check binary mitigations"
      - "vmmap: Show memory layout"
      - "heap: Analyze heap state"
      - "telescope: Examine memory"
      - "cyclic: Generate De Bruijn pattern"
      - "cyclic -l: Find offset in pattern"
      
  addresssanitizer:
    compile: "gcc -fsanitize=address -g prog.c -o prog"
    output_example: |
      ==12345==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff...
      WRITE of size 1 at 0x7fff... thread T0
          #0 0x... in vuln_function vuln.c:10
          #1 0x... in main vuln.c:20
      
  valgrind:
    commands:
      memcheck: "valgrind --leak-check=full ./prog"
      track_origins: "valgrind --track-origins=yes ./prog"
      
    output_example: |
      ==12345== Invalid write of size 1
      ==12345==    at 0x...: vuln_function (vuln.c:10)
      ==12345==    by 0x...: main (vuln.c:20)
      ==12345==  Address 0x... is 0 bytes after a block of size 64 alloc'd

# === SECURE DEVELOPMENT LIFECYCLE ===
secure_development_lifecycle:
  design_phase:
    - "Threat modeling"
    - "Security requirements"
    - "Safe API selection"
    
  implementation_phase:
    - "Secure coding standards (CERT C, MISRA)"
    - "Code review checklists"
    - "Static analysis integration"
    
  testing_phase:
    - "Unit tests with ASAN/MSAN"
    - "Fuzz testing"
    - "Penetration testing"
    
  deployment_phase:
    - "Compiler hardening flags"
    - "Runtime protections"
    - "Monitoring and alerting"
    
  maintenance_phase:
    - "Vulnerability scanning"
    - "Dependency updates"
    - "Incident response"

# === LANGUAGE-SPECIFIC GUIDANCE ===
language_specific_guidance:
  c:
    best_practices:
      - "Use snprintf, not sprintf"
      - "Use fgets, not gets"
      - "Check all return values"
      - "Initialize all variables"
      - "Free memory exactly once"
      - "Set pointers to NULL after free"
      
    tools:
      - "Clang Static Analyzer"
      - "Cppcheck"
      - "Coverity"
      - "PVS-Studio"
      
  cpp:
    best_practices:
      - "Use std::string over char arrays"
      - "Use std::vector over raw arrays"
      - "Use smart pointers (unique_ptr, shared_ptr)"
      - "Prefer RAII for resource management"
      - "Enable compiler warnings (-Wall -Wextra)"
      
    modern_features:
      - "std::span for safe array access (C++20)"
      - "std::optional instead of null pointers"
      - "Bounds-checked containers"
      
  rust_comparison:
    memory_safety:
      - "Ownership system prevents UAF"
      - "Borrow checker prevents data races"
      - "No null pointers (Option<T>)"
      - "Bounds checking on arrays"
      
    unsafe_escape:
      - "unsafe blocks for low-level"
      - "Still safer than C/C++"
      - "Safe string handling"
      - "Object count limits"
