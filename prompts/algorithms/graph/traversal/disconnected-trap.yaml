id: "algo-graph-disconnected-trap-001"
version: "2.0.0"
category: "algorithms"
subcategory: "graph/traversal"

# =============================================================================
# LLM GENERATION FRAMEWORK
# =============================================================================
# This file is a comprehensive generation specification for LLMs to create
# unique, extremely challenging graph traversal tasks with disconnected components.
# The goal is to enable generation of 10,000+ fundamentally different tasks.
# =============================================================================

generation_framework:
  overview: |
    This specification enables LLMs to generate graph traversal tasks that are
    genuinely difficult. Disconnected graphs have subtle issues around component
    discovery, implicit nodes, edge directionality, and self-loops.

  multi_conversation_workflow:
    phase_1_research:
      description: "LLM researches graph traversal edge cases"
      activities:
        - "Study BFS/DFS on disconnected graphs"
        - "Research implicit vs explicit node handling"
        - "Investigate self-loop effects"
        - "Analyze directed vs undirected handling"
        - "Study real-world graph data issues"
      output: "Comprehensive list of traversal traps"
    
    phase_2_creation:
      description: "LLM creates task with hidden traversal flaws"
      activities:
        - "Design graphs with hidden disconnected components"
        - "Create scenarios with implicit nodes"
        - "Embed self-loop confusion"
        - "Add directed/undirected mixing"
        - "Include metadata-based connections"
      output: "Complete task with traversal traps"
    
    phase_3_amplification:
      description: "LLM adds difficulty multipliers"
      activities:
        - "Layer multiple traversal issues"
        - "Add dynamic graph updates"
        - "Include concurrent modifications"
        - "Create large-scale scenarios"
        - "Add streaming graph input"
      output: "Amplified task"
    
    phase_4_verification:
      description: "LLM validates task is genuinely hard"
      validation_criteria:
        - "Cannot be solved with simple BFS/DFS"
        - "Requires understanding of graph structure"
        - "Has at least 5 interacting hidden traps"
        - "Would take experienced developers 30+ minutes"
        - "Has cascading failure modes that interact with each other"
        - "Requires multi-domain knowledge synthesis (algorithms + systems + performance)"
      output: "Verified task"

  quality_requirements:
    mandatory:
      - "Must require careful node/edge handling"
      - "Must have non-obvious disconnections"
      - "Must include at least 5 traversal issues"
      - "Must have realistic data"
      - "Must resist simple solutions"
      - "Must take 30+ minutes for experienced developers, 45+ for intermediate"

# =============================================================================
# EXHAUSTIVE TOPIC UNIVERSE
# =============================================================================

topic_universe:
  # ---------------------------------------------------------------------------
  # Graph Traversal Topics (35 topics)
  # ---------------------------------------------------------------------------
  traversal_algorithms:
    basic:
      - bfs_single_source
      - bfs_multi_source
      - bfs_level_order
      - dfs_recursive
      - dfs_iterative
      - dfs_preorder
      - dfs_postorder
      - dfs_inorder_tree
    
    component_finding:
      - connected_components_undirected
      - weakly_connected_directed
      - strongly_connected_tarjan
      - strongly_connected_kosaraju
      - biconnected_components
      - bridges_detection
      - articulation_points
      - condensation_graph
    
    specialized:
      - topological_sort
      - cycle_detection_directed
      - cycle_detection_undirected
      - bipartite_check
      - tree_verification
      - forest_counting
      - euler_path
      - hamiltonian_path
    
    tree_traversals:
      - level_order
      - zigzag_traversal
      - boundary_traversal
      - vertical_order
      - diagonal_traversal

  # ---------------------------------------------------------------------------
  # Graph Representation Topics (25 topics)
  # ---------------------------------------------------------------------------
  representations:
    explicit:
      - adjacency_list_dict
      - adjacency_list_array
      - adjacency_matrix
      - edge_list
      - incidence_list
      - compressed_sparse
    
    implicit:
      - grid_graph
      - tree_from_parent
      - tree_from_children
      - graph_from_edges_only
      - graph_from_nodes_only
      - graph_from_metadata
    
    special:
      - multigraph
      - hypergraph
      - labeled_graph
      - attributed_graph
      - dynamic_graph
      - temporal_graph

  # ---------------------------------------------------------------------------
  # Application Domains (30 topics)
  # ---------------------------------------------------------------------------
  domains:
    social_networks:
      - friend_networks
      - follower_graphs
      - community_detection
      - influence_propagation
      - viral_spreading
    
    web:
      - link_graph
      - citation_network
      - web_crawling
      - page_rank_prep
    
    system:
      - dependency_graph
      - call_graph
      - data_flow
      - control_flow
      - module_graph
    
    science:
      - protein_interaction
      - gene_regulatory
      - chemical_compounds
      - neural_networks

# =============================================================================
# COMPLEXITY DIMENSIONS
# =============================================================================

complexity_dimensions:
  graph_structure:
    connectivity:
      - fully_connected
      - sparse_connected
      - multiple_components
      - many_small_components
      - one_giant_component
      - isolated_nodes
    
    directionality:
      - undirected
      - directed
      - mixed_directed_undirected
      - bidirectional_edges
      - asymmetric_connections
    
    special_structures:
      - self_loops
      - parallel_edges
      - tree_structure
      - dag_structure
      - cyclic_structure

  data_issues:
    node_issues:
      - nodes_only_as_sources
      - nodes_only_as_targets
      - nodes_in_metadata
      - nodes_implicit
      - nodes_with_variants
    
    edge_issues:
      - duplicate_edges
      - missing_reverse_edges
      - weighted_vs_unweighted
      - typed_edges
      - temporal_edges

# =============================================================================
# TRAP TAXONOMY
# =============================================================================

trap_taxonomy:
  # ---------------------------------------------------------------------------
  # Node Discovery Traps (8 types)
  # ---------------------------------------------------------------------------
  node_discovery:
    target_only_nodes:
      trap_id: "ND001"
      name: "Nodes Only as Edge Targets"
      description: "Some nodes only appear as edge destinations"
      example: |
        # Node list: [A, B, C]
        # Edges: A->B, B->D
        # D not in node list but exists!
      detection_difficulty: "medium"
      manifestation: "Nodes missed"
      fix: "Extract nodes from all edges"
      
    source_only_nodes:
      trap_id: "ND002"
      name: "Nodes Only as Edge Sources"
      description: "Nodes only appear as edge sources"
      example: |
        # Edges: A->B, C->B
        # Node C might be missed in some representations
      detection_difficulty: "medium"
      manifestation: "Nodes missed"
      fix: "Extract both source and target"
      
    isolated_in_metadata:
      trap_id: "ND003"
      name: "Isolated Nodes in Metadata Only"
      description: "Nodes exist in metadata but have no edges"
      example: |
        # Node metadata: {A: {...}, B: {...}, C: {...}}
        # Edges: A->B only
        # C is isolated but valid
      detection_difficulty: "medium"
      manifestation: "Isolated nodes missed"
      fix: "Include metadata nodes"
      
    case_variant_nodes:
      trap_id: "ND004"
      name: "Case Variants of Node IDs"
      description: "Node IDs differ only in case"
      example: |
        # Edges: A->b, B->c
        # Is 'b' same as 'B'?
      detection_difficulty: "medium"
      manifestation: "Incorrect connectivity"
      fix: "Normalize node IDs"
      
    whitespace_variants:
      trap_id: "ND005"
      name: "Whitespace in Node IDs"
      description: "Node IDs with trailing/leading whitespace"
      example: |
        # Node: "A " vs "A"
        # Different strings, same node?
      detection_difficulty: "medium"
      manifestation: "Lookup failures"
      fix: "Strip whitespace"
      
    unicode_variants:
      trap_id: "ND006"
      name: "Unicode Variant Node IDs"
      description: "Node IDs with different Unicode forms"
      example: |
        # "café" (NFC) vs "café" (NFD)
        # Look same, different bytes
      detection_difficulty: "hard"
      manifestation: "Duplicate nodes"
      fix: "Normalize Unicode"
      
    type_variant_nodes:
      trap_id: "ND007"
      name: "Type Variants of Node IDs"
      description: "Integer vs string node IDs"
      example: |
        # Edge: (1, 2)
        # Node list: ["1", "2"]
        # 1 != "1"
      detection_difficulty: "medium"
      manifestation: "KeyError"
      fix: "Consistent typing"
      
    null_node_id:
      trap_id: "ND008"
      name: "Null or Empty Node IDs"
      description: "Edges with null/empty node references"
      example: |
        # Edge: A -> None
        # Or Edge: "" -> B
      detection_difficulty: "easy"
      manifestation: "Invalid nodes"
      fix: "Validate node IDs"

  # ---------------------------------------------------------------------------
  # Edge Handling Traps (8 types)
  # ---------------------------------------------------------------------------
  edge_handling:
    directed_undirected_mix:
      trap_id: "EH001"
      name: "Mixed Directed and Undirected"
      description: "Some edges directed, some undirected"
      example: |
        # Friend relationship: bidirectional
        # Follow relationship: unidirectional
        # Mixed in same graph
      detection_difficulty: "medium"
      manifestation: "Wrong connectivity"
      fix: "Handle edge types"
      
    missing_reverse:
      trap_id: "EH002"
      name: "Missing Reverse Edges"
      description: "Undirected graph stored as directed, missing reverse"
      example: |
        # Undirected: A--B
        # Stored as: A->B only
        # Missing B->A
      detection_difficulty: "medium"
      manifestation: "Asymmetric traversal"
      fix: "Add reverse edges"
      
    duplicate_edges:
      trap_id: "EH003"
      name: "Duplicate Edges"
      description: "Same edge appears multiple times"
      example: |
        # Edges: A->B, A->B, A->B
        # Three entries for same edge
      detection_difficulty: "easy"
      manifestation: "Affects degree counting"
      fix: "Deduplicate edges"
      
    self_loops:
      trap_id: "EH004"
      name: "Self Loop Handling"
      description: "Edges from node to itself"
      example: |
        # Edge: A->A
        # Should it count for connectivity?
      detection_difficulty: "easy"
      manifestation: "Depends on intent"
      fix: "Filter or handle explicitly"
      
    parallel_edges:
      trap_id: "EH005"
      name: "Parallel Edges (Multigraph)"
      description: "Multiple distinct edges between same nodes"
      example: |
        # Road network: highway A->B, local A->B
        # Two different edges
      detection_difficulty: "medium"
      manifestation: "Depends on representation"
      fix: "Support multigraph or merge"
      
    edge_weight_zero:
      trap_id: "EH006"
      name: "Zero Weight Edge Confusion"
      description: "Zero weight might mean 'no edge'"
      example: |
        # Weight 0: no connection or free edge?
      detection_difficulty: "medium"
      manifestation: "Interpretation dependent"
      fix: "Define semantics clearly"
      
    edge_direction_implicit:
      trap_id: "EH007"
      name: "Implicit Edge Direction"
      description: "Direction implied but not explicit"
      example: |
        # "A relates to B"
        # Is it A->B, B->A, or both?
      detection_difficulty: "medium"
      manifestation: "Wrong direction"
      fix: "Make direction explicit"
      
    temporal_edges:
      trap_id: "EH008"
      name: "Temporal Edge Validity"
      description: "Edges valid only at certain times"
      example: |
        # Friendship from 2020-2022
        # Query for 2023: not connected
      detection_difficulty: "hard"
      manifestation: "Stale connections"
      fix: "Check temporal validity"

  # ---------------------------------------------------------------------------
  # Component Discovery Traps (8 types)
  # ---------------------------------------------------------------------------
  component_discovery:
    single_source_traversal:
      trap_id: "CD001"
      name: "Single Source Traversal"
      description: "BFS/DFS from one source misses components"
      example: |
        # Start BFS from A
        # Component {C, D} unreachable from A
        # Missed!
      detection_difficulty: "easy"
      manifestation: "Missing components"
      fix: "Traverse from all unvisited"
      
    scc_vs_wcc:
      trap_id: "CD002"
      name: "SCC vs WCC Confusion"
      description: "Using weakly connected when strongly needed"
      example: |
        # Directed graph A->B, C->B
        # WCC: {A,B,C}
        # SCC: {A}, {B}, {C}
      detection_difficulty: "medium"
      manifestation: "Wrong components"
      fix: "Use correct algorithm"
      
    self_loop_isolated:
      trap_id: "CD003"
      name: "Self Loop Makes Node Non-Isolated"
      description: "Node with only self-loop appears connected"
      example: |
        # Node A with edge A->A only
        # Has an edge, but effectively isolated
      detection_difficulty: "medium"
      manifestation: "Depends on definition"
      fix: "Define isolated clearly"
      
    bidirectional_component:
      trap_id: "CD004"
      name: "Bidirectional Edges Create Component"
      description: "Two nodes connected bidirectionally form SCC"
      example: |
        # A->B and B->A
        # SCC: {A, B}
        # Without B->A: SCC: {A}, {B}
      detection_difficulty: "easy"
      manifestation: "SCC size depends on reverse edges"
      fix: "Check both directions"
      
    giant_component_dominance:
      trap_id: "CD005"
      name: "Giant Component Masks Others"
      description: "Large component makes small ones seem unimportant"
      example: |
        # Component 1: 10000 nodes
        # Component 2: 5 nodes
        # Easy to miss component 2
      detection_difficulty: "easy"
      manifestation: "Small components ignored"
      fix: "Report all components"
      
    transitive_closure:
      trap_id: "CD006"
      name: "Transitive Closure Missing"
      description: "Not computing transitive reachability"
      example: |
        # A->B->C
        # Direct edges only: A not connected to C
        # Transitive: A connected to C
      detection_difficulty: "medium"
      manifestation: "Depends on definition"
      fix: "Clarify connectivity definition"
      
    articulation_point_split:
      trap_id: "CD007"
      name: "Articulation Point Removal"
      description: "Removing articulation point splits component"
      example: |
        # A--B--C (B is articulation point)
        # Remove B: {A}, {C} separate
      detection_difficulty: "medium"
      manifestation: "Component count changes"
      fix: "Handle articulation points"
      
    bridge_removal:
      trap_id: "CD008"
      name: "Bridge Edge Removal"
      description: "Removing bridge splits component"
      example: |
        # Component connected by single edge
        # Remove that edge: two components
      detection_difficulty: "medium"
      manifestation: "Fragile connectivity"
      fix: "Identify bridges"

  # ---------------------------------------------------------------------------
  # Data Format Traps (6 types)
  # ---------------------------------------------------------------------------
  data_format:
    json_parsing:
      trap_id: "DF001"
      name: "JSON Parsing Issues"
      description: "JSON format variations"
      example: |
        # {"nodes": [...]} vs {"vertices": [...]}
        # {"edges": [...]} vs {"links": [...]}
      detection_difficulty: "easy"
      manifestation: "KeyError"
      fix: "Flexible parsing"
      
    csv_delimiter:
      trap_id: "DF002"
      name: "CSV Delimiter Confusion"
      description: "Wrong delimiter used"
      example: |
        # A;B;5 (semicolon)
        # A,B,5 (comma)
        # A\tB\t5 (tab)
      detection_difficulty: "easy"
      manifestation: "Parse error"
      fix: "Detect delimiter"
      
    header_confusion:
      trap_id: "DF003"
      name: "Header Row Confusion"
      description: "First row is header not data"
      example: |
        # source,target,weight
        # A,B,5
        # Parsing "source" as node
      detection_difficulty: "easy"
      manifestation: "Invalid node"
      fix: "Skip header"
      
    encoding_bom:
      trap_id: "DF004"
      name: "Encoding BOM Issues"
      description: "BOM affects first node ID"
      example: |
        # UTF-8 BOM: EF BB BF
        # First node: "\ufeffA" not "A"
      detection_difficulty: "medium"
      manifestation: "First node wrong"
      fix: "Strip BOM"
      
    line_ending:
      trap_id: "DF005"
      name: "Line Ending Issues"
      description: "Mixed or wrong line endings"
      example: |
        # Windows: \r\n
        # Unix: \n
        # Mixed file
      detection_difficulty: "medium"
      manifestation: "Parse issues"
      fix: "Handle all line endings"
      
    comment_lines:
      trap_id: "DF006"
      name: "Comment Lines"
      description: "File contains comment lines"
      example: |
        # # This is a comment
        # A,B,5
      detection_difficulty: "easy"
      manifestation: "Parse error on comments"
      fix: "Skip comments"

# =============================================================================
# EDGE CASE CATALOG
# =============================================================================

edge_cases:
  graph_structure:
    - empty_graph
    - single_node
    - single_edge
    - single_component
    - two_components
    - many_components
    - all_isolated_nodes
    - complete_graph
    - tree_graph
    - star_graph
    - cycle_graph
    - grid_graph

  node_edge_cases:
    - no_explicit_nodes
    - duplicate_node_ids
    - unicode_node_ids
    - numeric_node_ids
    - mixed_type_ids
    - empty_string_id
    - whitespace_id

  edge_edge_cases:
    - no_edges
    - all_self_loops
    - all_parallel
    - mixed_directions
    - weighted_and_unweighted
    - typed_edges

# =============================================================================
# ANTI-PATTERNS
# =============================================================================

anti_patterns:
  llm_failure_modes:
    - "Pattern matching without considering node discovery completeness"
    - "Applying single-source traversal without restarting from unvisited nodes"
    - "Missing nodes that only appear as edge targets"
    - "Ignoring self-loop handling in connectivity analysis"
    - "Confusing strongly connected with weakly connected components"
    - "Skipping verification of node coverage"
    - "Over-relying on explicit node lists without extracting from edges"
    - "Missing directed vs undirected edge interpretation"
    - "Ignoring metadata-based relationships"
    - "Failing to handle mixed edge types in same graph"
    - "Not normalizing node IDs before comparison"
    - "Missing Unicode normalization in node ID handling"
    - "Overlooking encoding issues in graph file parsing"
    - "Failing to detect isolated nodes"
    - "Not handling empty graph edge case"
    - "Missing BOM handling in file input"
    - "Failing to process comment lines in input"
    - "Not detecting delimiter in CSV-like formats"
    - "Missing whitespace stripping in node IDs"
    - "Failing to handle parallel edges correctly"
    - "Not considering articulation points for component fragility"
    - "Missing bridge edge detection"
    - "Overlooking type coercion in node ID comparison"
    - "Failing to handle very large graphs efficiently"
    - "Not implementing incremental component updates for dynamic graphs"

  task_anti_patterns:
    obvious_disconnect:
      description: "Clearly separate components"
      why_bad: "No discovery needed"

# =============================================================================
# DIFFICULTY AMPLIFIERS
# =============================================================================

difficulty_amplifiers:
  nightmare:
    multiplier: 3.0
    description: "Extreme difficulty requiring expert-level multi-domain synthesis"
    requirements:
      - "7+ interacting traps across multiple domains"
      - "Requires understanding of hardware-level effects"
      - "Time estimate: 90+ minutes for senior engineers"
      - "Multiple red herrings that waste investigation time"
      - "Solution requires synthesizing knowledge from 3+ distinct areas"

  nightmare_plus:
    multiplier: 5.0
    estimated_time: [28800, 172800]  # 8-48 hours
    command_steps: [300, 1200]
    techniques_required: 12
    description: "Research paper difficulty requiring novel graph traversal design"
    requirements:
      - "10+ deeply interacting traps across connectivity/representation/parsing domains"
      - "Requires novel node discovery and edge normalization techniques"
      - "Must synthesize knowledge from graph theory, data formats, and distributed systems"
      - "Requires formal proof of component discovery completeness"
      - "Time estimate: 8-48 hours for competitive programmers with ICPC/IOI medal experience"
      - "Multiple data representation issues that hide nodes/edges"
      - "Must handle streaming graph input with incremental component updates"
      - "Requires understanding of strongly vs weakly connected components"
      - "Solution involves robust graph construction from heterogeneous sources"

# =============================================================================
# MULTI-AGENT ORCHESTRATION COMPLEXITY
# =============================================================================

multi_agent_orchestration:
  description: "Coordinating 4-7 specialized agents for complex graph traversal analysis"
  
  specialized_agents:
    node_discoverer:
      role: "Find all nodes in graph from various sources"
      capabilities:
        - "Node extraction from edge sources/targets"
        - "Metadata-based node discovery"
        - "Implicit node identification"
        - "Node ID normalization"
      handoff_triggers:
        - "Nodes missing from traversal"
        - "Node ID inconsistencies"
    
    edge_normalizer:
      role: "Normalize edge representation"
      capabilities:
        - "Directed/undirected conversion"
        - "Self-loop handling"
        - "Parallel edge processing"
        - "Edge type classification"
      handoff_triggers:
        - "Edge direction confusion"
        - "Mixed edge types"
    
    component_finder:
      role: "Find connected components"
      capabilities:
        - "Undirected component detection"
        - "Strongly connected components"
        - "Weakly connected components"
        - "Articulation points and bridges"
      handoff_triggers:
        - "Component analysis needed"
        - "Connectivity verification"
    
    data_format_handler:
      role: "Parse various graph formats"
      capabilities:
        - "JSON graph parsing"
        - "CSV edge list parsing"
        - "GraphML/GEXF parsing"
        - "Encoding detection"
      handoff_triggers:
        - "Parse errors"
        - "Unknown format"
    
    correctness_verifier:
      role: "Verify traversal correctness"
      capabilities:
        - "Node coverage verification"
        - "Edge coverage verification"
        - "Component correctness"
        - "Isolated node detection"
      handoff_triggers:
        - "Verification needed"
        - "Discrepancies found"

  cross_algorithm_attack_chains:
    chain_1:
      name: "Missing Node → Incomplete Traversal → Wrong Components → Missing Community"
      stages:
        - "Node exists only in edge targets"
        - "Node set doesn't include it"
        - "Traversal misses that component"
        - "Community detection incomplete"
    
    chain_2:
      name: "Edge Direction Wrong → Unreachable Nodes → Missing Edges → Fragmented Graph"
      stages:
        - "Directed edge treated as undirected"
        - "Nodes appear reachable but aren't"
        - "Component seems connected but isn't"
        - "Analysis based on wrong structure"
    
    chain_3:
      name: "Self-Loop Counted → False Connectivity → Wrong Isolation → Bad Analysis"
      stages:
        - "Node has only self-loop"
        - "Node appears connected to itself"
        - "Not marked as isolated"
        - "Component analysis wrong"

# =============================================================================
# THEORETICAL COMPLEXITY REQUIREMENTS
# =============================================================================

theoretical_complexity_requirements:
  connectivity_theory:
    concepts:
      - "Connected components (undirected)"
      - "Strongly connected components (directed)"
      - "Weakly connected components (directed)"
      - "Biconnected components"
    algorithms:
      - "DFS/BFS for components"
      - "Tarjan's SCC algorithm"
      - "Kosaraju's SCC algorithm"
      - "Articulation point detection"

  graph_structure:
    concepts:
      - "Bridges and cut edges"
      - "Articulation points"
      - "Block-cut tree"
      - "Ear decomposition"
    applications:
      - "Network reliability"
      - "Critical edge identification"
      - "Component splitting analysis"

  traversal_complexity:
    concepts:
      - "Linear time component detection"
      - "Space complexity of traversal"
      - "Online/dynamic connectivity"
    techniques:
      - "DFS tree properties"
      - "Low-link values"
      - "Discovery time ordering"

# =============================================================================
# ADVERSARIAL INPUT DESIGN
# =============================================================================

adversarial_input_design:
  worst_case_input_generation:
    hidden_nodes:
      description: "Nodes discoverable only through specific paths"
      technique: "Nodes only in edge targets, not sources or metadata"
      
    edge_direction_confusion:
      description: "Graph where direction interpretation changes result"
      technique: "SCC structure visible only with correct direction"
      
    self_loop_isolation:
      description: "Nodes with only self-loops appear connected"
      technique: "Self-loop makes node degree non-zero but effectively isolated"

  anti_optimization_inputs:
    maximum_components:
      description: "Graph with maximum possible components"
      technique: "Totally disconnected graph"
    
    single_bridge:
      description: "Large components connected by single edge"
      technique: "Removing one edge doubles component count"

  data_format_attacks:
    inconsistent_ids:
      description: "Same node with different ID representations"
      technique: "1 vs '1' vs 1.0 as node IDs"
    
    encoding_variation:
      description: "Different encodings in same file"
      technique: "UTF-8 and Latin-1 mixed"

# =============================================================================
# FORMAL PROOF REQUIREMENTS
# =============================================================================

formal_proof_requirements:
  correctness_proofs:
    completeness:
      requirements:
        - "Prove all nodes are discovered"
        - "Prove all edges are processed"
        - "Prove all components are found"
      
    component_correctness:
      requirements:
        - "Prove each component is maximal"
        - "Prove components are disjoint"
        - "Prove union of components is full graph"

  traversal_correctness:
    dfs_bfs_properties:
      requirements:
        - "Prove traversal visits each node once"
        - "Prove all reachable nodes are visited"
        - "Prove termination"

  data_amplifiers:
    large_scale:
      description: "Millions of nodes/edges"
      amplification: "Performance matters"
      
    streaming_input:
      description: "Graph arrives incrementally"
      amplification: "Can't preprocess"

# =============================================================================
# VARIATION ENGINES
# =============================================================================

variation_engines:
  problem_type_variations:
    count_components:
      description: "Count connected components"
      
    list_components:
      description: "List all components"
      
    find_isolated:
      description: "Find isolated nodes"
      
    verify_connectivity:
      description: "Check if graph is connected"

  domain_variations:
    social:
      context: "Social network communities"
      
    web:
      context: "Web page link graph"
      
    system:
      context: "Dependency analysis"

# =============================================================================
# SWE-bench_Pro style fields
# =============================================================================

problem_statement: |
  A social network analysis tool is missing users in its community detection algorithm.
  The tool uses BFS/DFS to find connected components but fails to identify all communities.
  
  Hidden issues in the data:
  1. Some edges are bidirectional while others are unidirectional (mixed graph)
  2. Self-loops create false "connectivity" signals
  3. Some nodes exist only in edge destinations, not in the node list
  4. Invisible nodes connected only through metadata relationships

requirements: |
  - Traverse the entire graph and identify ALL connected components
  - Handle mixed directed/undirected edges correctly
  - Detect and handle self-loops appropriately  
  - Find nodes that exist only as edge endpoints
  - Report isolated nodes (no edges)
  - Handle metadata-based implicit edges

interface: |
  Input: Node list file, Edge list file (with edge types)
  Output: List of connected components, isolated nodes, graph statistics
  Format: Each component as a set of node IDs

difficulty:
  estimated: "nightmare_plus"
  time_range: [5400, 18000]  # 90-300 minutes for competitive programmers with ICPC/IOI medal experience
  command_steps: [60, 200]
  techniques_required: 12
  trap_count: "10+ deeply interacting traps across correctness/performance/edge-case domains"
  target_audience: "Competitive programmers with ICPC/IOI medal experience"

traps:
  - type: "incomplete_node_set"
    description: "Node list doesn't include nodes that only appear as edge destinations"
    trigger: "Only iterating over explicit node list"
  
  - type: "directional_confusion"
    description: "Some edges are directed, treating all as undirected misses components"
    trigger: "Assuming all edges are bidirectional"
  
  - type: "self_loop_trap"
    description: "Self-loops make isolated nodes appear connected"
    trigger: "Not filtering self-loops in connectivity analysis"
  
  - type: "hidden_metadata_edges"
    description: "Some connections exist only in node metadata (shared attributes)"
    trigger: "Ignoring metadata relationships"

  - type: "single_source_traversal"
    description: "BFS/DFS from one source misses disconnected components"
    trigger: "Not restarting traversal from unvisited nodes"

  - type: "scc_wcc_confusion"
    description: "Using weakly connected when strongly connected is required"
    trigger: "Wrong algorithm for directed graph connectivity"

  - type: "node_id_type_mismatch"
    description: "Node IDs compared as different types causing lookup failures"
    trigger: "Mixing int and string node identifiers"

  - type: "unicode_node_id_variation"
    description: "Same node with different Unicode representations"
    trigger: "Not normalizing Unicode before node ID comparison"

  - type: "missing_reverse_edges"
    description: "Undirected graph stored as directed, missing reverse edges"
    trigger: "Not adding reverse edges for undirected interpretation"

  - type: "temporal_edge_invalidity"
    description: "Edge valid only at certain times, currently invalid"
    trigger: "Not checking temporal validity of edges"

  - type: "encoding_corruption"
    description: "File encoding mismatch corrupts node IDs"
    trigger: "Not detecting and handling encoding correctly"

instruction_template: |
  You are debugging a {{ scenario_type }} community detection system.
  The data files are at {{ path }}.
  
  Reports indicate missing communities. Your task:
  {{ task_steps }}
  
  The network has approximately {{ node_count }} users and {{ edge_count }} relationships.
  Expected components: around {{ expected_components }}.

reference_solution: |
  #!/usr/bin/env python3
  from collections import defaultdict, deque
  import json
  
  def load_graph(node_file, edge_file):
      nodes = set()
      edges = defaultdict(set)
      edge_types = {}
      
      with open(node_file, 'r') as f:
          for line in f:
              data = json.loads(line.strip())
              nodes.add(data['id'])
      
      with open(edge_file, 'r') as f:
          for line in f:
              parts = line.strip().split()
              if len(parts) >= 2:
                  src, dst = parts[0], parts[1]
                  edge_type = parts[2] if len(parts) > 2 else 'undirected'
                  
                  nodes.add(src)
                  nodes.add(dst)
                  
                  if src == dst:
                      continue
                  
                  edges[src].add(dst)
                  if edge_type in ('undirected', 'mutual', 'bidirectional'):
                      edges[dst].add(src)
                  
                  edge_types[(src, dst)] = edge_type
      
      return nodes, edges, edge_types
  
  def find_connected_components(nodes, edges):
      visited = set()
      components = []
      isolated = []
      
      for node in nodes:
          if node in visited:
              continue
          
          has_edges = bool(edges[node])
          if not has_edges:
              for other_node in nodes:
                  if node in edges[other_node]:
                      has_edges = True
                      break
          
          if not has_edges:
              isolated.append(node)
              visited.add(node)
              continue
          
          component = set()
          queue = deque([node])
          
          while queue:
              current = queue.popleft()
              if current in visited:
                  continue
              visited.add(current)
              component.add(current)
              
              for neighbor in edges[current]:
                  if neighbor not in visited:
                      queue.append(neighbor)
              
              for other_node in nodes:
                  if current in edges[other_node] and other_node not in visited:
                      queue.append(other_node)
          
          if component:
              components.append(component)
      
      return components, isolated

fail_to_pass:
  - "test_find_all_components_mixed_graph"
  - "test_discover_implicit_nodes"
  - "test_handle_self_loops"
  - "test_directed_vs_undirected"

pass_to_pass:
  - "test_basic_bfs"
  - "test_simple_components"
  - "test_isolated_detection"

variables:
  - name: scenario_type
    type: string
    options: ["social network", "citation graph", "web crawler", "dependency analyzer"]
  - name: path
    type: path
    generator: random_path
  - name: node_count
    type: int
    min: 100
    max: 5000
  - name: edge_count
    type: int
    min: 200
    max: 10000
  - name: expected_components
    type: int
    min: 5
    max: 50
  - name: task_steps
    type: template
    value: |
      1. Load and validate the graph data
      2. Identify all explicit and implicit nodes
      3. Handle mixed edge types correctly
      4. Find all connected components
      5. Report isolated nodes separately

anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  hidden_elements:
    - nodes_only_in_edge_destinations
    - self_loop_isolated_nodes
    - directed_edge_components

generation_targets:
  unique_tasks: 10000
  minimum_difficulty: "experienced developer needs 30+ minutes, requires deep domain expertise"
  trap_coverage: "all trap types used at least 100 times"

# =============================================================================
# EXTENDED GRAPH TRAVERSAL PATTERNS
# =============================================================================

extended_patterns:
  # ---------------------------------------------------------------------------
  # Component Finding Algorithms
  # ---------------------------------------------------------------------------
  component_algorithms:
    undirected_connected:
      algorithm: "BFS or DFS from each unvisited node"
      complexity: "O(V + E)"
      implementation: |
        def find_components(adj, n):
            visited = [False] * n
            components = []
            for i in range(n):
                if not visited[i]:
                    component = bfs(adj, i, visited)
                    components.append(component)
            return components
      
    strongly_connected:
      algorithm: "Tarjan's or Kosaraju's"
      complexity: "O(V + E)"
      tarjan_description: "Single DFS with low-link values"
      kosaraju_description: "Two DFS: one for ordering, one on transpose"
      
    weakly_connected:
      algorithm: "Treat directed as undirected"
      complexity: "O(V + E)"
      description: "Add reverse edges, then find connected components"
      
    biconnected:
      algorithm: "Find articulation points"
      complexity: "O(V + E)"
      description: "Components remaining after removing any single node"

  # ---------------------------------------------------------------------------
  # Graph Data Formats
  # ---------------------------------------------------------------------------
  data_formats:
    adjacency_list_json:
      format: '{"nodes": [...], "edges": [...]}'
      variants:
        - '{"vertices": [...], "links": [...]}'
        - '{"V": [...], "E": [...]}'
      
    edge_list_csv:
      format: "source,target,weight"
      variants:
        - "source;target;weight"
        - "source\ttarget\tweight"
        - "source target weight"
      
    adjacency_matrix:
      format: "2D array of weights"
      representation: "0 for no edge, weight for edge"
      
    graphml:
      format: "XML-based graph format"
      pros: "Rich metadata support"
      
    gexf:
      format: "Graph Exchange XML Format"
      pros: "Dynamic graph support"
      
    dot:
      format: "GraphViz DOT language"
      example: "digraph G { A -> B; B -> C; }"

  # ---------------------------------------------------------------------------
  # Special Graph Patterns
  # ---------------------------------------------------------------------------
  special_patterns:
    power_law_graphs:
      description: "Few high-degree nodes, many low-degree"
      examples: ["social networks", "web graphs"]
      component_implication: "Often giant component + small fragments"
      
    small_world:
      description: "High clustering, low average path length"
      examples: ["social networks", "neural networks"]
      component_implication: "Usually single giant component"
      
    bipartite:
      description: "Two disjoint sets, edges only between sets"
      examples: ["user-item graphs", "job-applicant matching"]
      detection: "BFS coloring, check for odd cycle"
      
    hierarchical:
      description: "Tree-like structure with levels"
      examples: ["organizational charts", "taxonomies"]
      component_implication: "Usually single connected tree"

# =============================================================================
# TASK COMBINATION MATRIX
# =============================================================================

combination_matrix:
  primary_trap:
    method: "Select 1-2 primary traps from trap_taxonomy"
    options:
      - node_discovery
      - edge_handling
      - component_discovery
      - data_format
    diversity_requirement: "Must not repeat within 100 tasks"
    
  data_format:
    method: "Select input format"
    options:
      - adjacency_list_json
      - edge_list_csv
      - adjacency_matrix
      - mixed_format
    
  context:
    method: "Select application domain"
    options:
      - social_network
      - web_crawl
      - citation
      - dependency
    
  complexity:
    easy: "Single format issue"
    medium: "Format + node discovery"
    hard: "Multiple interacting issues"
    expert: "Large scale + correctness"

# =============================================================================
# EXTENDED EDGE CASES
# =============================================================================

extended_edge_cases:
  graph_structure:
    - empty_no_nodes_no_edges
    - all_isolated_nodes
    - single_giant_component
    - many_tiny_components
    - balanced_components
    - one_large_many_small
    
  node_issues:
    - node_id_collision
    - unicode_node_ids
    - numeric_vs_string_ids
    - empty_string_ids
    - very_long_node_ids
    
  edge_issues:
    - all_edges_self_loops
    - all_edges_bidirectional
    - all_edges_unidirectional
    - mixed_edge_types
    - weighted_vs_unweighted
