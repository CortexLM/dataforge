id: "algo-sorting-comparison-trap-001"
version: "2.0.0"
category: "algorithms"
subcategory: "sorting"

# =============================================================================
# LLM GENERATION FRAMEWORK
# =============================================================================
# This file is a comprehensive generation specification for LLMs to create
# unique, extremely challenging comparator and sorting tasks through multi-
# conversation workflows. The goal is to enable generation of 10,000+ 
# fundamentally different, genuinely hard tasks.
# =============================================================================

generation_framework:
  overview: |
    This specification enables LLMs to generate sorting and comparator tasks that 
    require deep understanding of total ordering, transitivity, stability, and the
    subtle ways comparators can fail. Tasks should be genuinely difficult, requiring
    understanding of mathematical properties of orderings.

  multi_conversation_workflow:
    phase_1_research:
      description: "LLM researches obscure comparator failures and sorting edge cases"
      activities:
        - "Study total ordering requirements (reflexivity, antisymmetry, transitivity)"
        - "Research real-world comparator bugs in production systems"
        - "Investigate floating-point comparison pitfalls"
        - "Analyze language-specific sorting quirks"
        - "Study comparator-related security vulnerabilities"
        - "Research historical sorting algorithm failures"
      output: "Comprehensive list of comparator traps to embed"
    
    phase_2_creation:
      description: "LLM creates task with hidden comparator flaws"
      activities:
        - "Design comparators that violate properties in subtle ways"
        - "Create scenarios where comparator issues are intermittent"
        - "Embed multiple interacting comparison problems"
        - "Add realistic domain context that obscures the flaws"
        - "Include comparators that work on most but not all inputs"
      output: "Complete task specification with hidden traps"
    
    phase_3_amplification:
      description: "LLM adds difficulty multipliers and complexity layers"
      activities:
        - "Add timing-dependent comparator behavior"
        - "Include external state dependencies"
        - "Create scenarios where standard debugging fails"
        - "Add type coercion complications"
        - "Include locale-dependent comparisons"
      output: "Amplified task with multiple difficulty layers"
    
    phase_4_verification:
      description: "LLM validates task is genuinely hard"
      validation_criteria:
        - "Cannot be solved by running sort once and checking"
        - "Requires understanding of total ordering properties"
        - "Has at least 5 interacting hidden traps"
        - "Would take experienced developers 30+ minutes"
        - "Resists common debugging approaches"
        - "Has cascading failure modes that interact with each other"
        - "Requires multi-domain knowledge synthesis (algorithms + systems + performance)"
      output: "Verified task ready for deployment"

  quality_requirements:
    mandatory:
      - "Must require understanding of total ordering axioms"
      - "Must have subtle failures, not obvious crashes"
      - "Must include at least 5 interacting comparison issues"
      - "Must require mathematical reasoning to solve"
      - "Must have realistic, production-like context"
      - "Must resist simple testing approaches"
      - "Must take 30+ minutes for experienced developers, 45+ for intermediate"
    
    difficulty_validation:
      - "Does running the sort reveal the problem? (must be NO)"
      - "Is the comparator obviously wrong? (must be NO)"
      - "Can simple unit tests catch this? (must be NO)"
      - "Would this take 30+ minutes for experienced developers, 45+ for intermediate? (must be YES)"

# =============================================================================
# EXHAUSTIVE TOPIC UNIVERSE
# =============================================================================

topic_universe:
  # ---------------------------------------------------------------------------
  # Sorting Algorithm Topics (40 topics)
  # ---------------------------------------------------------------------------
  sorting_algorithms:
    comparison_based_stable:
      - mergesort_top_down
      - mergesort_bottom_up
      - mergesort_natural
      - timsort
      - insertion_sort
      - binary_insertion_sort
      - library_sort
      - block_sort
      - patience_sort
      - strand_sort
      - cocktail_shaker_sort
      - gnome_sort
      - odd_even_sort
      - bubble_sort
      - adaptive_mergesort
    
    comparison_based_unstable:
      - quicksort_standard
      - quicksort_three_way
      - quicksort_dual_pivot
      - quicksort_introspective
      - heapsort_standard
      - heapsort_bottom_up
      - heapsort_ternary
      - smoothsort
      - introsort
      - shellsort_original
      - shellsort_hibbard
      - shellsort_sedgewick
      - comb_sort
      - tree_sort
      - tournament_sort
      - cycle_sort
    
    non_comparison_based:
      - counting_sort
      - radix_sort_lsd
      - radix_sort_msd
      - bucket_sort
      - pigeonhole_sort
      - flashsort
      - burstsort
      - bead_sort
      - interpolation_sort

  # ---------------------------------------------------------------------------
  # Comparator Property Topics (20 topics)
  # ---------------------------------------------------------------------------
  comparator_properties:
    total_ordering_axioms:
      - reflexivity_a_equals_a
      - antisymmetry_a_leq_b_and_b_leq_a_implies_equality
      - transitivity_a_leq_b_and_b_leq_c_implies_a_leq_c
      - totality_a_leq_b_or_b_leq_a
      - trichotomy_exactly_one_of_less_equal_greater
    
    partial_ordering_issues:
      - incomparable_elements
      - cycles_in_preference
      - rock_paper_scissors_pattern
      - context_dependent_ordering
      - observer_dependent_ordering
    
    stability_concerns:
      - equal_element_preservation
      - key_extraction_consistency
      - tie_breaking_rules
      - secondary_sort_keys
      - natural_ordering_vs_custom
    
    consistency_requirements:
      - consistent_with_equals
      - hashcode_contract
      - serialization_ordering
      - cross_version_compatibility
      - cross_platform_consistency

  # ---------------------------------------------------------------------------
  # Data Type Topics (30 topics)
  # ---------------------------------------------------------------------------
  data_types:
    numeric_types:
      - integers_signed
      - integers_unsigned
      - integers_arbitrary_precision
      - floating_point_single
      - floating_point_double
      - floating_point_extended
      - decimal_fixed_point
      - decimal_arbitrary_precision
      - complex_numbers
      - rational_numbers
      - infinity_values
      - nan_values
      - negative_zero
      - denormalized_numbers
      - mixed_numeric_types
    
    string_types:
      - ascii_strings
      - utf8_strings
      - utf16_strings
      - utf32_strings
      - binary_strings
      - locale_dependent_strings
      - case_sensitive_strings
      - case_insensitive_strings
      - natural_sort_strings
      - version_strings
      - numeric_strings
      - mixed_alphanumeric
      - unicode_normalized_nfc
      - unicode_normalized_nfd
      - collation_ordered_strings
    
    composite_types:
      - arrays_by_length
      - arrays_lexicographic
      - tuples_component_wise
      - objects_by_field
      - objects_multi_field
      - nested_structures
      - optional_values
      - nullable_values
      - recursive_structures
      - graphs_topologically

  # ---------------------------------------------------------------------------
  # Domain Topics (25 topics)
  # ---------------------------------------------------------------------------
  domain_contexts:
    ranking_systems:
      - leaderboard_scores
      - search_relevance
      - recommendation_ranking
      - auction_bidding
      - priority_queues
      - task_scheduling
      - resource_allocation
      - load_balancing
    
    sorting_applications:
      - file_browser_ordering
      - email_threading
      - event_chronology
      - log_aggregation
      - database_indexing
      - merge_join_operations
      - external_sorting
      - stream_merging
    
    ordering_domains:
      - version_numbering
      - ip_address_ordering
      - date_time_ordering
      - geographic_proximity
      - semantic_similarity
      - edit_distance
      - hierarchical_ordering
      - partial_order_linearization
      - dependency_ordering

# =============================================================================
# COMPLEXITY DIMENSIONS
# =============================================================================

complexity_dimensions:
  comparator_complexity:
    mathematical_properties:
      - reflexivity_violation
      - antisymmetry_violation
      - transitivity_violation
      - totality_violation
      - consistency_violation
    
    implementation_issues:
      - overflow_in_subtraction
      - floating_point_epsilon
      - type_coercion_errors
      - null_handling
      - exception_in_comparator
    
    state_dependencies:
      - external_state_reads
      - mutable_compared_objects
      - time_dependent_values
      - random_components
      - observer_effects
    
    correctness_vs_efficiency:
      - comparison_count_explosion
      - cache_unfriendly_access
      - branch_misprediction
      - memory_allocation_in_compare
      - recursive_comparison

  sorting_complexity:
    stability_issues:
      - unstable_sort_on_stable_requirement
      - key_mutation_during_sort
      - duplicate_handling
      - tie_breaking_inconsistency
    
    performance_traps:
      - quadratic_on_adversarial
      - stack_overflow_on_deep
      - excessive_swaps
      - poor_pivot_selection
      - cache_thrashing
    
    correctness_traps:
      - partial_sort_confusion
      - nth_element_misuse
      - inplace_vs_copy
      - iterator_invalidation
      - concurrent_modification

# =============================================================================
# TRAP TAXONOMY
# =============================================================================

trap_taxonomy:
  # ---------------------------------------------------------------------------
  # Transitivity Violations (10 types)
  # ---------------------------------------------------------------------------
  transitivity_violations:
    rock_paper_scissors:
      trap_id: "TV001"
      name: "Rock-Paper-Scissors Comparator"
      description: "A < B, B < C, but C < A"
      example: |
        def compare(a, b):
            if a.type == 'rock' and b.type == 'scissors': return -1
            if a.type == 'scissors' and b.type == 'paper': return -1
            if a.type == 'paper' and b.type == 'rock': return -1
            # ... symmetric cases
      detection_difficulty: "hard"
      manifestation: "Different sort results on different runs"
      
    floating_point_chain:
      trap_id: "TV002"
      name: "Floating Point Transitivity Break"
      description: "Epsilon comparisons break transitivity"
      example: |
        def compare(a, b):
            if abs(a - b) < 0.01: return 0  # "equal"
            return -1 if a < b else 1
        # 0.0 == 0.005 == 0.01, but 0.0 < 0.01
      detection_difficulty: "very_hard"
      manifestation: "Inconsistent equality chains"
      
    weighted_comparison:
      trap_id: "TV003"
      name: "Weighted Multi-Criteria Comparison"
      description: "Weights cause cyclic preferences"
      example: |
        # A beats B on criteria 1 and 2
        # B beats C on criteria 2 and 3
        # C beats A on criteria 1 and 3
      detection_difficulty: "very_hard"
      manifestation: "No stable ordering exists"
      
    conditional_transitivity:
      trap_id: "TV004"
      name: "Context-Dependent Transitivity"
      description: "Transitivity holds in some contexts but not others"
      example: |
        # Priority depends on current system load
        # Under high load, A > B > C
        # Under low load, C > A > B
      detection_difficulty: "very_hard"
      manifestation: "Load-dependent sort failures"
      
    accumulated_rounding:
      trap_id: "TV005"
      name: "Accumulated Rounding Errors"
      description: "Multiple rounded comparisons break transitivity"
      example: |
        # Each comparison rounds, errors accumulate
        # After many comparisons, A > B > C > A
      detection_difficulty: "very_hard"
      manifestation: "Large dataset sorting failures"
      
    derived_field_mismatch:
      trap_id: "TV006"
      name: "Derived Field Computation Variance"
      description: "Computed comparison field varies"
      example: |
        def compare(a, b):
            return a.compute_score() - b.compute_score()
        # compute_score() varies due to caching/timing
      detection_difficulty: "hard"
      manifestation: "Non-deterministic ordering"
      
    multi_key_rollover:
      trap_id: "TV007"
      name: "Multi-Key Comparison Rollover"
      description: "Secondary key affects primary comparison"
      example: |
        # Compare by score, then by name
        # Score overflow wraps, affecting comparison
      detection_difficulty: "medium"
      manifestation: "Unexpected orderings"
      
    currency_conversion:
      trap_id: "TV008"
      name: "Currency Conversion Triangle"
      description: "Exchange rates create arbitrage cycles"
      example: |
        # USD > EUR > GBP > USD at same "value"
      detection_difficulty: "hard"
      manifestation: "Value-based sorts are inconsistent"
      
    time_zone_ordering:
      trap_id: "TV009"
      name: "Time Zone Comparison Trap"
      description: "DST transitions break time ordering"
      example: |
        # Times during DST transition may compare incorrectly
      detection_difficulty: "hard"
      manifestation: "Temporal sort failures"
      
    version_comparison:
      trap_id: "TV010"
      name: "Version String Comparison"
      description: "Version formats create ordering issues"
      example: |
        # 1.9 vs 1.10 vs 1.2.3 vs 1.2.3-alpha
      detection_difficulty: "medium"
      manifestation: "Version sorts are wrong"

  # ---------------------------------------------------------------------------
  # Antisymmetry Violations (8 types)
  # ---------------------------------------------------------------------------
  antisymmetry_violations:
    asymmetric_nan:
      trap_id: "AV001"
      name: "NaN Asymmetric Comparison"
      description: "NaN comparisons are not antisymmetric"
      example: |
        NaN < 5 → False
        5 < NaN → False
        # Neither a ≤ b nor b ≤ a
      detection_difficulty: "medium"
      manifestation: "NaN elements cause chaos"
      
    null_inconsistency:
      trap_id: "AV002"
      name: "Null Comparison Inconsistency"
      description: "Null handling is asymmetric"
      example: |
        def compare(a, b):
            if a is None: return -1  # null first
            if b is None: return -1  # BUG: should be +1
      detection_difficulty: "medium"
      manifestation: "Nulls don't sort consistently"
      
    type_coercion_asymmetry:
      trap_id: "AV003"
      name: "Type Coercion Asymmetry"
      description: "Type conversion differs by direction"
      example: |
        compare("10", 9) → "10" > "9" (string) → positive
        compare(9, "10") → 9 < 10 (number) → negative
        # a > b and b > a!
      detection_difficulty: "hard"
      manifestation: "Mixed type sorts fail"
      
    case_sensitivity_mismatch:
      trap_id: "AV004"
      name: "Case Sensitivity Mismatch"
      description: "Case handling differs by direction"
      example: |
        def compare(a, b):
            return a.lower() < b  # oops, b not lowered
      detection_difficulty: "easy"
      manifestation: "Case-insensitive sort fails"
      
    absolute_value_trap:
      trap_id: "AV005"
      name: "Absolute Value Comparison"
      description: "Comparing magnitudes loses sign info"
      example: |
        def compare(a, b):
            return abs(a) - abs(b)
        # -5 and 5 both map to 5, but aren't equal
      detection_difficulty: "medium"
      manifestation: "Magnitude-based sorts wrong"
      
    string_number_hybrid:
      trap_id: "AV006"
      name: "String-Number Hybrid Comparison"
      description: "Partial numeric comparison"
      example: |
        compare("file10", "file2") using atoi prefix
        # Depends on which argument is converted first
      detection_difficulty: "hard"
      manifestation: "Natural sort is broken"
      
    unicode_normalization:
      trap_id: "AV007"
      name: "Unicode Normalization Asymmetry"
      description: "One side normalized, other not"
      example: |
        "café" (NFC) vs "café" (NFD) compare as unequal
        # but café < café and café < café are both true
      detection_difficulty: "hard"
      manifestation: "Unicode string sorts fail"
      
    locale_asymmetry:
      trap_id: "AV008"
      name: "Locale-Dependent Asymmetry"
      description: "Locale affects comparison differently"
      example: |
        # German locale: ß sorts with ss
        # But ss doesn't sort with ß
      detection_difficulty: "very_hard"
      manifestation: "Locale-specific sort failures"

  # ---------------------------------------------------------------------------
  # Consistency Violations (8 types)
  # ---------------------------------------------------------------------------
  consistency_violations:
    hashcode_mismatch:
      trap_id: "CV001"
      name: "HashCode/Equals/Compare Mismatch"
      description: "equals() and compare() disagree"
      example: |
        # compare(a, b) == 0 but !a.equals(b)
        # Breaks TreeSet/TreeMap contracts
      detection_difficulty: "hard"
      manifestation: "Collections behave unexpectedly"
      
    mutable_comparison_field:
      trap_id: "CV002"
      name: "Mutable Comparison Field"
      description: "Field used in comparison changes"
      example: |
        obj.score = 10  # inserted into TreeSet
        obj.score = 20  # now can't be found
      detection_difficulty: "medium"
      manifestation: "Elements become unfindable"
      
    side_effect_comparator:
      trap_id: "CV003"
      name: "Side Effect in Comparator"
      description: "Comparator modifies state"
      example: |
        def compare(a, b):
            counter += 1  # affects other comparisons
            return a.value - b.value
      detection_difficulty: "medium"
      manifestation: "Comparison count affects results"
      
    lazy_initialization:
      trap_id: "CV004"
      name: "Lazy Initialization in Compare"
      description: "First comparison initializes state"
      example: |
        def compare(a, b):
            if not a._cached:
                a._cached = expensive_compute()
            return a._cached - b._cached
        # First comparison differs from subsequent
      detection_difficulty: "hard"
      manifestation: "First sort differs from re-sort"
      
    concurrent_modification:
      trap_id: "CV005"
      name: "Concurrent Comparison Modification"
      description: "Object modified during sort"
      example: |
        # Another thread modifies objects while sorting
      detection_difficulty: "very_hard"
      manifestation: "Race condition in sort"
      
    floating_point_accumulation:
      trap_id: "CV006"
      name: "Floating Point Accumulation"
      description: "Accumulated FP errors change comparison"
      example: |
        sum = 0.1 + 0.1 + 0.1  # ≠ 0.3
        # compare(sum, 0.3) varies by computation path
      detection_difficulty: "hard"
      manifestation: "Sums compare unexpectedly"
      
    time_of_check_time_of_use:
      trap_id: "CV007"
      name: "TOCTOU in Comparison"
      description: "Value changes between checks"
      example: |
        def compare(a, b):
            if a.valid() and b.valid():  # checked
                return a.value - b.value  # changed!
      detection_difficulty: "very_hard"
      manifestation: "Validation-comparison race"
      
    exception_inconsistency:
      trap_id: "CV008"
      name: "Exception Handling Inconsistency"
      description: "Exceptions break comparison symmetry"
      example: |
        def compare(a, b):
            try: return a.key - b.key
            except: return -1  # always "less" on error
      detection_difficulty: "medium"
      manifestation: "Errors cause wrong ordering"

  # ---------------------------------------------------------------------------
  # Overflow and Numeric Traps (8 types)
  # ---------------------------------------------------------------------------
  numeric_traps:
    subtraction_overflow:
      trap_id: "NT001"
      name: "Subtraction Overflow"
      description: "a - b overflows for large values"
      example: |
        def compare(a, b):
            return a - b  # INT_MAX - INT_MIN overflows
      detection_difficulty: "medium"
      manifestation: "Large value comparison wrong"
      
    double_precision_loss:
      trap_id: "NT002"
      name: "Double Precision Loss"
      description: "Large integers lose precision in double"
      example: |
        (double)(1L << 60) - (double)((1L << 60) + 1)
        # May equal 0 due to precision loss
      detection_difficulty: "hard"
      manifestation: "Large numbers compare equal"
      
    signed_unsigned_mismatch:
      trap_id: "NT003"
      name: "Signed/Unsigned Comparison"
      description: "Mixing signed and unsigned"
      example: |
        int a = -1;
        unsigned b = 1;
        a < b  // -1 becomes MAX_UINT, so false!
      detection_difficulty: "medium"
      manifestation: "Negative numbers sort wrong"
      
    decimal_scale_mismatch:
      trap_id: "NT004"
      name: "Decimal Scale Mismatch"
      description: "Different decimal scales compare wrong"
      example: |
        Decimal("1.0") vs Decimal("1.00")
        # Equal value but different scales
      detection_difficulty: "medium"
      manifestation: "Decimal comparison fails"
      
    bignum_comparison_cost:
      trap_id: "NT005"
      name: "BigNum Comparison Cost"
      description: "Large number comparison is expensive"
      example: |
        # Comparing million-digit numbers in sort
        # O(d) per comparison, O(n log n * d) total
      detection_difficulty: "medium"
      manifestation: "Sort becomes extremely slow"
      
    floating_special_values:
      trap_id: "NT006"
      name: "Floating Point Special Values"
      description: "Inf, -Inf, NaN, -0 comparisons"
      example: |
        -0.0 == 0.0  # true
        1/-0.0 vs 1/0.0  # -Inf vs Inf
      detection_difficulty: "hard"
      manifestation: "Special values sort wrong"
      
    modular_arithmetic:
      trap_id: "NT007"
      name: "Modular Arithmetic Comparison"
      description: "Comparing values mod N"
      example: |
        # Sequence numbers that wrap around
        # Is 0xFFFFFFFF < 0x00000001? (if wrapping)
      detection_difficulty: "hard"
      manifestation: "Wrapping values sort wrong"
      
    currency_precision:
      trap_id: "NT008"
      name: "Currency Precision Comparison"
      description: "Monetary values with rounding"
      example: |
        # $10.005 rounds to $10.01 or $10.00?
        # Comparison before/after rounding differs
      detection_difficulty: "medium"
      manifestation: "Money sorts incorrectly"

  # ---------------------------------------------------------------------------
  # String Comparison Traps (10 types)
  # ---------------------------------------------------------------------------
  string_traps:
    locale_collation:
      trap_id: "ST001"
      name: "Locale Collation Rules"
      description: "Different locales order differently"
      example: |
        # Swedish: z < ö < ä
        # German: ä < ö < z
      detection_difficulty: "medium"
      manifestation: "Locale-dependent ordering"
      
    case_folding_complexity:
      trap_id: "ST002"
      name: "Case Folding Complexity"
      description: "Case conversion isn't simple"
      example: |
        # Turkish: i → İ (dotted), ı → I (dotless)
        # German: ß → SS (one char to two)
      detection_difficulty: "hard"
      manifestation: "Case-insensitive sort fails"
      
    combining_characters:
      trap_id: "ST003"
      name: "Combining Character Ordering"
      description: "Combining chars affect comparison"
      example: |
        "e\u0301" (e + combining acute) vs "é"
        # Should be equal but byte comparison differs
      detection_difficulty: "hard"
      manifestation: "Accented chars sort wrong"
      
    string_length_vs_content:
      trap_id: "ST004"
      name: "Length vs Content Priority"
      description: "Length comparison vs lexicographic"
      example: |
        # "aa" vs "b": by length aa wins, by lex b wins
      detection_difficulty: "easy"
      manifestation: "Length-based sort surprises"
      
    natural_number_sorting:
      trap_id: "ST005"
      name: "Natural Number Sorting"
      description: "Numeric substrings in strings"
      example: |
        "file2" vs "file10"
        # Lexicographic: file10 < file2
        # Natural: file2 < file10
      detection_difficulty: "medium"
      manifestation: "Files sort in wrong order"
      
    empty_string_handling:
      trap_id: "ST006"
      name: "Empty String Handling"
      description: "Empty string comparison edge cases"
      example: |
        "" vs null vs " " vs "\u0000"
        # Different languages handle differently
      detection_difficulty: "medium"
      manifestation: "Empty values sort wrong"
      
    surrogate_pairs:
      trap_id: "ST007"
      name: "UTF-16 Surrogate Pair Handling"
      description: "Surrogate pairs compare incorrectly"
      example: |
        # Emoji and CJK Extension B chars
        # Comparing code units vs code points
      detection_difficulty: "hard"
      manifestation: "Unicode sort failures"
      
    rtl_text_ordering:
      trap_id: "ST008"
      name: "RTL Text Ordering"
      description: "Right-to-left text comparison"
      example: |
        # Hebrew/Arabic text visual vs logical order
      detection_difficulty: "hard"
      manifestation: "RTL text sorts wrong"
      
    zero_width_characters:
      trap_id: "ST009"
      name: "Zero-Width Character Ordering"
      description: "Invisible chars affect comparison"
      example: |
        "abc" vs "a\u200Bbc" (zero-width space)
        # Look identical, compare different
      detection_difficulty: "very_hard"
      manifestation: "Identical-looking strings differ"
      
    homoglyph_confusion:
      trap_id: "ST010"
      name: "Homoglyph Comparison"
      description: "Look-alike characters"
      example: |
        "a" (Latin) vs "а" (Cyrillic)
        # Look identical, different code points
      detection_difficulty: "very_hard"
      manifestation: "Visual duplicates sort apart"

  # ---------------------------------------------------------------------------
  # Stability Traps (6 types)
  # ---------------------------------------------------------------------------
  stability_traps:
    unstable_algorithm:
      trap_id: "SB001"
      name: "Unstable Algorithm on Equal Keys"
      description: "Equal elements change relative order"
      example: |
        # quicksort on [(a,1), (b,1), (c,1)]
        # May return [(c,1), (a,1), (b,1)]
      detection_difficulty: "easy"
      manifestation: "Equal keys reorder"
      
    key_extraction_variation:
      trap_id: "SB002"
      name: "Key Extraction Variation"
      description: "Key function returns different values"
      example: |
        key=lambda x: x.get_score()  # computed, varies
        # Keys computed at different times differ
      detection_difficulty: "hard"
      manifestation: "Keys seem to change"
      
    parallel_sort_instability:
      trap_id: "SB003"
      name: "Parallel Sort Instability"
      description: "Parallel sorting loses stability"
      example: |
        # Splitting data across threads
        # Merge doesn't preserve original order
      detection_difficulty: "medium"
      manifestation: "Parallel sort unstable"
      
    secondary_sort_reversal:
      trap_id: "SB004"
      name: "Secondary Sort Order Wrong"
      description: "Multi-key sort order reversed"
      example: |
        # Want: primary ASC, secondary DESC
        # Got: primary ASC, secondary ASC
      detection_difficulty: "easy"
      manifestation: "Secondary order wrong"
      
    tie_breaker_missing:
      trap_id: "SB005"
      name: "Missing Tie Breaker"
      description: "No tie breaker for equal primary keys"
      example: |
        # Sort by score only
        # Equal scores have random order
      detection_difficulty: "medium"
      manifestation: "Non-deterministic order"
      
    insertion_order_dependency:
      trap_id: "SB006"
      name: "Insertion Order Dependency"
      description: "Final order depends on input order"
      example: |
        # Stable sort preserves input order for ties
        # Input order wasn't consistent
      detection_difficulty: "medium"
      manifestation: "Order varies by input"

# =============================================================================
# EDGE CASE CATALOG
# =============================================================================

edge_cases:
  array_edge_cases:
    - empty_array
    - single_element
    - two_elements
    - two_elements_equal
    - all_elements_equal
    - all_elements_different
    - sorted_ascending
    - sorted_descending
    - reverse_sorted
    - nearly_sorted_one_swap
    - nearly_sorted_few_percent
    - alternating_high_low
    - many_duplicates
    - few_duplicates
    - first_element_is_min
    - first_element_is_max
    - last_element_is_min
    - last_element_is_max
    - median_element_at_end
    - random_uniform
    - random_zipf
    - adversarial_quicksort_killer
    - adversarial_mergesort_killer
    - maximum_size_array
    - power_of_two_size
    - power_of_two_minus_one_size

  numeric_edge_cases:
    - zero_value
    - negative_zero
    - positive_infinity
    - negative_infinity
    - nan_value
    - max_int
    - min_int
    - max_long
    - min_long
    - overflow_boundary
    - underflow_boundary
    - denormalized_float
    - epsilon_difference
    - large_magnitude_small_difference
    - mixed_signs
    - all_positive
    - all_negative

  string_edge_cases:
    - empty_string
    - single_char
    - null_character_in_string
    - unicode_bmp_only
    - unicode_with_surrogates
    - combining_characters
    - control_characters
    - whitespace_only
    - leading_whitespace
    - trailing_whitespace
    - locale_sensitive_chars
    - case_pairs_ascii
    - case_pairs_unicode
    - rtl_characters
    - mixed_scripts
    - emoji_sequences
    - zero_width_joiners

  comparator_edge_cases:
    - null_first_argument
    - null_second_argument
    - both_arguments_null
    - same_object_twice
    - equal_different_objects
    - exception_thrown
    - very_slow_comparison
    - comparison_modifies_state
    - comparison_depends_on_external
    - comparison_non_deterministic

# =============================================================================
# ANTI-PATTERNS
# =============================================================================

anti_patterns:
  llm_failure_modes:
    - "Pattern matching without understanding total ordering axioms"
    - "Applying comparators without transitivity verification"
    - "Missing antisymmetry violations in asymmetric comparisons"
    - "Ignoring type coercion effects in mixed-type comparisons"
    - "Assuming subtraction-based comparison is always safe"
    - "Skipping verification of NaN and infinity handling"
    - "Over-relying on language default comparison"
    - "Missing locale-dependent comparison issues"
    - "Ignoring stability requirements for equal elements"
    - "Failing to handle null/undefined values correctly"
    - "Not considering case sensitivity in string comparison"
    - "Missing Unicode normalization in string comparison"
    - "Overlooking floating-point epsilon comparison needs"
    - "Failing to handle comparison with external state"
    - "Not considering comparison side effects"
    - "Missing integer overflow in subtraction comparator"
    - "Overlooking signed vs unsigned comparison issues"
    - "Failing to verify consistency with equals/hashCode"
    - "Not handling mutable comparison keys"
    - "Missing thread safety in concurrent sorting"
    - "Overlooking lazy initialization in comparator"
    - "Failing to detect rock-paper-scissors comparators"
    - "Not considering comparison cost in algorithm selection"
    - "Missing natural ordering vs custom comparator distinction"
    - "Ignoring secondary/tertiary sort key requirements"

  task_design_anti_patterns:
    obvious_violation:
      description: "Comparator clearly violates properties"
      why_bad: "No analysis needed"
      
    single_failure_mode:
      description: "Only one thing wrong"
      why_bad: "Too easy once found"
      
    fails_on_first_test:
      description: "Sort immediately fails"
      why_bad: "No debugging challenge"
      
    error_message_reveals:
      description: "Exception message explains problem"
      why_bad: "Just read the error"
      
    textbook_example:
      description: "Well-known comparator pitfall"
      why_bad: "Pattern matching solves it"

  code_anti_patterns:
    commented_warning:
      description: "Comment says 'FIXME: comparator issue'"
      why_bad: "Reading reveals answer"
      
    simple_subtraction:
      description: "Only issue is a-b overflow"
      why_bad: "Well-known pattern"
      
    obvious_nan_check:
      description: "Clearly missing NaN handling"
      why_bad: "Common knowledge"

# =============================================================================
# DIFFICULTY AMPLIFIERS
# =============================================================================

difficulty_amplifiers:
  nightmare:
    multiplier: 3.0
    description: "Extreme difficulty requiring expert-level multi-domain synthesis"
    requirements:
      - "7+ interacting traps across multiple domains"
      - "Requires understanding of hardware-level effects"
      - "Time estimate: 90+ minutes for senior engineers"
      - "Multiple red herrings that waste investigation time"
      - "Solution requires synthesizing knowledge from 3+ distinct areas"

  nightmare_plus:
    multiplier: 5.0
    estimated_time: [28800, 172800]  # 8-48 hours
    command_steps: [300, 1200]
    techniques_required: 12
    description: "Research paper difficulty requiring novel comparator design"
    requirements:
      - "10+ deeply interacting traps across ordering axioms/stability/concurrency domains"
      - "Requires formal verification of total ordering properties"
      - "Must synthesize knowledge from algebra, type theory, and concurrent programming"
      - "Requires proof of transitivity, antisymmetry, and totality"
      - "Time estimate: 8-48 hours for competitive programmers with ICPC/IOI medal experience"
      - "Multiple ordering violations that interact non-obviously"
      - "Must handle type coercion and locale-dependent comparisons"
      - "Requires understanding of partial orders and extensions"
      - "Solution involves mathematically correct comparator construction"

# =============================================================================
# MULTI-AGENT ORCHESTRATION COMPLEXITY
# =============================================================================

multi_agent_orchestration:
  description: "Coordinating 4-7 specialized agents for complex comparator analysis"
  
  specialized_agents:
    ordering_verifier:
      role: "Verify total ordering properties"
      capabilities:
        - "Transitivity verification"
        - "Antisymmetry verification"
        - "Totality verification"
        - "Consistency with equals"
      handoff_triggers:
        - "Ordering violation suspected"
        - "Comparator correctness analysis"
    
    stability_analyst:
      role: "Analyze sort stability requirements"
      capabilities:
        - "Stability requirement identification"
        - "Key extraction consistency"
        - "Tie-breaking analysis"
        - "Secondary sort key handling"
      handoff_triggers:
        - "Stability issues detected"
        - "Equal element reordering"
    
    type_analyzer:
      role: "Handle type-related comparison issues"
      capabilities:
        - "Type coercion detection"
        - "Null/undefined handling"
        - "Mixed type comparison"
        - "Locale-dependent comparison"
      handoff_triggers:
        - "Type-related failures"
        - "Locale-specific issues"
    
    numeric_analyst:
      role: "Handle numeric comparison issues"
      capabilities:
        - "Overflow detection"
        - "Floating-point comparison"
        - "NaN/Infinity handling"
        - "Precision issues"
      handoff_triggers:
        - "Numeric comparison failures"
        - "Overflow suspected"
    
    concurrency_analyzer:
      role: "Analyze thread safety of comparators"
      capabilities:
        - "Race condition detection"
        - "Mutable state analysis"
        - "Side effect detection"
        - "Concurrent modification handling"
      handoff_triggers:
        - "Multi-threaded sorting"
        - "Non-deterministic behavior"

  cross_algorithm_attack_chains:
    chain_1:
      name: "Non-Transitive → Inconsistent Order → Algorithm Confusion → Wrong Result"
      stages:
        - "Comparator violates transitivity"
        - "Sort algorithm relies on transitivity"
        - "Algorithm makes inconsistent decisions"
        - "Final order is undefined/wrong"
    
    chain_2:
      name: "Type Coercion → Asymmetric Comparison → Silent Reordering → Data Corruption"
      stages:
        - "Mixed types in comparison"
        - "compare(a,b) != -compare(b,a)"
        - "Sort produces unpredictable order"
        - "Downstream processing fails"
    
    chain_3:
      name: "Mutable State → Inconsistent Key → Order Changes → Non-Deterministic Output"
      stages:
        - "Comparison key computed from mutable state"
        - "State changes during sort"
        - "Same element compares differently"
        - "Sort output varies between runs"

# =============================================================================
# THEORETICAL COMPLEXITY REQUIREMENTS
# =============================================================================

theoretical_complexity_requirements:
  total_ordering:
    axioms:
      - "Reflexivity: a ≤ a"
      - "Antisymmetry: a ≤ b ∧ b ≤ a → a = b"
      - "Transitivity: a ≤ b ∧ b ≤ c → a ≤ c"
      - "Totality: a ≤ b ∨ b ≤ a"
    verification:
      - "Property testing with generated triples"
      - "Exhaustive verification for small domains"
      - "Counterexample generation"

  stability_theory:
    concepts:
      - "Stable sort definition"
      - "Stability-preserving algorithms"
      - "Key function stability requirements"
    algorithms:
      - "Stable: mergesort, timsort"
      - "Unstable: quicksort, heapsort"

  sorting_lower_bounds:
    concepts:
      - "Comparison-based lower bound: Ω(n log n)"
      - "Decision tree model"
      - "Information-theoretic argument"
    applications:
      - "Proving algorithm optimality"
      - "Non-comparison sorting when applicable"

# =============================================================================
# ADVERSARIAL INPUT DESIGN
# =============================================================================

adversarial_input_design:
  worst_case_input_generation:
    transitivity_breaker:
      description: "Input triggering non-transitive comparison"
      technique: "Rock-paper-scissors style elements"
      
    type_coercion_attack:
      description: "Mixed types causing asymmetric comparison"
      technique: "1 vs '1' vs 1.0 in same array"
      
    nan_injection:
      description: "NaN values causing comparison chaos"
      technique: "Insert NaN in numeric array"

  anti_optimization_inputs:
    worst_case_quicksort:
      description: "Input causing O(n²) quicksort"
      technique: "Already sorted or reverse sorted"
    
    mergesort_worst_memory:
      description: "Input maximizing merge memory"
      technique: "Large array requiring full auxiliary space"

  stability_attacks:
    key_collision:
      description: "Many elements with same sort key"
      technique: "All elements have equal key"
    
    unstable_reordering:
      description: "Input where unstable sort changes relative order"
      technique: "Stable order required but unstable sort used"

# =============================================================================
# FORMAL PROOF REQUIREMENTS
# =============================================================================

formal_proof_requirements:
  correctness_proofs:
    total_ordering:
      requirements:
        - "Prove reflexivity: compare(a, a) == 0"
        - "Prove antisymmetry: compare(a, b) == -compare(b, a)"
        - "Prove transitivity: compare(a,b) ≤ 0 ∧ compare(b,c) ≤ 0 → compare(a,c) ≤ 0"
        - "Prove totality: compare always returns valid result"
      
    consistency:
      requirements:
        - "Prove consistency with equals: compare(a, b) == 0 ↔ a.equals(b)"
        - "Prove hashCode compatibility"
        - "Prove serialization stability"

  stability_proofs:
    requirements:
      - "Prove equal elements maintain relative order"
      - "Prove key extraction is deterministic"
      - "Prove stability under concurrent access"

  code_structure:
    indirection:
      description: "Comparator defined elsewhere, passed indirectly"
      amplification: "Must trace comparator source"
      
    inheritance:
      description: "Comparison in base class, bug in override"
      amplification: "Must understand class hierarchy"
      
    composition:
      description: "Comparator composed of other comparators"
      amplification: "Must understand composition"
      
    reflection:
      description: "Comparison method found via reflection"
      amplification: "Must understand dynamic dispatch"
      
    decorator:
      description: "Comparator wrapped with logging/caching"
      amplification: "Wrapper affects behavior"

  analysis_amplifiers:
    intermittent_failure:
      description: "Fails only on certain data patterns"
      amplification: "Must identify triggering patterns"
      
    race_condition:
      description: "Failure depends on timing"
      amplification: "Must consider concurrency"
      
    environment_dependent:
      description: "Fails only in certain locales/configs"
      amplification: "Must consider environment"
      
    scale_dependent:
      description: "Fails only with large data"
      amplification: "Must test at scale"
      
    order_dependent:
      description: "Fails only with certain input orders"
      amplification: "Must test many orderings"

  context_amplifiers:
    production_code:
      description: "Embedded in realistic system"
      amplification: "Must filter noise"
      
    legacy_code:
      description: "Old code, unclear intent"
      amplification: "Must reverse engineer"
      
    multiple_comparators:
      description: "Several comparators, only one broken"
      amplification: "Must identify which one"
      
    correct_test_suite:
      description: "Tests pass but comparator is wrong"
      amplification: "Tests give false confidence"

# =============================================================================
# VARIATION ENGINES
# =============================================================================

variation_engines:
  problem_type_variations:
    identification:
      description: "Find the comparator bug"
      task_type: "diagnostic"
      
    fix:
      description: "Correct the comparator"
      task_type: "implementation"
      
    design:
      description: "Design comparator with constraints"
      task_type: "creative"
      
    proof:
      description: "Prove comparator properties"
      task_type: "analytical"
      
    test_generation:
      description: "Generate tests that expose bug"
      task_type: "testing"

  domain_variations:
    leaderboard:
      context: "Game ranking system"
      elements: ["scores", "timestamps", "tiebreakers"]
      
    search_ranking:
      context: "Search result ordering"
      elements: ["relevance", "recency", "personalization"]
      
    file_sorting:
      context: "File browser ordering"
      elements: ["names", "dates", "sizes", "types"]
      
    scheduling:
      context: "Task priority queue"
      elements: ["priorities", "deadlines", "dependencies"]
      
    database:
      context: "Database ORDER BY"
      elements: ["null handling", "collation", "case sensitivity"]

  language_variations:
    python:
      comparator_style: "key function or functools.cmp_to_key"
      specific_issues: ["None handling", "type mixing"]
      
    java:
      comparator_style: "Comparator interface"
      specific_issues: ["null handling", "equals consistency"]
      
    javascript:
      comparator_style: "compare function"
      specific_issues: ["type coercion", "undefined handling"]
      
    cpp:
      comparator_style: "strict weak ordering"
      specific_issues: ["operator overloading", "const correctness"]
      
    rust:
      comparator_style: "Ord trait"
      specific_issues: ["partial vs total ord", "NaN handling"]

# =============================================================================
# SWE-bench_Pro style fields
# =============================================================================

problem_statement: |
  A custom sorting implementation produces inconsistent results. The sort uses a 
  user-defined comparator function, but the output order changes between runs or 
  the sorted list violates expected ordering properties.
  
  Hidden issues:
  1. The comparator is not transitive (a < b and b < c doesn't imply a < c)
  2. The comparator returns inconsistent results for the same pair
  3. Floating-point comparison issues cause non-determinism
  4. The comparator has side effects that affect subsequent comparisons

requirements: |
  - Identify non-transitive comparator issues
  - Detect and fix comparator inconsistency
  - Handle floating-point comparison edge cases
  - Ensure deterministic sorting output
  - Validate comparator satisfies total ordering requirements

interface: |
  Input: List of items, comparator function
  Output: Sorted list with deterministic ordering
  Validation: Report any comparator violations detected

# terminal-bench style fields
difficulty:
  estimated: "nightmare_plus"
  time_range: [5400, 18000]  # 90-300 minutes for competitive programmers with ICPC/IOI medal experience
  command_steps: [60, 200]
  techniques_required: 12
  trap_count: "10+ deeply interacting traps across correctness/performance/edge-case domains"
  target_audience: "Competitive programmers with ICPC/IOI medal experience"

# LLM trap configurations
traps:
  - type: "non_transitive"
    description: "Comparator where A < B, B < C, but A > C (rock-paper-scissors)"
    trigger: "Using the comparator without transitivity check"
  
  - type: "inconsistent_comparison"
    description: "Comparator uses external state that changes"
    trigger: "Not detecting comparator side effects"
  
  - type: "floating_point_non_determinism"
    description: "Floating point comparisons return different results"
    trigger: "Using == for float comparison in sort"
  
  - type: "equality_asymmetry"
    description: "compare(a,b)==0 but compare(b,a)!=0"
    trigger: "Not verifying comparison symmetry"

  - type: "subtraction_overflow"
    description: "return a - b overflows for INT_MAX - INT_MIN"
    trigger: "Using subtraction instead of comparison operators"

  - type: "nan_comparison_chaos"
    description: "NaN < x and x < NaN both return false, breaking totality"
    trigger: "Not special-casing NaN in floating-point comparator"

  - type: "type_coercion_asymmetry"
    description: "Different coercion paths for compare(a,b) vs compare(b,a)"
    trigger: "Comparing mixed types without normalization"

  - type: "locale_dependent_string"
    description: "String comparison differs by locale setting"
    trigger: "Not specifying locale for string comparator"

  - type: "mutable_key_during_sort"
    description: "Object's comparison key changes while being sorted"
    trigger: "Modifying objects during sort operation"

  - type: "unstable_on_stable_requirement"
    description: "Using unstable sort when stability is required"
    trigger: "Not verifying algorithm stability for equal elements"

  - type: "hashcode_compare_mismatch"
    description: "compare(a,b)==0 but a.hashCode()!=b.hashCode()"
    trigger: "Violating consistency with hashCode for collection use"

# Task generation template
instruction_template: |
  You are debugging a {{ scenario_type }} sorting system.
  The code is at {{ path }}.
  
  The sort produces different results on different runs. Your task:
  {{ task_steps }}
  
  Dataset size: {{ item_count }} items
  Reported inconsistencies: {{ inconsistency_count }}

# Reference solution (hidden from agent)
reference_solution: |
  #!/usr/bin/env python3
  from typing import List, Callable, TypeVar, Tuple
  from functools import cmp_to_key
  import math
  
  T = TypeVar('T')
  
  class ComparatorValidator:
      """Validates and wraps comparators for safe sorting."""
      
      def __init__(self, comparator: Callable[[T, T], int], tolerance: float = 1e-9):
          self.comparator = comparator
          self.tolerance = tolerance
          self.call_cache = {}
          self.violations = []
      
      def validated_compare(self, a: T, b: T) -> int:
          """Compare with caching and consistency check."""
          key_ab = (id(a), id(b))
          key_ba = (id(b), id(a))
          
          result = self.comparator(a, b)
          
          # Check consistency with cached results
          if key_ab in self.call_cache:
              if self.call_cache[key_ab] != result:
                  self.violations.append(
                      f"Inconsistent: compare({a}, {b}) = {self.call_cache[key_ab]} then {result}"
                  )
          self.call_cache[key_ab] = result
          
          # Check antisymmetry
          if key_ba in self.call_cache:
              reverse = self.call_cache[key_ba]
              if not self._check_antisymmetry(result, reverse):
                  self.violations.append(
                      f"Antisymmetry violation: compare({a}, {b})={result}, compare({b}, {a})={reverse}"
                  )
          
          return result
      
      def _check_antisymmetry(self, ab: int, ba: int) -> bool:
          """Check if compare(a,b) and compare(b,a) are consistent."""
          if ab < 0:
              return ba > 0
          if ab > 0:
              return ba < 0
          return ba == 0
      
      def check_transitivity_sample(self, items: List[T], sample_size: int = 100) -> List[str]:
          """Sample-based transitivity check."""
          import random
          violations = []
          
          n = len(items)
          if n < 3:
              return violations
          
          for _ in range(min(sample_size, n * (n-1) * (n-2) // 6)):
              a, b, c = random.sample(items, 3)
              ab = self.comparator(a, b)
              bc = self.comparator(b, c)
              ac = self.comparator(a, c)
              
              # If a <= b and b <= c, then a <= c
              if ab <= 0 and bc <= 0 and ac > 0:
                  violations.append(f"Non-transitive: {a} <= {b} <= {c} but {a} > {c}")
              if ab >= 0 and bc >= 0 and ac < 0:
                  violations.append(f"Non-transitive: {a} >= {b} >= {c} but {a} < {c}")
          
          return violations
  
  def create_safe_comparator(
      comparator: Callable[[T, T], int],
      tolerance: float = 1e-9
  ) -> Callable[[T, T], int]:
      """Create a safe, deterministic comparator wrapper."""
      
      def safe_compare(a: T, b: T) -> int:
          result = comparator(a, b)
          
          # Normalize to -1, 0, 1
          if isinstance(result, float):
              if math.isnan(result):
                  # NaN handling - use fallback comparison
                  return (str(a) > str(b)) - (str(a) < str(b))
              if abs(result) < tolerance:
                  return 0
          
          if result < 0:
              return -1
          if result > 0:
              return 1
          return 0
      
      return safe_compare
  
  def stable_sort_with_validation(
      items: List[T], 
      comparator: Callable[[T, T], int]
  ) -> Tuple[List[T], List[str]]:
      """Sort with comparator validation."""
      validator = ComparatorValidator(comparator)
      
      # Check for transitivity violations
      transitivity_issues = validator.check_transitivity_sample(items)
      
      if transitivity_issues:
          # Fall back to deterministic ordering
          print(f"Warning: Comparator has transitivity issues: {transitivity_issues[:3]}")
          # Use stable secondary key
          return sorted(items, key=lambda x: (str(type(x).__name__), str(x))), transitivity_issues
      
      # Use validated comparator
      safe_cmp = create_safe_comparator(validator.validated_compare)
      sorted_items = sorted(items, key=cmp_to_key(safe_cmp))
      
      return sorted_items, validator.violations

# Test cases
fail_to_pass:
  - "test_non_transitive_comparator"
  - "test_inconsistent_comparator"
  - "test_float_comparison_stability"
  - "test_equality_symmetry"

pass_to_pass:
  - "test_basic_sort"
  - "test_empty_list"
  - "test_single_element"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: ["leaderboard ranking", "search result ordering", "file sorting", "priority queue"]
  - name: path
    type: path
    generator: random_path
  - name: item_count
    type: int
    min: 100
    max: 10000
  - name: inconsistency_count
    type: int
    min: 1
    max: 50
  - name: task_steps
    type: template
    value: |
      1. Analyze the comparator function for violations
      2. Check transitivity property
      3. Check antisymmetry property
      4. Handle floating-point edge cases
      5. Implement fallback for invalid comparators
      6. Ensure deterministic output

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  comparator_issues:
    - rock_paper_scissors_transitivity
    - external_state_dependency
    - floating_point_instability
    - asymmetric_equality

# =============================================================================
# TASK COMBINATION MATRIX
# =============================================================================

combination_matrix:
  primary_trap_selection:
    method: "Select 1-2 primary traps from trap_taxonomy"
    diversity_requirement: "Must not repeat within 100 generated tasks"
    
  secondary_trap_selection:
    method: "Select 2-3 secondary traps that interact with primary"
    interaction_requirement: "Traps must compound difficulty"
    
  context_selection:
    method: "Select domain from variation_engines.domain_variations"
    realism_requirement: "Context must be believable production code"
    
  edge_case_inclusion:
    method: "Select 3-5 edge cases that trigger the traps"
    coverage_requirement: "Edge cases must be non-obvious"
    
  difficulty_amplification:
    method: "Apply 2-3 amplifiers from difficulty_amplifiers"
    balance_requirement: "Task must be hard but solvable"

# =============================================================================
# GENERATION STATISTICS TARGET
# =============================================================================

generation_targets:
  unique_tasks: 10000
  minimum_difficulty: "experienced developer needs 30+ minutes, requires deep domain expertise"
  trap_coverage: "all trap types used at least 100 times"
  domain_coverage: "all domains used at least 500 times"
  edge_case_coverage: "all edge cases appear in at least 50 tasks"
