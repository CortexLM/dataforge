id: "algo-search-binary-edge-001"
version: "2.0.0"
category: "algorithms"
subcategory: "search"

# =============================================================================
# LLM GENERATION FRAMEWORK
# =============================================================================
# This file is a comprehensive generation specification for LLMs to create
# unique, extremely challenging binary search and search algorithm tasks.
# The goal is to enable generation of 10,000+ fundamentally different,
# genuinely hard tasks that require deep understanding of search invariants.
# =============================================================================

generation_framework:
  overview: |
    This specification enables LLMs to generate search algorithm tasks that are
    genuinely difficult. Binary search looks simple but has numerous subtle pitfalls
    around boundaries, duplicates, overflow, and loop invariants. Tasks should
    require true understanding of these invariants.

  multi_conversation_workflow:
    phase_1_research:
      description: "LLM researches obscure search algorithm edge cases"
      activities:
        - "Study famous binary search bugs (Java Arrays.binarySearch, etc.)"
        - "Research off-by-one error patterns"
        - "Investigate integer overflow scenarios"
        - "Analyze duplicate handling variations"
        - "Study search variants (lower_bound, upper_bound, etc.)"
        - "Research real-world search bugs in production systems"
      output: "Comprehensive list of search traps to embed"
    
    phase_2_creation:
      description: "LLM creates task with hidden search flaws"
      activities:
        - "Design searches that fail on specific boundary conditions"
        - "Create scenarios with subtle off-by-one errors"
        - "Embed overflow bugs that only trigger on large arrays"
        - "Add duplicate handling that works in most but not all cases"
        - "Include loop termination bugs"
      output: "Complete task specification with hidden traps"
    
    phase_3_amplification:
      description: "LLM adds difficulty multipliers"
      activities:
        - "Layer multiple boundary issues"
        - "Add concurrent modification scenarios"
        - "Include floating-point search variations"
        - "Create rotated/transformed array scenarios"
        - "Add search on custom comparators"
      output: "Amplified task with multiple difficulty layers"
    
    phase_4_verification:
      description: "LLM validates task is genuinely hard"
      validation_criteria:
        - "Cannot be solved by running simple tests"
        - "Requires understanding of loop invariants"
        - "Has at least 5 interacting hidden traps"
        - "Would take experienced developers 30+ minutes"
        - "Standard binary search template doesn't work directly"
        - "Has cascading failure modes that interact with each other"
        - "Requires multi-domain knowledge synthesis (algorithms + systems + performance)"
      output: "Verified task ready for deployment"

  quality_requirements:
    mandatory:
      - "Must require understanding of binary search invariants"
      - "Must have non-obvious boundary failures"
      - "Must include at least 5 distinct edge case traps"
      - "Must have intermittent failures, not total breakage"
      - "Must resist simple test-driven debugging"
      - "Must take 30+ minutes for experienced developers, 45+ for intermediate"
    
    difficulty_validation:
      - "Does the standard binary search template work? (must be NO)"
      - "Are the edge cases obvious? (must be NO)"
      - "Can simple print debugging find the issue? (must be NO)"
      - "Would this take 30+ minutes for experienced developers, 45+ for intermediate? (must be YES)"

# =============================================================================
# EXHAUSTIVE TOPIC UNIVERSE
# =============================================================================

topic_universe:
  # ---------------------------------------------------------------------------
  # Search Algorithm Topics (40 topics)
  # ---------------------------------------------------------------------------
  search_algorithms:
    binary_search_variants:
      - binary_search_find_exact
      - binary_search_find_first
      - binary_search_find_last
      - binary_search_lower_bound
      - binary_search_upper_bound
      - binary_search_count_occurrences
      - binary_search_range_search
      - binary_search_floor
      - binary_search_ceiling
      - binary_search_closest
      - binary_search_peak_element
      - binary_search_rotation_point
      - binary_search_minimum_rotated
      - binary_search_search_rotated
      - binary_search_bitonic_peak
      - binary_search_bitonic_search
      - binary_search_square_root
      - binary_search_kth_element
      - binary_search_median_two_arrays
      - binary_search_allocation_problem
    
    interpolation_search_variants:
      - interpolation_search_uniform
      - interpolation_search_exponential
      - interpolation_search_adaptive
      - interpolation_search_quadratic
      - interpolation_search_robust
    
    exponential_search:
      - exponential_search_unbounded
      - exponential_search_bounded
      - galloping_search
      - jumping_search
    
    ternary_search:
      - ternary_search_maximum
      - ternary_search_minimum
      - ternary_search_unimodal
      - golden_section_search
      - fibonacci_search
    
    tree_based_search:
      - bst_search
      - avl_search
      - red_black_search
      - b_tree_search
      - b_plus_tree_range
      - trie_prefix_search
      - suffix_tree_search
      - van_emde_boas_search

  # ---------------------------------------------------------------------------
  # Data Structure Topics (25 topics)
  # ---------------------------------------------------------------------------
  data_structures:
    array_types:
      - sorted_array
      - reverse_sorted_array
      - rotated_sorted_array
      - bitonic_array
      - nearly_sorted_array
      - array_with_duplicates
      - sparse_array
      - chunked_array
      - memory_mapped_array
      - compressed_array
    
    specialized_arrays:
      - 2d_sorted_matrix
      - row_wise_sorted_matrix
      - column_wise_sorted_matrix
      - young_tableau
      - diagonal_sorted_matrix
    
    tree_structures:
      - binary_search_tree
      - avl_tree
      - red_black_tree
      - b_tree
      - b_plus_tree
      - skip_list
      - treap
      - splay_tree
      - segment_tree
      - fenwick_tree

  # ---------------------------------------------------------------------------
  # Domain Context Topics (30 topics)
  # ---------------------------------------------------------------------------
  domain_contexts:
    database_operations:
      - index_lookup
      - range_query
      - prefix_search
      - nearest_neighbor
      - time_range_search
      - version_lookup
      - cursor_positioning
    
    system_applications:
      - memory_address_lookup
      - page_table_search
      - process_scheduler
      - load_balancer
      - cache_lookup
      - dns_resolution
    
    algorithm_applications:
      - merge_step
      - intersection_finding
      - union_finding
      - difference_finding
      - binary_lifting
      - lca_computation
    
    real_world_search:
      - dictionary_lookup
      - phone_book_search
      - library_catalog
      - log_search
      - time_series_query
      - geospatial_search
      - ip_range_lookup
      - version_comparison

# =============================================================================
# COMPLEXITY DIMENSIONS
# =============================================================================

complexity_dimensions:
  boundary_handling:
    start_boundary:
      - target_at_index_0
      - target_before_all
      - target_is_minimum
      - empty_prefix_search
    
    end_boundary:
      - target_at_last_index
      - target_after_all
      - target_is_maximum
      - empty_suffix_search
    
    mid_calculation:
      - integer_overflow_mid
      - negative_indices
      - unsigned_underflow
      - floating_point_mid
    
    loop_termination:
      - lo_equals_hi
      - lo_plus_one_equals_hi
      - off_by_one_termination
      - infinite_loop_potential

  duplicate_handling:
    duplicate_scenarios:
      - all_elements_equal
      - many_duplicates
      - target_duplicated
      - adjacent_duplicates
      - scattered_duplicates
    
    duplicate_search_modes:
      - find_any_occurrence
      - find_first_occurrence
      - find_last_occurrence
      - find_all_occurrences
      - count_occurrences
      - find_insertion_point

  numeric_edge_cases:
    integer_boundaries:
      - max_int_values
      - min_int_values
      - overflow_on_addition
      - overflow_on_multiplication
      - negative_number_handling
      - signed_unsigned_conversion
    
    floating_point_issues:
      - precision_loss
      - nan_handling
      - infinity_handling
      - negative_zero
      - denormalized_numbers
      - epsilon_comparisons

  search_space_issues:
    empty_search_space:
      - empty_array
      - null_array
      - zero_length
      - invalid_bounds
    
    single_element:
      - target_found
      - target_not_found
      - target_equals_bounds
    
    two_elements:
      - both_equal
      - target_first
      - target_second
      - target_between
      - target_outside

# =============================================================================
# TRAP TAXONOMY
# =============================================================================

trap_taxonomy:
  # ---------------------------------------------------------------------------
  # Off-By-One Errors (12 types)
  # ---------------------------------------------------------------------------
  off_by_one:
    loop_condition_wrong:
      trap_id: "OBO001"
      name: "Wrong Loop Termination Condition"
      description: "Using < instead of <= or vice versa"
      example: |
        while lo < hi:  # Should be lo <= hi
            mid = lo + (hi - lo) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                lo = mid + 1
            else:
                hi = mid - 1
        return -1  # Misses target when lo == hi
      detection_difficulty: "medium"
      manifestation: "Misses element at boundaries"
      
    boundary_update_wrong:
      trap_id: "OBO002"
      name: "Wrong Boundary Update"
      description: "Using mid instead of mid+1 or mid-1"
      example: |
        if arr[mid] < target:
            lo = mid  # Should be mid + 1
        # Causes infinite loop when lo + 1 == hi
      detection_difficulty: "medium"
      manifestation: "Infinite loop on some inputs"
      
    return_index_off:
      trap_id: "OBO003"
      name: "Return Index Off By One"
      description: "Returning wrong index for insertion point"
      example: |
        # Looking for insertion point
        return lo  # Should be lo or lo+1 depending on convention
      detection_difficulty: "medium"
      manifestation: "Insertion point incorrect"
      
    first_occurrence_miss:
      trap_id: "OBO004"
      name: "First Occurrence Miss"
      description: "Finding any occurrence instead of first"
      example: |
        if arr[mid] == target:
            return mid  # Returns any match, not first
        # For first occurrence, should continue searching left
      detection_difficulty: "hard"
      manifestation: "Returns wrong index with duplicates"
      
    last_occurrence_miss:
      trap_id: "OBO005"
      name: "Last Occurrence Miss"
      description: "Finding any occurrence instead of last"
      example: |
        if arr[mid] == target:
            return mid  # Returns any match, not last
        # For last occurrence, should continue searching right
      detection_difficulty: "hard"
      manifestation: "Returns wrong index with duplicates"
      
    exclusive_boundary_confusion:
      trap_id: "OBO006"
      name: "Inclusive vs Exclusive Boundary"
      description: "Mixing inclusive and exclusive bounds"
      example: |
        lo, hi = 0, len(arr)  # hi is exclusive
        while lo < hi:
            mid = (lo + hi) // 2
            if arr[mid] < target:
                lo = mid + 1
            else:
                hi = mid  # Correct for exclusive
        # But then:
        if arr[hi] == target:  # BUG: hi might be out of bounds
      detection_difficulty: "hard"
      manifestation: "Index out of bounds"
      
    search_range_end:
      trap_id: "OBO007"
      name: "Search Range End Off By One"
      description: "Wrong ending index for range search"
      example: |
        def search_range(arr, target):
            first = find_first(arr, target)
            last = find_last(arr, target)
            return [first, last]  # Off by one in either
      detection_difficulty: "medium"
      manifestation: "Range bounds incorrect"
      
    count_off_by_one:
      trap_id: "OBO008"
      name: "Count Off By One"
      description: "Wrong count of elements in range"
      example: |
        count = upper_bound - lower_bound  # Should be +1?
      detection_difficulty: "easy"
      manifestation: "Element count wrong"
      
    ceiling_vs_floor:
      trap_id: "OBO009"
      name: "Ceiling vs Floor Confusion"
      description: "Returning floor when ceiling needed"
      example: |
        # Find smallest element >= target (ceiling)
        # But implementation returns largest < target (floor)
      detection_difficulty: "medium"
      manifestation: "Wrong element returned"
      
    predecessor_vs_successor:
      trap_id: "OBO010"
      name: "Predecessor vs Successor"
      description: "Returning predecessor instead of successor"
      example: |
        # Find next greater element
        # But returns current element
      detection_difficulty: "medium"
      manifestation: "Wrong adjacent element"
      
    empty_result_handling:
      trap_id: "OBO011"
      name: "Empty Result Off By One"
      description: "Wrong return value when not found"
      example: |
        if lo > hi:
            return lo  # Should be -1 for not found
                       # or lo for insertion point
      detection_difficulty: "easy"
      manifestation: "Wrong not-found indicator"
      
    range_exclusive_inclusive:
      trap_id: "OBO012"
      name: "Range Bounds Convention"
      description: "Inconsistent [lo, hi) vs [lo, hi] convention"
      example: |
        # Some functions use inclusive, some exclusive
        # Caller and callee disagree on convention
      detection_difficulty: "hard"
      manifestation: "Off by one at boundaries"

  # ---------------------------------------------------------------------------
  # Integer Overflow Traps (8 types)
  # ---------------------------------------------------------------------------
  integer_overflow:
    mid_calculation_overflow:
      trap_id: "IOV001"
      name: "Mid Calculation Overflow"
      description: "(lo + hi) / 2 overflows for large indices"
      example: |
        mid = (lo + hi) / 2
        # If lo = 1B, hi = 2B, sum overflows in 32-bit
        # Should use: mid = lo + (hi - lo) / 2
      detection_difficulty: "medium"
      manifestation: "Negative index or wrong mid"
      
    sum_overflow:
      trap_id: "IOV002"
      name: "Sum Overflow in Search"
      description: "Adding elements overflows"
      example: |
        # Binary search on prefix sums
        # Sum of INT_MAX values overflows
      detection_difficulty: "medium"
      manifestation: "Wrong search result"
      
    multiplication_overflow:
      trap_id: "IOV003"
      name: "Multiplication Overflow"
      description: "Index calculation overflows"
      example: |
        # 2D array indexing: row * cols + col
        # Overflows for large matrices
      detection_difficulty: "medium"
      manifestation: "Wrong array access"
      
    unsigned_underflow:
      trap_id: "IOV004"
      name: "Unsigned Underflow"
      description: "Subtracting from unsigned causes underflow"
      example: |
        size_t hi = arr.size() - 1;  // Underflows if empty
        while (lo <= hi) { ... }
      detection_difficulty: "medium"
      manifestation: "Huge positive value wraps"
      
    signed_to_unsigned:
      trap_id: "IOV005"
      name: "Signed to Unsigned Conversion"
      description: "Negative index becomes huge positive"
      example: |
        int lo = -1;  // Not found indicator
        size_t index = lo;  // Becomes MAX_SIZE_T
      detection_difficulty: "hard"
      manifestation: "Huge array access"
      
    index_times_element_size:
      trap_id: "IOV006"
      name: "Index Times Element Size"
      description: "Byte offset calculation overflows"
      example: |
        offset = index * sizeof(element);
        // For large indices and element sizes
      detection_difficulty: "hard"
      manifestation: "Memory corruption"
      
    exponential_search_overflow:
      trap_id: "IOV007"
      name: "Exponential Search Overflow"
      description: "Doubling bound overflows"
      example: |
        bound = 1;
        while (bound < n && arr[bound] < target)
            bound *= 2;  // Eventually overflows
      detection_difficulty: "medium"
      manifestation: "Negative or wrong bound"
      
    difference_overflow:
      trap_id: "IOV008"
      name: "Difference Calculation Overflow"
      description: "hi - lo overflows when negative"
      example: |
        // Search in range [lo, hi] where hi < lo
        range_size = hi - lo;  // Unexpected result
      detection_difficulty: "easy"
      manifestation: "Wrong size calculation"

  # ---------------------------------------------------------------------------
  # Duplicate Handling Traps (8 types)
  # ---------------------------------------------------------------------------
  duplicate_handling:
    wrong_occurrence:
      trap_id: "DUP001"
      name: "Wrong Occurrence Selection"
      description: "Returns any match instead of specified occurrence"
      example: |
        # Task: Find first occurrence
        # Code: Returns middle occurrence
      detection_difficulty: "medium"
      manifestation: "Wrong index for duplicates"
      
    all_duplicates:
      trap_id: "DUP002"
      name: "All Elements Same"
      description: "Fails when all elements equal target"
      example: |
        arr = [5, 5, 5, 5, 5]
        find_first(arr, 5)  # Might loop or return wrong
      detection_difficulty: "medium"
      manifestation: "Infinite loop or wrong index"
      
    duplicate_at_boundary:
      trap_id: "DUP003"
      name: "Duplicate at Boundary"
      description: "First/last occurrence at array boundary"
      example: |
        arr = [1, 1, 1, 2, 3]
        find_first(arr, 1)  # Must return 0
        find_last(arr, 1)   # Must return 2
      detection_difficulty: "medium"
      manifestation: "Boundary duplicates wrong"
      
    single_duplicate:
      trap_id: "DUP004"
      name: "Single Occurrence Duplicate Handling"
      description: "Target appears once but treated as duplicate"
      example: |
        # find_first and find_last should return same index
        # But code assumes duplicates exist
      detection_difficulty: "easy"
      manifestation: "Wrong index for unique"
      
    count_duplicates:
      trap_id: "DUP005"
      name: "Counting Duplicates"
      description: "Wrong count of duplicate elements"
      example: |
        count = upper_bound_index - lower_bound_index
        # Off by one error in counting
      detection_difficulty: "medium"
      manifestation: "Wrong duplicate count"
      
    insertion_with_duplicates:
      trap_id: "DUP006"
      name: "Insertion Point with Duplicates"
      description: "Wrong insertion point among duplicates"
      example: |
        arr = [1, 3, 3, 3, 5]
        # Insert 3: should go where?
        # Before first 3? After last 3?
      detection_difficulty: "medium"
      manifestation: "Inconsistent insertion"
      
    range_with_duplicates:
      trap_id: "DUP007"
      name: "Range Search with Duplicates"
      description: "Range boundaries wrong with duplicates"
      example: |
        arr = [1, 2, 2, 2, 3]
        search_range(arr, 2)  # Should be [1, 3]
      detection_difficulty: "medium"
      manifestation: "Range bounds wrong"
      
    adjacent_different_duplicates:
      trap_id: "DUP008"
      name: "Adjacent Different Duplicate Groups"
      description: "Multiple adjacent duplicate groups"
      example: |
        arr = [1, 1, 2, 2, 2, 3, 3]
        # Boundaries between groups
      detection_difficulty: "hard"
      manifestation: "Group boundary errors"

  # ---------------------------------------------------------------------------
  # Rotated Array Traps (6 types)
  # ---------------------------------------------------------------------------
  rotated_array:
    rotation_point_off:
      trap_id: "ROT001"
      name: "Rotation Point Off By One"
      description: "Wrong index for rotation point"
      example: |
        arr = [4, 5, 6, 7, 0, 1, 2]
        # Rotation point is index 4 (value 0)
        # But code returns 3 or 5
      detection_difficulty: "medium"
      manifestation: "Wrong rotation point"
      
    search_wrong_half:
      trap_id: "ROT002"
      name: "Search in Wrong Half"
      description: "Goes to wrong half of rotated array"
      example: |
        arr = [4, 5, 6, 7, 0, 1, 2]
        search(arr, 0)  # Must search right half
        # Code might search left half
      detection_difficulty: "hard"
      manifestation: "Element not found"
      
    no_rotation:
      trap_id: "ROT003"
      name: "No Rotation Edge Case"
      description: "Fails on non-rotated sorted array"
      example: |
        arr = [1, 2, 3, 4, 5]  # No rotation
        # Code assumes rotation exists
      detection_difficulty: "medium"
      manifestation: "Fails on sorted input"
      
    full_rotation:
      trap_id: "ROT004"
      name: "Full Rotation Edge Case"
      description: "Rotated by n positions = original"
      example: |
        arr = [1, 2, 3, 4, 5]  # Rotated by 5
        # Same as no rotation
      detection_difficulty: "easy"
      manifestation: "Treated as rotated"
      
    duplicates_in_rotated:
      trap_id: "ROT005"
      name: "Duplicates in Rotated Array"
      description: "Duplicates obscure rotation point"
      example: |
        arr = [2, 2, 2, 0, 1, 2]
        # Hard to find rotation point with duplicates
      detection_difficulty: "very_hard"
      manifestation: "Wrong rotation detection"
      
    single_element_rotated:
      trap_id: "ROT006"
      name: "Single Element Rotated"
      description: "Single element array rotation"
      example: |
        arr = [1]  # Rotated by any amount
      detection_difficulty: "easy"
      manifestation: "Divide by zero or wrong"

  # ---------------------------------------------------------------------------
  # Floating Point Search Traps (6 types)
  # ---------------------------------------------------------------------------
  floating_point:
    epsilon_termination:
      trap_id: "FPS001"
      name: "Epsilon Termination Criteria"
      description: "Wrong convergence criteria"
      example: |
        while hi - lo > 1e-9:  # Too tight, may not converge
            mid = (lo + hi) / 2
      detection_difficulty: "medium"
      manifestation: "Infinite loop or wrong result"
      
    precision_loss:
      trap_id: "FPS002"
      name: "Floating Point Precision Loss"
      description: "Precision loss in mid calculation"
      example: |
        # For very close lo and hi
        mid = (lo + hi) / 2
        # May equal lo or hi due to precision
      detection_difficulty: "hard"
      manifestation: "No progress in search"
      
    nan_in_search:
      trap_id: "FPS003"
      name: "NaN in Search Space"
      description: "NaN values break comparisons"
      example: |
        if arr[mid] < target:  # NaN < x is false
            ...               # NaN > x is also false
      detection_difficulty: "hard"
      manifestation: "Unpredictable branching"
      
    infinity_bounds:
      trap_id: "FPS004"
      name: "Infinity in Bounds"
      description: "Infinity as initial bound"
      example: |
        lo = float('-inf')
        hi = float('inf')
        mid = (lo + hi) / 2  # Results in NaN
      detection_difficulty: "medium"
      manifestation: "NaN mid value"
      
    negative_zero:
      trap_id: "FPS005"
      name: "Negative Zero Comparison"
      description: "-0.0 vs 0.0 comparison issues"
      example: |
        arr = [-0.0, 0.0]
        # -0.0 == 0.0 is True
        # But 1/-0.0 != 1/0.0
      detection_difficulty: "very_hard"
      manifestation: "Subtle wrong results"
      
    denormalized_numbers:
      trap_id: "FPS006"
      name: "Denormalized Number Handling"
      description: "Denormalized floats near zero"
      example: |
        # Very small numbers near underflow
        # May compare unexpectedly
      detection_difficulty: "very_hard"
      manifestation: "Precision issues near zero"

  # ---------------------------------------------------------------------------
  # Concurrent Search Traps (4 types)
  # ---------------------------------------------------------------------------
  concurrent_search:
    concurrent_modification:
      trap_id: "CON001"
      name: "Concurrent Array Modification"
      description: "Array modified during search"
      example: |
        # Another thread modifies array while searching
        # Invariants broken mid-search
      detection_difficulty: "very_hard"
      manifestation: "Race condition crashes"
      
    stale_cache:
      trap_id: "CON002"
      name: "Stale Cached Values"
      description: "Cached values become stale"
      example: |
        # Binary search on cached data
        # Source data changed
      detection_difficulty: "hard"
      manifestation: "Search finds stale data"
      
    lock_granularity:
      trap_id: "CON003"
      name: "Lock Granularity Issues"
      description: "Locks don't cover full search"
      example: |
        with lock:
            mid = find_mid()
        # Another thread modifies between lock releases
        check_mid(mid)
      detection_difficulty: "very_hard"
      manifestation: "Inconsistent results"
      
    memory_ordering:
      trap_id: "CON004"
      name: "Memory Ordering Issues"
      description: "Weak memory ordering affects search"
      example: |
        # Writes not visible to searcher
        # due to memory model
      detection_difficulty: "very_hard"
      manifestation: "Missing updates"

# =============================================================================
# EDGE CASE CATALOG
# =============================================================================

edge_cases:
  size_edge_cases:
    - empty_array_size_0
    - single_element_size_1
    - two_elements_size_2
    - power_of_two_size
    - power_of_two_minus_one
    - power_of_two_plus_one
    - maximum_array_size
    - just_under_max_size
    - odd_size
    - even_size

  target_position_cases:
    - target_at_index_0
    - target_at_index_1
    - target_at_last_index
    - target_at_second_to_last
    - target_at_middle
    - target_just_before_middle
    - target_just_after_middle
    - target_not_in_array
    - target_smaller_than_all
    - target_larger_than_all
    - target_between_elements

  value_edge_cases:
    - all_elements_same
    - all_elements_equal_target
    - two_distinct_values
    - strictly_increasing
    - strictly_decreasing
    - contains_max_int
    - contains_min_int
    - contains_zero
    - all_negative
    - all_positive
    - mixed_signs

  boundary_value_cases:
    - lo_equals_hi
    - lo_equals_hi_minus_1
    - lo_greater_than_hi
    - lo_is_zero
    - hi_is_max_index
    - indices_at_int_max
    - indices_at_int_min
    - mid_would_overflow
    - sum_would_overflow

  duplicate_edge_cases:
    - no_duplicates
    - all_duplicates
    - two_duplicates_adjacent
    - two_duplicates_separated
    - many_duplicates_at_start
    - many_duplicates_at_end
    - many_duplicates_in_middle
    - target_is_duplicate_first
    - target_is_duplicate_last
    - target_is_unique_among_duplicates

  special_array_cases:
    - sorted_ascending
    - sorted_descending
    - rotated_once
    - rotated_half
    - rotated_to_original
    - bitonic_peak_at_start
    - bitonic_peak_at_end
    - bitonic_peak_in_middle
    - step_function_array
    - alternating_values

# =============================================================================
# ANTI-PATTERNS
# =============================================================================

anti_patterns:
  llm_failure_modes:
    - "Pattern matching without understanding loop invariant requirements"
    - "Applying textbook binary search without boundary validation"
    - "Missing off-by-one errors in loop condition (< vs <=)"
    - "Ignoring integer overflow in mid calculation (lo + hi)/2"
    - "Confusing inclusive and exclusive upper bounds"
    - "Skipping verification of empty array handling"
    - "Over-relying on standard template without adaptation"
    - "Missing first/last occurrence distinction for duplicates"
    - "Ignoring boundary update correctness (mid+1 vs mid)"
    - "Failing to handle target not in array correctly"
    - "Not considering floating-point binary search convergence"
    - "Missing lower_bound vs upper_bound distinction"
    - "Overlooking insertion point semantics"
    - "Failing to verify loop termination"
    - "Not considering signed vs unsigned index types"
    - "Missing early termination optimization opportunities"
    - "Overlooking rotated array search requirements"
    - "Failing to handle bitonic array search"
    - "Not considering custom comparator requirements"
    - "Missing exponential search for unbounded arrays"
    - "Overlooking interpolation search opportunities"
    - "Failing to handle concurrent array modifications"
    - "Not implementing proper tie-breaking for duplicates"
    - "Missing floor/ceiling element distinction"
    - "Ignoring predecessor/successor semantics"

  task_design_anti_patterns:
    obvious_off_by_one:
      description: "Off-by-one error visible in first test"
      why_bad: "No debugging needed"
      
    always_fails:
      description: "Search always fails, never works"
      why_bad: "No subtlety required"
      
    standard_template_works:
      description: "Standard binary search template solves it"
      why_bad: "No thought required"
      
    error_message_reveals:
      description: "IndexError reveals the problem"
      why_bad: "Just read the error"

  code_anti_patterns:
    single_bug:
      description: "Only one thing is wrong"
      why_bad: "Too easy once found"
      
    commented_solution:
      description: "Comment shows correct code"
      why_bad: "Just uncomment"
      
    obvious_overflow:
      description: "Obvious (lo + hi) / 2 overflow"
      why_bad: "Well-known pattern"

# =============================================================================
# DIFFICULTY AMPLIFIERS
# =============================================================================

difficulty_amplifiers:
  nightmare:
    multiplier: 3.0
    description: "Extreme difficulty requiring expert-level multi-domain synthesis"
    requirements:
      - "7+ interacting traps across multiple domains"
      - "Requires understanding of hardware-level effects"
      - "Time estimate: 90+ minutes for senior engineers"
      - "Multiple red herrings that waste investigation time"
      - "Solution requires synthesizing knowledge from 3+ distinct areas"

  nightmare_plus:
    multiplier: 5.0
    estimated_time: [28800, 172800]  # 8-48 hours
    command_steps: [300, 1200]
    techniques_required: 12
    description: "Research paper difficulty requiring novel binary search design"
    requirements:
      - "10+ deeply interacting traps across boundary/overflow/invariant domains"
      - "Requires formal verification of loop invariants"
      - "Must synthesize knowledge from algorithms, numerical analysis, and formal methods"
      - "Requires proof of termination and correctness"
      - "Time estimate: 8-48 hours for competitive programmers with ICPC/IOI medal experience"
      - "Multiple off-by-one scenarios that interact with overflow"
      - "Must handle floating-point binary search with convergence guarantees"
      - "Requires understanding of randomized binary search variants"
      - "Solution involves formally verified implementation"

# =============================================================================
# MULTI-AGENT ORCHESTRATION COMPLEXITY
# =============================================================================

multi_agent_orchestration:
  description: "Coordinating 4-7 specialized agents for complex binary search analysis"
  
  specialized_agents:
    invariant_analyzer:
      role: "Identify and verify loop invariants"
      capabilities:
        - "Invariant discovery"
        - "Initialization proof"
        - "Maintenance proof"
        - "Termination proof"
      handoff_triggers:
        - "Loop correctness uncertain"
        - "Off-by-one suspected"
    
    boundary_checker:
      role: "Verify boundary conditions"
      capabilities:
        - "Empty array handling"
        - "Single element handling"
        - "First/last element cases"
        - "Inclusive vs exclusive bounds"
      handoff_triggers:
        - "Boundary failures detected"
        - "Edge case analysis needed"
    
    overflow_detector:
      role: "Detect and fix overflow issues"
      capabilities:
        - "Mid calculation overflow"
        - "Sum overflow detection"
        - "Index range analysis"
        - "Safe arithmetic patterns"
      handoff_triggers:
        - "Large array handling"
        - "Numerical issues suspected"
    
    duplicate_handler:
      role: "Handle duplicate elements correctly"
      capabilities:
        - "First occurrence finding"
        - "Last occurrence finding"
        - "Count computation"
        - "Range search"
      handoff_triggers:
        - "Duplicate handling required"
        - "Multiple occurrence search"
    
    variant_selector:
      role: "Select appropriate binary search variant"
      capabilities:
        - "Lower/upper bound selection"
        - "Rotated array search"
        - "Floating-point binary search"
        - "Parametric binary search"
      handoff_triggers:
        - "Variant selection needed"
        - "Non-standard search scenario"

  cross_algorithm_attack_chains:
    chain_1:
      name: "Off-by-One → Boundary Miss → Wrong Result → Silent Failure"
      stages:
        - "Loop condition uses < instead of <="
        - "Element at boundary not checked"
        - "Search returns not found"
        - "Element actually exists"
    
    chain_2:
      name: "Overflow → Negative Index → Memory Error → Crash"
      stages:
        - "(lo + hi) / 2 overflows"
        - "Mid becomes negative"
        - "Array access with negative index"
        - "Segmentation fault or wrong access"
    
    chain_3:
      name: "Duplicate Handling → Wrong Index → Incorrect Range → Bad Count"
      stages:
        - "Finding any occurrence instead of first"
        - "Returned index not leftmost"
        - "Range calculation wrong"
        - "Count of duplicates incorrect"

# =============================================================================
# THEORETICAL COMPLEXITY REQUIREMENTS
# =============================================================================

theoretical_complexity_requirements:
  loop_invariant_verification:
    concepts:
      - "Loop invariant definition"
      - "Initialization, maintenance, termination"
      - "Partial vs total correctness"
      - "Hoare logic foundations"
    applications:
      - "Proving binary search correctness"
      - "Variant function for termination"
      - "Bound tightness proofs"

  search_bounds:
    concepts:
      - "Comparison-based lower bounds"
      - "Information-theoretic arguments"
      - "Adversary arguments for search"
    applications:
      - "log n lower bound proof"
      - "Interpolation search analysis"
      - "Optimal search tree bounds"

  numerical_analysis:
    concepts:
      - "Integer overflow conditions"
      - "Floating-point convergence"
      - "Epsilon selection"
    applications:
      - "Safe mid calculation"
      - "Floating-point binary search termination"
      - "Precision requirements"

# =============================================================================
# ADVERSARIAL INPUT DESIGN
# =============================================================================

adversarial_input_design:
  worst_case_input_generation:
    overflow_trigger:
      description: "Array size and indices that cause overflow"
      technique: "lo = INT_MAX/2, hi = INT_MAX causes (lo+hi)/2 overflow"
      
    boundary_torture:
      description: "Target at every possible boundary position"
      technique: "Generate tests for all boundary positions"
      
    duplicate_saturation:
      description: "All elements equal to target"
      technique: "Array where every element matches"

  anti_optimization_inputs:
    worst_case_comparisons:
      description: "Input maximizing comparison count"
      technique: "Target never found, full log n comparisons"
    
    cache_unfriendly:
      description: "Large array with poor cache locality"
      technique: "Very large sparse array"

  edge_case_combinations:
    empty_and_single:
      description: "Empty array and single element"
      technique: "Test both with found and not found"
    
    all_same_all_different:
      description: "All same elements vs all different"
      technique: "Maximum and minimum duplicate scenarios"

# =============================================================================
# FORMAL PROOF REQUIREMENTS
# =============================================================================

formal_proof_requirements:
  correctness_proofs:
    loop_invariant:
      requirements:
        - "Define precise loop invariant"
        - "Prove initialization (invariant holds before loop)"
        - "Prove maintenance (invariant preserved)"
        - "Prove termination (loop terminates)"
        - "Prove postcondition (invariant + exit condition implies result)"
      
    termination:
      requirements:
        - "Define variant function (loop measure)"
        - "Prove variant decreases each iteration"
        - "Prove variant is bounded below"

  boundary_proofs:
    requirements:
      - "Prove empty array handled correctly"
      - "Prove single element cases correct"
      - "Prove first/last element found"
      - "Prove target not in array handled"

  code_structure:
    abstraction:
      description: "Search abstracted behind layers"
      amplification: "Must trace through abstraction"
      
    generic_implementation:
      description: "Generic search with type parameters"
      amplification: "Type-related edge cases"
      
    custom_comparator:
      description: "Search uses custom comparator"
      amplification: "Comparator might be wrong too"
      
    recursive_implementation:
      description: "Recursive rather than iterative"
      amplification: "Stack overflow possibility"
      
    iterator_based:
      description: "Uses iterators instead of indices"
      amplification: "Iterator invalidation issues"

  analysis_amplifiers:
    intermittent_failure:
      description: "Only fails on specific inputs"
      amplification: "Must find triggering inputs"
      
    large_scale_only:
      description: "Only fails with large arrays"
      amplification: "Need to test at scale"
      
    race_condition:
      description: "Concurrent access issues"
      amplification: "Non-deterministic failure"
      
    precision_dependent:
      description: "Depends on floating point precision"
      amplification: "Subtle precision issues"

  context_amplifiers:
    performance_critical:
      description: "Must be O(log n)"
      amplification: "Can't use simple linear fixes"
      
    external_data:
      description: "Array from external source"
      amplification: "Can't assume invariants"
      
    multiple_searches:
      description: "Part of larger search workflow"
      amplification: "Error compounds"

# =============================================================================
# VARIATION ENGINES
# =============================================================================

variation_engines:
  problem_type_variations:
    find_exact:
      description: "Find exact element"
      
    find_first:
      description: "Find first occurrence"
      
    find_last:
      description: "Find last occurrence"
      
    find_range:
      description: "Find range of occurrences"
      
    find_insertion:
      description: "Find insertion point"
      
    find_floor:
      description: "Find floor element"
      
    find_ceiling:
      description: "Find ceiling element"
      
    find_closest:
      description: "Find closest element"

  array_type_variations:
    sorted:
      elements: ["integers", "strings", "objects"]
      
    rotated:
      elements: ["single rotation", "multiple rotations"]
      
    bitonic:
      elements: ["peak at middle", "peak at boundary"]
      
    matrix_2d:
      elements: ["row-wise sorted", "fully sorted"]
      
    with_duplicates:
      elements: ["few duplicates", "many duplicates", "all same"]

  language_variations:
    python:
      issues: ["negative indices", "bisect module"]
      
    java:
      issues: ["Arrays.binarySearch", "Collections.binarySearch"]
      
    cpp:
      issues: ["std::lower_bound", "std::upper_bound", "std::binary_search"]
      
    javascript:
      issues: ["typed arrays", "sparse arrays"]
      
    rust:
      issues: ["slice::binary_search", "partition_point"]

# =============================================================================
# SWE-bench_Pro style fields
# =============================================================================

problem_statement: |
  A binary search implementation in a critical system is producing incorrect results 
  in edge cases. The search appears correct on most inputs but fails on:
  - Boundary conditions (first/last element)
  - Duplicate elements (find first/last occurrence)
  - Empty arrays
  - Single element arrays
  - Integer overflow in index calculations

requirements: |
  - Fix off-by-one errors in boundary handling
  - Implement correct first/last occurrence finding for duplicates
  - Handle empty and single-element arrays
  - Prevent integer overflow in mid calculation
  - Support both inclusive and exclusive upper bounds

interface: |
  Input: Sorted array, target value, search mode (any/first/last)
  Output: Index of found element (-1 if not found)
  Modes: FIND_ANY, FIND_FIRST, FIND_LAST

# terminal-bench style fields
difficulty:
  estimated: "nightmare_plus"
  time_range: [5400, 18000]  # 90-300 minutes for competitive programmers with ICPC/IOI medal experience
  command_steps: [60, 200]
  techniques_required: 12
  trap_count: "10+ deeply interacting traps across correctness/performance/edge-case domains"
  target_audience: "Competitive programmers with ICPC/IOI medal experience"

# LLM trap configurations
traps:
  - type: "off_by_one"
    description: "Classic lo <= hi vs lo < hi boundary confusion"
    trigger: "Using wrong loop termination condition"
  
  - type: "mid_overflow"
    description: "(lo + hi) / 2 overflows for large indices"
    trigger: "Using (lo + hi) / 2 instead of lo + (hi - lo) / 2"
  
  - type: "duplicate_handling"
    description: "Returns any match instead of first/last for duplicates"
    trigger: "Returning immediately on match instead of continuing search"
  
  - type: "boundary_update"
    description: "lo = mid vs lo = mid + 1 causes infinite loop"
    trigger: "Wrong boundary update after comparison"

  - type: "empty_array_crash"
    description: "Accessing arr[mid] on empty array"
    trigger: "Not checking array length before accessing"

  - type: "single_element_miss"
    description: "Loop skips single element case"
    trigger: "Loop condition excludes lo == hi case"

  - type: "unsigned_underflow"
    description: "hi = mid - 1 underflows when hi is 0"
    trigger: "Using unsigned type for indices"

  - type: "floating_point_non_termination"
    description: "Float binary search never terminates"
    trigger: "Epsilon too small for precision"

  - type: "first_occurrence_wrong"
    description: "Finding any occurrence when first required"
    trigger: "hi = mid - 1 when arr[mid] == target"

  - type: "insertion_point_confusion"
    description: "Wrong insertion point for not-found case"
    trigger: "Returning lo vs lo+1 inconsistently"

  - type: "rotated_array_wrong_half"
    description: "Searching wrong half of rotated array"
    trigger: "Incorrect sorted-half detection"

# Task generation template
instruction_template: |
  You are fixing a {{ scenario_type }} binary search implementation.
  The code is at {{ path }}.
  
  Tests are failing on edge cases. Your task:
  {{ task_steps }}
  
  Test array sizes: {{ min_size }} to {{ max_size }} elements
  Duplicate ratio: {{ duplicate_ratio }}%

# Reference solution (hidden from agent)
reference_solution: |
  #!/usr/bin/env python3
  from typing import List, Optional
  from enum import Enum
  
  class SearchMode(Enum):
      FIND_ANY = "any"
      FIND_FIRST = "first"
      FIND_LAST = "last"
      FIND_LOWER_BOUND = "lower_bound"
      FIND_UPPER_BOUND = "upper_bound"
  
  def binary_search(
      arr: List[int], 
      target: int, 
      mode: SearchMode = SearchMode.FIND_ANY
  ) -> int:
      if not arr:
          if mode in (SearchMode.FIND_LOWER_BOUND, SearchMode.FIND_UPPER_BOUND):
              return 0
          return -1
      
      n = len(arr)
      
      if mode == SearchMode.FIND_ANY:
          return _binary_search_any(arr, target)
      elif mode == SearchMode.FIND_FIRST:
          return _binary_search_first(arr, target)
      elif mode == SearchMode.FIND_LAST:
          return _binary_search_last(arr, target)
      elif mode == SearchMode.FIND_LOWER_BOUND:
          return _lower_bound(arr, target)
      elif mode == SearchMode.FIND_UPPER_BOUND:
          return _upper_bound(arr, target)
  
  def _binary_search_any(arr: List[int], target: int) -> int:
      lo, hi = 0, len(arr) - 1
      while lo <= hi:
          mid = lo + (hi - lo) // 2
          if arr[mid] == target:
              return mid
          elif arr[mid] < target:
              lo = mid + 1
          else:
              hi = mid - 1
      return -1
  
  def _binary_search_first(arr: List[int], target: int) -> int:
      lo, hi = 0, len(arr) - 1
      result = -1
      while lo <= hi:
          mid = lo + (hi - lo) // 2
          if arr[mid] == target:
              result = mid
              hi = mid - 1
          elif arr[mid] < target:
              lo = mid + 1
          else:
              hi = mid - 1
      return result
  
  def _binary_search_last(arr: List[int], target: int) -> int:
      lo, hi = 0, len(arr) - 1
      result = -1
      while lo <= hi:
          mid = lo + (hi - lo) // 2
          if arr[mid] == target:
              result = mid
              lo = mid + 1
          elif arr[mid] < target:
              lo = mid + 1
          else:
              hi = mid - 1
      return result
  
  def _lower_bound(arr: List[int], target: int) -> int:
      lo, hi = 0, len(arr)
      while lo < hi:
          mid = lo + (hi - lo) // 2
          if arr[mid] < target:
              lo = mid + 1
          else:
              hi = mid
      return lo
  
  def _upper_bound(arr: List[int], target: int) -> int:
      lo, hi = 0, len(arr)
      while lo < hi:
          mid = lo + (hi - lo) // 2
          if arr[mid] <= target:
              lo = mid + 1
          else:
              hi = mid
      return lo
  
  def count_occurrences(arr: List[int], target: int) -> int:
      first = _binary_search_first(arr, target)
      if first == -1:
          return 0
      last = _binary_search_last(arr, target)
      return last - first + 1
  
  def search_range(arr: List[int], target: int) -> List[int]:
      first = _binary_search_first(arr, target)
      if first == -1:
          return [-1, -1]
      last = _binary_search_last(arr, target)
      return [first, last]

# Test cases
fail_to_pass:
  - "test_empty_array"
  - "test_single_element_found"
  - "test_single_element_not_found"
  - "test_first_element"
  - "test_last_element"
  - "test_find_first_duplicate"
  - "test_find_last_duplicate"
  - "test_large_array_overflow"

pass_to_pass:
  - "test_basic_search"
  - "test_middle_element"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: ["database index lookup", "time series query", "log search", "sorted file lookup"]
  - name: path
    type: path
    generator: random_path
  - name: min_size
    type: int
    min: 0
    max: 10
  - name: max_size
    type: int
    min: 100000
    max: 10000000
  - name: duplicate_ratio
    type: int
    min: 0
    max: 50
  - name: task_steps
    type: template
    value: |
      1. Identify boundary condition bugs
      2. Fix integer overflow in mid calculation
      3. Implement correct first/last occurrence finding
      4. Handle empty and single-element cases
      5. Add comprehensive edge case tests

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  edge_cases:
    - empty_array
    - single_element
    - all_duplicates
    - target_at_boundaries
    - integer_overflow_indices

# =============================================================================
# TASK COMBINATION MATRIX
# =============================================================================

combination_matrix:
  primary_trap_selection:
    method: "Select 1-2 primary traps from trap_taxonomy"
    diversity_requirement: "Must not repeat within 100 generated tasks"
    
  edge_case_selection:
    method: "Select 3-5 edge cases that trigger the traps"
    coverage_requirement: "Edge cases must be non-obvious"
    
  search_variant_selection:
    method: "Select search variant from problem_type_variations"
    requirement: "Variant must interact with selected traps"
    
  context_selection:
    method: "Select domain from domain_contexts"
    realism_requirement: "Context must be believable"

# =============================================================================
# GENERATION STATISTICS TARGET
# =============================================================================

generation_targets:
  unique_tasks: 10000
  minimum_difficulty: "experienced developer needs 30+ minutes, requires deep domain expertise"
  trap_coverage: "all trap types used at least 100 times"
  edge_case_coverage: "all edge cases appear in at least 50 tasks"
