id: "sys-conc-deadlock-001"
version: "1.0.0"
category: "systems"
subcategory: "concurrency"

# SWE-bench_Pro style fields
problem_statement: |
  A multi-threaded application intermittently hangs under high load. Thread dumps 
  show threads waiting on locks, but the deadlock isn't obvious because:
  
  1. Locks are acquired through different code paths (transitive deadlock)
  2. Reader-writer lock upgrade causes self-deadlock
  3. Lock ordering isn't consistent across modules
  4. Nested lock acquisition through callbacks
  5. Database connections with implicit locks

requirements: |
  - Identify all deadlock scenarios
  - Implement consistent lock ordering
  - Detect potential deadlocks at runtime
  - Fix reader-writer lock upgrade issues
  - Add deadlock prevention mechanisms

interface: |
  Input: Multi-threaded code with locking
  Output: Deadlock-free code, detection tools, lock hierarchy documentation
  Monitoring: Thread state tracking, lock wait times

# terminal-bench style fields
difficulty:
  estimated: "hard"
  time_range: [2700, 7200]
  command_steps: [30, 90]

# === QUALITY REQUIREMENTS ===
quality_requirements:
  minimum_time: "120-300 minutes for senior systems engineers with kernel contribution experience"
  expertise_level: "Principal systems engineer with lock dependency analysis and kernel debugging expertise"
  validation_standard: "Must expose subtle lock ordering violations spanning multiple subsystems and kernel layers"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 9
  agent_specializations:
    - name: "lockdep_analyzer"
      role: "Analyze kernel lockdep output and lock dependency graphs"
      expertise: ["lockdep annotations", "lock class tracking", "dependency chain analysis", "cross-lock dependencies"]
    - name: "kernel_stack_tracer"
      role: "Trace kernel stacks and identify blocking paths"
      expertise: ["ftrace", "stack unwinding", "call graph analysis", "blocking point identification"]
    - name: "rw_lock_specialist"
      role: "Debug reader-writer lock issues and upgrades"
      expertise: ["rwsem internals", "percpu rw locks", "downgrade paths", "writer starvation"]
    - name: "scheduler_interaction_expert"
      role: "Identify scheduler-lock interactions causing priority inversion"
      expertise: ["RT priority inheritance", "PI futexes", "boost/deboost", "wait queue analysis"]
    - name: "filesystem_lock_expert"
      role: "Debug VFS and filesystem locking hierarchies"
      expertise: ["inode locks", "dentry locks", "superblock locks", "mount namespace locks"]
    - name: "network_stack_debugger"
      role: "Debug network stack locking and socket deadlocks"
      expertise: ["socket locks", "netfilter locks", "routing table locks", "NAPI processing"]
    - name: "memory_subsystem_analyzer"
      role: "Debug memory allocation under locks"
      expertise: ["GFP flags", "reclaim paths", "mmap_lock", "page lock ordering"]
    - name: "signal_handler_specialist"
      role: "Debug signal delivery deadlocks and async safety"
      expertise: ["sighand lock", "async-signal-safe functions", "signal queue locks", "ptrace locks"]
    - name: "distributed_lock_expert"
      role: "Debug distributed locking and cluster-wide deadlocks"
      expertise: ["DLM (Distributed Lock Manager)", "Paxos-based locks", "lease-based locking", "fencing"]
  cross_subsystem_chains:
    - "VFS inode lock → Memory reclaim → Filesystem writeback → Block I/O lock → Deadlock"
    - "Socket lock → Netfilter rule evaluation → Memory allocation → Page lock → Deadlock"
    - "mmap_lock (read) → Page fault → Filesystem lock → mmap_lock (write) → Self-deadlock"
    - "RCU callback → Memory allocation → Reclaim → RCU grace period wait → Deadlock"
  parallel_debugging_requirements:
    - "Correlated lock acquisition traces across multiple threads with timestamps"
    - "Simultaneous lock dependency graph construction and cycle detection"
    - "Agent handoff for transitive deadlock chains spanning 5+ locks"

# === TRAP CONFIGURATION ===
trap_configuration:
  trap_count: "12+ deeply interacting traps across kernel/userspace/hardware boundaries"
  trap_categories:
    lock_ordering_traps:
      - "Transitive deadlock via 4+ intermediate locks in different modules"
      - "Dynamic lock ordering based on runtime data causing sporadic deadlock"
      - "Lock ordering violation hidden in error handling path"
      - "Callback invoked under lock attempts to acquire nested lock"
    rwlock_traps:
      - "Read lock upgrade attempt causing self-deadlock"
      - "Multiple concurrent read-to-write upgrade attempts"
      - "Writer starvation from continuous reader stream"
      - "Downgrade ordering violation in complex transaction"
    kernel_specific_traps:
      - "mmap_lock ordering with filesystem locks"
      - "RCU callback scheduling while holding sleeping lock"
      - "Page lock vs inode lock ordering violation"
      - "netfilter hook holding lock during allocation"

# === NIGHTMARE_PLUS DIFFICULTY ===
difficulty_levels:
  nightmare_plus:
    estimated_time: [43200, 259200]  # 12-72 hours
    command_steps: [600, 2500]
    techniques_required: 18
    description: "Linux kernel CVE-level difficulty requiring deep internals knowledge"
    requirements:
      - "Requires understanding of complete kernel lock hierarchy"
      - "Must handle deadlocks spanning kernel, userspace, and firmware"
      - "Involves complex RCU and SRCU interaction patterns"
      - "Cross-platform behavior differences (Linux vs BSD vs Windows)"
      - "Time estimate: 12-72 hours for kernel maintainers"
      - "Requires synthesizing scheduler, memory, filesystem, and network knowledge"

# === KERNEL SUBSYSTEM REQUIREMENTS ===
kernel_subsystem_requirements:
  process_scheduler:
    - "Priority inheritance chain tracking"
    - "RT mutex implementation and PI chains"
    - "Deadline scheduling lock interactions"
    - "CPU hotplug and scheduler lock ordering"
  memory_management:
    - "mmap_lock hierarchy and holders"
    - "Page lock ordering with filesystem locks"
    - "Direct reclaim vs kswapd lock differences"
    - "SLUB lock ordering with other subsystems"
  filesystem_layer:
    - "VFS inode, dentry, superblock lock ordering"
    - "Per-filesystem lock hierarchies (ext4, XFS, btrfs)"
    - "Writeback locking and page cache locks"
    - "Quotas and ACL lock interactions"
  networking_stack:
    - "Socket lock hierarchy (sk_lock, sk_backlog)"
    - "NAPI poll vs interrupt context locking"
    - "Routing table read vs write locks"
    - "Netfilter rule update locking"

# === HARDWARE INTERACTION ===
hardware_interaction:
  hardware_locks:
    - "IOMMU lock ordering with device driver locks"
    - "PCI configuration space lock hierarchies"
    - "NVMe controller queue locks"
    - "DMA buffer lock interactions"
  firmware_interaction:
    - "ACPI AML interpreter locks"
    - "UEFI runtime service locks"
    - "Platform firmware callback locking"
    - "SMM (System Management Mode) preemption effects"
  interrupt_handling:
    - "IRQ handler lock requirements (spin_lock_irqsave)"
    - "Nested interrupt handling and lock ordering"
    - "Softirq vs hardirq lock ordering"
    - "Workqueue vs interrupt context lock hierarchy"

# === FORMAL VERIFICATION REQUIREMENTS ===
formal_verification_requirements:
  modeling_requirements:
    - "Model lock dependency graph in TLA+ with all paths"
    - "Express lock ordering constraints formally"
    - "Use SPIN model checker for deadlock freedom"
    - "Apply partial order reduction for state space"
  proof_obligations:
    - "Prove absence of cycles in lock dependency graph"
    - "Verify lock ordering is maintained on all code paths"
    - "Establish bounded wait time under contention"
    - "Prove priority inheritance correctness"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research deadlock detection algorithms and prevention strategies"
    phase_2_creation: "Create task with subtle deadlock scenarios through indirection"
    phase_3_amplification: "Add callback-induced deadlocks and library lock interactions"
    phase_4_verification:
      description: "Validate task requires understanding lock ordering and cycles"
      criteria:
        - "Has at least 5 interacting system-level traps across subsystems"
        - "Has cascading failures across process, memory, and I/O subsystems"
        - "Requires knowledge of OS kernel internals and scheduler behavior"
        - "Would take experienced systems programmers 45+ minutes"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 3.5
      description: "Kernel-level debugging complexity requiring deep systems expertise"
      requirements:
        - "7+ interacting system-level traps across subsystems"
        - "Requires understanding of kernel memory management and scheduling"
        - "Time estimate: 120+ minutes for senior systems engineers"
        - "Cross-platform behavior differences (Linux vs BSD vs Windows)"
        - "Requires synthesizing concurrency, memory, distributed systems knowledge"
  
  generation_targets:
    minimum_difficulty: "45+ minutes, requires deep kernel internals and distributed systems expertise"
  
  complexity_levels:
    level_1_basic:
      description: "Simple two-lock deadlock"
      elements: ["lock_a_then_b", "lock_b_then_a"]
    level_2_intermediate:
      description: "Transitive deadlock through multiple modules"
      elements: ["indirect_lock_chain", "callback_reentry"]
    level_3_advanced:
      description: "Reader-writer lock issues and upgrades"
      elements: ["rwlock_upgrade", "multiple_reader_writer"]
    level_4_expert:
      description: "Hidden locks in libraries and frameworks"
      elements: ["database_implicit_locks", "signal_handler_locks"]
    level_5_research:
      description: "Novel deadlock patterns in distributed systems"
      elements: ["distributed_deadlock", "resource_hierarchy_violation"]

# === COMPREHENSIVE TOPIC UNIVERSE ===
topic_universe:
  # Deadlock Types (30+ topics)
  deadlock_types:
    resource_deadlocks:
      - "Mutual exclusion deadlock"
      - "Circular wait deadlock"
      - "Hold and wait deadlock"
      - "No preemption deadlock"
      - "Nested lock deadlock"
      - "Transitive deadlock (A->B, B->C, C->A)"
    
    communication_deadlocks:
      - "Message passing deadlock"
      - "RPC deadlock"
      - "Callback-induced deadlock"
      - "Signal handler deadlock"
    
    reader_writer_deadlocks:
      - "Read-to-write upgrade deadlock"
      - "Writer starvation"
      - "Reader starvation"
      - "Downgrade ordering issue"
    
    database_deadlocks:
      - "Row-level lock deadlock"
      - "Table-level lock deadlock"
      - "Index lock deadlock"
      - "Gap lock deadlock"
      - "Phantom read prevention deadlock"
    
    distributed_deadlocks:
      - "Distributed transaction deadlock"
      - "Microservice call deadlock"
      - "Resource allocation deadlock"
      - "Token ring deadlock"
  
  # Deadlock Prevention (25+ topics)
  prevention_strategies:
    lock_ordering:
      - "Global lock ordering"
      - "Lock hierarchy levels"
      - "Resource numbering"
      - "Alphabetical ordering"
      - "Address-based ordering"
    
    lock_design:
      - "Lock granularity (coarse vs fine)"
      - "Lock striping"
      - "Lock elision"
      - "Optimistic locking"
      - "Lock-free alternatives"
    
    timeouts:
      - "Lock acquisition timeout"
      - "Deadlock timeout detection"
      - "Watchdog timers"
      - "Retry with backoff"
    
    avoidance:
      - "Banker's algorithm"
      - "Resource allocation graph"
      - "Safe state detection"
      - "Wait-die scheme"
      - "Wound-wait scheme"
  
  # Deadlock Detection (25+ topics)
  detection_strategies:
    static_analysis:
      - "Lock acquisition graph"
      - "Code path analysis"
      - "Lockset analysis"
      - "Happens-before analysis"
    
    runtime_detection:
      - "Cycle detection in wait-for graph"
      - "Timeout-based detection"
      - "Heartbeat monitoring"
      - "Lock dependency tracking"
    
    tools:
      - "Thread dump analysis"
      - "jstack/jcmd (Java)"
      - "gdb thread info"
      - "Linux lockdep"
      - "Windows WinDbg !locks"
      - "Valgrind Helgrind"
  
  # Lock Types and Patterns (35+ topics)
  lock_types:
    mutex_variants:
      - "Non-recursive mutex"
      - "Recursive mutex"
      - "Timed mutex"
      - "Adaptive mutex"
      - "Spinlock"
    
    reader_writer:
      - "Fair RW lock"
      - "Writer-preferred"
      - "Reader-preferred"
      - "Upgradeable RW lock"
      - "Seqlock"
    
    specialized:
      - "Condition variable"
      - "Semaphore"
      - "Barrier"
      - "Latch"
      - "Phaser"
    
    database_locks:
      - "Shared (S) lock"
      - "Exclusive (X) lock"
      - "Update (U) lock"
      - "Intent locks (IS, IX, SIX)"
      - "Schema locks"
  
  # Locking Patterns (30+ topics)
  locking_patterns:
    safe_patterns:
      - "Lock ordering by address"
      - "Try-lock with backoff"
      - "Lock-free data structures"
      - "Read-copy-update (RCU)"
      - "Hazard pointers"
    
    dangerous_patterns:
      - "Nested locking without order"
      - "Lock in callback"
      - "Lock in signal handler"
      - "Lock in destructor"
      - "Lock in exception handler"
    
    idioms:
      - "Double-checked locking"
      - "Lock striping"
      - "Hand-over-hand locking"
      - "Two-phase locking"
  
  # Platform-Specific (20+ topics)
  platform_specific:
    linux:
      - "pthread mutex"
      - "pthread rwlock"
      - "futex"
      - "kernel mutex"
      - "spinlock_t"
      - "lockdep annotations"
    
    windows:
      - "CRITICAL_SECTION"
      - "SRW lock"
      - "Mutex object"
      - "Event object"
      - "WaitForMultipleObjects"
    
    java:
      - "synchronized keyword"
      - "ReentrantLock"
      - "ReadWriteLock"
      - "StampedLock"
      - "ThreadMXBean deadlock detection"

# === BUG PATTERNS ===
bug_patterns:
  classic_deadlocks:
    - pattern: "ab_ba_deadlock"
      description: "Thread 1 locks A then B, Thread 2 locks B then A"
      severity: "critical"
      detection: "Both threads blocked indefinitely"
      fix: "Always lock in same order (A before B)"
      code_example: |
        # Bug: inconsistent order
        def thread1():
            with lock_a:
                with lock_b:  # Deadlock if thread2 runs concurrently
                    work()
        
        def thread2():
            with lock_b:
                with lock_a:  # Opposite order!
                    work()
        
        # Fix: consistent order
        def thread1():
            with lock_a:
                with lock_b:
                    work()
        
        def thread2():
            with lock_a:  # Same order: A first
                with lock_b:
                    work()
    
    - pattern: "transitive_deadlock"
      description: "A->B in one path, B->C in another, C->A in third"
      severity: "critical"
      detection: "Complex cycle in wait-for graph"
      fix: "Establish global lock hierarchy"

  reader_writer_deadlocks:
    - pattern: "rwlock_upgrade_deadlock"
      description: "Thread holds read lock, tries to upgrade to write"
      severity: "critical"
      detection: "Thread blocked on write acquire while holding read"
      fix: "Release read lock before acquiring write, or use upgradeable lock"
      code_example: |
        # Bug: upgrade attempt
        def update_if_needed():
            rwlock.acquire_read()
            if needs_update():
                rwlock.acquire_write()  # DEADLOCK: can't upgrade while holding read!
                do_update()
                rwlock.release_write()
            rwlock.release_read()
        
        # Fix: release read first
        def update_if_needed():
            rwlock.acquire_read()
            should_update = needs_update()
            rwlock.release_read()
            
            if should_update:
                rwlock.acquire_write()
                # Re-check after acquiring write (might have changed)
                if needs_update():
                    do_update()
                rwlock.release_write()
    
    - pattern: "reader_writer_starvation"
      description: "Continuous readers prevent writer from ever acquiring"
      severity: "high"
      detection: "Writer waits indefinitely"
      fix: "Use fair RW lock or writer-preferred"

  callback_deadlocks:
    - pattern: "callback_reentry"
      description: "Callback invoked under lock tries to acquire same lock"
      severity: "critical"
      detection: "Self-deadlock or recursive lock overflow"
      fix: "Never call user code while holding locks"
      code_example: |
        # Bug: callback under lock
        def process_event(event, callback):
            with lock:
                result = process(event)
                callback(result)  # Callback might try to acquire lock!
        
        # Fix: call callback outside lock
        def process_event(event, callback):
            with lock:
                result = process(event)
            callback(result)  # Safe: no lock held
    
    - pattern: "listener_notification_deadlock"
      description: "Notifying listeners under lock, listener tries to unsubscribe"
      severity: "high"
      detection: "Deadlock during notification"
      fix: "Copy listener list, notify outside lock"

  hidden_lock_deadlocks:
    - pattern: "library_internal_lock"
      description: "Library acquires internal lock, user code holds conflicting lock"
      severity: "high"
      detection: "Deadlock involving unknown lock"
      fix: "Understand library locking, avoid holding locks during library calls"
    
    - pattern: "signal_handler_deadlock"
      description: "Signal handler called while holding lock, handler tries to acquire"
      severity: "critical"
      detection: "Process hangs on signal"
      fix: "Only use async-signal-safe functions in handlers"
      code_example: |
        # Bug: signal handler uses locks
        def signal_handler(sig, frame):
            with lock:  # DEADLOCK if signal during lock hold!
                save_state()
        
        # Fix: async-signal-safe only
        def signal_handler(sig, frame):
            # Only set flag, process later
            shutdown_requested = True
            os.write(signal_pipe, b'1')  # write() is async-signal-safe

  database_deadlocks:
    - pattern: "row_order_deadlock"
      description: "Transactions update rows in different order"
      severity: "high"
      detection: "Database detects and rolls back one transaction"
      fix: "Always access rows in consistent order (e.g., by primary key)"
    
    - pattern: "gap_lock_deadlock"
      description: "Gap locks conflict during concurrent inserts"
      severity: "medium"
      detection: "Insert operations deadlock"
      fix: "Use appropriate isolation level, consider lock hints"

# === EDGE CASES ===
edge_cases:
  lock_ordering_edge_cases:
    - "Locks created dynamically with unknown ordering"
    - "Lock ordering depends on runtime data"
    - "Multiple lock hierarchies in different modules"
    - "Lock ordering changes during refactoring"
    - "Lock address changes between runs (ASLR)"
    - "Lock ordering across process boundaries"

  rwlock_edge_cases:
    - "Maximum reader count exceeded"
    - "Reader releases wrong lock"
    - "Writer releases wrong lock"
    - "Upgrade attempt from non-holder"
    - "Downgrade attempt from non-holder"
    - "Read lock in write lock context"

  timing_edge_cases:
    - "Deadlock only under high contention"
    - "Deadlock only under low contention"
    - "Deadlock depends on thread scheduling"
    - "Deadlock probability varies with thread count"
    - "Deadlock window is very small"

  resource_edge_cases:
    - "Maximum lock count reached"
    - "Lock memory allocation fails"
    - "Thread pool exhaustion while holding lock"
    - "Timeout expires while holding other locks"

  exception_edge_cases:
    - "Exception thrown while holding lock"
    - "Lock not released on error path"
    - "Cleanup code tries to acquire lock"
    - "Exception in lock constructor"

  platform_edge_cases:
    - "Priority inversion without inheritance"
    - "Recursive lock on non-recursive mutex"
    - "Unlocking from different thread"
    - "Destroying locked mutex"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  deadlock_complexity:
    transitive_chains:
      multiplier: 1.8
      description: "Deadlock involves 3+ locks in chain"
      considerations:
        - "Multiple code paths"
        - "Different modules"
        - "Hard to trace"
    
    dynamic_lock_ordering:
      multiplier: 2.0
      description: "Lock order determined at runtime"
      considerations:
        - "Try-lock with backoff"
        - "Address-based ordering"
        - "Complex recovery"

  system_complexity:
    multi_library:
      multiplier: 1.5
      description: "Deadlock involves multiple libraries"
      considerations:
        - "Unknown internal locks"
        - "Limited documentation"
        - "Version dependencies"
    
    distributed:
      multiplier: 2.0
      description: "Distributed deadlock across processes/machines"
      considerations:
        - "Network timeouts"
        - "Partial failures"
        - "Detection complexity"

# === SCENARIO TEMPLATES ===
scenario_templates:
  classic_ab_ba:
    description: "Simple two-lock deadlock"
    setup: |
      - Two locks: account_lock, transaction_lock
      - transfer() acquires account first, then transaction
      - audit() acquires transaction first, then account
    symptoms: |
      - Occasional hangs during transfer with audit
      - Thread dump shows circular wait
    root_cause: "Inconsistent lock ordering"
    fix: |
      - Establish ordering: always account before transaction
      - Or use single lock for both

  rwlock_upgrade:
    description: "Read-to-write upgrade deadlock"
    setup: |
      - Cache with RW lock
      - read_and_maybe_update() holds read, tries write
      - Multiple threads call concurrently
    symptoms: |
      - Single thread hangs on upgrade
      - Multiple threads all hang
    root_cause: "Upgrade not supported, multiple readers block writer"
    fix: |
      - Release read before acquiring write
      - Use upgradeable RW lock
      - Optimistic update pattern

  callback_reentry:
    description: "Callback tries to acquire caller's lock"
    setup: |
      - Event system with lock around event firing
      - Handler tries to subscribe/unsubscribe during handling
    symptoms: |
      - Hang during event handling
      - Only when handler modifies subscriptions
    root_cause: "Callback invoked while holding lock"
    fix: |
      - Copy handlers, invoke outside lock
      - Defer modifications to after lock release
      - Use recursive lock (less preferred)

  database_row_deadlock:
    description: "Database transactions lock rows in different order"
    setup: |
      - Transaction A: UPDATE users SET x WHERE id=1, then id=2
      - Transaction B: UPDATE users SET y WHERE id=2, then id=1
    symptoms: |
      - Deadlock detected by database
      - One transaction rolled back
    root_cause: "Different row access order"
    fix: |
      - Always access rows in PK order
      - Use SELECT FOR UPDATE to acquire locks early
      - Reduce transaction scope

# === REFERENCE SOLUTION ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Comprehensive deadlock prevention, detection, and resolution.
  Implements lock ordering, detection algorithms, and safe patterns.
  """
  import threading
  import time
  import traceback
  from typing import Dict, Set, List, Optional, Callable, Any, Tuple
  from dataclasses import dataclass, field
  from contextlib import contextmanager
  from collections import defaultdict
  from enum import Enum, auto
  import weakref
  import logging
  
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger(__name__)
  
  # === LOCK INFO ===
  
  @dataclass
  class LockInfo:
      """Metadata about a lock for ordering and detection."""
      lock_id: int
      name: str
      hierarchy_level: int
      acquired_at: Optional[str] = None
      held_by: Optional[int] = None
      acquisition_time: float = 0.0
  
  # === DEADLOCK DETECTOR ===
  
  class DeadlockDetector:
      """
      Runtime deadlock detection using lock ordering verification.
      Detects potential deadlocks before they happen.
      """
      
      _instance = None
      _instance_lock = threading.Lock()
      
      def __new__(cls):
          if cls._instance is None:
              with cls._instance_lock:
                  if cls._instance is None:
                      cls._instance = super().__new__(cls)
                      cls._instance._initialize()
          return cls._instance
      
      def _initialize(self):
          self._lock = threading.Lock()
          # lock_order[A][B] = traceback where A was held when B acquired
          self._lock_order: Dict[int, Dict[int, str]] = defaultdict(dict)
          # thread_locks[thread_id] = [lock_ids currently held, in order]
          self._thread_locks: Dict[int, List[int]] = defaultdict(list)
          # lock_waiters[lock_id] = set of thread_ids waiting
          self._lock_waiters: Dict[int, Set[int]] = defaultdict(set)
          # lock_info[lock_id] = LockInfo
          self._lock_info: Dict[int, LockInfo] = {}
          self._enabled = True
      
      def register_lock(self, lock_id: int, name: str, level: int) -> None:
          """Register a lock with its hierarchy level."""
          with self._lock:
              self._lock_info[lock_id] = LockInfo(lock_id, name, level)
      
      def before_acquire(self, lock_id: int, lock_name: str = "") -> None:
          """Call before acquiring a lock. Detects potential deadlock."""
          if not self._enabled:
              return
          
          thread_id = threading.get_ident()
          
          with self._lock:
              held_locks = self._thread_locks.get(thread_id, [])
              
              # Check for hierarchy violation
              if lock_id in self._lock_info:
                  new_level = self._lock_info[lock_id].hierarchy_level
                  for held_id in held_locks:
                      if held_id in self._lock_info:
                          held_level = self._lock_info[held_id].hierarchy_level
                          if new_level <= held_level:
                              held_name = self._lock_info[held_id].name
                              logger.warning(
                                  f"Lock hierarchy violation: acquiring {lock_name} (L{new_level}) "
                                  f"while holding {held_name} (L{held_level})"
                              )
              
              # Check for potential cycle
              for held_id in held_locks:
                  # Record that held_id was held when acquiring lock_id
                  if lock_id in self._lock_order and held_id in self._lock_order[lock_id]:
                      # POTENTIAL DEADLOCK: previously lock_id was held when acquiring held_id
                      prev_trace = self._lock_order[lock_id][held_id]
                      curr_trace = ''.join(traceback.format_stack())
                      raise RuntimeError(
                          f"Potential deadlock detected!\n"
                          f"Thread {thread_id} holds lock {held_id} and wants lock {lock_id}\n"
                          f"But previously lock {lock_id} was held when acquiring {held_id}.\n"
                          f"Previous acquisition:\n{prev_trace}\n"
                          f"Current acquisition:\n{curr_trace}"
                      )
                  
                  # Record this ordering
                  self._lock_order[held_id][lock_id] = ''.join(traceback.format_stack())
              
              # Record that we're waiting
              self._lock_waiters[lock_id].add(thread_id)
      
      def after_acquire(self, lock_id: int) -> None:
          """Call after successfully acquiring a lock."""
          if not self._enabled:
              return
          
          thread_id = threading.get_ident()
          
          with self._lock:
              self._lock_waiters[lock_id].discard(thread_id)
              self._thread_locks[thread_id].append(lock_id)
              
              if lock_id in self._lock_info:
                  self._lock_info[lock_id].held_by = thread_id
                  self._lock_info[lock_id].acquisition_time = time.monotonic()
      
      def before_release(self, lock_id: int) -> None:
          """Call before releasing a lock."""
          if not self._enabled:
              return
          
          thread_id = threading.get_ident()
          
          with self._lock:
              if thread_id in self._thread_locks:
                  if lock_id in self._thread_locks[thread_id]:
                      self._thread_locks[thread_id].remove(lock_id)
              
              if lock_id in self._lock_info:
                  self._lock_info[lock_id].held_by = None
      
      def detect_deadlock(self) -> Optional[List[Tuple[int, int, int]]]:
          """
          Detect deadlock using wait-for graph cycle detection.
          Returns cycle as list of (thread_id, lock_held, lock_waiting) if found.
          """
          with self._lock:
              # Build wait-for graph: thread -> threads it's waiting for
              wait_for: Dict[int, Set[int]] = defaultdict(set)
              
              for lock_id, waiters in self._lock_waiters.items():
                  if lock_id in self._lock_info:
                      holder = self._lock_info[lock_id].held_by
                      if holder:
                          for waiter in waiters:
                              wait_for[waiter].add(holder)
              
              # DFS for cycle detection
              visited = set()
              rec_stack = set()
              path = []
              
              def dfs(thread_id: int) -> bool:
                  visited.add(thread_id)
                  rec_stack.add(thread_id)
                  path.append(thread_id)
                  
                  for waited_thread in wait_for.get(thread_id, []):
                      if waited_thread not in visited:
                          if dfs(waited_thread):
                              return True
                      elif waited_thread in rec_stack:
                          # Found cycle
                          cycle_start = path.index(waited_thread)
                          return True
                  
                  path.pop()
                  rec_stack.remove(thread_id)
                  return False
              
              for thread_id in wait_for:
                  if thread_id not in visited:
                      if dfs(thread_id):
                          return [(t, 0, 0) for t in path]  # Simplified
              
              return None
  
  # === HIERARCHICAL LOCK ===
  
  class HierarchicalLock:
      """
      Lock with hierarchy level to prevent deadlocks.
      Lower-level locks must be acquired before higher-level locks.
      """
      
      _detector = DeadlockDetector()
      _lock_counter = 0
      _counter_lock = threading.Lock()
      
      def __init__(self, name: str, level: int):
          self.name = name
          self.level = level
          self._lock = threading.RLock()
          
          with HierarchicalLock._counter_lock:
              HierarchicalLock._lock_counter += 1
              self._id = HierarchicalLock._lock_counter
          
          self._detector.register_lock(self._id, name, level)
      
      def acquire(self, blocking: bool = True, timeout: float = -1) -> bool:
          """Acquire the lock with deadlock detection."""
          self._detector.before_acquire(self._id, self.name)
          try:
              if timeout > 0:
                  result = self._lock.acquire(blocking=True, timeout=timeout)
              else:
                  result = self._lock.acquire(blocking=blocking)
              
              if result:
                  self._detector.after_acquire(self._id)
              return result
          except:
              # Clean up if acquisition fails
              self._detector.before_release(self._id)
              raise
      
      def release(self) -> None:
          """Release the lock."""
          self._detector.before_release(self._id)
          self._lock.release()
      
      def __enter__(self):
          self.acquire()
          return self
      
      def __exit__(self, exc_type, exc_val, exc_tb):
          self.release()
          return False
  
  # === SAFE RW LOCK ===
  
  class SafeRWLock:
      """
      Reader-writer lock that prevents upgrade deadlock.
      Does NOT allow upgrading from read to write lock.
      """
      
      def __init__(self, name: str = "rwlock"):
          self.name = name
          self._lock = threading.Lock()
          self._readers = 0
          self._writer_waiting = False
          self._writer_active = False
          self._read_ready = threading.Condition(self._lock)
          self._write_ready = threading.Condition(self._lock)
          self._thread_holds_read: Dict[int, int] = {}  # thread_id -> count
          self._thread_holds_write: Optional[int] = None
      
      @contextmanager
      def read_lock(self):
          """Acquire read lock. Cannot be upgraded to write."""
          thread_id = threading.get_ident()
          
          with self._lock:
              # Check for upgrade attempt
              if self._thread_holds_write == thread_id:
                  # Already have write lock - allow read
                  yield
                  return
              
              # Wait for writer to finish
              while self._writer_active or self._writer_waiting:
                  self._read_ready.wait()
              
              self._readers += 1
              self._thread_holds_read[thread_id] = \
                  self._thread_holds_read.get(thread_id, 0) + 1
          
          try:
              yield
          finally:
              with self._lock:
                  self._readers -= 1
                  self._thread_holds_read[thread_id] -= 1
                  if self._thread_holds_read[thread_id] == 0:
                      del self._thread_holds_read[thread_id]
                  
                  if self._readers == 0:
                      self._write_ready.notify()
      
      @contextmanager
      def write_lock(self):
          """Acquire write lock. Cannot upgrade from read."""
          thread_id = threading.get_ident()
          
          with self._lock:
              # Check for upgrade attempt (DEADLOCK)
              if thread_id in self._thread_holds_read:
                  raise RuntimeError(
                      f"Deadlock prevention: Cannot upgrade read lock to write lock. "
                      f"Thread {thread_id} holds read lock on {self.name}. "
                      f"Release read lock first, then acquire write lock."
                  )
              
              # Check for reentry
              if self._thread_holds_write == thread_id:
                  yield
                  return
              
              # Signal that writer is waiting
              self._writer_waiting = True
              
              # Wait for readers to finish
              while self._readers > 0 or self._writer_active:
                  self._write_ready.wait()
              
              self._writer_waiting = False
              self._writer_active = True
              self._thread_holds_write = thread_id
          
          try:
              yield
          finally:
              with self._lock:
                  self._writer_active = False
                  self._thread_holds_write = None
                  self._read_ready.notify_all()
                  self._write_ready.notify()
      
      def try_upgrade(self, timeout: float = 0) -> bool:
          """
          Try to upgrade from read to write lock safely.
          RELEASES read lock first, then acquires write.
          Returns False if cannot acquire write in time.
          
          WARNING: Data may change between read release and write acquire!
          """
          thread_id = threading.get_ident()
          
          with self._lock:
              if thread_id not in self._thread_holds_read:
                  return False  # Don't have read lock
              
              read_count = self._thread_holds_read[thread_id]
              
              # Release all read locks
              self._readers -= read_count
              del self._thread_holds_read[thread_id]
              
              if self._readers == 0:
                  self._write_ready.notify()
          
          # Now try to get write lock
          deadline = time.monotonic() + timeout if timeout > 0 else None
          
          with self._lock:
              self._writer_waiting = True
              
              while self._readers > 0 or self._writer_active:
                  if deadline:
                      remaining = deadline - time.monotonic()
                      if remaining <= 0:
                          # Timeout - restore read locks
                          self._writer_waiting = False
                          self._readers += read_count
                          self._thread_holds_read[thread_id] = read_count
                          return False
                      self._write_ready.wait(remaining)
                  else:
                      self._write_ready.wait()
              
              self._writer_waiting = False
              self._writer_active = True
              self._thread_holds_write = thread_id
          
          return True
  
  # === LOCK ORDER VALIDATOR ===
  
  class LockOrderValidator:
      """
      Static analysis tool to validate lock ordering across codebase.
      """
      
      def __init__(self):
          self._lock_definitions: Dict[str, int] = {}  # name -> hierarchy level
          self._acquisition_graph: Dict[str, Set[str]] = defaultdict(set)
      
      def define_lock(self, name: str, level: int) -> None:
          """Define a lock with its hierarchy level."""
          self._lock_definitions[name] = level
      
      def record_acquisition(self, held: str, acquiring: str) -> None:
          """Record that 'acquiring' was acquired while 'held' was held."""
          self._acquisition_graph[held].add(acquiring)
      
      def validate(self) -> List[str]:
          """Validate lock ordering and return violations."""
          violations = []
          
          # Check for cycles using DFS
          def find_cycles():
              visited = set()
              rec_stack = set()
              
              def dfs(lock: str, path: List[str]) -> List[str]:
                  if lock in rec_stack:
                      cycle_start = path.index(lock)
                      return path[cycle_start:] + [lock]
                  
                  if lock in visited:
                      return []
                  
                  visited.add(lock)
                  rec_stack.add(lock)
                  path.append(lock)
                  
                  for next_lock in self._acquisition_graph.get(lock, []):
                      cycle = dfs(next_lock, path)
                      if cycle:
                          return cycle
                  
                  path.pop()
                  rec_stack.remove(lock)
                  return []
              
              for start in self._acquisition_graph:
                  cycle = dfs(start, [])
                  if cycle:
                      violations.append(f"Cycle detected: {' -> '.join(cycle)}")
                      break
          
          find_cycles()
          
          # Check hierarchy violations
          for held, acquired_set in self._acquisition_graph.items():
              held_level = self._lock_definitions.get(held, 0)
              for acquired in acquired_set:
                  acquired_level = self._lock_definitions.get(acquired, 0)
                  if acquired_level <= held_level:
                      violations.append(
                          f"Hierarchy violation: {held} (L{held_level}) -> "
                          f"{acquired} (L{acquired_level})"
                      )
          
          return violations
  
  # === TRY-LOCK WITH BACKOFF ===
  
  class TryLockWithBackoff:
      """
      Acquire multiple locks without deadlock using try-lock and backoff.
      """
      
      def __init__(
          self, 
          max_retries: int = 10,
          base_backoff_ms: float = 1.0,
          max_backoff_ms: float = 100.0
      ):
          self.max_retries = max_retries
          self.base_backoff = base_backoff_ms / 1000
          self.max_backoff = max_backoff_ms / 1000
      
      @contextmanager
      def acquire_all(self, locks: List[threading.Lock]):
          """
          Acquire all locks without deadlock.
          Uses try-lock with exponential backoff.
          """
          import random
          
          acquired = []
          retries = 0
          
          while retries < self.max_retries:
              acquired = []
              success = True
              
              for lock in locks:
                  if lock.acquire(blocking=False):
                      acquired.append(lock)
                  else:
                      success = False
                      break
              
              if success:
                  break
              
              # Release all acquired locks
              for lock in acquired:
                  lock.release()
              acquired = []
              
              # Exponential backoff with jitter
              backoff = min(
                  self.base_backoff * (2 ** retries),
                  self.max_backoff
              )
              jitter = random.uniform(0, backoff)
              time.sleep(backoff + jitter)
              retries += 1
          
          if not acquired or len(acquired) != len(locks):
              raise TimeoutError(
                  f"Failed to acquire all locks after {self.max_retries} retries"
              )
          
          try:
              yield
          finally:
              for lock in reversed(acquired):
                  lock.release()
  
  # === CALLBACK SAFE PATTERN ===
  
  class CallbackSafeNotifier:
      """
      Safely notify callbacks without holding locks.
      Prevents callback-induced deadlocks.
      """
      
      def __init__(self):
          self._callbacks: List[Callable] = []
          self._lock = threading.Lock()
      
      def subscribe(self, callback: Callable) -> None:
          """Subscribe a callback."""
          with self._lock:
              self._callbacks.append(callback)
      
      def unsubscribe(self, callback: Callable) -> None:
          """Unsubscribe a callback."""
          with self._lock:
              if callback in self._callbacks:
                  self._callbacks.remove(callback)
      
      def notify(self, *args, **kwargs) -> None:
          """
          Notify all callbacks OUTSIDE the lock.
          Safe even if callbacks try to subscribe/unsubscribe.
          """
          # Copy list while holding lock
          with self._lock:
              callbacks = list(self._callbacks)
          
          # Notify outside lock
          for callback in callbacks:
              try:
                  callback(*args, **kwargs)
              except Exception as e:
                  logger.error(f"Callback error: {e}")
  
  # === TESTS ===
  
  def test_deadlock_detection():
      """Test deadlock detector catches potential deadlock."""
      detector = DeadlockDetector()
      
      lock_a = HierarchicalLock("A", level=1)
      lock_b = HierarchicalLock("B", level=2)
      
      # This should work (correct order)
      with lock_a:
          with lock_b:
              pass
      
      # This would be detected as potential deadlock if we tried B then A
      print("✓ Deadlock detection works")
  
  def test_rwlock_upgrade_prevention():
      """Test that RW lock prevents unsafe upgrade."""
      rwlock = SafeRWLock("test")
      
      with rwlock.read_lock():
          try:
              with rwlock.write_lock():
                  pass
              assert False, "Should have raised"
          except RuntimeError as e:
              assert "Cannot upgrade" in str(e)
      
      print("✓ RW lock upgrade prevention works")
  
  def test_try_lock_backoff():
      """Test try-lock with backoff acquires multiple locks."""
      locks = [threading.Lock() for _ in range(3)]
      locker = TryLockWithBackoff()
      
      results = []
      
      def worker(worker_id: int):
          with locker.acquire_all(locks):
              results.append(worker_id)
              time.sleep(0.01)
      
      threads = [
          threading.Thread(target=worker, args=(i,))
          for i in range(5)
      ]
      
      for t in threads:
          t.start()
      for t in threads:
          t.join()
      
      assert len(results) == 5, "All workers should complete"
      print("✓ Try-lock with backoff works")
  
  def test_callback_safe():
      """Test callback-safe notifier."""
      notifier = CallbackSafeNotifier()
      results = []
      
      def callback(value):
          results.append(value)
          # Try to unsubscribe during callback - should not deadlock
          notifier.unsubscribe(callback)
      
      notifier.subscribe(callback)
      notifier.notify("test")
      
      assert results == ["test"]
      print("✓ Callback-safe notifier works")
  
  if __name__ == "__main__":
      test_deadlock_detection()
      test_rwlock_upgrade_prevention()
      test_try_lock_backoff()
      test_callback_safe()
      print("\nAll tests passed!")

# LLM trap configurations
traps:
  - type: "transitive_deadlock"
    description: "A->B in one path, B->A in another, deadlock when concurrent"
    trigger: "Not analyzing all lock acquisition paths"
  
  - type: "rwlock_upgrade"
    description: "Thread holds read lock, tries to upgrade to write lock"
    trigger: "Upgrading lock while other readers exist"
  
  - type: "callback_deadlock"
    description: "Callback invoked under lock tries to acquire same lock"
    trigger: "Calling user code while holding locks"
  
  - type: "hidden_lock"
    description: "Library or framework acquires locks internally"
    trigger: "Not considering implicit locks in dependencies"
  
  - type: "signal_handler_deadlock"
    description: "Signal handler called while lock held, handler needs lock"
    trigger: "Using locks in signal handlers"
  
  - type: "database_deadlock"
    description: "Transactions access rows in different order"
    trigger: "No consistent row access ordering"

# Task generation template
instruction_template: |
  You are debugging a {{ scenario_type }} with intermittent deadlocks.
  The code is at {{ path }}.
  
  Hang frequency: {{ hang_frequency }} per week
  Threads involved: typically {{ thread_count }}
  
  Your task:
  {{ task_steps }}

# Test cases
fail_to_pass:
  - "test_transitive_deadlock_detection"
  - "test_rwlock_upgrade_prevention"
  - "test_callback_deadlock_detection"
  - "test_lock_hierarchy_validation"
  - "test_signal_handler_safety"

pass_to_pass:
  - "test_basic_locking"
  - "test_concurrent_readers"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: 
      - "database connection pool"
      - "resource manager"
      - "transaction processor"
      - "cache system"
      - "event dispatcher"
      - "worker pool"
  - name: path
    type: path
    generator: random_path
  - name: hang_frequency
    type: int
    min: 1
    max: 100
  - name: thread_count
    type: int
    min: 2
    max: 20
  - name: task_steps
    type: template
    value: |
      1. Analyze lock acquisition patterns across all code paths
      2. Build lock dependency graph
      3. Detect potential deadlock cycles
      4. Implement lock hierarchy with enforcement
      5. Fix reader-writer lock upgrade issues
      6. Handle callbacks safely (outside locks)
      7. Add runtime deadlock detection

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  deadlock_patterns:
    - transitive_via_different_paths
    - rwlock_upgrade_self_deadlock
    - callback_reentry
    - hidden_library_locks
    - signal_handler_locks

# Anti-patterns that LLMs commonly fail on
anti_patterns:
  llm_failure_modes:
    - "Applying userspace patterns to kernel-level problems"
    - "Missing memory ordering and barrier requirements"
    - "Ignoring NUMA topology effects on performance"
    - "Not considering scheduler behavior under load"
    - "Missing ABA problems in lock-free data structures"
    - "Overlooking signal handler safety restrictions"
    - "Assuming atomic operations are always sufficient"
    - "Missing file descriptor inheritance across fork/exec"
    - "Ignoring distributed consensus edge cases (Byzantine failures)"
    - "Not recognizing transitive lock dependencies across modules"
    - "Missing lock ordering violations in error handling paths"
    - "Ignoring callback-induced deadlocks from listener notifications"
    - "Not understanding rwlock upgrade semantics and self-deadlock"
    - "Missing priority inversion scenarios with RT scheduling"
    - "Ignoring mmap_lock ordering requirements with page faults"
    - "Not handling GFP_NOFS/GFP_NOIO requirements under locks"
    - "Missing RCU callback deadlocks with sleeping locks"
    - "Assuming spinlock vs mutex equivalence in all contexts"
    - "Not understanding lockdep annotations and cross-lock dependencies"
    - "Ignoring percpu lock and preemption interactions"
    - "Missing seqlock writer contention with long readers"
    - "Not handling distributed lock manager timeout races"
