id: "sys-mem-use-after-free-001"
version: "1.0.0"
category: "systems"
subcategory: "memory-management"

# SWE-bench_Pro style fields
problem_statement: |
  A systems application is experiencing intermittent crashes and data corruption. 
  Analysis suggests use-after-free bugs, but they're difficult to reproduce because 
  they depend on allocation patterns and timing.
  
  Hidden vulnerabilities:
  1. Dangling pointers after object destruction
  2. Iterator invalidation from container modifications
  3. Callbacks referencing freed objects
  4. Race conditions in memory reclamation
  5. Double-free causing heap corruption

requirements: |
  - Identify use-after-free locations
  - Implement safe object lifecycle management
  - Handle callback deregistration properly
  - Prevent iterator invalidation
  - Add runtime detection mechanisms

interface: |
  Input: Application code with memory management
  Output: Fixed code, safety mechanisms, detection tools
  Validation: No use-after-free under stress testing

# terminal-bench style fields
difficulty:
  estimated: "hard"
  time_range: [2700, 7200]
  command_steps: [30, 90]

# === QUALITY REQUIREMENTS ===
quality_requirements:
  minimum_time: "120-300 minutes for senior systems engineers with kernel contribution experience"
  expertise_level: "Principal systems engineer with memory safety, kernel exploitation, and formal verification expertise"
  validation_standard: "Must expose subtle memory lifecycle bugs including concurrent UAF and kernel slab UAF"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 10
  agent_specializations:
    - name: "kasan_expert"
      role: "Debug using Kernel Address Sanitizer"
      expertise: ["KASAN reports", "shadow memory", "stack UAF", "global UAF"]
    - name: "slab_uaf_specialist"
      role: "Debug kernel slab use-after-free vulnerabilities"
      expertise: ["SLUB freelist", "slab reuse timing", "cross-cache attacks", "object reallocation"]
    - name: "rcu_lifecycle_expert"
      role: "Debug RCU-protected object lifecycles"
      expertise: ["grace periods", "call_rcu", "rcu_read_lock scope", "synchronize_rcu"]
    - name: "refcount_debugger"
      role: "Debug reference counting issues"
      expertise: ["kref", "atomic refcount", "refcount_t saturation", "reference cycles"]
    - name: "callback_lifecycle_analyst"
      role: "Debug callback-related UAF"
      expertise: ["deferred callbacks", "workqueue UAF", "timer UAF", "completion UAF"]
    - name: "concurrent_uaf_expert"
      role: "Debug race condition UAF"
      expertise: ["race window analysis", "KCSAN", "data race detection", "ordering constraints"]
    - name: "exploit_analyst"
      role: "Analyze UAF exploitability and mitigations"
      expertise: ["heap spray", "object reallocation", "KASLR bypass", "SMAP/SMEP"]
    - name: "static_analyzer"
      role: "Apply static analysis for UAF detection"
      expertise: ["Coccinelle", "sparse", "Coverity", "CodeQL"]
    - name: "fuzzer_operator"
      role: "Use fuzzing to find UAF"
      expertise: ["syzkaller", "AFL", "coverage-guided", "corpus analysis"]
    - name: "safe_reclamation_designer"
      role: "Implement safe memory reclamation schemes"
      expertise: ["hazard pointers", "epoch-based reclamation", "QSBR", "type-stable memory"]
  cross_subsystem_chains:
    - "Object free → Slab reallocation → Different type → Type confusion → Code execution"
    - "Callback registration → Object free → Callback fire → UAF → Privilege escalation"
    - "Reference count decrement → Race → Double free → Heap corruption"
    - "RCU read side → Object freed → Grace period skip → UAF in callback"
  parallel_debugging_requirements:
    - "Correlated allocation/free traces with timestamps"
    - "Simultaneous KASAN and KCSAN analysis"
    - "Agent handoff for complex concurrent UAF debugging"

# === TRAP CONFIGURATION ===
trap_configuration:
  trap_count: "12+ deeply interacting traps across kernel/userspace/hardware boundaries"
  trap_categories:
    simple_uaf_traps:
      - "Object freed but pointer not nullified"
      - "Double free from different error paths"
      - "Use in destructor after partial free"
      - "Move semantic violation leaving dangling state"
    concurrent_uaf_traps:
      - "Race between free and use in different threads"
      - "Refcount check-then-decrement race"
      - "RCU callback scheduled but grace period not waited"
      - "Lock-free queue use-after-free"
    callback_uaf_traps:
      - "Timer callback to freed object"
      - "Workqueue callback with freed context"
      - "Completion callback to stack-freed object"
      - "Listener notification to freed subscriber"

# === NIGHTMARE_PLUS DIFFICULTY ===
difficulty_levels:
  nightmare_plus:
    estimated_time: [43200, 259200]  # 12-72 hours
    command_steps: [600, 2500]
    techniques_required: 18
    description: "Kernel CVE-level UAF requiring deep exploitation and mitigation knowledge"
    requirements:
      - "Requires understanding of kernel memory allocator internals"
      - "Must handle concurrent UAF with precise race analysis"
      - "Involves RCU and safe reclamation scheme design"
      - "Cross-platform behavior differences in allocator timing"
      - "Time estimate: 12-72 hours for kernel security researchers"
      - "Requires synthesizing memory safety, concurrency, and security knowledge"

# === KERNEL SUBSYSTEM REQUIREMENTS ===
kernel_subsystem_requirements:
  slab_allocator:
    - "SLUB freelist and object reuse timing"
    - "Per-CPU partial slab lists"
    - "Slab merging and cache aliasing"
    - "SLAB_TYPESAFE_BY_RCU semantics"
  rcu_subsystem:
    - "Classic RCU grace period mechanism"
    - "SRCU (Sleepable RCU) for blocking contexts"
    - "Tasks RCU for trampolines"
    - "call_rcu vs synchronize_rcu tradeoffs"
  reference_counting:
    - "kref and kref_put_lock"
    - "refcount_t with overflow protection"
    - "percpu_ref for scalable refcounting"
    - "Reference count vs RCU combined patterns"
  callback_mechanisms:
    - "Workqueue lifecycle management"
    - "Timer callback and hrtimer"
    - "Completion variables"
    - "Tasklet and softirq contexts"

# === HARDWARE INTERACTION ===
hardware_interaction:
  memory_hardware:
    - "Cache timing effects on UAF exploitation"
    - "Memory initialization on allocation"
    - "ECC effects on corrupted data"
    - "Memory controller reordering"
  cpu_features:
    - "SMAP/SMEP protection bypass"
    - "KASLR and address randomization"
    - "ARM PAC/BTI mitigations"
    - "Intel CET shadow stack effects"
  debug_hardware:
    - "Hardware watchpoints for UAF detection"
    - "Intel PT for execution tracing"
    - "ARM CoreSight for debug"
    - "JTAG debugging capabilities"

# === FORMAL VERIFICATION REQUIREMENTS ===
formal_verification_requirements:
  modeling_requirements:
    - "Model object lifecycle in TLA+"
    - "Express ownership invariants formally"
    - "Verify RCU grace period correctness"
    - "Model reference counting protocol"
  proof_obligations:
    - "Prove object not accessed after free"
    - "Verify callback deregistration before free"
    - "Establish refcount monotonicity to zero"
    - "Prove RCU read-side protection sufficiency"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research memory safety patterns and vulnerabilities"
    phase_2_creation: "Create task with subtle use-after-free scenarios"
    phase_3_amplification: "Add concurrent access and callback timing issues"
    phase_4_verification:
      description: "Validate task requires understanding of object lifecycles"
      criteria:
        - "Has at least 5 interacting system-level traps across subsystems"
        - "Has cascading failures across process, memory, and I/O subsystems"
        - "Requires knowledge of OS kernel internals and scheduler behavior"
        - "Would take experienced systems programmers 45+ minutes"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 3.5
      description: "Kernel-level debugging complexity requiring deep systems expertise"
      requirements:
        - "7+ interacting system-level traps across subsystems"
        - "Requires understanding of kernel memory management and scheduling"
        - "Time estimate: 120+ minutes for senior systems engineers"
        - "Cross-platform behavior differences (Linux vs BSD vs Windows)"
        - "Requires synthesizing concurrency, memory, distributed systems knowledge"
  
  generation_targets:
    minimum_difficulty: "45+ minutes, requires deep kernel internals and distributed systems expertise"
  
  complexity_levels:
    level_1_basic:
      description: "Simple dangling pointer after explicit free"
      elements: ["free_then_use", "null_after_free"]
    level_2_intermediate:
      description: "Iterator invalidation during container modification"
      elements: ["remove_during_iteration", "resize_invalidation"]
    level_3_advanced:
      description: "Callbacks to freed objects"
      elements: ["callback_dangling", "weak_reference_pattern"]
    level_4_expert:
      description: "Concurrent use-after-free races"
      elements: ["race_free_use", "reference_counting_race"]
    level_5_research:
      description: "Novel UAF in modern systems"
      elements: ["epoch_reclamation", "hazard_pointers"]

# === COMPREHENSIVE TOPIC UNIVERSE ===
topic_universe:
  # Use-After-Free Types (35+ topics)
  uaf_types:
    explicit_free:
      - "Direct free then dereference"
      - "Free in one function, use in another"
      - "Conditional free path not taken"
      - "Free in error handler, use in cleanup"
      - "Free in destructor, use in callback"
    
    container_invalidation:
      - "Vector resize invalidates iterators"
      - "Map insertion invalidates references"
      - "Deque insert/erase invalidation"
      - "List splice invalidation"
      - "Unordered container rehash"
    
    callback_issues:
      - "Callback stored, object freed"
      - "Event handler to freed subscriber"
      - "Timer callback to freed context"
      - "Signal handler to freed state"
    
    concurrent_uaf:
      - "Race between free and use"
      - "Reference count underflow"
      - "Lock-free reclamation bug"
      - "RCU grace period violation"
  
  # Memory Safety Mechanisms (40+ topics)
  safety_mechanisms:
    reference_counting:
      - "Strong references (shared_ptr)"
      - "Weak references (weak_ptr)"
      - "Intrusive reference counting"
      - "Atomic reference counting"
      - "Reference cycle detection"
      - "Reference counting in Rust (Rc, Arc)"
    
    smart_pointers:
      - "Unique ownership (unique_ptr)"
      - "Shared ownership (shared_ptr)"
      - "Observer pattern (weak_ptr)"
      - "Custom deleters"
      - "Enable_shared_from_this"
    
    garbage_collection:
      - "Mark and sweep"
      - "Copying collector"
      - "Generational GC"
      - "Concurrent GC"
      - "Reference counting GC"
    
    ownership_models:
      - "Rust ownership system"
      - "C++ RAII pattern"
      - "Swift ARC"
      - "Objective-C manual retain/release"
    
    safe_reclamation:
      - "Epoch-based reclamation (EBR)"
      - "Hazard pointers"
      - "Quiescent state reclamation"
      - "Read-copy-update (RCU)"
      - "Pass-the-buck scheme"
  
  # Detection Tools (25+ topics)
  detection_tools:
    static_analysis:
      - "Clang static analyzer"
      - "Coverity"
      - "PVS-Studio"
      - "Infer (Facebook)"
      - "Rust borrow checker"
    
    dynamic_analysis:
      - "AddressSanitizer (ASan)"
      - "MemorySanitizer (MSan)"
      - "Valgrind memcheck"
      - "Dr. Memory"
      - "Electric Fence"
    
    runtime_checks:
      - "Debug allocators"
      - "Guard pages"
      - "Canary values"
      - "Delayed free"
      - "Memory poisoning"
  
  # Language-Specific (30+ topics)
  language_specific:
    cpp:
      - "RAII idiom"
      - "Smart pointer hierarchy"
      - "Move semantics"
      - "Rule of zero/three/five"
      - "noexcept and exception safety"
    
    rust:
      - "Ownership rules"
      - "Borrowing and lifetimes"
      - "Interior mutability (RefCell)"
      - "Pin for self-referential"
      - "Unsafe blocks and raw pointers"
    
    c:
      - "Manual memory management"
      - "Defensive programming"
      - "Convention-based ownership"
      - "Cleanup attribute (GCC)"
    
    managed_languages:
      - "Java finalizers (deprecated)"
      - "C# disposable pattern"
      - "Go defer for cleanup"
      - "Python weak references"

# === BUG PATTERNS ===
bug_patterns:
  dangling_pointers:
    - pattern: "free_then_use"
      description: "Pointer used after memory freed"
      severity: "critical"
      detection: "ASan reports use-after-free"
      fix: "Set pointer to NULL after free, use smart pointers"
      code_example: |
        # Bug: use after free
        ptr = malloc(100)
        free(ptr)
        memcpy(ptr, data, 50)  # UAF!
        
        # Fix: nullify pointer
        ptr = malloc(100)
        free(ptr)
        ptr = NULL  # Prevents use
        if (ptr):
            memcpy(ptr, data, 50)  # Won't execute
    
    - pattern: "return_local_reference"
      description: "Returning reference to local variable"
      severity: "critical"
      detection: "Compiler warning, ASan"
      fix: "Return by value or allocate on heap"

  iterator_invalidation:
    - pattern: "erase_during_iteration"
      description: "Container erase invalidates iterator"
      severity: "high"
      detection: "Crash or undefined behavior"
      fix: "Use erase's return value or index-based iteration"
      code_example: |
        # Bug: invalidated iterator
        for item in list(container):
            if should_remove(item):
                container.remove(item)  # Invalidates!
        
        # Fix: iterate copy or use remove_if
        items_to_keep = [x for x in container if not should_remove(x)]
        container = items_to_keep
        
        # Or in C++:
        container.erase(
            std::remove_if(container.begin(), container.end(), should_remove),
            container.end()
        );
    
    - pattern: "resize_while_iterating"
      description: "Container resize invalidates all iterators"
      severity: "high"
      detection: "Crash on iterator access"
      fix: "Pre-reserve capacity or collect changes"

  callback_dangling:
    - pattern: "stored_callback_uaf"
      description: "Callback invoked after object destroyed"
      severity: "critical"
      detection: "Crash in callback, corrupted state"
      fix: "Deregister callbacks in destructor, use weak references"
      code_example: |
        # Bug: callback to freed object
        class Observer:
            def __init__(self, subject):
                subject.subscribe(self.on_event)
            # No unsubscribe in __del__!
        
        # Fix: weak reference callback
        class Observer:
            def __init__(self, subject):
                self._subject = subject
                subject.subscribe(weakref.ref(self), self._on_event_weak)
            
            def __del__(self):
                if self._subject:
                    self._subject.unsubscribe(self)
    
    - pattern: "timer_callback_uaf"
      description: "Timer fires after context freed"
      severity: "critical"
      detection: "Crash in timer callback"
      fix: "Cancel timer before freeing context"

  concurrent_uaf:
    - pattern: "race_free_use"
      description: "Thread A frees while Thread B uses"
      severity: "critical"
      detection: "ThreadSanitizer + ASan"
      fix: "Proper synchronization or safe reclamation"
    
    - pattern: "refcount_race"
      description: "Check refcount then use not atomic"
      severity: "critical"
      detection: "Sporadic crashes under load"
      fix: "Atomic refcount with acquire/release"

  double_free:
    - pattern: "double_free"
      description: "Same memory freed twice"
      severity: "critical"
      detection: "Allocator assertion, heap corruption"
      fix: "NULL after free, unique ownership"
      code_example: |
        # Bug: double free
        free(ptr)
        # ... later
        free(ptr)  # Double free!
        
        # Fix: null after free
        free(ptr)
        ptr = NULL
        # ... later
        free(ptr)  # Safe: free(NULL) is no-op

# === EDGE CASES ===
edge_cases:
  lifecycle_edge_cases:
    - "Object destroyed during own method call"
    - "Self-deletion in callback"
    - "Destructor throws exception"
    - "Destructor called twice"
    - "Move from then use"
    - "Resurrection of destroyed object"

  timing_edge_cases:
    - "Use-after-free only under memory pressure"
    - "UAF depends on allocator reuse timing"
    - "UAF only with specific allocation sizes"
    - "UAF race window is nanoseconds"
    - "UAF manifests after long delay"

  container_edge_cases:
    - "Single element container"
    - "Empty container iteration"
    - "Container at capacity"
    - "Nested container modification"
    - "Container moved from while iterating"

  callback_edge_cases:
    - "Callback deregisters itself"
    - "Callback deregisters other callbacks"
    - "Recursive callback invocation"
    - "Callback during object construction"
    - "Callback during object destruction"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  concurrency:
    multi_threaded:
      multiplier: 2.0
      description: "UAF involves concurrent access"
      considerations:
        - "Thread synchronization"
        - "Safe reclamation schemes"
        - "Memory ordering"
    
    lock_free:
      multiplier: 2.5
      description: "UAF in lock-free data structure"
      considerations:
        - "Hazard pointers"
        - "Epoch-based reclamation"
        - "ABA problem interaction"

  system_complexity:
    callbacks_events:
      multiplier: 1.5
      description: "UAF involves callbacks or events"
      considerations:
        - "Subscription lifecycle"
        - "Weak references"
        - "Deregistration"
    
    graph_structures:
      multiplier: 1.8
      description: "UAF in graph or cyclic structures"
      considerations:
        - "Cycle detection"
        - "Weak references for back-edges"
        - "Destruction ordering"

# === SCENARIO TEMPLATES ===
scenario_templates:
  simple_dangling:
    description: "Basic use-after-free"
    setup: |
      - Object freed explicitly
      - Pointer still used elsewhere
      - Random crash on dereference
    symptoms: |
      - Intermittent crashes
      - Corrupted data
      - ASan reports UAF
    root_cause: "Pointer not nullified after free"
    fix: |
      - Use smart pointers
      - Null after free
      - Clear all references

  iterator_invalidation:
    description: "Container modification during iteration"
    setup: |
      - Loop iterates over container
      - Loop body removes elements
      - Iterator becomes invalid
    symptoms: |
      - Crash during iteration
      - Skipped elements
      - Infinite loop
    root_cause: "Erase invalidates iterator"
    fix: |
      - Use erase return value
      - Iterate copy
      - Use remove_if idiom

  callback_dangling:
    description: "Callback to destroyed object"
    setup: |
      - Object subscribes to events
      - Object destroyed
      - Event fires, calls callback
    symptoms: |
      - Crash in callback
      - Corrupted subscriber data
    root_cause: "No unsubscribe in destructor"
    fix: |
      - Unsubscribe in destructor
      - Use weak references
      - Check validity before call

  concurrent_uaf:
    description: "Race between free and access"
    setup: |
      - Thread A checks pointer valid
      - Thread B frees pointer
      - Thread A dereferences (UAF)
    symptoms: |
      - Rare crashes under load
      - Hard to reproduce
    root_cause: "No synchronization on lifecycle"
    fix: |
      - Reference counting
      - Read-copy-update
      - Epoch-based reclamation

# === REFERENCE SOLUTION ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Comprehensive use-after-free prevention and detection.
  Implements reference counting, weak references, and safe patterns.
  """
  import weakref
  import threading
  from typing import TypeVar, Generic, Optional, Callable, Set, Dict, List, Any
  from dataclasses import dataclass
  from contextlib import contextmanager
  from abc import ABC, abstractmethod
  import logging
  import gc
  
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger(__name__)
  
  T = TypeVar('T')
  
  # === REFERENCE COUNTED WRAPPER ===
  
  class RefCounted(Generic[T]):
      """
      Reference-counted wrapper to prevent use-after-free.
      Object is freed only when reference count reaches zero.
      """
      
      def __init__(self, value: T):
          self._value = value
          self._ref_count = 1
          self._lock = threading.Lock()
          self._freed = False
      
      def acquire(self) -> Optional[T]:
          """Acquire a reference, returns value or None if freed."""
          with self._lock:
              if self._freed:
                  return None
              self._ref_count += 1
              return self._value
      
      def release(self) -> None:
          """Release a reference."""
          should_cleanup = False
          with self._lock:
              self._ref_count -= 1
              if self._ref_count <= 0 and not self._freed:
                  self._freed = True
                  should_cleanup = True
          
          if should_cleanup:
              self._cleanup()
      
      def _cleanup(self) -> None:
          """Clean up the wrapped value."""
          if hasattr(self._value, 'close'):
              try:
                  self._value.close()
              except Exception as e:
                  logger.error(f"Cleanup error: {e}")
          self._value = None
      
      @contextmanager
      def use(self):
          """Context manager for safe value access."""
          value = self.acquire()
          if value is None:
              raise RuntimeError("Attempted to use freed object")
          try:
              yield value
          finally:
              self.release()
      
      def is_alive(self) -> bool:
          """Check if object is still valid."""
          with self._lock:
              return not self._freed
  
  # === SAFE POINTER ===
  
  class SafePointer(Generic[T]):
      """
      Safe pointer using weak references.
      Returns None if target is freed, preventing use-after-free.
      """
      
      def __init__(self, target: T, weak: bool = True):
          if weak:
              self._ref: weakref.ref = weakref.ref(target)
              self._strong = None
          else:
              self._ref = None
              self._strong = target
      
      def get(self) -> Optional[T]:
          """Get the target object, or None if it's been collected."""
          if self._ref is not None:
              return self._ref()
          return self._strong
      
      def is_valid(self) -> bool:
          """Check if the pointer is still valid."""
          return self.get() is not None
      
      def __bool__(self) -> bool:
          return self.is_valid()
      
      @contextmanager
      def access(self):
          """Safely access the target."""
          target = self.get()
          if target is None:
              raise RuntimeError("Target has been freed")
          yield target
  
  # === CALLBACK REGISTRY ===
  
  class CallbackRegistry:
      """
      Safe callback registry that prevents dangling callback invocations.
      Uses weak references to automatically clean up callbacks to freed objects.
      """
      
      def __init__(self):
          self._callbacks: Dict[str, List[weakref.ref]] = {}
          self._lock = threading.Lock()
      
      def register(
          self, 
          event: str, 
          callback: Callable,
          weak: bool = True
      ) -> int:
          """
          Register a callback for an event.
          Returns registration ID for later unregistration.
          """
          with self._lock:
              if event not in self._callbacks:
                  self._callbacks[event] = []
              
              if weak:
                  ref = weakref.ref(callback)
              else:
                  # Store strong reference (be careful!)
                  ref = lambda cb=callback: cb
              
              self._callbacks[event].append(ref)
              return id(ref)
      
      def unregister(self, event: str, callback: Callable) -> bool:
          """Unregister a callback."""
          with self._lock:
              if event not in self._callbacks:
                  return False
              
              # Find and remove the callback
              for i, ref in enumerate(self._callbacks[event]):
                  if ref() is callback:
                      del self._callbacks[event][i]
                      return True
              
              return False
      
      def unregister_all_for_object(self, obj: Any) -> int:
          """Unregister all callbacks that are methods of obj."""
          count = 0
          with self._lock:
              for event in self._callbacks:
                  to_remove = []
                  for i, ref in enumerate(self._callbacks[event]):
                      cb = ref()
                      if cb is not None:
                          # Check if callback is a bound method of obj
                          if hasattr(cb, '__self__') and cb.__self__ is obj:
                              to_remove.append(i)
                  
                  for i in reversed(to_remove):
                      del self._callbacks[event][i]
                      count += 1
          return count
      
      def fire(self, event: str, *args, **kwargs) -> int:
          """
          Fire an event, safely skipping freed callbacks.
          Returns number of callbacks invoked.
          """
          # Get callbacks snapshot
          with self._lock:
              if event not in self._callbacks:
                  return 0
              callbacks = list(self._callbacks[event])
          
          # Clean up dead references
          dead = []
          invoked = 0
          
          # Invoke outside lock
          for i, ref in enumerate(callbacks):
              callback = ref()
              if callback is not None:
                  try:
                      callback(*args, **kwargs)
                      invoked += 1
                  except Exception as e:
                      logger.error(f"Callback error for {event}: {e}")
              else:
                  dead.append(i)
          
          # Remove dead references
          if dead:
              with self._lock:
                  if event in self._callbacks:
                      for i in reversed(dead):
                          if i < len(self._callbacks[event]):
                              del self._callbacks[event][i]
          
          return invoked
  
  # === SAFE ITERATOR ===
  
  class SafeIterator(Generic[T]):
      """
      Iterator that detects container modification.
      Raises error if container modified during iteration.
      """
      
      def __init__(self, container: List[T], version_getter: Callable[[], int]):
          self._container = container
          self._version_getter = version_getter
          self._initial_version = version_getter()
          self._index = 0
      
      def __iter__(self):
          return self
      
      def __next__(self) -> T:
          current_version = self._version_getter()
          if current_version != self._initial_version:
              raise RuntimeError(
                  "Container modified during iteration - iterator invalidated"
              )
          
          if self._index >= len(self._container):
              raise StopIteration
          
          value = self._container[self._index]
          self._index += 1
          return value
  
  class SafeContainer(Generic[T]):
      """
      Container with safe iteration and modification tracking.
      """
      
      def __init__(self):
          self._items: List[T] = []
          self._version = 0
          self._lock = threading.RLock()
      
      def add(self, item: T) -> None:
          with self._lock:
              self._items.append(item)
              self._version += 1
      
      def remove(self, item: T) -> bool:
          with self._lock:
              try:
                  self._items.remove(item)
                  self._version += 1
                  return True
              except ValueError:
                  return False
      
      def __iter__(self) -> SafeIterator[T]:
          """Returns iterator over a copy to prevent invalidation."""
          with self._lock:
              return iter(list(self._items))
      
      def safe_iterate(self) -> SafeIterator[T]:
          """Returns iterator that detects modification."""
          with self._lock:
              return SafeIterator(self._items, lambda: self._version)
      
      def remove_if(self, predicate: Callable[[T], bool]) -> List[T]:
          """
          Safely remove items matching predicate.
          Returns list of removed items.
          """
          with self._lock:
              removed = [item for item in self._items if predicate(item)]
              self._items = [item for item in self._items if not predicate(item)]
              if removed:
                  self._version += 1
              return removed
      
      def __len__(self) -> int:
          with self._lock:
              return len(self._items)
  
  # === USE-AFTER-FREE DETECTOR ===
  
  class UseAfterFreeDetector:
      """
      Runtime detector for use-after-free bugs.
      Poisons freed memory and tracks allocation lifecycle.
      """
      
      POISON_VALUE = "FREED_OBJECT"
      
      def __init__(self):
          self._tracked: Dict[int, dict] = {}
          self._freed: Set[int] = set()
          self._lock = threading.Lock()
      
      def track(self, obj: object) -> None:
          """Track a new object."""
          obj_id = id(obj)
          with self._lock:
              self._tracked[obj_id] = {
                  'type': type(obj).__name__,
                  'freed': False
              }
      
      def mark_freed(self, obj: object) -> None:
          """Mark object as freed and poison it."""
          obj_id = id(obj)
          with self._lock:
              if obj_id in self._tracked:
                  self._tracked[obj_id]['freed'] = True
                  self._freed.add(obj_id)
          
          # Poison object attributes
          if hasattr(obj, '__dict__'):
              for key in list(obj.__dict__.keys()):
                  try:
                      obj.__dict__[key] = self.POISON_VALUE
                  except Exception:
                      pass
      
      def check(self, obj: object) -> bool:
          """
          Check if object was freed.
          Returns True if safe to use, raises if freed.
          """
          obj_id = id(obj)
          with self._lock:
              if obj_id in self._freed:
                  raise RuntimeError(
                      f"Use-after-free detected: {self._tracked[obj_id]['type']}"
                  )
          return True
      
      def get_status(self, obj: object) -> str:
          """Get tracking status of object."""
          obj_id = id(obj)
          with self._lock:
              if obj_id not in self._tracked:
                  return "untracked"
              if obj_id in self._freed:
                  return "freed"
              return "alive"
  
  # === DISPOSABLE PATTERN ===
  
  class Disposable(ABC):
      """
      Base class for objects that need explicit cleanup.
      Tracks disposal state to prevent use-after-free.
      """
      
      def __init__(self):
          self._disposed = False
          self._dispose_lock = threading.Lock()
      
      @property
      def is_disposed(self) -> bool:
          return self._disposed
      
      def dispose(self) -> None:
          """Dispose of the object."""
          with self._dispose_lock:
              if self._disposed:
                  return
              self._disposed = True
          
          self._do_dispose()
      
      @abstractmethod
      def _do_dispose(self) -> None:
          """Override to implement cleanup logic."""
          pass
      
      def _check_disposed(self) -> None:
          """Call at start of methods to prevent use after dispose."""
          if self._disposed:
              raise RuntimeError(f"{type(self).__name__} has been disposed")
      
      def __enter__(self):
          return self
      
      def __exit__(self, exc_type, exc_val, exc_tb):
          self.dispose()
          return False
  
  # === SUBSCRIPTION WITH AUTO-CLEANUP ===
  
  class Subscription:
      """
      Represents a subscription that auto-cleans on owner destruction.
      """
      
      def __init__(
          self, 
          owner: object,
          unsubscribe_func: Callable[[], None]
      ):
          self._owner_ref = weakref.ref(owner, self._on_owner_collected)
          self._unsubscribe = unsubscribe_func
          self._active = True
          self._lock = threading.Lock()
      
      def _on_owner_collected(self, ref: weakref.ref) -> None:
          """Called when owner is garbage collected."""
          self.unsubscribe()
      
      def unsubscribe(self) -> None:
          """Manually unsubscribe."""
          with self._lock:
              if not self._active:
                  return
              self._active = False
          
          try:
              self._unsubscribe()
          except Exception as e:
              logger.error(f"Unsubscribe error: {e}")
      
      @property
      def is_active(self) -> bool:
          with self._lock:
              return self._active
  
  # === TESTS ===
  
  def test_ref_counted():
      """Test reference counted wrapper."""
      class Resource:
          def __init__(self, name: str):
              self.name = name
              self.closed = False
          def close(self):
              self.closed = True
      
      rc = RefCounted(Resource("test"))
      
      # Acquire multiple references
      with rc.use() as r1:
          assert r1.name == "test"
          with rc.use() as r2:
              assert r2.name == "test"
      
      # Release all references
      rc.release()
      
      # Should be freed now
      assert not rc.is_alive()
      
      # Should raise on use after free
      try:
          with rc.use():
              pass
          assert False, "Should have raised"
      except RuntimeError:
          pass
      
      print("✓ Reference counting works")
  
  def test_safe_pointer():
      """Test safe pointer prevents UAF."""
      class Target:
          def __init__(self):
              self.value = 42
      
      target = Target()
      ptr = SafePointer(target)
      
      assert ptr.is_valid()
      assert ptr.get().value == 42
      
      # Delete target
      del target
      gc.collect()
      
      # Pointer should be invalid now
      assert not ptr.is_valid()
      assert ptr.get() is None
      
      print("✓ Safe pointer works")
  
  def test_callback_registry():
      """Test callback registry with weak references."""
      registry = CallbackRegistry()
      results = []
      
      class Handler:
          def __init__(self, name: str):
              self.name = name
          def handle(self, data):
              results.append((self.name, data))
      
      handler1 = Handler("h1")
      handler2 = Handler("h2")
      
      registry.register("event", handler1.handle)
      registry.register("event", handler2.handle)
      
      # Fire event
      registry.fire("event", "data1")
      assert len(results) == 2
      
      # Delete handler1
      del handler1
      gc.collect()
      
      # Fire again - should only invoke handler2
      results.clear()
      registry.fire("event", "data2")
      assert len(results) == 1
      assert results[0][0] == "h2"
      
      print("✓ Callback registry with weak refs works")
  
  def test_safe_container():
      """Test safe container iteration."""
      container = SafeContainer[int]()
      for i in range(5):
          container.add(i)
      
      # Safe iteration over copy
      collected = []
      for item in container:
          collected.append(item)
          # Modification doesn't affect iteration
          if item == 2:
              container.add(100)
      
      assert collected == [0, 1, 2, 3, 4]
      assert len(container) == 6
      
      # Remove with predicate
      removed = container.remove_if(lambda x: x > 3)
      assert 100 in removed
      assert 4 in removed
      
      print("✓ Safe container works")
  
  if __name__ == "__main__":
      test_ref_counted()
      test_safe_pointer()
      test_callback_registry()
      test_safe_container()
      print("\nAll tests passed!")

# LLM trap configurations
traps:
  - type: "dangling_pointer"
    description: "Pointer used after object freed"
    trigger: "Not nullifying pointers after free"
  
  - type: "iterator_invalidation"
    description: "Container modified while iterating"
    trigger: "Removing elements during iteration"
  
  - type: "callback_dangling"
    description: "Callback invoked on freed object"
    trigger: "Not deregistering callbacks on destruction"
  
  - type: "concurrent_free"
    description: "Object freed while another thread uses it"
    trigger: "No reference counting or synchronization"
  
  - type: "double_free"
    description: "Same memory freed twice"
    trigger: "No tracking of freed status"

# Task generation template
instruction_template: |
  You are debugging a {{ scenario_type }} with use-after-free bugs.
  The code is at {{ path }}.
  
  Crash rate: {{ crash_rate }} crashes per day
  Corruption events: {{ corruption_events }} per day
  
  Your task:
  {{ task_steps }}

# Test cases
fail_to_pass:
  - "test_no_use_after_free"
  - "test_callback_deregistration"
  - "test_iterator_invalidation_detection"
  - "test_concurrent_access_safety"
  - "test_no_double_free"

pass_to_pass:
  - "test_ref_counted_basic"
  - "test_safe_container"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: 
      - "network server"
      - "plugin system"
      - "event dispatcher"
      - "cache manager"
      - "object pool"
      - "resource manager"
  - name: path
    type: path
    generator: random_path
  - name: crash_rate
    type: int
    min: 1
    max: 500
  - name: corruption_events
    type: int
    min: 1
    max: 200
  - name: task_steps
    type: template
    value: |
      1. Identify use-after-free locations using ASan
      2. Implement reference counting where needed
      3. Add safe callback management with weak refs
      4. Prevent iterator invalidation
      5. Add runtime UAF detection
      6. Handle concurrent access safely
      7. Verify with stress testing

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  uaf_patterns:
    - dangling_after_delete
    - iterator_during_modification
    - callback_to_freed
    - concurrent_free_and_use
    - double_free

# Anti-patterns that LLMs commonly fail on
anti_patterns:
  llm_failure_modes:
    - "Applying userspace patterns to kernel-level problems"
    - "Missing memory ordering and barrier requirements"
    - "Ignoring NUMA topology effects on performance"
    - "Not considering scheduler behavior under load"
    - "Missing ABA problems in lock-free data structures"
    - "Overlooking signal handler safety restrictions"
    - "Assuming atomic operations are always sufficient"
    - "Missing file descriptor inheritance across fork/exec"
    - "Ignoring distributed consensus edge cases (Byzantine failures)"
    - "Not nullifying pointers after free"
    - "Missing callback deregistration in destructor"
    - "Not waiting for RCU grace period before free"
    - "Refcount check-then-decrement race"
    - "Iterator invalidation during container modification"
    - "Timer callback to stack-allocated object"
    - "Workqueue item accessing freed parent context"
    - "Completion callback to freed waiter"
    - "Lock-free queue node reuse without safe reclamation"
    - "SLAB_TYPESAFE_BY_RCU misuse"
    - "kref_put without proper synchronization"
    - "Dangling callback registration after module unload"
    - "Missing memory barrier before publishing freed indicator"
