id: "sys-os-zombie-process-001"
version: "1.0.0"
category: "systems"
subcategory: "operating-systems"

# SWE-bench_Pro style fields
problem_statement: |
  A long-running server application is accumulating zombie processes over time. 
  The process table is filling up, and eventually the system cannot spawn new 
  processes. The main process forks children but fails to properly reap them.
  
  Hidden complications:
  1. Some children are adopted by init but still linger
  2. Signal handlers interfere with wait() calls
  3. Double-fork daemon pattern implemented incorrectly
  4. SIGCHLD handling has race conditions
  5. Multi-threaded parent complicates reaping

requirements: |
  - Identify why zombie processes are being created
  - Implement proper child process reaping
  - Handle SIGCHLD correctly without race conditions
  - Clean up existing zombie processes
  - Implement robust daemon forking pattern

interface: |
  Input: Process management code, PID of parent process
  Output: Clean process tree, no zombies, proper child handling
  Monitoring: Track process count before/after cleanup

# terminal-bench style fields
difficulty:
  estimated: "hard"
  time_range: [1800, 5400]
  command_steps: [25, 75]

# === QUALITY REQUIREMENTS ===
quality_requirements:
  minimum_time: "120-300 minutes for senior systems engineers with kernel contribution experience"
  expertise_level: "Principal systems engineer with process management, signal handling, and daemon design expertise"
  validation_standard: "Must expose subtle process lifecycle bugs including signal races and daemon pattern errors"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 9
  agent_specializations:
    - name: "process_lifecycle_expert"
      role: "Debug process creation and termination"
      expertise: ["fork semantics", "exit codes", "process states", "task_struct"]
    - name: "signal_handler_specialist"
      role: "Debug SIGCHLD handling and signal safety"
      expertise: ["sigaction", "SA_NOCLDWAIT", "async-signal-safe", "signal coalescing"]
    - name: "wait_syscall_debugger"
      role: "Debug wait family syscalls"
      expertise: ["waitpid", "waitid", "WNOHANG", "WUNTRACED"]
    - name: "daemon_pattern_expert"
      role: "Debug daemon double-fork pattern"
      expertise: ["setsid", "session leader", "controlling terminal", "process groups"]
    - name: "init_system_analyst"
      role: "Debug init system and subreaper behavior"
      expertise: ["PID 1", "PR_SET_CHILD_SUBREAPER", "systemd", "orphan adoption"]
    - name: "container_process_expert"
      role: "Debug process management in containers"
      expertise: ["PID namespace", "tini/dumb-init", "container init", "signal forwarding"]
    - name: "thread_fork_specialist"
      role: "Debug fork in multi-threaded processes"
      expertise: ["pthread_atfork", "async-signal-safety after fork", "single-threaded child"]
    - name: "cgroup_process_analyst"
      role: "Debug cgroup process limits"
      expertise: ["pids.max", "cgroup freeze", "process accounting", "zombie effects"]
    - name: "kernel_process_tracer"
      role: "Trace kernel process operations"
      expertise: ["ftrace", "eBPF", "process events", "task state transitions"]
  cross_subsystem_chains:
    - "Fork → Child exits → SIGCHLD coalesced → Multiple zombies → Process table full"
    - "Double-fork → Intermediate not waited → Zombie → Parent returns"
    - "Signal handler → wait() race with main → ECHILD → Missing reap"
    - "Multi-threaded fork → Deadlock → Child stuck → Zombie when killed"
  parallel_debugging_requirements:
    - "Correlated process state traces with parent-child relationships"
    - "Simultaneous signal delivery and wait() analysis"
    - "Agent handoff for complex process group debugging"

# === TRAP CONFIGURATION ===
trap_configuration:
  trap_count: "12+ deeply interacting traps across kernel/userspace/hardware boundaries"
  trap_categories:
    reaping_traps:
      - "Fork without corresponding wait()"
      - "SIGCHLD handler races with main wait()"
      - "SA_NOCLDWAIT misunderstanding"
      - "EINTR not handled in wait loop"
    daemon_traps:
      - "Double-fork intermediate not waited"
      - "setsid() called in wrong process"
      - "Controlling terminal not properly released"
      - "Session leader becoming zombie"
    signal_traps:
      - "Multiple SIGCHLD coalesced losing children"
      - "Signal handler not async-signal-safe"
      - "Signal mask not restored after handler"
      - "Signal delivered to wrong thread"

# === NIGHTMARE_PLUS DIFFICULTY ===
difficulty_levels:
  nightmare_plus:
    estimated_time: [43200, 259200]  # 12-72 hours
    command_steps: [600, 2500]
    techniques_required: 18
    description: "Production incident-level difficulty requiring deep process management knowledge"
    requirements:
      - "Requires understanding of kernel process scheduler internals"
      - "Must handle multi-threaded fork and signal edge cases"
      - "Involves container PID namespace complications"
      - "Cross-platform behavior differences (Linux vs BSD)"
      - "Time estimate: 12-72 hours for systems reliability engineers"
      - "Requires synthesizing process, signal, and namespace knowledge"

# === KERNEL SUBSYSTEM REQUIREMENTS ===
kernel_subsystem_requirements:
  process_management:
    - "task_struct and process states"
    - "do_exit() and exit_notify()"
    - "wait_task_zombie() implementation"
    - "Process reaping and resource release"
  signal_subsystem:
    - "Signal delivery mechanism"
    - "SIGCHLD generation and delivery"
    - "Signal queuing (POSIX.1b)"
    - "Thread signal handling"
  process_groups:
    - "Session and process group leadership"
    - "Orphan process group handling"
    - "Controlling terminal management"
    - "Job control signals"
  namespaces:
    - "PID namespace hierarchy"
    - "Orphan reparenting in namespaces"
    - "init process in namespace"
    - "Namespace exit cleanup"

# === HARDWARE INTERACTION ===
hardware_interaction:
  processor_effects:
    - "Context switch overhead with many zombies"
    - "Process table kernel memory usage"
    - "Scheduler effects with process table full"
    - "TLB effects of process termination"
  memory_effects:
    - "Zombie memory footprint (task_struct only)"
    - "Memory pressure effects on fork"
    - "OOM killer interaction with zombies"
    - "Page table cleanup on exit"
  io_effects:
    - "File descriptor cleanup on exit"
    - "Pending I/O completion on exit"
    - "Async I/O and zombie timing"
    - "Network socket cleanup"

# === FORMAL VERIFICATION REQUIREMENTS ===
formal_verification_requirements:
  modeling_requirements:
    - "Model process lifecycle in TLA+"
    - "Express reaping requirements formally"
    - "Verify signal handler correctness"
    - "Model daemon double-fork protocol"
  proof_obligations:
    - "Prove all children eventually reaped"
    - "Verify no zombie accumulation"
    - "Establish signal handler atomicity"
    - "Prove daemon pattern leaves no zombies"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research Unix process model and signal handling"
    phase_2_creation: "Create task with subtle zombie accumulation scenarios"
    phase_3_amplification: "Add signal race conditions and multi-threading complications"
    phase_4_verification:
      description: "Validate task requires understanding of process lifecycle"
      criteria:
        - "Has at least 5 interacting system-level traps across subsystems"
        - "Has cascading failures across process, memory, and I/O subsystems"
        - "Requires knowledge of OS kernel internals and scheduler behavior"
        - "Would take experienced systems programmers 45+ minutes"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 3.5
      description: "Kernel-level debugging complexity requiring deep systems expertise"
      requirements:
        - "7+ interacting system-level traps across subsystems"
        - "Requires understanding of kernel memory management and scheduling"
        - "Time estimate: 120+ minutes for senior systems engineers"
        - "Cross-platform behavior differences (Linux vs BSD vs Windows)"
        - "Requires synthesizing concurrency, memory, distributed systems knowledge"
  
  generation_targets:
    minimum_difficulty: "45+ minutes, requires deep kernel internals and distributed systems expertise"
  
  complexity_levels:
    level_1_basic:
      description: "Simple fork without wait"
      elements: ["fork_no_wait", "missing_waitpid"]
    level_2_intermediate:
      description: "Signal handler race conditions"
      elements: ["sigchld_race", "eintr_not_handled"]
    level_3_advanced:
      description: "Double-fork daemon issues"
      elements: ["daemon_pattern_bug", "session_leader_zombie"]
    level_4_expert:
      description: "Multi-threaded process management"
      elements: ["thread_fork_issues", "signal_in_multithread"]
    level_5_research:
      description: "Complex process group scenarios"
      elements: ["process_group_orphan", "controlling_terminal_issues"]

# === COMPREHENSIVE TOPIC UNIVERSE ===
topic_universe:
  # Process Lifecycle (35+ topics)
  process_lifecycle:
    creation:
      - "fork() system call"
      - "vfork() for exec"
      - "clone() with flags"
      - "posix_spawn()"
      - "Copy-on-write semantics"
      - "PID allocation"
      - "Process descriptor creation"
    
    states:
      - "Running (R)"
      - "Sleeping (S, D)"
      - "Stopped (T)"
      - "Zombie (Z)"
      - "Dead (X)"
      - "Tracing stop"
      - "Wake kill"
    
    termination:
      - "exit() and _exit()"
      - "Exit status encoding"
      - "WIFEXITED, WIFSIGNALED"
      - "WEXITSTATUS, WTERMSIG"
      - "Core dump generation"
    
    reaping:
      - "wait() system call"
      - "waitpid() with options"
      - "waitid() extended info"
      - "wait3()/wait4() with rusage"
      - "WNOHANG non-blocking"
      - "WUNTRACED for stopped"
      - "WCONTINUED for continued"
  
  # Zombie Processes (30+ topics)
  zombie_processes:
    causes:
      - "Fork without wait"
      - "Parent exits before wait"
      - "Signal handler not reaping"
      - "SIGCHLD ignored incorrectly"
      - "Race between exit and wait"
      - "Multi-threaded wait confusion"
    
    detection:
      - "ps aux | grep Z"
      - "/proc/[pid]/stat state"
      - "top showing zombies"
      - "Process count monitoring"
    
    cleanup:
      - "Kill parent (reparent to init)"
      - "Signal parent to reap"
      - "SA_NOCLDWAIT flag"
      - "SIGCHLD SIG_IGN"
    
    prevention:
      - "Always wait for children"
      - "Double-fork daemon pattern"
      - "SIGCHLD handler"
      - "Non-blocking reap loop"
  
  # Signal Handling (35+ topics)
  signal_handling:
    sigchld:
      - "SIGCHLD on child exit"
      - "SIGCHLD on child stop"
      - "SIGCHLD on child continue"
      - "SA_NOCLDSTOP flag"
      - "SA_NOCLDWAIT flag"
    
    handler_issues:
      - "Async-signal-safe functions"
      - "Reentrant function requirement"
      - "Signal handler race"
      - "EINTR handling"
      - "Signal queuing (POSIX.1b)"
    
    signal_actions:
      - "SIG_DFL default action"
      - "SIG_IGN ignore"
      - "sigaction() setup"
      - "Signal mask manipulation"
      - "Pending signals"
    
    best_practices:
      - "Minimal handler work"
      - "Self-pipe trick"
      - "signalfd() approach"
      - "Eventfd for notification"
  
  # Daemon Patterns (25+ topics)
  daemon_patterns:
    classic_daemon:
      - "First fork (detach from parent)"
      - "setsid() create session"
      - "Second fork (prevent terminal)"
      - "chdir to root"
      - "umask reset"
      - "Close file descriptors"
      - "Redirect stdin/out/err"
    
    systemd_style:
      - "No double fork needed"
      - "sd_notify() readiness"
      - "Socket activation"
      - "Journal logging"
    
    common_bugs:
      - "Missing wait between forks"
      - "Wrong exit in intermediate"
      - "FD inheritance issues"
      - "Signal inheritance"
  
  # Process Groups and Sessions (20+ topics)
  process_groups:
    concepts:
      - "Process group (PGID)"
      - "Session (SID)"
      - "Session leader"
      - "Process group leader"
      - "Controlling terminal"
      - "Foreground process group"
      - "Background process group"
    
    operations:
      - "setpgid()"
      - "setsid()"
      - "tcsetpgrp()"
      - "tcgetpgrp()"
    
    orphan_process_groups:
      - "Orphan definition"
      - "SIGHUP/SIGCONT to orphans"
      - "Stopped orphan handling"

# === BUG PATTERNS ===
bug_patterns:
  missing_wait:
    - pattern: "fork_no_wait"
      description: "Parent forks but never calls wait()"
      severity: "critical"
      detection: "Zombie count grows over time"
      fix: "Add waitpid() loop or SIGCHLD handler"
      code_example: |
        # Bug: no wait
        def spawn_worker():
            pid = os.fork()
            if pid == 0:
                do_work()
                os._exit(0)
            # Parent continues without waiting
        
        # Fix: wait for child
        def spawn_worker():
            pid = os.fork()
            if pid == 0:
                do_work()
                os._exit(0)
            else:
                os.waitpid(pid, 0)  # Wait for child
    
    - pattern: "async_spawn_no_reap"
      description: "Async child spawning without reaping mechanism"
      severity: "critical"
      detection: "Zombies accumulate during operation"
      fix: "Implement SIGCHLD handler or periodic reap"

  signal_handler_issues:
    - pattern: "sigchld_race"
      description: "SIGCHLD handler has race with main wait()"
      severity: "high"
      detection: "Occasional zombie or double-wait error"
      fix: "Use SA_NOCLDWAIT or synchronize carefully"
      code_example: |
        # Bug: race between handler and main code
        def sigchld_handler(sig, frame):
            os.waitpid(-1, os.WNOHANG)  # May race with main
        
        def main():
            signal.signal(signal.SIGCHLD, sigchld_handler)
            pid = os.fork()
            if pid > 0:
                os.waitpid(pid, 0)  # May get ECHILD if handler ran first
        
        # Fix: reap all in handler
        def sigchld_handler(sig, frame):
            while True:
                try:
                    pid, status = os.waitpid(-1, os.WNOHANG)
                    if pid == 0:
                        break
                except ChildProcessError:
                    break
    
    - pattern: "eintr_not_handled"
      description: "wait() returns EINTR, not retried"
      severity: "medium"
      detection: "Sporadic zombie creation"
      fix: "Retry wait on EINTR"

  daemon_pattern_bugs:
    - pattern: "missing_intermediate_wait"
      description: "First fork, setsid, second fork without waiting"
      severity: "high"
      detection: "Zombie of intermediate process"
      fix: "Wait for intermediate process to exit"
      code_example: |
        # Bug: intermediate becomes zombie
        def daemonize():
            pid = os.fork()
            if pid > 0:
                return  # Parent returns, intermediate orphaned
            
            os.setsid()
            
            pid = os.fork()
            if pid > 0:
                os._exit(0)  # Intermediate exits → zombie!
            
            # Daemon continues
        
        # Fix: wait for intermediate
        def daemonize():
            pid = os.fork()
            if pid > 0:
                os.waitpid(pid, 0)  # Wait for intermediate
                return
            
            os.setsid()
            
            pid = os.fork()
            if pid > 0:
                os._exit(0)  # Now properly reaped by original parent
            
            # Daemon continues
    
    - pattern: "wrong_process_exits"
      description: "Wrong process calls _exit in daemon pattern"
      severity: "high"
      detection: "Unexpected process termination"
      fix: "Carefully track which process should exit"

  multi_threaded_issues:
    - pattern: "fork_in_multithread"
      description: "Fork in multi-threaded program"
      severity: "high"
      detection: "Deadlocks, zombies, undefined behavior"
      fix: "Only async-signal-safe after fork, or use posix_spawn"
    
    - pattern: "signal_wrong_thread"
      description: "SIGCHLD delivered to thread that can't handle it"
      severity: "medium"
      detection: "Zombies when signal handler exists"
      fix: "Block SIGCHLD in threads, handle in main"

# === EDGE CASES ===
edge_cases:
  process_edge_cases:
    - "Child exits before parent calls wait"
    - "Parent exits before child"
    - "Multiple children exit simultaneously"
    - "Child stopped then continued then exits"
    - "Child killed by signal"
    - "Child core dumps"
    - "Maximum PID reached and wraparound"

  signal_edge_cases:
    - "SIGCHLD during SIGCHLD handler"
    - "SIGCHLD while in wait()"
    - "Multiple signals coalesced"
    - "Signal delivered to wrong thread"
    - "Signal handler interrupted by same signal"

  timing_edge_cases:
    - "Child exits during fork()"
    - "Signal arrives during system call"
    - "Race between exit and kill"
    - "Zombie exists for microseconds"

  resource_edge_cases:
    - "Process table full"
    - "Maximum children per process"
    - "Out of memory during fork"
    - "Maximum PIDs exhausted"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  multi_threaded:
    threads_involved:
      multiplier: 2.0
      description: "Process management in multi-threaded app"
      considerations:
        - "Signal delivery to threads"
        - "fork() in threaded process"
        - "Thread synchronization"
  
  daemon_complexity:
    double_fork_required:
      multiplier: 1.5
      description: "Must implement proper daemon pattern"
      considerations:
        - "Session/process group handling"
        - "Controlling terminal"
        - "File descriptor inheritance"

# === SCENARIO TEMPLATES ===
scenario_templates:
  basic_zombie:
    description: "Simple fork without wait"
    setup: |
      - Parent forks children
      - Children exit
      - Parent never calls wait
    symptoms: |
      - ps shows Z state processes
      - /proc shows zombie count
      - Process table fills up
    root_cause: "Missing wait() call"
    fix: |
      - Add waitpid() after fork
      - Or SIGCHLD handler
      - Or SA_NOCLDWAIT

  sigchld_race:
    description: "Race between handler and wait"
    setup: |
      - SIGCHLD handler calls waitpid
      - Main code also calls waitpid
      - Race condition occurs
    symptoms: |
      - ECHILD errors
      - Occasional zombie
    root_cause: "Uncoordinated wait calls"
    fix: |
      - Reap only in handler
      - Or use SA_NOCLDWAIT

  daemon_zombie:
    description: "Intermediate process in double-fork"
    setup: |
      - First fork creates intermediate
      - Intermediate forks daemon
      - Intermediate exits
      - No wait for intermediate
    symptoms: |
      - Single zombie per daemon
      - Zombie is PPID=1
    root_cause: "Missing wait for intermediate"
    fix: |
      - Parent waits for intermediate
      - Before returning

# === REFERENCE SOLUTION ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Comprehensive zombie process prevention and cleanup.
  Implements proper SIGCHLD handling, daemon pattern, and reaping.
  """
  import os
  import sys
  import signal
  import errno
  import subprocess
  import threading
  import time
  from typing import Set, Dict, List, Optional, Callable, Tuple
  from dataclasses import dataclass
  import logging
  
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger(__name__)
  
  # === PROCESS MANAGER ===
  
  class ProcessManager:
      """
      Robust process management with proper zombie handling.
      """
      
      def __init__(self, use_sigchld: bool = True):
          self._children: Set[int] = set()
          self._lock = threading.Lock()
          self._use_sigchld = use_sigchld
          
          if use_sigchld:
              self._setup_sigchld_handler()
      
      def _setup_sigchld_handler(self) -> None:
          """Setup SIGCHLD handler for automatic reaping."""
          # Use SA_RESTART to auto-restart interrupted syscalls
          signal.signal(signal.SIGCHLD, self._sigchld_handler)
      
      def _sigchld_handler(self, signum: int, frame) -> None:
          """
          Handle SIGCHLD - reap all terminated children.
          Uses WNOHANG to not block.
          """
          self._reap_children()
      
      def _reap_children(self) -> List[Tuple[int, int]]:
          """
          Reap all terminated children.
          Returns list of (pid, status) for reaped children.
          """
          reaped = []
          
          while True:
              try:
                  # WNOHANG: don't block if no children ready
                  pid, status = os.waitpid(-1, os.WNOHANG)
                  if pid == 0:
                      break  # No more children ready
                  
                  with self._lock:
                      self._children.discard(pid)
                  
                  reaped.append((pid, status))
                  self._log_child_exit(pid, status)
                  
              except ChildProcessError:
                  # ECHILD: no children to wait for
                  break
              except OSError as e:
                  if e.errno == errno.ECHILD:
                      break
                  elif e.errno == errno.EINTR:
                      continue  # Retry on interrupt
                  raise
          
          return reaped
      
      def _log_child_exit(self, pid: int, status: int) -> None:
          """Log child process exit."""
          if os.WIFEXITED(status):
              code = os.WEXITSTATUS(status)
              logger.debug(f"Child {pid} exited with code {code}")
          elif os.WIFSIGNALED(status):
              sig = os.WTERMSIG(status)
              logger.debug(f"Child {pid} killed by signal {sig}")
          elif os.WIFSTOPPED(status):
              sig = os.WSTOPSIG(status)
              logger.debug(f"Child {pid} stopped by signal {sig}")
      
      def fork_child(
          self, 
          func: Callable, 
          *args,
          wait: bool = False
      ) -> int:
          """
          Fork a child process safely.
          Returns child PID to parent, 0 to child.
          """
          pid = os.fork()
          
          if pid == 0:
              # Child process
              try:
                  # Reset signal handlers in child
                  signal.signal(signal.SIGCHLD, signal.SIG_DFL)
                  result = func(*args)
                  os._exit(0 if result is None or result else 1)
              except Exception as e:
                  logger.error(f"Child error: {e}")
                  os._exit(1)
          else:
              # Parent process
              with self._lock:
                  self._children.add(pid)
              
              if wait:
                  self.wait_for_child(pid)
              
              return pid
      
      def wait_for_child(self, pid: int, timeout: float = None) -> Optional[int]:
          """
          Wait for specific child to exit.
          Returns exit status or None on timeout.
          """
          start = time.monotonic()
          
          while True:
              try:
                  wpid, status = os.waitpid(pid, os.WNOHANG)
                  if wpid == pid:
                      with self._lock:
                          self._children.discard(pid)
                      return status
                  
                  if timeout is not None:
                      if time.monotonic() - start > timeout:
                          return None
                  
                  time.sleep(0.01)
                  
              except ChildProcessError:
                  return None  # Already reaped
              except OSError as e:
                  if e.errno == errno.EINTR:
                      continue
                  raise
      
      def wait_all(self, timeout: float = None) -> None:
          """Wait for all children to complete."""
          start = time.monotonic()
          
          while self._children:
              if timeout and (time.monotonic() - start > timeout):
                  break
              self._reap_children()
              time.sleep(0.01)
      
      def get_children(self) -> Set[int]:
          """Get set of tracked child PIDs."""
          with self._lock:
              return self._children.copy()
  
  # === DAEMON PATTERN ===
  
  def daemonize(func: Callable, *args) -> None:
      """
      Proper double-fork daemon pattern.
      
      First fork: Detach from parent
      Second fork: Ensure daemon can't acquire terminal
      """
      # First fork
      pid = os.fork()
      if pid > 0:
          # Parent waits for intermediate process
          os.waitpid(pid, 0)
          return  # Return to caller
      
      # === Intermediate process ===
      
      # Create new session (become session leader)
      os.setsid()
      
      # Second fork
      pid = os.fork()
      if pid > 0:
          # Intermediate process exits immediately
          # Parent already waiting for us
          os._exit(0)
      
      # === Daemon process ===
      
      # Change to root directory
      os.chdir('/')
      
      # Reset umask
      os.umask(0)
      
      # Close standard file descriptors
      os.close(0)
      os.close(1)
      os.close(2)
      
      # Redirect to /dev/null
      null_fd = os.open('/dev/null', os.O_RDWR)
      os.dup2(null_fd, 0)
      os.dup2(null_fd, 1)
      os.dup2(null_fd, 2)
      if null_fd > 2:
          os.close(null_fd)
      
      # Run daemon function
      try:
          func(*args)
      finally:
          os._exit(0)
  
  # === ZOMBIE UTILITIES ===
  
  def find_zombies(parent_pid: int = None) -> List[Dict]:
      """
      Find zombie processes, optionally filtered by parent.
      """
      zombies = []
      
      result = subprocess.run(
          ['ps', '-eo', 'pid,ppid,stat,comm', '--no-headers'],
          capture_output=True,
          text=True
      )
      
      for line in result.stdout.strip().split('\n'):
          if not line.strip():
              continue
          parts = line.split()
          if len(parts) >= 4:
              try:
                  pid = int(parts[0])
                  ppid = int(parts[1])
                  stat = parts[2]
                  comm = parts[3]
                  
                  if 'Z' in stat:
                      if parent_pid is None or ppid == parent_pid:
                          zombies.append({
                              'pid': pid,
                              'ppid': ppid,
                              'stat': stat,
                              'comm': comm
                          })
              except ValueError:
                  pass
      
      return zombies
  
  def count_zombies() -> int:
      """Count total zombie processes on system."""
      return len(find_zombies())
  
  def cleanup_my_zombies() -> int:
      """
      Reap all zombie children of current process.
      Returns number of zombies reaped.
      """
      count = 0
      while True:
          try:
              pid, status = os.waitpid(-1, os.WNOHANG)
              if pid == 0:
                  break
              count += 1
              logger.info(f"Reaped zombie child {pid}")
          except ChildProcessError:
              break
      return count
  
  def signal_parent_to_reap(zombie_pid: int) -> bool:
      """
      Signal parent of zombie to reap it.
      Returns True if signal sent.
      """
      try:
          # Read ppid from /proc
          with open(f'/proc/{zombie_pid}/stat') as f:
              stat = f.read().split()
              ppid = int(stat[3])
          
          if ppid == 1:
              logger.info(f"Zombie {zombie_pid} orphaned to init, will be reaped")
              return True
          
          # Send SIGCHLD to parent
          os.kill(ppid, signal.SIGCHLD)
          logger.info(f"Sent SIGCHLD to {ppid} for zombie {zombie_pid}")
          return True
          
      except (FileNotFoundError, ProcessLookupError, PermissionError) as e:
          logger.error(f"Cannot signal parent of {zombie_pid}: {e}")
          return False
  
  # === SA_NOCLDWAIT PATTERN ===
  
  def setup_auto_reap() -> None:
      """
      Configure system to automatically reap children.
      Children won't become zombies.
      """
      # Setting SIGCHLD to SIG_IGN or SA_NOCLDWAIT
      # causes children to be automatically reaped
      signal.signal(signal.SIGCHLD, signal.SIG_IGN)
      logger.info("Auto-reap enabled: children won't become zombies")
  
  # === SIGNALFD PATTERN ===
  
  class SignalFDReaper:
      """
      Reap children using signalfd instead of signal handler.
      Useful for event-loop based programs.
      """
      
      def __init__(self):
          import selectors
          self._selector = selectors.DefaultSelector()
          self._signalfd = None
          self._setup()
      
      def _setup(self) -> None:
          """Setup signalfd for SIGCHLD."""
          # Block SIGCHLD in normal delivery
          signal.pthread_sigmask(signal.SIG_BLOCK, [signal.SIGCHLD])
          
          # Create signalfd
          # Note: Python doesn't have signalfd binding by default
          # This is conceptual - in practice use pyos or ctypes
          logger.info("SignalFD reaper would be set up here")
      
      def check_and_reap(self) -> List[int]:
          """Check signalfd and reap any terminated children."""
          reaped = []
          while True:
              try:
                  pid, status = os.waitpid(-1, os.WNOHANG)
                  if pid == 0:
                      break
                  reaped.append(pid)
              except ChildProcessError:
                  break
          return reaped
  
  # === TESTS ===
  
  def test_process_manager():
      """Test process manager reaps children."""
      manager = ProcessManager()
      
      def child_work():
          time.sleep(0.01)
      
      # Spawn some children
      pids = []
      for _ in range(3):
          pid = manager.fork_child(child_work)
          pids.append(pid)
      
      # Wait a bit for children to finish
      time.sleep(0.1)
      manager._reap_children()
      
      # Check no zombies
      zombies = find_zombies(os.getpid())
      assert len(zombies) == 0, f"Found zombies: {zombies}"
      
      print("✓ Process manager reaps children")
  
  def test_daemon_pattern():
      """Test daemon pattern doesn't leave zombies."""
      initial_zombies = count_zombies()
      
      def daemon_work():
          time.sleep(0.01)
      
      daemonize(daemon_work)
      
      # Wait for daemon to exit
      time.sleep(0.2)
      
      final_zombies = count_zombies()
      assert final_zombies <= initial_zombies, "Daemon pattern created zombies!"
      
      print("✓ Daemon pattern clean")
  
  def test_auto_reap():
      """Test auto-reap with SIG_IGN."""
      # Save old handler
      old_handler = signal.signal(signal.SIGCHLD, signal.SIG_IGN)
      
      try:
          pid = os.fork()
          if pid == 0:
              os._exit(0)
          
          # Wait a bit
          time.sleep(0.1)
          
          # Child should be auto-reaped, not zombie
          try:
              os.waitpid(pid, os.WNOHANG)
          except ChildProcessError:
              pass  # Expected: already reaped
          
          print("✓ Auto-reap works")
      finally:
          signal.signal(signal.SIGCHLD, old_handler)
  
  def test_cleanup_zombies():
      """Test zombie cleanup function."""
      # Create a zombie by forking without waiting
      old_handler = signal.signal(signal.SIGCHLD, signal.SIG_DFL)
      
      try:
          pid = os.fork()
          if pid == 0:
              os._exit(0)
          
          # Don't wait immediately - child becomes zombie
          time.sleep(0.05)
          
          # Now cleanup
          count = cleanup_my_zombies()
          assert count >= 1, "Should have cleaned up zombie"
          
          print("✓ Zombie cleanup works")
      finally:
          signal.signal(signal.SIGCHLD, old_handler)
  
  if __name__ == "__main__":
      test_process_manager()
      test_auto_reap()
      test_cleanup_zombies()
      # test_daemon_pattern()  # Creates background process
      print("\nAll tests passed!")

# LLM trap configurations
traps:
  - type: "missing_wait"
    description: "Parent doesn't call wait()/waitpid() for terminated children"
    trigger: "Forking without corresponding wait"
  
  - type: "signal_handler_race"
    description: "SIGCHLD handler has race with main wait() calls"
    trigger: "Not using SA_NOCLDWAIT or proper synchronization"
  
  - type: "double_fork_error"
    description: "Daemon pattern doesn't wait for intermediate process"
    trigger: "Missing wait between first and second fork"
  
  - type: "eintr_handling"
    description: "wait() interrupted by signal not retried"
    trigger: "Not handling EINTR from wait syscall"
  
  - type: "fork_in_threads"
    description: "Fork in multi-threaded process causes issues"
    trigger: "Not handling thread-safety of fork"

# Task generation template
instruction_template: |
  You are debugging a {{ scenario_type }} with zombie process accumulation.
  The server code is at {{ path }}.
  
  The process table shows {{ zombie_count }} zombies. Your task:
  {{ task_steps }}
  
  Parent PID: {{ parent_pid }}
  Expected children: {{ expected_children }}
  Actual children: {{ actual_children }}

# Test cases
fail_to_pass:
  - "test_no_zombies_after_fork"
  - "test_sigchld_race_condition"
  - "test_daemon_double_fork"
  - "test_eintr_handling"
  - "test_multi_thread_fork"

pass_to_pass:
  - "test_basic_fork"
  - "test_wait_for_child"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: 
      - "web server"
      - "task scheduler"
      - "worker pool"
      - "batch processor"
      - "job queue"
      - "background service"
  - name: path
    type: path
    generator: random_path
  - name: zombie_count
    type: int
    min: 10
    max: 5000
  - name: parent_pid
    type: int
    generator: random_pid
  - name: expected_children
    type: int
    min: 1
    max: 100
  - name: actual_children
    type: int
    min: 10
    max: 5000
  - name: task_steps
    type: template
    value: |
      1. Identify zombie processes in process table
      2. Find the cause of zombie accumulation
      3. Implement proper SIGCHLD handling
      4. Fix the fork/wait pattern
      5. Clean up existing zombies
      6. Handle EINTR correctly
      7. Verify no new zombies are created

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  zombie_causes:
    - missing_wait
    - signal_handler_race
    - incorrect_double_fork
    - eintr_not_handled
    - fork_in_threads

# Anti-patterns that LLMs commonly fail on
anti_patterns:
  llm_failure_modes:
    - "Applying userspace patterns to kernel-level problems"
    - "Missing memory ordering and barrier requirements"
    - "Ignoring NUMA topology effects on performance"
    - "Not considering scheduler behavior under load"
    - "Missing ABA problems in lock-free data structures"
    - "Overlooking signal handler safety restrictions"
    - "Assuming atomic operations are always sufficient"
    - "Missing file descriptor inheritance across fork/exec"
    - "Ignoring distributed consensus edge cases (Byzantine failures)"
    - "Fork without wait() creating accumulating zombies"
    - "SIGCHLD handler racing with main thread wait()"
    - "EINTR from wait() not handled with retry"
    - "SA_NOCLDWAIT not preventing zombie (only with SIG_IGN)"
    - "Double-fork daemon not waiting for intermediate"
    - "SIGCHLD signal coalescing losing multiple children"
    - "Signal handler calling non-async-signal-safe functions"
    - "Fork in multi-threaded process causing deadlock"
    - "Container PID 1 not reaping orphaned children"
    - "Process group orphan not receiving SIGHUP"
    - "Session leader zombie blocking terminal release"
    - "cgroup pids.max counting zombies"
    - "WNOHANG loop not handling ECHILD correctly"

# === EXTENDED TOPIC COVERAGE ===
extended_topics:
  # Process Table Internals
  process_table:
    structure:
      - "task_struct in Linux kernel"
      - "Process state transitions"
      - "EXIT_ZOMBIE state details"
      - "Zombie memory footprint"
      - "Process table size limits"
    kernel_limits:
      - "kernel.pid_max sysctl"
      - "kernel.threads-max"
      - "fs.file-max relationship"
      - "RLIMIT_NPROC per user"
    monitoring:
      - "/proc/[pid]/status State field"
      - "/proc/[pid]/stat (3rd field = Z)"
      - "Number of processes via /proc"
  
  # Signal Internals
  signal_internals:
    sigchld_details:
      - "SIGCHLD delivery semantics"
      - "Signal coalescing behavior"
      - "Per-thread signal handling"
      - "Signal pending mask"
    sigaction_flags:
      - "SA_RESTART for system calls"
      - "SA_NOCLDSTOP suppress stop signals"
      - "SA_NOCLDWAIT auto-reap children"
      - "SA_SIGINFO for extra information"
    siginfo_fields:
      - "si_pid - child PID"
      - "si_uid - child real UID"
      - "si_status - exit status or signal"
      - "si_code - CLD_EXITED, CLD_KILLED, etc."
  
  # Process Groups Deep Dive
  process_groups_advanced:
    orphan_handling:
      - "Orphan process group definition"
      - "SIGHUP to stopped orphan members"
      - "SIGCONT follows SIGHUP"
      - "Job control implications"
    session_management:
      - "Session leader responsibilities"
      - "Controlling terminal association"
      - "Hangup on session leader death"
      - "No controlling terminal after setsid"
    job_control:
      - "Foreground vs background groups"
      - "Terminal I/O and SIGTTIN/SIGTTOU"
      - "tcsetpgrp for foreground control"
      - "Shell job control implementation"

# === ADVANCED SCENARIOS ===
advanced_scenarios:
  container_zombies:
    description: "Zombie accumulation in containers"
    details: |
      - Container PID 1 doesn't reap orphans
      - Orphaned processes reparent to PID 1
      - PID 1 (if not init) may not wait
      - Zombies accumulate in container
    detection: |
      - docker top shows Z state
      - /proc/1/children in container
    solution: |
      - Use tini or dumb-init as PID 1
      - Implement signal handling in entry point
      - Use --init flag in Docker
  
  cgroup_zombies:
    description: "Zombies affecting cgroup limits"
    details: |
      - Zombies count toward pids.max
      - Can hit cgroup process limit
      - New forks fail with EAGAIN
    detection: |
      - cgroup pids.current high
      - Many Z state processes in cgroup
    solution: |
      - Reap zombies to free pids
      - Kill parent to orphan zombies
      - Adjust cgroup pids.max
  
  systemd_service_zombies:
    description: "Zombies in systemd services"
    details: |
      - Service forks children
      - Main PID exits, service stops
      - Children become zombies briefly
      - systemd should reap as subreaper
    detection: |
      - journalctl shows zombie warnings
      - Service fails to stop cleanly
    solution: |
      - Ensure proper shutdown sequence
      - Wait for children before exit
      - Use Type=notify with proper protocol

# === LANGUAGE-SPECIFIC PATTERNS ===
language_patterns:
  python:
    - "multiprocessing.Process with join()"
    - "subprocess.Popen with communicate()"
    - "os.waitpid in signal handler"
    - "concurrent.futures ProcessPoolExecutor"
  
  go:
    - "exec.Command with Wait()"
    - "os/signal for SIGCHLD"
    - "syscall.Wait4 for rusage"
    - "cmd.Process.Release() cleanup"
  
  rust:
    - "std::process::Command with wait()"
    - "nix::sys::wait::waitpid"
    - "signal-hook for SIGCHLD"
    - "Drop impl for process handles"
  
  java:
    - "ProcessBuilder with waitFor()"
    - "Process.destroy() and destroyForcibly()"
    - "ProcessHandle API (Java 9+)"
    - "onExit() CompletableFuture"
  
  c_cpp:
    - "waitpid with WNOHANG in loop"
    - "sigaction for SIGCHLD"
    - "posix_spawn as alternative to fork"
    - "pthread_atfork handlers"

# === MONITORING AND ALERTING ===
monitoring:
  metrics:
    - "zombie_process_count gauge"
    - "child_reap_latency histogram"
    - "fork_without_wait counter"
    - "sigchld_received counter"
  
  alerting:
    - "Zombie count > 10 for 5 minutes"
    - "Zombie count growing continuously"
    - "Process table > 80% capacity"
    - "ECHILD errors increasing"
  
  debugging:
    - "ps -eo pid,ppid,stat,comm | grep Z"
    - "pstree -p to show hierarchy"
    - "strace -e wait4,waitpid,waitid"
    - "Audit log for process events"
