id: "sys-os-permission-escalation-001"
version: "1.0.0"
category: "systems"
subcategory: "operating-systems"

# SWE-bench_Pro style fields
problem_statement: |
  A setuid binary on a Linux system has privilege escalation vulnerabilities. 
  The program is meant to allow specific operations with elevated privileges 
  but has flaws that could allow arbitrary privilege escalation.
  
  Vulnerabilities present:
  1. Incomplete dropping of supplementary groups
  2. Unsafe handling of environment variables
  3. Race condition in file permission checks
  4. Improper handling of symbolic links
  5. Inherited file descriptors not closed

requirements: |
  - Identify all privilege escalation vectors
  - Properly drop and restore privileges
  - Sanitize environment and inherited resources
  - Handle symlinks and race conditions securely
  - Implement principle of least privilege

interface: |
  Input: Setuid binary source code
  Output: Hardened code, security audit report
  Testing: Privilege escalation attempts blocked

# terminal-bench style fields
difficulty:
  estimated: "hard"
  time_range: [2700, 7200]
  command_steps: [30, 90]

# === QUALITY REQUIREMENTS ===
quality_requirements:
  minimum_time: "120-300 minutes for senior systems engineers with kernel contribution experience"
  expertise_level: "Principal systems engineer with Unix security, privilege separation, and exploitation expertise"
  validation_standard: "Must expose subtle privilege escalation vectors across kernel/userspace boundary"

# === MULTI-AGENT ORCHESTRATION ===
multi_agent_orchestration:
  required_agents: 10
  agent_specializations:
    - name: "credential_expert"
      role: "Debug Unix credential management"
      expertise: ["UID/GID transitions", "supplementary groups", "capabilities", "seccomp"]
    - name: "setuid_auditor"
      role: "Audit setuid binary security"
      expertise: ["privilege drop", "environment sanitization", "fd inheritance", "signal safety"]
    - name: "capability_specialist"
      role: "Debug Linux capabilities"
      expertise: ["capability sets", "ambient capabilities", "file capabilities", "bounding set"]
    - name: "namespace_security_expert"
      role: "Debug namespace security boundaries"
      expertise: ["user namespaces", "mount namespaces", "PID namespaces", "network namespaces"]
    - name: "lsm_analyst"
      role: "Debug LSM (SELinux/AppArmor) policies"
      expertise: ["type enforcement", "MAC policies", "security contexts", "policy analysis"]
    - name: "race_condition_hunter"
      role: "Find TOCTOU and symlink races"
      expertise: ["symlink attacks", "open/access races", "fd passing races", "mount races"]
    - name: "container_escape_expert"
      role: "Debug container security boundaries"
      expertise: ["cgroup escapes", "namespace escapes", "capability abuse", "device access"]
    - name: "exploit_developer"
      role: "Analyze and develop privilege escalation exploits"
      expertise: ["kernel exploits", "race exploitation", "heap spray", "ROP chains"]
    - name: "seccomp_specialist"
      role: "Debug seccomp filter security"
      expertise: ["BPF filters", "syscall filtering", "seccomp-bpf", "sandbox escapes"]
    - name: "audit_system_analyst"
      role: "Use audit subsystem for detection"
      expertise: ["auditd", "audit rules", "syscall auditing", "security event analysis"]
  cross_subsystem_chains:
    - "Setuid binary → Environment injection → LD_PRELOAD → Code execution as root"
    - "Capability abuse → Namespace escape → Host access → Full root"
    - "TOCTOU race → Symlink swap → Write to /etc/shadow → Credential theft"
    - "Inherited FD → Privileged socket → Command injection → Escalation"
  parallel_debugging_requirements:
    - "Correlated syscall traces with security context"
    - "Simultaneous capability and namespace analysis"
    - "Agent handoff for multi-stage privilege escalation debugging"

# === TRAP CONFIGURATION ===
trap_configuration:
  trap_count: "12+ deeply interacting traps across kernel/userspace/hardware boundaries"
  trap_categories:
    credential_traps:
      - "Supplementary groups not cleared with setgroups()"
      - "UID dropped before GID (can't change GID after)"
      - "Saved UID allowing privilege restoration"
      - "FSUID not dropped for filesystem operations"
    environment_traps:
      - "LD_PRELOAD not cleared allowing library injection"
      - "PATH allowing malicious binary execution"
      - "IFS manipulation for command injection"
      - "PYTHONPATH/RUBYLIB for interpreter hijacking"
    file_access_traps:
      - "TOCTOU race between access() and open()"
      - "Symlink following to privileged file"
      - "FD inheritance to child process"
      - "Hard link to setuid binary"

# === NIGHTMARE_PLUS DIFFICULTY ===
difficulty_levels:
  nightmare_plus:
    estimated_time: [43200, 259200]  # 12-72 hours
    command_steps: [600, 2500]
    techniques_required: 18
    description: "CVE-level privilege escalation requiring deep kernel security knowledge"
    requirements:
      - "Requires understanding of complete Unix security model"
      - "Must handle multi-stage escalation chains"
      - "Involves container/namespace escape techniques"
      - "Cross-platform behavior differences (Linux vs BSD)"
      - "Time estimate: 12-72 hours for security researchers"
      - "Requires synthesizing credential, filesystem, and kernel knowledge"

# === KERNEL SUBSYSTEM REQUIREMENTS ===
kernel_subsystem_requirements:
  credential_subsystem:
    - "struct cred lifecycle and inheritance"
    - "prepare_creds/commit_creds semantics"
    - "Capability checking (ns_capable, capable)"
    - "LSM credential hooks"
  filesystem_security:
    - "inode permission checking"
    - "Setuid/setgid execution semantics"
    - "AT_EMPTY_PATH and dirfd attacks"
    - "Mount namespace security"
  namespace_subsystem:
    - "User namespace privilege model"
    - "Namespace hierarchy and capabilities"
    - "Unprivileged namespace creation"
    - "Namespace escape vectors"
  seccomp:
    - "Seccomp-bpf filter installation"
    - "Syscall argument filtering"
    - "Filter inheritance across fork/exec"
    - "SECCOMP_RET_USER_NOTIF handling"

# === HARDWARE INTERACTION ===
hardware_interaction:
  device_security:
    - "/dev/mem and /dev/kmem access"
    - "Device node creation and access"
    - "IOMMU and device isolation"
    - "USB device security"
  processor_features:
    - "SMAP/SMEP enforcement"
    - "UMIP for unprivileged instruction"
    - "PCID effects on KASLR"
    - "Spectre/Meltdown mitigations"
  firmware_interaction:
    - "UEFI Secure Boot bypass"
    - "ACPI exploitation"
    - "SMM (System Management Mode)"
    - "Intel ME/AMD PSP security"

# === FORMAL VERIFICATION REQUIREMENTS ===
formal_verification_requirements:
  modeling_requirements:
    - "Model privilege transitions in TLA+"
    - "Express capability requirements formally"
    - "Verify privilege drop completeness"
    - "Model TOCTOU race conditions"
  proof_obligations:
    - "Prove privilege cannot be regained after drop"
    - "Verify environment sanitization completeness"
    - "Establish fd inheritance security"
    - "Prove symlink attack prevention"

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research Unix privilege model and security best practices"
    phase_2_creation: "Create task with subtle privilege escalation scenarios"
    phase_3_amplification: "Add environment injection and TOCTOU races"
    phase_4_verification:
      description: "Validate task requires deep security understanding"
      criteria:
        - "Has at least 5 interacting system-level traps across subsystems"
        - "Has cascading failures across process, memory, and I/O subsystems"
        - "Requires knowledge of OS kernel internals and scheduler behavior"
        - "Would take experienced systems programmers 45+ minutes"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 3.5
      description: "Kernel-level debugging complexity requiring deep systems expertise"
      requirements:
        - "7+ interacting system-level traps across subsystems"
        - "Requires understanding of kernel memory management and scheduling"
        - "Time estimate: 120+ minutes for senior systems engineers"
        - "Cross-platform behavior differences (Linux vs BSD vs Windows)"
        - "Requires synthesizing concurrency, memory, distributed systems knowledge"
  
  generation_targets:
    minimum_difficulty: "45+ minutes, requires deep kernel internals and distributed systems expertise"
  
  complexity_levels:
    level_1_basic:
      description: "Missing setgroups() call"
      elements: ["supplementary_groups_retained", "basic_priv_drop"]
    level_2_intermediate:
      description: "Environment variable injection"
      elements: ["ld_preload", "path_injection", "ifs_manipulation"]
    level_3_advanced:
      description: "TOCTOU race conditions"
      elements: ["symlink_race", "open_follow_race"]
    level_4_expert:
      description: "File descriptor attacks"
      elements: ["fd_inheritance", "privileged_fd_leak"]
    level_5_research:
      description: "Novel escalation techniques"
      elements: ["namespace_escape", "capability_abuse"]

# === COMPREHENSIVE TOPIC UNIVERSE ===
topic_universe:
  # Unix Privilege Model (40+ topics)
  privilege_model:
    user_ids:
      - "Real UID (RUID)"
      - "Effective UID (EUID)"
      - "Saved set-user-ID (SUID)"
      - "Filesystem UID (FSUID) - Linux"
      - "setuid() semantics"
      - "seteuid() semantics"
      - "setreuid() semantics"
      - "setresuid() semantics"
    
    group_ids:
      - "Real GID (RGID)"
      - "Effective GID (EGID)"
      - "Saved set-group-ID (SGID)"
      - "Filesystem GID (FSGID)"
      - "Supplementary groups"
      - "setgid() semantics"
      - "setgroups() requirement"
      - "initgroups()"
    
    capabilities:
      - "POSIX capabilities overview"
      - "Permitted capabilities"
      - "Effective capabilities"
      - "Inheritable capabilities"
      - "Ambient capabilities"
      - "Bounding set"
      - "cap_get/set_proc()"
      - "File capabilities"
    
    special_permissions:
      - "Setuid bit"
      - "Setgid bit"
      - "Sticky bit"
      - "Setuid on scripts (disabled)"
  
  # Privilege Dropping (30+ topics)
  privilege_dropping:
    permanent_drop:
      - "Drop to unprivileged user"
      - "Drop groups first, then UID"
      - "Verify drop succeeded"
      - "No way to regain privileges"
    
    temporary_drop:
      - "Drop EUID, keep SUID"
      - "Restore when needed"
      - "Risks of temporary drop"
    
    common_mistakes:
      - "Forgetting setgroups()"
      - "Wrong order of operations"
      - "Not verifying success"
      - "Assuming drop worked"
    
    platform_differences:
      - "Linux vs BSD semantics"
      - "POSIX requirements"
      - "Saved UID behavior"
  
  # Environment Attacks (35+ topics)
  environment_attacks:
    dangerous_variables:
      - "LD_PRELOAD"
      - "LD_LIBRARY_PATH"
      - "LD_AUDIT"
      - "LD_DEBUG"
      - "LD_DEBUG_OUTPUT"
      - "PATH"
      - "IFS"
      - "BASH_ENV"
      - "ENV"
      - "CDPATH"
      - "LOCALDOMAIN"
      - "HOSTALIASES"
      - "NLSPATH"
      - "MALLOC_TRACE"
    
    sanitization:
      - "Clear dangerous variables"
      - "Reset PATH to safe default"
      - "Reset IFS"
      - "Use execve() with explicit env"
    
    attack_techniques:
      - "LD_PRELOAD injection"
      - "PATH hijacking"
      - "IFS command splitting"
      - "Library replacement"
  
  # File Security (35+ topics)
  file_security:
    toctou_attacks:
      - "access() then open() race"
      - "stat() then open() race"
      - "lstat() for symlinks"
      - "Symlink swapping attack"
    
    safe_patterns:
      - "Open then fstat()"
      - "O_NOFOLLOW flag"
      - "openat() with directory FD"
      - "Atomic file creation"
    
    file_descriptors:
      - "FD_CLOEXEC flag"
      - "Inherited FDs on fork/exec"
      - "Privileged FD leakage"
      - "Closing inherited FDs"
    
    symlink_handling:
      - "Don't follow symlinks"
      - "O_NOFOLLOW"
      - "AT_SYMLINK_NOFOLLOW"
      - "Safe temporary files"
  
  # Secure Programming (30+ topics)
  secure_programming:
    input_validation:
      - "Buffer overflow prevention"
      - "Format string validation"
      - "Path traversal prevention"
      - "Command injection prevention"
    
    resource_limits:
      - "RLIMIT_NPROC"
      - "RLIMIT_NOFILE"
      - "RLIMIT_CORE"
      - "Resource exhaustion attacks"
    
    sandboxing:
      - "chroot()"
      - "Seccomp"
      - "Linux namespaces"
      - "SELinux/AppArmor"
      - "Capabilities sandboxing"
  
  # Detection and Exploitation (25+ topics)
  detection_exploitation:
    finding_vulnerabilities:
      - "Static analysis"
      - "Dynamic testing"
      - "Fuzzing"
      - "Code review"
    
    exploitation_techniques:
      - "Local privilege escalation"
      - "Arbitrary code execution"
      - "Information disclosure"
      - "Denial of service"
    
    tools:
      - "ltrace/strace analysis"
      - "GDB for debugging"
      - "checksec for binary"
      - "Linux audit subsystem"

# === BUG PATTERNS ===
bug_patterns:
  credential_issues:
    - pattern: "supplementary_groups_retained"
      description: "setuid() doesn't clear supplementary groups"
      severity: "critical"
      detection: "Process retains unexpected group memberships"
      fix: "Call setgroups(0, NULL) before setuid()"
      code_example: |
        # Bug: groups not cleared
        def drop_privileges(uid, gid):
            os.setgid(gid)
            os.setuid(uid)
            # Still in supplementary groups!
        
        # Fix: clear groups first
        def drop_privileges(uid, gid):
            os.setgroups([])  # Clear supplementary groups
            os.setgid(gid)    # Then GID
            os.setuid(uid)    # Then UID last
            
            # Verify
            if os.getuid() != uid or os.getgid() != gid:
                raise RuntimeError("Failed to drop privileges")
    
    - pattern: "wrong_order"
      description: "Drop UID before GID (can't change GID after)"
      severity: "critical"
      detection: "GID unchanged after drop attempt"
      fix: "Always: groups → GID → UID"

  environment_issues:
    - pattern: "ld_preload_not_cleared"
      description: "LD_PRELOAD allows code injection"
      severity: "critical"
      detection: "Arbitrary code execution via preload"
      fix: "Clear all LD_* variables before any operation"
      code_example: |
        # Bug: env not sanitized
        def main():
            do_privileged_work()  # LD_PRELOAD injects code!
        
        # Fix: sanitize environment first
        DANGEROUS_ENV = {
            'LD_PRELOAD', 'LD_LIBRARY_PATH', 'LD_AUDIT',
            'LD_DEBUG', 'MALLOC_TRACE', 'HOSTALIASES'
        }
        
        def sanitize_environment():
            for var in list(os.environ.keys()):
                if var in DANGEROUS_ENV or var.startswith('LD_'):
                    del os.environ[var]
            os.environ['PATH'] = '/usr/bin:/bin'
            os.environ['IFS'] = ' \t\n'
        
        def main():
            sanitize_environment()
            do_privileged_work()
    
    - pattern: "path_injection"
      description: "PATH allows running malicious commands"
      severity: "high"
      detection: "Unexpected binary execution"
      fix: "Use absolute paths or reset PATH"

  file_access_issues:
    - pattern: "symlink_race"
      description: "Symlink swapped between check and use"
      severity: "critical"
      detection: "Access to unintended file"
      fix: "Use O_NOFOLLOW, fstat() after open"
      code_example: |
        # Bug: TOCTOU with symlink
        def read_user_file(path, user_uid):
            # Check ownership
            stat = os.stat(path)  # Follows symlink
            if stat.st_uid != user_uid:
                raise PermissionError("Not owner")
            
            # Attacker swaps file for symlink here!
            
            with open(path) as f:  # Opens different file
                return f.read()
        
        # Fix: open then verify
        def read_user_file(path, user_uid):
            fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)
            try:
                stat = os.fstat(fd)  # Check the open file
                if stat.st_uid != user_uid:
                    raise PermissionError("Not owner")
                if not stat.S_ISREG(stat.st_mode):
                    raise PermissionError("Not a regular file")
                return os.read(fd, stat.st_size)
            finally:
                os.close(fd)
    
    - pattern: "toctou_access_open"
      description: "access() then open() race"
      severity: "critical"
      detection: "File changes between check and open"
      fix: "Open first, then check using fstat()"

  fd_issues:
    - pattern: "privileged_fd_leak"
      description: "Privileged FD inherited by child process"
      severity: "high"
      detection: "Child has access to privileged resource"
      fix: "Set FD_CLOEXEC on all FDs, close before exec"
      code_example: |
        # Bug: FD inherited
        def run_command(cmd):
            privileged_fd = open('/etc/shadow', 'r')
            subprocess.run(cmd)  # cmd inherits privileged_fd!
        
        # Fix: CLOEXEC
        import fcntl
        
        def run_command(cmd):
            fd = os.open('/etc/shadow', os.O_RDONLY)
            fcntl.fcntl(fd, fcntl.F_SETFD, fcntl.FD_CLOEXEC)
            # Or: close FD before exec
            subprocess.run(cmd, close_fds=True)
    
    - pattern: "inherited_fd_not_closed"
      description: "Setuid binary doesn't close inherited FDs"
      severity: "medium"
      detection: "Attacker passes malicious FD"
      fix: "Close all FDs >2 at startup"

# === EDGE CASES ===
edge_cases:
  privilege_edge_cases:
    - "Root setuid to non-root"
    - "Non-root setuid root (impossible)"
    - "setuid root, setgid non-root"
    - "Capability-only elevation"
    - "SUID binary run as root"
    - "Nested privilege operations"

  file_edge_cases:
    - "Symlink in path component"
    - "Hardlink to privileged file"
    - "Mount point under checked path"
    - "Bind mount attack"
    - "Deleted but open file"
    - "File on different filesystem"

  timing_edge_cases:
    - "Race window is microseconds"
    - "Attack requires many attempts"
    - "Timing depends on system load"

  platform_edge_cases:
    - "Linux-specific syscalls"
    - "BSD vs Linux setuid semantics"
    - "Container namespace effects"
    - "32-bit vs 64-bit differences"

# === DIFFICULTY MULTIPLIERS ===
difficulty_multipliers:
  attack_complexity:
    race_conditions:
      multiplier: 1.8
      description: "Must exploit TOCTOU races"
      considerations:
        - "Timing window"
        - "Success probability"
        - "Attack automation"
    
    multi_stage:
      multiplier: 2.0
      description: "Requires chaining vulnerabilities"
      considerations:
        - "Multiple vectors"
        - "Dependency between stages"
        - "Information leakage"

  defense_requirements:
    full_hardening:
      multiplier: 1.5
      description: "Must implement comprehensive security"
      considerations:
        - "All attack vectors"
        - "Defense in depth"
        - "Least privilege"

# === SCENARIO TEMPLATES ===
scenario_templates:
  supplementary_groups:
    description: "Groups not cleared on privilege drop"
    setup: |
      - Setuid binary drops to user
      - Doesn't call setgroups()
      - User retains privileged groups
    symptoms: |
      - User can access group-restricted files
      - Unexpected permissions
    root_cause: "Missing setgroups(0, NULL)"
    fix: |
      - Clear groups before setgid/setuid
      - Verify all credentials after drop

  ld_preload_injection:
    description: "LD_PRELOAD allows code injection"
    setup: |
      - Setuid binary runs
      - Attacker sets LD_PRELOAD
      - Malicious library loaded
    symptoms: |
      - Arbitrary code execution
      - Function hijacking
    root_cause: "Environment not sanitized"
    fix: |
      - Clear LD_* variables
      - Use secure_getenv()

  symlink_attack:
    description: "TOCTOU via symlink swap"
    setup: |
      - Binary checks file ownership
      - Attacker swaps file for symlink
      - Binary opens symlinked file
    symptoms: |
      - Access to unintended files
      - Privilege bypass
    root_cause: "access() then open() pattern"
    fix: |
      - Use O_NOFOLLOW
      - fstat() after open()

# === REFERENCE SOLUTION ===
reference_solution: |
  #!/usr/bin/env python3
  """
  Comprehensive privilege management and security hardening.
  Implements proper privilege dropping, environment sanitization, and safe file access.
  """
  import os
  import sys
  import stat
  import pwd
  import grp
  import fcntl
  import resource
  from typing import List, Optional, Set, Dict, Callable
  from dataclasses import dataclass
  from contextlib import contextmanager
  import logging
  
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger(__name__)
  
  # === DANGEROUS ENVIRONMENT VARIABLES ===
  
  DANGEROUS_ENV_VARS: Set[str] = {
      # Dynamic linker
      'LD_PRELOAD', 'LD_LIBRARY_PATH', 'LD_AUDIT',
      'LD_DEBUG', 'LD_DEBUG_OUTPUT', 'LD_PROFILE',
      'LD_SHOW_AUXV', 'LD_TRACE_LOADED_OBJECTS',
      'LD_DYNAMIC_WEAK', 'LD_ORIGIN_PATH',
      # Memory
      'MALLOC_TRACE', 'MALLOC_CHECK_',
      # Locale/resolution
      'HOSTALIASES', 'LOCALDOMAIN', 'RESOLV_HOST_CONF',
      'NLSPATH', 'LOCPATH',
      # Shell
      'IFS', 'BASH_ENV', 'ENV', 'CDPATH',
      'SHELLOPTS', 'BASHOPTS', 'PS4',
      # Python-specific
      'PYTHONPATH', 'PYTHONSTARTUP', 'PYTHONHOME',
  }
  
  # === CREDENTIALS ===
  
  @dataclass
  class ProcessCredentials:
      """Current process credentials."""
      real_uid: int
      effective_uid: int
      saved_uid: int
      real_gid: int
      effective_gid: int
      saved_gid: int
      supplementary_groups: List[int]
  
  def get_credentials() -> ProcessCredentials:
      """Get current process credentials."""
      ruid, euid, suid = os.getresuid()
      rgid, egid, sgid = os.getresgid()
      
      return ProcessCredentials(
          real_uid=ruid,
          effective_uid=euid,
          saved_uid=suid,
          real_gid=rgid,
          effective_gid=egid,
          saved_gid=sgid,
          supplementary_groups=list(os.getgroups())
      )
  
  def print_credentials() -> None:
      """Print current credentials for debugging."""
      creds = get_credentials()
      logger.info(
          f"UID: real={creds.real_uid}, effective={creds.effective_uid}, "
          f"saved={creds.saved_uid}"
      )
      logger.info(
          f"GID: real={creds.real_gid}, effective={creds.effective_gid}, "
          f"saved={creds.saved_gid}"
      )
      logger.info(f"Supplementary groups: {creds.supplementary_groups}")
  
  # === ENVIRONMENT SANITIZATION ===
  
  def sanitize_environment() -> None:
      """
      Remove all dangerous environment variables.
      Must be called early in setuid programs.
      """
      # Remove dangerous variables
      for var in list(os.environ.keys()):
          if var in DANGEROUS_ENV_VARS or var.startswith('LD_'):
              logger.debug(f"Removing dangerous env var: {var}")
              del os.environ[var]
      
      # Reset PATH to safe default
      os.environ['PATH'] = '/usr/local/bin:/usr/bin:/bin'
      
      # Reset IFS
      os.environ['IFS'] = ' \t\n'
      
      # Set safe locale
      os.environ['LC_ALL'] = 'C'
      
      logger.debug("Environment sanitized")
  
  # === FILE DESCRIPTOR CLEANUP ===
  
  def close_inherited_fds(keep_fds: Set[int] = None) -> int:
      """
      Close all inherited file descriptors except stdin/stdout/stderr.
      Returns number of FDs closed.
      """
      if keep_fds is None:
          keep_fds = {0, 1, 2}
      
      # Get max FD
      max_fd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
      max_fd = min(max_fd, 4096)  # Reasonable limit
      
      closed = 0
      for fd in range(3, max_fd):
          if fd not in keep_fds:
              try:
                  os.close(fd)
                  closed += 1
              except OSError:
                  pass
      
      logger.debug(f"Closed {closed} inherited FDs")
      return closed
  
  def set_cloexec(fd: int) -> None:
      """Set FD_CLOEXEC flag on file descriptor."""
      flags = fcntl.fcntl(fd, fcntl.F_GETFD)
      fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)
  
  # === PRIVILEGE MANAGEMENT ===
  
  def drop_privileges_permanently(target_uid: int, target_gid: int) -> None:
      """
      Permanently drop all privileges.
      Cannot be undone.
      """
      # CRITICAL: Order matters!
      # 1. Clear supplementary groups
      # 2. Set GID (must be before UID)
      # 3. Set UID last
      
      # Step 1: Clear supplementary groups
      os.setgroups([])
      
      # Step 2: Set GID
      os.setresgid(target_gid, target_gid, target_gid)
      
      # Step 3: Set UID (can't change GID after this if non-root)
      os.setresuid(target_uid, target_uid, target_uid)
      
      # Step 4: Verify everything worked
      creds = get_credentials()
      
      if creds.effective_uid != target_uid or creds.real_uid != target_uid:
          raise RuntimeError(
              f"Failed to drop UID: expected {target_uid}, "
              f"got euid={creds.effective_uid}, ruid={creds.real_uid}"
          )
      
      if creds.effective_gid != target_gid or creds.real_gid != target_gid:
          raise RuntimeError(
              f"Failed to drop GID: expected {target_gid}, "
              f"got egid={creds.effective_gid}, rgid={creds.real_gid}"
          )
      
      if creds.supplementary_groups:
          raise RuntimeError(
              f"Failed to clear supplementary groups: {creds.supplementary_groups}"
          )
      
      logger.info(f"Dropped privileges to uid={target_uid}, gid={target_gid}")
  
  @contextmanager
  def temporary_privileges():
      """
      Context manager to temporarily elevate privileges.
      Restores original credentials on exit.
      """
      original = get_credentials()
      
      try:
          # Elevate to saved UID
          os.seteuid(original.saved_uid)
          os.setegid(original.saved_gid)
          logger.debug(f"Elevated to uid={original.saved_uid}")
          yield
      finally:
          # Drop back to real UID
          os.setegid(original.real_gid)
          os.seteuid(original.real_uid)
          logger.debug(f"Dropped back to uid={original.real_uid}")
  
  # === SAFE FILE OPERATIONS ===
  
  def safe_open_file(
      path: str, 
      flags: int, 
      allowed_uid: Optional[int] = None,
      follow_symlinks: bool = False
  ) -> int:
      """
      Safely open a file avoiding symlink and TOCTOU races.
      """
      # Add O_NOFOLLOW unless explicitly allowing symlinks
      if not follow_symlinks:
          flags |= os.O_NOFOLLOW
      
      try:
          fd = os.open(path, flags, 0o600)
      except OSError as e:
          if e.errno == 40:  # ELOOP - was a symlink
              raise PermissionError(f"Refusing to follow symlink: {path}")
          raise
      
      try:
          # Check the OPEN file, not the path (TOCTOU safe)
          stat_info = os.fstat(fd)
          
          # Verify it's a regular file
          if not stat.S_ISREG(stat_info.st_mode):
              raise PermissionError(f"Not a regular file: {path}")
          
          # Verify ownership if required
          if allowed_uid is not None:
              if stat_info.st_uid != allowed_uid and stat_info.st_uid != 0:
                  raise PermissionError(
                      f"File not owned by uid {allowed_uid}: {path}"
                  )
          
          # Set close-on-exec
          set_cloexec(fd)
          
          return fd
          
      except:
          os.close(fd)
          raise
  
  def safe_exec(
      program: str, 
      args: List[str], 
      env: Dict[str, str] = None
  ) -> None:
      """
      Safely execute a program with sanitized environment.
      """
      # Require absolute path
      if not program.startswith('/'):
          raise ValueError("Must use absolute path for exec")
      
      # Verify program exists and is executable
      if not os.path.isfile(program):
          raise FileNotFoundError(f"Program not found: {program}")
      if not os.access(program, os.X_OK):
          raise PermissionError(f"Program not executable: {program}")
      
      # Create safe environment
      if env is None:
          try:
              pw = pwd.getpwuid(os.getuid())
              home = pw.pw_dir
              user = pw.pw_name
          except KeyError:
              home = '/'
              user = 'unknown'
          
          env = {
              'PATH': '/usr/local/bin:/usr/bin:/bin',
              'HOME': home,
              'USER': user,
              'SHELL': '/bin/sh',
              'LC_ALL': 'C',
          }
      
      # Close all FDs except stdin/stdout/stderr
      close_inherited_fds()
      
      # Execute
      os.execve(program, [program] + args, env)
  
  # === SETUID PROGRAM BASE CLASS ===
  
  class SetuidProgram:
      """Base class for secure setuid programs."""
      
      def __init__(self):
          self.original_creds = get_credentials()
          self._startup_sanitize()
      
      def _startup_sanitize(self) -> None:
          """Perform security measures at startup."""
          # 1. Sanitize environment
          sanitize_environment()
          
          # 2. Close inherited FDs
          close_inherited_fds()
          
          # 3. Drop privileges immediately if EUID=0
          if self.original_creds.effective_uid == 0:
              os.seteuid(self.original_creds.real_uid)
              os.setegid(self.original_creds.real_gid)
          
          logger.debug("Startup sanitization complete")
      
      def run_privileged(self, func: Callable, *args, **kwargs):
          """Run a function with elevated privileges."""
          with temporary_privileges():
              return func(*args, **kwargs)
  
  # === TESTS ===
  
  def test_env_sanitization():
      """Test environment sanitization."""
      # Set dangerous variables
      os.environ['LD_PRELOAD'] = '/evil.so'
      os.environ['LD_LIBRARY_PATH'] = '/evil'
      os.environ['SAFE_VAR'] = 'keep_me'
      
      sanitize_environment()
      
      assert 'LD_PRELOAD' not in os.environ
      assert 'LD_LIBRARY_PATH' not in os.environ
      assert os.environ.get('SAFE_VAR') == 'keep_me'
      assert os.environ['PATH'] == '/usr/local/bin:/usr/bin:/bin'
      
      print("✓ Environment sanitization works")
  
  def test_credentials():
      """Test credential retrieval."""
      creds = get_credentials()
      
      assert creds.real_uid == os.getuid()
      assert creds.effective_uid == os.geteuid()
      assert isinstance(creds.supplementary_groups, list)
      
      print("✓ Credential retrieval works")
  
  def test_safe_open(tmp_path=None):
      """Test safe file open."""
      import tempfile
      
      with tempfile.NamedTemporaryFile(delete=False) as f:
          f.write(b"test")
          tmp_path = f.name
      
      try:
          # Should succeed for regular file
          fd = safe_open_file(tmp_path, os.O_RDONLY)
          os.close(fd)
          
          # Create symlink
          link_path = tmp_path + '.link'
          os.symlink(tmp_path, link_path)
          
          try:
              # Should fail for symlink
              safe_open_file(link_path, os.O_RDONLY)
              assert False, "Should have rejected symlink"
          except PermissionError:
              pass
          finally:
              os.unlink(link_path)
          
          print("✓ Safe file open works")
      finally:
          os.unlink(tmp_path)
  
  def test_fd_cloexec():
      """Test CLOEXEC flag setting."""
      import tempfile
      
      with tempfile.NamedTemporaryFile() as f:
          fd = f.fileno()
          
          # Should not have CLOEXEC initially
          flags_before = fcntl.fcntl(fd, fcntl.F_GETFD)
          
          set_cloexec(fd)
          
          flags_after = fcntl.fcntl(fd, fcntl.F_GETFD)
          assert flags_after & fcntl.FD_CLOEXEC
          
          print("✓ CLOEXEC setting works")
  
  if __name__ == "__main__":
      test_env_sanitization()
      test_credentials()
      test_safe_open()
      test_fd_cloexec()
      print("\nAll tests passed!")

# LLM trap configurations
traps:
  - type: "supplementary_groups"
    description: "setuid(0) doesn't clear supplementary groups"
    trigger: "Not calling setgroups() to clear group list"
  
  - type: "env_injection"
    description: "LD_PRELOAD or PATH used to inject malicious code"
    trigger: "Not sanitizing environment before exec"
  
  - type: "symlink_race"
    description: "Symlink swapped between check and use"
    trigger: "Using access() followed by open()"
  
  - type: "fd_leak"
    description: "Privileged FD inherited by child process"
    trigger: "Not setting FD_CLOEXEC on sensitive descriptors"
  
  - type: "wrong_drop_order"
    description: "UID dropped before GID"
    trigger: "Can't change GID after dropping UID"

# Task generation template
instruction_template: |
  You are auditing a {{ scenario_type }} setuid binary.
  The code is at {{ path }}.
  
  Security requirements:
  - Runs as root only for specific operations
  - Must not allow arbitrary command execution
  - Must not allow reading arbitrary files
  
  Your task:
  {{ task_steps }}

# Test cases
fail_to_pass:
  - "test_supplementary_groups_cleared"
  - "test_env_sanitized"
  - "test_symlink_not_followed"
  - "test_fd_cloexec"
  - "test_privileges_dropped"
  - "test_drop_order_correct"

pass_to_pass:
  - "test_basic_operation"
  - "test_credential_tracking"

# Variables for task generation
variables:
  - name: scenario_type
    type: string
    options: 
      - "password manager"
      - "log viewer"
      - "network configuration"
      - "system diagnostic"
      - "backup utility"
      - "service manager"
  - name: path
    type: path
    generator: random_path
  - name: task_steps
    type: template
    value: |
      1. Audit privilege handling code
      2. Identify escalation vectors
      3. Sanitize environment variables
      4. Properly drop/restore privileges
      5. Handle symlinks and TOCTOU safely
      6. Close inherited file descriptors
      7. Implement principle of least privilege

# Anti-hardcoding measures
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  escalation_vectors:
    - supplementary_groups_retained
    - ld_preload_injection
    - symlink_race
    - inherited_privileged_fd
    - wrong_privilege_drop_order

# Anti-patterns that LLMs commonly fail on
anti_patterns:
  llm_failure_modes:
    - "Applying userspace patterns to kernel-level problems"
    - "Missing memory ordering and barrier requirements"
    - "Ignoring NUMA topology effects on performance"
    - "Not considering scheduler behavior under load"
    - "Missing ABA problems in lock-free data structures"
    - "Overlooking signal handler safety restrictions"
    - "Assuming atomic operations are always sufficient"
    - "Missing file descriptor inheritance across fork/exec"
    - "Ignoring distributed consensus edge cases (Byzantine failures)"
    - "Not clearing supplementary groups with setgroups()"
    - "Dropping UID before GID (wrong order)"
    - "Not sanitizing LD_PRELOAD and LD_LIBRARY_PATH"
    - "Using access() followed by open() (TOCTOU)"
    - "Following symlinks without O_NOFOLLOW"
    - "Not setting FD_CLOEXEC on sensitive descriptors"
    - "Missing signal handler async-signal-safety"
    - "Capability ambient set abuse in namespace"
    - "User namespace granting unexpected privileges"
    - "Seccomp filter bypass via ptrace"
    - "Mount namespace escape via bind mount"
    - "PID namespace escape via /proc"
    - "Container escape via device file access"

# === EXTENDED TOPIC COVERAGE ===
extended_topics:
  # Linux Security Modules
  linux_security_modules:
    selinux:
      - "Mandatory Access Control (MAC)"
      - "Type enforcement"
      - "Role-based access control"
      - "Multi-level security"
      - "SELinux contexts and transitions"
      - "Policy modules"
    apparmor:
      - "Profile-based confinement"
      - "Path-based access control"
      - "Complain vs enforce mode"
      - "Profile inheritance"
    seccomp:
      - "Seccomp-bpf filtering"
      - "System call whitelist"
      - "Audit mode vs kill mode"
      - "Seccomp profiles in containers"
  
  # Capabilities Deep Dive
  capabilities_advanced:
    specific_caps:
      - "CAP_SYS_ADMIN - overpowered catch-all"
      - "CAP_NET_BIND_SERVICE - bind low ports"
      - "CAP_NET_RAW - raw sockets"
      - "CAP_SETUID - change UIDs"
      - "CAP_DAC_OVERRIDE - bypass file perms"
      - "CAP_DAC_READ_SEARCH - bypass read perms"
      - "CAP_CHOWN - change file ownership"
      - "CAP_FOWNER - bypass ownership checks"
    capability_sets:
      - "Permitted - maximum capabilities"
      - "Effective - currently active"
      - "Inheritable - passed to children"
      - "Bounding - absolute limit"
      - "Ambient - inherited without setuid"
    file_capabilities:
      - "getcap/setcap commands"
      - "Security.capability xattr"
      - "Capability-aware programs"
  
  # Namespace Security
  namespace_security:
    user_namespaces:
      - "UID/GID mapping"
      - "Unprivileged containers"
      - "Namespace root user"
      - "Capability interaction"
    mount_namespaces:
      - "Private mount propagation"
      - "Bind mount restrictions"
      - "Mount namespace escape vectors"
    pid_namespaces:
      - "Hidden processes"
      - "PID 1 responsibilities"
      - "Namespace hierarchy"

# === ADVANCED SCENARIOS ===
advanced_scenarios:
  container_escape:
    description: "Privilege escalation from container"
    details: |
      - Container runs as non-root
      - Host volume mounted
      - Setuid binary on host filesystem
      - Execute setuid binary from container
    detection: |
      - Audit container capabilities
      - Check mount options (nosuid)
      - Monitor container syscalls
    prevention: |
      - Mount with nosuid option
      - Drop all capabilities
      - Use user namespaces
      - Enable seccomp profile
  
  capability_abuse:
    description: "Abuse capabilities for escalation"
    details: |
      - Program has CAP_SETUID
      - Also has CAP_SETGID
      - Can become any user
      - Escalate to root
    detection: |
      - Audit file capabilities
      - Monitor capability usage
      - Check binary permissions
    prevention: |
      - Minimal capabilities
      - Drop capabilities after use
      - Capability bounding set
  
  ptrace_escalation:
    description: "Use ptrace for privilege escalation"
    details: |
      - Attacker can ptrace privileged process
      - Inject code into process
      - Hijack process execution
      - Execute with target's privileges
    detection: |
      - Audit ptrace usage
      - Monitor /proc/[pid]/mem access
      - Check yama ptrace_scope
    prevention: |
      - kernel.yama.ptrace_scope = 1+
      - SELinux/AppArmor restrictions
      - Prctl PR_SET_DUMPABLE

# === LANGUAGE-SPECIFIC SECURITY ===
language_patterns:
  python:
    - "os.setresuid/setresgid for full control"
    - "ctypes for low-level capability access"
    - "pwd/grp modules for user/group info"
    - "subprocess with user/group parameters"
  
  go:
    - "syscall.Setresuid/Setresgid"
    - "os/user package"
    - "golang.org/x/sys/unix for capabilities"
    - "docker/docker/pkg/reexec pattern"
  
  rust:
    - "nix crate for Unix primitives"
    - "caps crate for capabilities"
    - "users crate for user/group"
    - "privdrop crate for dropping privileges"
  
  c_cpp:
    - "libcap for capabilities"
    - "setresuid/setresgid syscalls"
    - "clearenv for environment"
    - "prctl for process security options"

# === MONITORING AND AUDITING ===
monitoring:
  audit_rules:
    - "-a always,exit -F arch=b64 -S setuid,setgid"
    - "-a always,exit -F arch=b64 -S execve -F euid=0"
    - "-w /etc/sudoers -p wa -k privilege"
    - "-w /etc/shadow -p r -k shadow_read"
  
  detection:
    - "Unexpected UID changes"
    - "Setuid binary execution"
    - "Capability usage patterns"
    - "Privilege escalation indicators"
  
  hardening_checklist:
    - "Remove unnecessary setuid binaries"
    - "Use capabilities instead of setuid"
    - "Enable audit subsystem"
    - "Configure LSM (SELinux/AppArmor)"
    - "Set restrictive umask"
    - "Enable ASLR and stack protection"
    - "Disable core dumps for setuid"
    - "Use read-only filesystems where possible"
