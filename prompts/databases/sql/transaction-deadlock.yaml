id: "db-sql-transaction-deadlock-001"
version: "2.0.0"
category: "databases"
subcategory: "sql"

# =============================================================================
# LLM GENERATION FRAMEWORK
# =============================================================================
# This configuration enables generation of 10,000+ unique, complex tasks
# related to transaction deadlocks across all major database systems.
# =============================================================================

generation_framework:
  # Difficulty parameters - SIGNIFICANTLY increased for database architect-level challenges
  time_range: [5400, 14400]  # 90-240 minutes for database architects with internals expertise
  command_steps: [80, 200]   # Requires extensive multi-layer investigation and debugging
  
  generation_targets:
    minimum_difficulty: "90+ minutes, requires deep database lock manager and concurrency control internals expertise"
    target_audience: "Principal Database Architects and concurrency control engineers with 10+ years experience"
    complexity_level: "Nightmare - requires synthesizing knowledge across lock managers, MVCC implementations, and distributed transaction protocols"
  
  multi_agent_orchestration:
    description: "Coordinate 5-8 specialized database agents for complex deadlock debugging"
    required_agents:
      - name: "lock_manager_debugger"
        role: "Debug lock acquisition, escalation, and wait-for graph analysis"
        expertise: ["lock table internals", "wait-for graphs", "deadlock detection algorithms", "lock escalation"]
      - name: "mvcc_analyst"
        role: "Analyze MVCC version chains and snapshot isolation interactions"
        expertise: ["version visibility", "snapshot construction", "garbage collection", "write skew detection"]
      - name: "isolation_level_expert"
        role: "Debug isolation level interactions and anomaly scenarios"
        expertise: ["serializable snapshot isolation", "predicate locks", "gap locks", "key-range locks"]
      - name: "distributed_deadlock_detector"
        role: "Detect and resolve deadlocks across distributed transactions"
        expertise: ["global wait-for graphs", "timeout-based detection", "wound-wait protocols", "2PC deadlocks"]
      - name: "query_plan_lock_analyzer"
        role: "Analyze query plan impact on lock acquisition patterns"
        expertise: ["index access locking", "table scan locks", "join order lock patterns", "parallel query locks"]
      - name: "application_concurrency_debugger"
        role: "Debug application-level concurrency patterns causing database deadlocks"
        expertise: ["connection pool transactions", "ORM locking", "retry logic bugs", "transaction scope issues"]
      - name: "resource_contention_profiler"
        role: "Profile lock wait times and contention hot spots"
        expertise: ["lock wait analysis", "hot row detection", "contention metrics", "lock timeout tuning"]
      - name: "recovery_protocol_analyst"
        role: "Analyze recovery and rollback behavior during deadlock resolution"
        expertise: ["victim selection", "rollback cost estimation", "partial rollback", "savepoint handling"]
    
    cross_engine_attack_chains:
      - chain: "lock_ordering_violation -> wait_cycle -> deadlock_detection_delay -> cascade_abort -> resource_exhaustion"
        description: "Lock ordering bug creates deadlock cycle that cascades into resource exhaustion"
      - chain: "index_scan_lock -> fk_validation_lock -> trigger_lock -> circular_dependency -> mass_rollback"
        description: "Index access triggers FK validation and triggers creating circular lock dependency"
      - chain: "gap_lock_conflict -> insert_intention_wait -> deadlock -> retry_storm -> amplified_contention"
        description: "Gap lock deadlock causes retry storm that amplifies original contention"
      - chain: "distributed_2pc_lock -> coordinator_timeout -> in_doubt_transaction -> lock_hold -> cascade_block"
        description: "Distributed transaction failure leaves locks held blocking entire application"
    
    parallel_analysis_requirements:
      - "Concurrent lock graph construction across all database sessions"
      - "Parallel wait-for chain analysis for multi-database deadlocks"
      - "Simultaneous MVCC version chain traversal for conflict detection"
      - "Coordinated query plan analysis for lock prediction"
    
    agent_handoff_scenarios:
      - from: "lock_manager_debugger"
        to: "query_plan_lock_analyzer"
        trigger: "Lock pattern traced to specific query plan behavior"
      - from: "mvcc_analyst"
        to: "isolation_level_expert"
        trigger: "MVCC conflict reveals isolation level interaction"
      - from: "distributed_deadlock_detector"
        to: "recovery_protocol_analyst"
        trigger: "Distributed deadlock requires complex recovery analysis"
  
  multi_conversation_workflow:
    phase_1_research: |
      Research obscure database deadlock behaviors and edge cases including:
      - Database-specific lock manager implementations
      - Lock compatibility matrices for each database system
      - Deadlock detection algorithm variations
      - Recovery and rollback mechanisms
      - Version-specific quirks and known issues
    
    phase_2_creation: |
      Create task with hidden complexity and traps including:
      - Subtle lock ordering violations
      - Implicit lock acquisition through constraints
      - Cross-version behavior differences
      - Configuration-dependent behaviors
      - Workload-specific deadlock patterns
    
    phase_3_amplification: |
      Add difficulty multipliers and edge cases:
      - Distributed transaction scenarios
      - Mixed isolation level interactions
      - Resource contention patterns
      - Recovery scenario complications
      - Performance constraint requirements
    
    phase_4_verification: |
      Validate task requires deep database expertise:
      - Must understand lock manager internals at implementation level
      - Must know database-specific locking, MVCC, and isolation behaviors
      - Cannot be solved by simple pattern matching or lock ordering fixes
      - Requires multi-step debugging with lock graph analysis and query plan correlation
      - Tests deep understanding of concurrency control across isolation levels
      - Has at least 10+ deeply interacting traps across locking/MVCC/query/application layers
      - Has cascading failure modes that span lock management, transaction coordination, and recovery
      - Requires knowledge of lock manager internals, MVCC implementations, and distributed lock protocols
      - Would take experienced database architects 90+ minutes
      - Involves distributed deadlock scenarios with complex recovery requirements
  
  quality_requirements:
    - "Must require understanding of database lock manager at kernel level"
    - "Must have at least 8 non-obvious failure modes with complex lock interactions"
    - "Must not be solvable by simple Google search or standard lock ordering"
    - "Must require deep analysis of lock acquisition patterns and MVCC interactions"
    - "Must involve cross-system, version-specific, or isolation-level-specific knowledge"
    - "Solution must handle edge cases in production workloads with high concurrency"
    - "90+ minutes for experienced database architects, 180+ for senior engineers"
    - "Requires synthesizing lock management, MVCC internals, query execution, and distributed transaction protocols"
    - "Must involve scenarios with FK locks, index locks, and gap locks interacting"
    - "Requires understanding of deadlock detection algorithms and victim selection strategies"

# =============================================================================
# TOPIC UNIVERSE - 150+ Deadlock-Related Topics
# =============================================================================

topic_universe:
  # ---------------------------------------------------------------------------
  # Transaction Isolation Levels & Their Lock Behaviors
  # ---------------------------------------------------------------------------
  isolation_levels:
    read_uncommitted:
      description: "No read locks, allows dirty reads"
      lock_behavior: "Write locks only, minimal deadlock risk"
      databases: ["SQL Server", "MySQL", "PostgreSQL (maps to READ COMMITTED)"]
      deadlock_scenarios:
        - "Write-write conflicts on same rows"
        - "Constraint violation during concurrent inserts"
      version_quirks:
        sql_server: "Allows dirty reads but still acquires exclusive locks for writes"
        mysql_innodb: "Uses row-level exclusive locks for writes"
    
    read_committed:
      description: "Read locks released immediately after read"
      lock_behavior: "Short-duration shared locks"
      databases: ["PostgreSQL (default)", "Oracle (default)", "SQL Server", "MySQL"]
      implementation_variants:
        locking_read_committed: "SQL Server default - uses locks"
        mvcc_read_committed: "PostgreSQL/Oracle - uses snapshots"
      deadlock_scenarios:
        - "Lock upgrade from shared to exclusive"
        - "Concurrent index range scans with updates"
        - "Foreign key validation locks"
    
    repeatable_read:
      description: "Read locks held until transaction end"
      lock_behavior: "Long-duration shared locks"
      databases: ["MySQL InnoDB (default)", "SQL Server", "PostgreSQL"]
      implementation_variants:
        mysql_innodb: "Uses next-key locking, prevents phantoms"
        postgresql: "Uses MVCC, snapshot isolation"
        sql_server: "Uses lock-based approach"
      deadlock_scenarios:
        - "Gap lock conflicts in MySQL"
        - "Lock duration causing resource starvation"
        - "Phantom prevention lock conflicts"
    
    serializable:
      description: "Full isolation, transactions appear sequential"
      lock_behavior: "Range locks, key-range locks, predicate locks"
      databases: ["All major databases"]
      implementation_variants:
        sql_server: "Key-range locks on indexes"
        postgresql: "Serializable Snapshot Isolation (SSI)"
        mysql_innodb: "Next-key locks + gap locks"
        oracle: "Uses undo segments + ORA-08177 errors"
      deadlock_scenarios:
        - "Read-write skew detection conflicts"
        - "Range lock vs point lock conflicts"
        - "Serialization failure cascades"
    
    snapshot_isolation:
      description: "Each transaction sees consistent snapshot"
      lock_behavior: "Write locks + conflict detection"
      databases: ["SQL Server (explicit)", "Oracle", "PostgreSQL (basis of SERIALIZABLE)"]
      deadlock_scenarios:
        - "Write-write conflict detection"
        - "First-committer-wins race conditions"
        - "Long-running snapshot resource exhaustion"

  # ---------------------------------------------------------------------------
  # Lock Types and Their Interactions
  # ---------------------------------------------------------------------------
  lock_types:
    shared_locks:
      abbreviation: "S"
      purpose: "Allow concurrent reads"
      compatibility: "Compatible with other S locks, conflicts with X locks"
      acquisition_triggers:
        - "SELECT statements (in locking isolation levels)"
        - "Foreign key reference validation"
        - "Index scan for read operations"
      
    exclusive_locks:
      abbreviation: "X"
      purpose: "Exclusive access for modifications"
      compatibility: "Conflicts with all other lock types"
      acquisition_triggers:
        - "INSERT, UPDATE, DELETE statements"
        - "SELECT ... FOR UPDATE"
        - "DDL operations"
      
    update_locks:
      abbreviation: "U"
      purpose: "Prevent conversion deadlock"
      compatibility: "Compatible with S, conflicts with U and X"
      databases: ["SQL Server", "DB2"]
      acquisition_triggers:
        - "UPDATE statement during scan phase"
        - "Explicit UPDLOCK hint"
      deadlock_prevention: "Prevents S-to-X upgrade deadlock"
      
    intent_locks:
      types:
        - name: "Intent Shared (IS)"
          purpose: "Signal intent to acquire S lock on child"
        - name: "Intent Exclusive (IX)"
          purpose: "Signal intent to acquire X lock on child"
        - name: "Shared with Intent Exclusive (SIX)"
          purpose: "S lock on resource + IX on children"
      hierarchy: "Database > Table > Page > Row"
      deadlock_scenarios:
        - "Intent lock escalation conflicts"
        - "Hierarchy traversal deadlocks"
    
    schema_locks:
      types:
        - name: "Schema Modification (Sch-M)"
          purpose: "DDL operations"
        - name: "Schema Stability (Sch-S)"
          purpose: "Query compilation"
      deadlock_scenarios:
        - "DDL during active queries"
        - "Schema modification race conditions"
    
    key_range_locks:
      purpose: "Prevent phantom reads in SERIALIZABLE"
      types:
        - "RangeS-S: Shared range, shared row"
        - "RangeS-U: Shared range, update row"
        - "RangeI-N: Insert range (gap)"
        - "RangeX-X: Exclusive range, exclusive row"
      databases: ["SQL Server"]
      deadlock_scenarios:
        - "Range scan conflicts with point inserts"
        - "Overlapping range lock requests"
    
    gap_locks:
      purpose: "Lock gap between index records"
      databases: ["MySQL InnoDB"]
      behavior: "Prevents inserts in gap, not reads"
      deadlock_scenarios:
        - "Concurrent gap locks on same gap"
        - "Gap lock + insert intention lock conflict"
        - "Gap locks on non-existent rows"
    
    next_key_locks:
      purpose: "Lock index record + gap before it"
      databases: ["MySQL InnoDB"]
      composition: "Record lock + gap lock"
      deadlock_scenarios:
        - "Range scan + point update conflicts"
        - "Delete + insert on same key range"
    
    predicate_locks:
      purpose: "Lock based on search condition"
      databases: ["PostgreSQL (SSI)", "SQL Server (SERIALIZABLE)"]
      deadlock_scenarios:
        - "Overlapping predicate conflicts"
        - "Predicate vs row lock conflicts"

  # ---------------------------------------------------------------------------
  # Lock Granularity Levels
  # ---------------------------------------------------------------------------
  lock_granularity:
    row_level:
      description: "Finest granularity, highest concurrency"
      overhead: "High memory for lock table"
      use_cases: ["OLTP workloads", "High concurrency applications"]
      databases: ["All modern databases support"]
      
    page_level:
      description: "Lock entire data page (typically 8KB)"
      overhead: "Medium memory, medium concurrency"
      databases: ["SQL Server (can escalate)", "Sybase"]
      deadlock_scenarios:
        - "Different rows on same page causing conflicts"
        - "Page-level deadlocks from row operations"
    
    extent_level:
      description: "Lock group of pages (typically 64KB)"
      databases: ["SQL Server (for allocation)"]
      use_cases: ["Bulk operations", "Table scans"]
      
    table_level:
      description: "Lock entire table"
      overhead: "Lowest memory, lowest concurrency"
      use_cases: ["Bulk loads", "DDL operations", "Full table scans"]
      deadlock_scenarios:
        - "Table lock vs row lock escalation"
        - "DDL operations blocking DML"
    
    database_level:
      description: "Lock entire database"
      use_cases: ["Database maintenance", "Backup operations"]
      databases: ["SQL Server (for some operations)"]
    
    lock_escalation:
      description: "Automatic upgrade from fine to coarse granularity"
      triggers:
        - "Exceeding lock count threshold"
        - "Memory pressure on lock manager"
      thresholds:
        sql_server: "5000 locks per table (default)"
        mysql: "Configurable via innodb_lock_escalation"
      deadlock_scenarios:
        - "Unexpected escalation during transaction"
        - "Escalation race between transactions"

  # ---------------------------------------------------------------------------
  # Deadlock Detection Algorithms
  # ---------------------------------------------------------------------------
  deadlock_detection:
    wait_for_graph:
      description: "Build graph of transaction dependencies"
      algorithm: |
        1. Nodes represent transactions
        2. Edges represent wait-for relationships
        3. Detect cycles in graph
        4. Select victim transaction to abort
      implementations:
        postgresql: "Regular background process checks"
        mysql_innodb: "Synchronous check on lock wait"
        sql_server: "Background thread every 5 seconds (configurable)"
        oracle: "Immediate detection on lock wait"
      
    timeout_based:
      description: "Abort transaction after wait timeout"
      parameters:
        postgresql: "lock_timeout, deadlock_timeout"
        mysql: "innodb_lock_wait_timeout"
        sql_server: "SET LOCK_TIMEOUT"
        oracle: "Distributed transaction timeout"
      limitations:
        - "May abort non-deadlocked transactions"
        - "Delay in detection"
        - "False positives under heavy load"
    
    cycle_detection_algorithms:
      - name: "Depth-First Search (DFS)"
        complexity: "O(V + E)"
        usage: "Most common implementation"
      - name: "Knuth's Algorithm"
        usage: "Some embedded databases"
      - name: "Chandy-Misra-Haas"
        usage: "Distributed deadlock detection"

  # ---------------------------------------------------------------------------
  # Deadlock Prevention Strategies
  # ---------------------------------------------------------------------------
  deadlock_prevention:
    wound_wait:
      description: "Older transaction 'wounds' younger"
      behavior: "Young transaction waiting for old is aborted"
      use_cases: ["Distributed databases", "Some NoSQL systems"]
      
    wait_die:
      description: "Older transaction waits, younger dies"
      behavior: "Old transaction waits; young aborts if waiting for old"
      use_cases: ["Distributed databases"]
      
    no_wait:
      description: "Never wait for locks"
      behavior: "Immediately abort if lock unavailable"
      use_cases: ["High-throughput OLTP", "Real-time systems"]
      implementation: "SELECT ... FOR UPDATE NOWAIT"
      
    cautious_waiting:
      description: "Wait only if holder is not waiting"
      behavior: "Abort if potential deadlock detected"
      use_cases: ["Some research systems"]
    
    lock_ordering:
      description: "Always acquire locks in consistent order"
      implementation_patterns:
        - "Order by primary key"
        - "Order by table name then key"
        - "Hierarchical locking protocol"
      limitations:
        - "Requires knowledge of all resources upfront"
        - "May not be possible for dynamic queries"

  # ---------------------------------------------------------------------------
  # MVCC Implementations
  # ---------------------------------------------------------------------------
  mvcc_implementations:
    postgresql:
      name: "PostgreSQL MVCC"
      mechanism: "Tuple versioning with xmin/xmax"
      components:
        - "Transaction ID (xid) assignment"
        - "Tuple header with xmin, xmax, cmin, cmax"
        - "Visibility map"
        - "Vacuum process for cleanup"
      deadlock_behavior:
        - "Write-write conflicts cause blocking"
        - "Read-write generally non-blocking"
        - "SSI can cause serialization failures"
      version_quirks:
        pre_9_1: "Read locks could cause issues"
        post_13: "Improved serializable snapshot isolation"
    
    mysql_innodb:
      name: "InnoDB MVCC"
      mechanism: "Undo logs + read views"
      components:
        - "Clustered index with DB_TRX_ID, DB_ROLL_PTR"
        - "Undo log segments"
        - "Read view for consistent reads"
        - "Purge thread for cleanup"
      deadlock_behavior:
        - "Uses locking for writes"
        - "Gap locks for repeatable read"
        - "Immediate deadlock detection"
      version_quirks:
        pre_5_7: "Limited deadlock information"
        8_0: "Improved performance schema deadlock info"
    
    oracle:
      name: "Oracle MVCC"
      mechanism: "Undo segments + SCN"
      components:
        - "System Change Number (SCN)"
        - "Undo tablespace"
        - "Consistent read from undo"
        - "Automatic undo management"
      deadlock_behavior:
        - "ORA-00060 for deadlock"
        - "ORA-08177 for serialization failure"
        - "ITL waits for row-level locking"
      version_quirks:
        pre_12c: "Manual undo management"
        19c_plus: "Automatic indexing may affect locking"
    
    sql_server:
      name: "SQL Server Versioning"
      mechanism: "tempdb version store (RCSI/SI)"
      components:
        - "Row versioning in tempdb"
        - "14-byte version tag"
        - "Version store cleanup"
      modes:
        read_committed_snapshot: "MVCC for READ COMMITTED"
        snapshot_isolation: "Explicit snapshot transactions"
      deadlock_behavior:
        - "Update conflicts in SI"
        - "Traditional locking still available"
        - "Lock-based still default"

  # ---------------------------------------------------------------------------
  # Write-Ahead Logging (WAL) and Deadlocks
  # ---------------------------------------------------------------------------
  wal_mechanics:
    wal_basics:
      description: "Log changes before modifying data pages"
      purpose: "Durability and crash recovery"
      relation_to_deadlocks:
        - "Log buffer contention"
        - "Log flush waits"
        - "Recovery lock conflicts"
    
    log_buffer:
      description: "In-memory buffer for log records"
      contention_scenarios:
        - "High transaction rate overwhelming buffer"
        - "Large transactions filling buffer"
        - "Log switch contention"
    
    checkpoint_algorithms:
      fuzzy_checkpoint:
        description: "Background page flushing"
        databases: ["PostgreSQL", "MySQL InnoDB"]
        deadlock_impact: "Minimal direct impact"
      
      sharp_checkpoint:
        description: "Flush all dirty pages at once"
        databases: ["Some embedded databases"]
        deadlock_impact: "Can cause brief blocking"
      
      aries:
        description: "Analysis, Redo, Undo recovery"
        databases: ["DB2", "SQL Server", "PostgreSQL influenced"]
        components:
          - "Log Sequence Number (LSN)"
          - "Dirty page table"
          - "Transaction table"
          - "Three-phase recovery"

  # ---------------------------------------------------------------------------
  # Database-Specific Lock Manager Details
  # ---------------------------------------------------------------------------
  lock_managers:
    postgresql:
      lock_table: "Shared memory hash table"
      lock_modes: "8 modes including AccessShareLock to AccessExclusiveLock"
      deadlock_detector:
        check_interval: "deadlock_timeout parameter (1s default)"
        algorithm: "Wait-for graph with DFS"
      monitoring:
        - "pg_locks view"
        - "pg_stat_activity"
        - "log_lock_waits parameter"
      
    mysql_innodb:
      lock_table: "In-memory lock system"
      lock_modes: "S, X, IS, IX, gap, next-key, insert intention"
      deadlock_detector:
        check_interval: "Immediate on lock wait"
        algorithm: "Wait-for graph"
      monitoring:
        - "SHOW ENGINE INNODB STATUS"
        - "information_schema.INNODB_LOCKS"
        - "performance_schema.data_locks (8.0+)"
      
    sql_server:
      lock_table: "Lock hash table in memory"
      lock_modes: "S, U, X, IS, IX, SIX, Sch-S, Sch-M, BU, Key-range"
      deadlock_detector:
        check_interval: "5 seconds (lock monitor)"
        algorithm: "Wait-for graph"
      monitoring:
        - "sys.dm_tran_locks"
        - "sys.dm_os_waiting_tasks"
        - "Extended Events for deadlock graphs"
      
    oracle:
      lock_table: "Enqueue resources"
      lock_modes: "RS, RX, S, SRX, X"
      deadlock_detector:
        check_interval: "3 seconds typical"
        algorithm: "Wait-for graph"
      monitoring:
        - "V$LOCK, V$LOCKED_OBJECT"
        - "DBA_WAITERS, DBA_BLOCKERS"
        - "ASH (Active Session History)"

  # ---------------------------------------------------------------------------
  # Recovery Algorithms
  # ---------------------------------------------------------------------------
  recovery_algorithms:
    aries_recovery:
      description: "Algorithms for Recovery and Isolation Exploiting Semantics"
      phases:
        analysis: "Scan log to determine dirty pages and active transactions"
        redo: "Reapply all logged changes"
        undo: "Rollback uncommitted transactions"
      relation_to_deadlocks:
        - "Recovery locks during undo"
        - "Lock restoration after crash"
    
    shadow_paging:
      description: "Maintain shadow copy of pages"
      use_cases: ["Some embedded databases", "SQLite (WAL mode alternative)"]
      deadlock_impact: "Minimal due to copy-on-write"
    
    logging_variants:
      undo_logging: "Log old values before modification"
      redo_logging: "Log new values after modification"
      undo_redo_logging: "Log both (most common)"

  # ---------------------------------------------------------------------------
  # Query Optimization and Lock Impact
  # ---------------------------------------------------------------------------
  query_optimization:
    optimizer_types:
      cost_based:
        description: "Estimate cost of different plans"
        lock_impact: "Plan choice affects lock patterns"
      rule_based:
        description: "Apply transformation rules"
        lock_impact: "Predictable but may not optimize for locking"
      adaptive:
        description: "Adjust plan based on runtime statistics"
        databases: ["Oracle 12c+", "SQL Server 2017+"]
        lock_impact: "Plan changes may cause different lock patterns"
    
    join_algorithms:
      nested_loop:
        lock_pattern: "Sequential row locks on inner table"
        deadlock_risk: "Low if consistent order"
      hash_join:
        lock_pattern: "Bulk locks during build phase"
        deadlock_risk: "Medium - holds locks during build"
      merge_join:
        lock_pattern: "Sequential access on both sides"
        deadlock_risk: "Low with consistent ordering"
      index_join:
        lock_pattern: "Index + table locks interleaved"
        deadlock_risk: "Medium - depends on index order"

  # ---------------------------------------------------------------------------
  # Index Types and Lock Interactions
  # ---------------------------------------------------------------------------
  index_types:
    btree:
      description: "Balanced tree index"
      lock_behavior:
        - "Page locks during splits"
        - "Key-range locks for serializable"
      deadlock_scenarios:
        - "Index page split during concurrent inserts"
        - "Root page contention"
    
    hash_index:
      description: "Hash-based index"
      lock_behavior:
        - "Bucket locks"
        - "No range locking support"
      deadlock_scenarios:
        - "Bucket overflow chain locks"
    
    bitmap_index:
      description: "Bitmap for low-cardinality columns"
      lock_behavior:
        - "Bitmap segment locks"
        - "Often table-level for updates"
      deadlock_scenarios:
        - "Bitmap merge conflicts"
      databases: ["Oracle"]
    
    gist_gin_brin:
      description: "PostgreSQL specialized indexes"
      lock_behavior:
        - "GiST: Page-level locks during operations"
        - "GIN: Pending list locks"
        - "BRIN: Range-level locks"

  # ---------------------------------------------------------------------------
  # Partitioning and Deadlocks
  # ---------------------------------------------------------------------------
  partitioning:
    partition_types:
      range: "Partition by value ranges"
      hash: "Partition by hash function"
      list: "Partition by explicit value lists"
      composite: "Multiple partitioning methods"
    
    lock_implications:
      partition_pruning: "May reduce lock scope"
      partition_maintenance: "DDL locks on partitions"
      cross_partition_queries: "May require multiple partition locks"
    
    deadlock_scenarios:
      - "Cross-partition transactions"
      - "Partition maintenance during queries"
      - "Global index updates"

  # ---------------------------------------------------------------------------
  # Replication and Deadlocks
  # ---------------------------------------------------------------------------
  replication:
    synchronous:
      description: "Wait for replica acknowledgment"
      deadlock_implications:
        - "Network delays affecting lock duration"
        - "Replica conflicts"
    
    asynchronous:
      description: "Don't wait for replica"
      deadlock_implications:
        - "Replica may see different lock state"
        - "Conflict resolution needed"
    
    semi_synchronous:
      description: "Wait for at least one replica"
      databases: ["MySQL"]
      deadlock_implications:
        - "Partial guarantee complicates reasoning"

  # ---------------------------------------------------------------------------
  # Consensus Protocols
  # ---------------------------------------------------------------------------
  consensus_protocols:
    two_phase_commit:
      description: "Prepare + Commit phases"
      deadlock_implications:
        - "Coordinator failure holds locks"
        - "Participant timeout decisions"
        - "Distributed deadlock detection needed"
    
    three_phase_commit:
      description: "Adds pre-commit phase"
      deadlock_implications:
        - "Reduced blocking but more complex"
    
    paxos:
      description: "Consensus for distributed agreement"
      deadlock_implications:
        - "Lock state must be agreed upon"
        - "Network partitions affect locks"
    
    raft:
      description: "Leader-based consensus"
      deadlock_implications:
        - "Leader election affects lock ownership"
        - "Log replication for lock state"

# =============================================================================
# TRAP TYPES - 75+ Deadlock Traps
# =============================================================================

trap_types:
  # ---------------------------------------------------------------------------
  # Lock Ordering Traps
  # ---------------------------------------------------------------------------
  lock_ordering:
    - trap_id: "LO-001"
      name: "Classic Lock Ordering Violation"
      description: "Transaction A locks X then Y, Transaction B locks Y then X"
      trigger: "Acquiring locks in inconsistent order across transactions"
      difficulty: "medium"
      detection: "Wait-for graph shows cycle"
      databases: ["All"]
    
    - trap_id: "LO-002"
      name: "Hidden Lock Ordering via Indexes"
      description: "Different index access paths cause different lock orders"
      trigger: "Query plan changes due to statistics update"
      difficulty: "hard"
      detection: "Intermittent deadlocks after analyze/statistics update"
      databases: ["All"]
    
    - trap_id: "LO-003"
      name: "FK Constraint Lock Ordering"
      description: "Implicit parent table lock from FK validation"
      trigger: "Insert into child table acquires parent lock"
      difficulty: "medium"
      detection: "Deadlock involves FK constraint"
      databases: ["All"]
    
    - trap_id: "LO-004"
      name: "Trigger-Induced Lock Ordering"
      description: "Trigger accesses tables in different order"
      trigger: "AFTER trigger on table causes secondary lock"
      difficulty: "hard"
      detection: "Deadlock graph shows trigger execution"
      databases: ["All"]
    
    - trap_id: "LO-005"
      name: "Materialized View Lock Ordering"
      description: "MV refresh locks base tables in different order"
      trigger: "Concurrent DML and MV refresh"
      difficulty: "hard"
      detection: "Deadlock during refresh operations"
      databases: ["Oracle", "PostgreSQL"]

  # ---------------------------------------------------------------------------
  # Long Transaction Traps
  # ---------------------------------------------------------------------------
  long_transactions:
    - trap_id: "LT-001"
      name: "Interactive Transaction Hold"
      description: "Transaction holds locks while waiting for user input"
      trigger: "Open transaction during application pause"
      difficulty: "easy"
      detection: "Very long lock wait times"
    
    - trap_id: "LT-002"
      name: "Application Retry Without Rollback"
      description: "Application retries operation without rolling back"
      trigger: "Exception handling doesn't rollback transaction"
      difficulty: "medium"
      detection: "Transaction accumulates locks over retries"
    
    - trap_id: "LT-003"
      name: "Connection Pool Transaction Leak"
      description: "Transaction left open when connection returned to pool"
      trigger: "Missing commit/rollback before connection release"
      difficulty: "hard"
      detection: "Ghost transactions holding locks"
    
    - trap_id: "LT-004"
      name: "Nested Transaction Misunderstanding"
      description: "Inner savepoint doesn't release outer locks"
      trigger: "Assuming nested transaction releases locks"
      difficulty: "medium"
      detection: "Locks held longer than expected"

  # ---------------------------------------------------------------------------
  # Lock Escalation Traps
  # ---------------------------------------------------------------------------
  escalation:
    - trap_id: "LE-001"
      name: "Unexpected Lock Escalation"
      description: "Row locks escalate to table lock mid-transaction"
      trigger: "Large UPDATE affecting many rows"
      difficulty: "medium"
      detection: "Sudden table-level lock appearing"
      databases: ["SQL Server", "DB2"]
    
    - trap_id: "LE-002"
      name: "Escalation Race Condition"
      description: "Two transactions escalate simultaneously"
      trigger: "Both transactions hit escalation threshold"
      difficulty: "hard"
      detection: "Deadlock at table lock level"
    
    - trap_id: "LE-003"
      name: "Partition Lock Escalation"
      description: "Locks escalate to partition level unexpectedly"
      trigger: "Many rows in same partition"
      difficulty: "medium"
      detection: "Partition-level locks in deadlock"
      databases: ["SQL Server"]

  # ---------------------------------------------------------------------------
  # Foreign Key Traps
  # ---------------------------------------------------------------------------
  foreign_key:
    - trap_id: "FK-001"
      name: "Parent Table Lock on Child Insert"
      description: "Inserting child row locks parent for validation"
      trigger: "Concurrent child inserts with parent updates"
      difficulty: "medium"
      detection: "Lock on parent table during child operation"
    
    - trap_id: "FK-002"
      name: "Cascade Delete Deadlock"
      description: "ON DELETE CASCADE causes unexpected lock pattern"
      trigger: "Deleting parent triggers cascade"
      difficulty: "hard"
      detection: "Deadlock involves cascaded deletes"
    
    - trap_id: "FK-003"
      name: "Self-Referencing FK Deadlock"
      description: "Hierarchical table with self-FK causes deadlock"
      trigger: "Moving node in hierarchy"
      difficulty: "hard"
      detection: "Same table appears multiple times in deadlock"
    
    - trap_id: "FK-004"
      name: "Deferred Constraint Check Surprise"
      description: "Deferred FK check at commit causes late lock"
      trigger: "DEFERRABLE INITIALLY DEFERRED constraint"
      difficulty: "hard"
      detection: "Lock acquired during commit phase"
      databases: ["PostgreSQL", "Oracle"]

  # ---------------------------------------------------------------------------
  # Index-Related Traps
  # ---------------------------------------------------------------------------
  index_traps:
    - trap_id: "IX-001"
      name: "Index Page Split Deadlock"
      description: "Concurrent inserts cause index page splits"
      trigger: "High insert rate on indexed column"
      difficulty: "hard"
      detection: "Deadlock in index maintenance"
    
    - trap_id: "IX-002"
      name: "Covering Index Lock Difference"
      description: "Different plans use different indexes, different locks"
      trigger: "Query plan variation"
      difficulty: "hard"
      detection: "Intermittent deadlocks with plan changes"
    
    - trap_id: "IX-003"
      name: "Index Rebuild Lock Conflict"
      description: "Online index rebuild conflicts with DML"
      trigger: "CONCURRENTLY index operation"
      difficulty: "medium"
      detection: "Long lock wait during index operation"
      databases: ["PostgreSQL", "SQL Server"]

  # ---------------------------------------------------------------------------
  # Gap Lock Traps (MySQL/InnoDB Specific)
  # ---------------------------------------------------------------------------
  gap_locks:
    - trap_id: "GL-001"
      name: "Gap Lock on Non-Existent Row"
      description: "Gap lock prevents insert of new row"
      trigger: "SELECT ... FOR UPDATE on non-existent row"
      difficulty: "medium"
      detection: "Insert blocked by gap lock"
      databases: ["MySQL InnoDB"]
    
    - trap_id: "GL-002"
      name: "Gap Lock Deadlock on Same Gap"
      description: "Two transactions both gap-lock same range"
      trigger: "Concurrent range queries"
      difficulty: "hard"
      detection: "Both transactions hold gap locks"
      databases: ["MySQL InnoDB"]
    
    - trap_id: "GL-003"
      name: "Insert Intention Lock Conflict"
      description: "Insert intention lock conflicts with gap lock"
      trigger: "INSERT into gap-locked range"
      difficulty: "medium"
      detection: "Insert waiting for gap lock"
      databases: ["MySQL InnoDB"]
    
    - trap_id: "GL-004"
      name: "Supremum Record Lock"
      description: "Lock on supremum pseudo-record"
      trigger: "Range query extending to infinity"
      difficulty: "hard"
      detection: "Lock on supremum in deadlock"
      databases: ["MySQL InnoDB"]

  # ---------------------------------------------------------------------------
  # MVCC/Snapshot Traps
  # ---------------------------------------------------------------------------
  mvcc_traps:
    - trap_id: "MV-001"
      name: "Write Skew Anomaly"
      description: "Concurrent transactions based on stale reads"
      trigger: "Read-then-write pattern in snapshot isolation"
      difficulty: "hard"
      detection: "Data constraint violation"
      databases: ["PostgreSQL", "SQL Server SI"]
    
    - trap_id: "MV-002"
      name: "Lost Update in MVCC"
      description: "Second transaction overwrites first's changes"
      trigger: "Concurrent read-modify-write"
      difficulty: "medium"
      detection: "Changes from first transaction missing"
    
    - trap_id: "MV-003"
      name: "Serialization Failure Cascade"
      description: "Multiple transactions abort due to SSI conflicts"
      trigger: "High contention on serializable"
      difficulty: "hard"
      detection: "High rate of serialization failures"
      databases: ["PostgreSQL"]

  # ---------------------------------------------------------------------------
  # Distributed Transaction Traps
  # ---------------------------------------------------------------------------
  distributed:
    - trap_id: "DT-001"
      name: "Cross-Database Deadlock"
      description: "Deadlock across database boundaries"
      trigger: "Distributed transaction spanning databases"
      difficulty: "hard"
      detection: "No single database detects deadlock"
    
    - trap_id: "DT-002"
      name: "Two-Phase Commit Timeout"
      description: "Coordinator timeout leaves participant locked"
      trigger: "Network partition during 2PC"
      difficulty: "hard"
      detection: "In-doubt transaction holding locks"
    
    - trap_id: "DT-003"
      name: "Linked Server Deadlock"
      description: "Deadlock involving linked server queries"
      trigger: "Remote query combined with local locks"
      difficulty: "hard"
      detection: "Cross-server deadlock"
      databases: ["SQL Server"]

  # ---------------------------------------------------------------------------
  # Application-Level Traps
  # ---------------------------------------------------------------------------
  application:
    - trap_id: "AP-001"
      name: "ORM N+1 Lock Pattern"
      description: "ORM generates queries with poor lock pattern"
      trigger: "Lazy loading in transaction"
      difficulty: "medium"
      detection: "Many small lock requests"
    
    - trap_id: "AP-002"
      name: "Batch Size Causing Escalation"
      description: "Batch processing exceeds lock threshold"
      trigger: "Processing too many rows in one transaction"
      difficulty: "medium"
      detection: "Escalation during batch"
    
    - trap_id: "AP-003"
      name: "Retry Storm Amplification"
      description: "Retries cause more contention"
      trigger: "All clients retry simultaneously"
      difficulty: "hard"
      detection: "Increasing deadlock rate during retry"

  # ---------------------------------------------------------------------------
  # Configuration Traps
  # ---------------------------------------------------------------------------
  configuration:
    - trap_id: "CF-001"
      name: "Lock Timeout Too Short"
      description: "Transactions abort before deadlock detection"
      trigger: "Lock timeout < deadlock detection interval"
      difficulty: "easy"
      detection: "Lock timeout errors instead of deadlock errors"
    
    - trap_id: "CF-002"
      name: "Isolation Level Mismatch"
      description: "Different sessions use different isolation levels"
      trigger: "Mixed isolation in application"
      difficulty: "hard"
      detection: "Unexpected lock behavior"
    
    - trap_id: "CF-003"
      name: "innodb_lock_wait_timeout Too Low"
      description: "MySQL times out before detecting deadlock"
      trigger: "Low timeout configuration"
      difficulty: "easy"
      detection: "Lock wait timeout errors"
      databases: ["MySQL"]

# =============================================================================
# EDGE CASES - 120+ Edge Cases
# =============================================================================

edge_cases:
  # ---------------------------------------------------------------------------
  # NULL Handling Edge Cases
  # ---------------------------------------------------------------------------
  null_handling:
    - case_id: "NULL-001"
      name: "NULL in Unique Index"
      description: "Multiple NULLs allowed in unique index (most databases)"
      lock_implication: "NULL rows may have different lock behavior"
      databases_vary: true
      
    - case_id: "NULL-002"
      name: "NULL Comparison in WHERE"
      description: "NULL comparisons don't use index as expected"
      lock_implication: "May cause table scan instead of index scan"
    
    - case_id: "NULL-003"
      name: "NULL in Foreign Key"
      description: "NULL FK doesn't require parent row"
      lock_implication: "No parent lock for NULL FK values"

  # ---------------------------------------------------------------------------
  # Unicode/Collation Edge Cases
  # ---------------------------------------------------------------------------
  unicode_collation:
    - case_id: "UC-001"
      name: "Case-Insensitive Collation Lock"
      description: "Different case matches same lock resource"
      lock_implication: "Lock conflicts on 'ABC' and 'abc'"
    
    - case_id: "UC-002"
      name: "Unicode Normalization Conflict"
      description: "Different Unicode representations of same character"
      lock_implication: "May or may not conflict depending on normalization"
    
    - case_id: "UC-003"
      name: "Supplementary Character Handling"
      description: "Characters outside BMP may have different behavior"
      lock_implication: "Index key comparison affects locks"

  # ---------------------------------------------------------------------------
  # Timestamp/Timezone Edge Cases
  # ---------------------------------------------------------------------------
  temporal:
    - case_id: "TZ-001"
      name: "Timezone Conversion in Index"
      description: "Timezone conversion prevents index use"
      lock_implication: "Table scan instead of index lookup"
    
    - case_id: "TZ-002"
      name: "Daylight Saving Time Gap"
      description: "DST transition creates non-existent times"
      lock_implication: "Range queries may behave unexpectedly"
    
    - case_id: "TZ-003"
      name: "Leap Second Handling"
      description: "Leap seconds may cause timestamp collisions"
      lock_implication: "Multiple rows with 'same' timestamp"
    
    - case_id: "TZ-004"
      name: "Timestamp Precision Loss"
      description: "Precision mismatch between application and database"
      lock_implication: "Range queries may include/exclude unexpected rows"

  # ---------------------------------------------------------------------------
  # Data Type Edge Cases
  # ---------------------------------------------------------------------------
  data_types:
    - case_id: "DT-001"
      name: "Implicit Type Conversion"
      description: "Comparing VARCHAR to INT prevents index use"
      lock_implication: "Full table scan acquires more locks"
    
    - case_id: "DT-002"
      name: "Decimal Precision Mismatch"
      description: "Different precision in comparison"
      lock_implication: "May not match expected rows"
    
    - case_id: "DT-003"
      name: "BLOB/CLOB Locking"
      description: "Large objects have special lock behavior"
      lock_implication: "May lock entire segment"
      databases: ["Oracle", "DB2"]
    
    - case_id: "DT-004"
      name: "JSON Field Access Locking"
      description: "JSON path access may not use index"
      lock_implication: "Table scan for JSON queries"
      databases: ["PostgreSQL", "MySQL 5.7+"]

  # ---------------------------------------------------------------------------
  # Transaction Boundary Edge Cases
  # ---------------------------------------------------------------------------
  transaction_boundaries:
    - case_id: "TB-001"
      name: "Auto-commit Mode Surprise"
      description: "Auto-commit OFF not set, each statement is transaction"
      lock_implication: "Locks released between statements"
    
    - case_id: "TB-002"
      name: "Implicit Commit from DDL"
      description: "DDL causes implicit commit in some databases"
      lock_implication: "Locks released unexpectedly"
      databases: ["MySQL", "Oracle"]
    
    - case_id: "TB-003"
      name: "Savepoint Scope Confusion"
      description: "Rollback to savepoint doesn't release all locks"
      lock_implication: "Locks from before savepoint still held"
    
    - case_id: "TB-004"
      name: "Nested Transaction Behavior"
      description: "Different databases handle nested transactions differently"
      lock_implication: "Inner commit may or may not release locks"
      databases_vary: true

  # ---------------------------------------------------------------------------
  # Connection State Edge Cases
  # ---------------------------------------------------------------------------
  connection_state:
    - case_id: "CS-001"
      name: "Session Variable Isolation Level"
      description: "SET TRANSACTION affects only next transaction"
      lock_implication: "Subsequent transactions use different level"
    
    - case_id: "CS-002"
      name: "Connection Pool State Leak"
      description: "Session state persists across pool reuse"
      lock_implication: "Unexpected isolation level from previous use"
    
    - case_id: "CS-003"
      name: "Prepared Statement Plan Caching"
      description: "Cached plan may use different lock strategy"
      lock_implication: "Plan changes affect lock patterns"
    
    - case_id: "CS-004"
      name: "Server-Side Cursor Locking"
      description: "Cursor holds locks while open"
      lock_implication: "Locks held until cursor closed"

  # ---------------------------------------------------------------------------
  # Constraint Edge Cases
  # ---------------------------------------------------------------------------
  constraints:
    - case_id: "CN-001"
      name: "Check Constraint Function Call"
      description: "CHECK constraint calls function that accesses other tables"
      lock_implication: "Hidden lock from constraint validation"
    
    - case_id: "CN-002"
      name: "Deferrable Unique Constraint"
      description: "Unique check deferred to commit"
      lock_implication: "Lock acquired at commit time"
      databases: ["PostgreSQL", "Oracle"]
    
    - case_id: "CN-003"
      name: "Exclusion Constraint Locking"
      description: "PostgreSQL exclusion constraints use special locks"
      lock_implication: "Predicate locks on constraint"
      databases: ["PostgreSQL"]

  # ---------------------------------------------------------------------------
  # Replication Edge Cases
  # ---------------------------------------------------------------------------
  replication:
    - case_id: "RP-001"
      name: "Replication Lag Affecting Locks"
      description: "Read from replica sees old data, write to primary conflicts"
      lock_implication: "Stale read leads to write conflict"
    
    - case_id: "RP-002"
      name: "Circular Replication Deadlock"
      description: "Multi-master replication can create deadlocks"
      lock_implication: "Conflicts detected on different masters"
    
    - case_id: "RP-003"
      name: "Logical Replication Lock Order"
      description: "Logical replication may apply in different order"
      lock_implication: "Deadlocks on replica not on primary"

  # ---------------------------------------------------------------------------
  # Resource Limit Edge Cases
  # ---------------------------------------------------------------------------
  resource_limits:
    - case_id: "RL-001"
      name: "Lock Table Memory Exhaustion"
      description: "Too many locks exhausts lock manager memory"
      lock_implication: "Lock requests fail or escalate"
    
    - case_id: "RL-002"
      name: "Maximum Transaction Duration"
      description: "Very long transactions exceed limits"
      lock_implication: "Transaction terminated, locks released"
    
    - case_id: "RL-003"
      name: "Undo Space Exhaustion"
      description: "Long transaction exhausts undo/rollback space"
      lock_implication: "Transaction must abort"
      databases: ["Oracle", "MySQL InnoDB"]

  # ---------------------------------------------------------------------------
  # Maintenance Operation Edge Cases
  # ---------------------------------------------------------------------------
  maintenance:
    - case_id: "MO-001"
      name: "VACUUM Conflict"
      description: "VACUUM blocked by long-running transaction"
      lock_implication: "Table bloat from blocked vacuum"
      databases: ["PostgreSQL"]
    
    - case_id: "MO-002"
      name: "Statistics Update Lock"
      description: "ANALYZE may require brief lock"
      lock_implication: "Can block during statistics collection"
    
    - case_id: "MO-003"
      name: "Index Maintenance Lock"
      description: "Index reorganization requires locks"
      lock_implication: "May conflict with queries"

  # ---------------------------------------------------------------------------
  # Version-Specific Edge Cases
  # ---------------------------------------------------------------------------
  version_specific:
    postgresql:
      - case_id: "PG-001"
        name: "Pre-9.6 Lock Timeout"
        description: "No statement-level lock_timeout before 9.6"
        version: "< 9.6"
      - case_id: "PG-002"
        name: "SSI Performance in Early Versions"
        description: "Serializable Snapshot Isolation performance"
        version: "< 12"
      - case_id: "PG-003"
        name: "Predicate Lock Memory"
        description: "Predicate locks can consume memory"
        version: "all"
    
    mysql:
      - case_id: "MY-001"
        name: "Gap Lock Disabled in RC"
        description: "innodb_locks_unsafe_for_binlog deprecated"
        version: "< 8.0"
      - case_id: "MY-002"
        name: "Data Dictionary Lock"
        description: "Metadata locking behavior changed"
        version: "8.0+"
    
    sql_server:
      - case_id: "SS-001"
        name: "Lock Partitioning"
        description: "Lock partitioning for high-concurrency"
        version: "2008+"
      - case_id: "SS-002"
        name: "Accelerated Database Recovery"
        description: "ADR changes undo behavior"
        version: "2019+"

# =============================================================================
# DIFFICULTY MULTIPLIERS
# =============================================================================

difficulty_multipliers:
  difficulty_amplifiers:
    nightmare:
      multiplier: 3.0
      description: "Extreme difficulty requiring expert DBA knowledge across multiple systems"
      requirements:
        - "7+ interacting traps across storage engine, query optimizer, and lock manager"
        - "Requires understanding of database internals and source code behavior"
        - "Time estimate: 90+ minutes for senior database engineers"
        - "Cross-database compatibility issues that manifest differently"
        - "Requires synthesizing SQL, transactions, and distributed systems knowledge"
    
    nightmare_plus:
      multiplier: 5.0
      estimated_time: [28800, 172800]  # 8-48 hours
      command_steps: [400, 1500]
      techniques_required: 12
      description: "Database kernel development difficulty requiring lock manager internals and MVCC implementation expertise"
      requirements:
        - "12+ deeply interacting traps across locking, MVCC, isolation, and distributed transaction layers"
        - "Requires understanding of lock manager source code and deadlock detection algorithm implementations"
        - "Time estimate: 8-48 hours for principal database architects"
        - "Cross-database deadlock patterns requiring deep lock compatibility matrix knowledge"
        - "Requires synthesizing lock escalation, gap locking, predicate locking, and MVCC conflict detection"
        - "Must debug distributed deadlocks across multiple database instances"
        - "Requires understanding of 2PC lock holding and in-doubt transaction resolution"
        - "Must handle cascading deadlock scenarios with complex victim selection analysis"
  
  storage_engine_internals:
    btree_locking_internals:
      description: "B-tree/B+tree locking during traversal and modification"
      factors:
        - "Lock coupling (crabbing) protocol implementation"
        - "Page split locking and deadlock potential"
        - "Index-organized table locking patterns"
        - "Clustered vs non-clustered index lock interactions"
      multiplier: 1.9
    
    lsm_tree_concurrency:
      description: "LSM-tree concurrency control and locking"
      factors:
        - "Memtable concurrent access"
        - "Compaction vs read lock interactions"
        - "Version visibility during flush"
        - "Write batch atomicity"
      multiplier: 1.8
    
    wal_and_locking:
      description: "Write-ahead log interaction with locking"
      factors:
        - "Log buffer latch contention"
        - "Group commit and lock release timing"
        - "Recovery locking behavior"
        - "Checkpoint lock interactions"
      multiplier: 1.6
    
    buffer_pool_latches:
      description: "Buffer pool latch contention and deadlocks"
      factors:
        - "Page latch acquisition ordering"
        - "Buffer replacement latch contention"
        - "Free list latch bottlenecks"
        - "Latch-lock deadlock scenarios"
      multiplier: 1.7
    
    lock_manager_implementation:
      description: "Lock manager internal implementation details"
      factors:
        - "Lock hash table collision handling"
        - "Wait-for graph construction overhead"
        - "Lock memory allocation and deallocation"
        - "Lock conversion implementation"
      multiplier: 2.0
    
    mvcc_lock_interaction:
      description: "MVCC version management and lock interactions"
      factors:
        - "Read view construction and lock acquisition"
        - "Version chain traversal locking"
        - "Garbage collection lock requirements"
        - "Snapshot isolation write conflict detection"
      multiplier: 2.1
  
  distributed_database_complexity:
    distributed_deadlock_detection:
      global_wait_for_graph:
        - "Distributed wait-for graph construction latency"
        - "False positive deadlocks from stale information"
        - "Coordinator failure during deadlock resolution"
        - "Victim selection across databases"
      timeout_based_detection:
        - "Timeout tuning for distributed transactions"
        - "Long-running transaction vs deadlock distinction"
        - "Network latency impact on timeout detection"
      multiplier: 2.5
    
    two_phase_commit_deadlocks:
      prepared_transaction_locks:
        - "Lock holding during prepared state"
        - "Coordinator failure leaving locks"
        - "Participant timeout during commit"
        - "Heuristic completion and lock release"
      cross_resource_manager_deadlock:
        - "XA transaction deadlocks"
        - "Cross-database lock ordering"
        - "Resource manager failure handling"
      multiplier: 2.4
    
    replication_and_locking:
      replica_lock_scenarios:
        - "Primary-replica lock divergence"
        - "Hot standby query conflicts"
        - "Replication apply lock contention"
        - "Logical replication lock conflicts"
      multiplier: 1.9
    
    sharded_deadlock:
      cross_shard_deadlock:
        - "Cross-shard transaction lock ordering"
        - "Distributed lock manager coordination"
        - "Shard-local vs global deadlock detection"
        - "Coordinator node lock management"
      multiplier: 2.3
  
  environmental_factors:
    - factor: "multi_database_transaction"
      multiplier: 2.0
      description: "Transaction spans multiple database systems"
    
    - factor: "cross_shard_consistency"
      multiplier: 1.8
      description: "Requires consistency across shards"
    
    - factor: "real_time_constraints"
      multiplier: 1.5
      description: "Must complete within strict time limit"
    
    - factor: "high_availability_requirement"
      multiplier: 1.7
      description: "System cannot have any downtime"
    
    - factor: "disaster_recovery_scenario"
      multiplier: 1.6
      description: "Must work during failover"
  
  regulatory_factors:
    - factor: "gdpr_compliance"
      multiplier: 1.3
      description: "Must maintain GDPR audit trail"
    
    - factor: "hipaa_compliance"
      multiplier: 1.4
      description: "Healthcare data handling requirements"
    
    - factor: "pci_dss_compliance"
      multiplier: 1.4
      description: "Payment card data handling"
    
    - factor: "sox_compliance"
      multiplier: 1.3
      description: "Financial reporting requirements"
  
  performance_factors:
    - factor: "high_throughput"
      multiplier: 1.4
      description: "Must handle 10,000+ TPS"
    
    - factor: "low_latency"
      multiplier: 1.5
      description: "P99 latency under 10ms"
    
    - factor: "resource_constrained"
      multiplier: 1.3
      description: "Limited CPU/memory available"
  
  scale_factors:
    - factor: "billion_row_tables"
      multiplier: 1.6
      description: "Tables with 1B+ rows"
    
    - factor: "thousands_of_concurrent_users"
      multiplier: 1.5
      description: "5000+ concurrent connections"
    
    - factor: "global_distribution"
      multiplier: 1.8
      description: "Data distributed across continents"

# =============================================================================
# DATABASE SYSTEM SPECIFICS
# =============================================================================

database_specifics:
  postgresql:
    versions: ["12", "13", "14", "15", "16"]
    lock_monitoring:
      - "SELECT * FROM pg_locks"
      - "SELECT * FROM pg_stat_activity"
      - "SET log_lock_waits = on"
    deadlock_info:
      - "Check postgresql.log for deadlock details"
      - "Use pg_locks join pg_stat_activity"
    configuration:
      deadlock_timeout: "1s default"
      lock_timeout: "0 (disabled) default"
      log_lock_waits: "off default"
    specific_traps:
      - "Advisory locks not tracked in pg_locks"
      - "Predicate locks memory consumption"
      - "SSI read-only optimization"
  
  mysql:
    versions: ["5.7", "8.0", "8.1"]
    lock_monitoring:
      - "SHOW ENGINE INNODB STATUS"
      - "SELECT * FROM performance_schema.data_locks"
      - "SELECT * FROM information_schema.INNODB_TRX"
    deadlock_info:
      - "SHOW ENGINE INNODB STATUS contains deadlock info"
      - "innodb_print_all_deadlocks in error log"
    configuration:
      innodb_lock_wait_timeout: "50 seconds default"
      innodb_deadlock_detect: "ON default"
      innodb_print_all_deadlocks: "OFF default"
    specific_traps:
      - "Gap locks in REPEATABLE READ"
      - "Insert intention lock waits"
      - "Auto-increment gap locking"
  
  sql_server:
    versions: ["2016", "2017", "2019", "2022"]
    lock_monitoring:
      - "SELECT * FROM sys.dm_tran_locks"
      - "SELECT * FROM sys.dm_os_waiting_tasks"
      - "Extended Events for deadlocks"
    deadlock_info:
      - "Deadlock graph in Extended Events"
      - "system_health session captures deadlocks"
    configuration:
      lock_timeout: "-1 (infinite) default"
      deadlock_priority: "NORMAL default"
    specific_traps:
      - "Lock escalation thresholds"
      - "NOLOCK hint misuse"
      - "Key-range lock conflicts"
  
  oracle:
    versions: ["19c", "21c", "23c"]
    lock_monitoring:
      - "SELECT * FROM V$LOCK"
      - "SELECT * FROM DBA_WAITERS"
      - "ASH (Active Session History)"
    deadlock_info:
      - "ORA-00060 error with trace file"
      - "V$LOCK for current locks"
    configuration:
      distributed_lock_timeout: "60 seconds"
    specific_traps:
      - "ITL (Interested Transaction List) waits"
      - "Bitmap index DML serialization"
      - "ORA-08177 serialization failure"

# =============================================================================
# PROBLEM STATEMENT TEMPLATES
# =============================================================================

problem_statement: |
  A {{ scenario_type }} database application experiences {{ deadlock_frequency }} deadlocks
  during {{ workload_pattern }} workloads. The system uses {{ database_system }} {{ database_version }}
  with {{ isolation_level }} isolation level.
  
  The deadlocks involve:
  {{ deadlock_patterns }}
  
  Environment characteristics:
  - Concurrent connections: {{ concurrent_connections }}
  - Transactions per second: {{ tps }}
  - Average transaction duration: {{ avg_txn_duration }}
  - Table sizes: {{ table_sizes }}
  
  Additional constraints:
  {{ additional_constraints }}

requirements: |
  - Identify all deadlock patterns in the application
  - Implement consistent lock ordering where possible
  - Minimize transaction duration and lock scope
  - Handle {{ edge_cases }} edge cases
  - Optimize for {{ optimization_goal }}
  - Implement proper retry logic with {{ retry_strategy }}
  - Ensure {{ consistency_requirement }} consistency
  - Maintain {{ availability_requirement }} availability

interface: |
  Input: {{ input_type }}
  Output: {{ output_type }}
  Validation: {{ validation_criteria }}

# =============================================================================
# REFERENCE SOLUTION PATTERNS
# =============================================================================

reference_solution: |
  -- Comprehensive Deadlock Prevention and Resolution
  
  -- ============================================================
  -- PATTERN 1: Consistent Lock Ordering
  -- ============================================================
  
  /*
  DEADLOCK SCENARIO:
  
  Transaction A:
    BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- Lock row 1
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- Wait for row 2
    COMMIT;
  
  Transaction B:
    BEGIN;
    UPDATE accounts SET balance = balance - 50 WHERE id = 2;   -- Lock row 2
    UPDATE accounts SET balance = balance + 50 WHERE id = 1;   -- Wait for row 1
    COMMIT;
  
  Result: Deadlock - A waits for B, B waits for A
  */
  
  -- SOLUTION: Lock in consistent order (lowest ID first)
  
  CREATE OR REPLACE FUNCTION transfer_funds_safe(
    p_from_id INT,
    p_to_id INT,
    p_amount DECIMAL(15,2)
  ) RETURNS VOID AS $$
  DECLARE
    v_first_id INT;
    v_second_id INT;
    v_first_balance DECIMAL(15,2);
    v_second_balance DECIMAL(15,2);
  BEGIN
    -- Determine lock order: always lock lower ID first
    IF p_from_id < p_to_id THEN
      v_first_id := p_from_id;
      v_second_id := p_to_id;
    ELSE
      v_first_id := p_to_id;
      v_second_id := p_from_id;
    END IF;
    
    -- Acquire locks in consistent order
    SELECT balance INTO v_first_balance
    FROM accounts WHERE id = v_first_id FOR UPDATE;
    
    SELECT balance INTO v_second_balance
    FROM accounts WHERE id = v_second_id FOR UPDATE;
    
    -- Validate sufficient funds
    IF p_from_id = v_first_id THEN
      IF v_first_balance < p_amount THEN
        RAISE EXCEPTION 'Insufficient funds';
      END IF;
    ELSE
      IF v_second_balance < p_amount THEN
        RAISE EXCEPTION 'Insufficient funds';
      END IF;
    END IF;
    
    -- Execute transfer
    UPDATE accounts SET balance = balance - p_amount WHERE id = p_from_id;
    UPDATE accounts SET balance = balance + p_amount WHERE id = p_to_id;
  END;
  $$ LANGUAGE plpgsql;
  
  -- ============================================================
  -- PATTERN 2: Minimize Lock Duration
  -- ============================================================
  
  /*
  BAD PATTERN - Long transaction holds locks:
  
  BEGIN;
  SELECT * FROM orders FOR UPDATE;  -- Locks orders
  -- ... external API call that takes 5 seconds ...
  UPDATE orders SET status = 'processed';
  COMMIT;
  */
  
  -- GOOD PATTERN - Optimistic locking with version check
  
  -- Step 1: Read without locking
  SELECT id, status, version FROM orders WHERE id = 123;
  
  -- Step 2: External processing (no transaction)
  -- ... call external API ...
  
  -- Step 3: Short transaction with optimistic lock
  BEGIN;
  UPDATE orders 
  SET status = 'processed', 
      version = version + 1,
      updated_at = NOW()
  WHERE id = 123 AND version = 5;  -- Version check
  
  -- Check if update succeeded
  IF NOT FOUND THEN
    ROLLBACK;
    RAISE EXCEPTION 'Concurrent modification detected, retry required';
  END IF;
  COMMIT;
  
  -- ============================================================
  -- PATTERN 3: Batch Processing Without Lock Escalation
  -- ============================================================
  
  CREATE OR REPLACE FUNCTION process_pending_orders_batch(
    p_batch_size INT DEFAULT 1000,
    p_max_batches INT DEFAULT 100
  ) RETURNS INT AS $$
  DECLARE
    v_processed INT := 0;
    v_batch_count INT;
    v_batch_num INT := 0;
  BEGIN
    LOOP
      v_batch_num := v_batch_num + 1;
      EXIT WHEN v_batch_num > p_max_batches;
      
      -- Process one batch with FOR UPDATE SKIP LOCKED
      WITH batch AS (
        SELECT id FROM orders
        WHERE status = 'pending'
        ORDER BY created_at
        LIMIT p_batch_size
        FOR UPDATE SKIP LOCKED  -- Skip locked rows
      )
      UPDATE orders o
      SET status = 'processing',
          processed_at = NOW()
      FROM batch b
      WHERE o.id = b.id;
      
      GET DIAGNOSTICS v_batch_count = ROW_COUNT;
      v_processed := v_processed + v_batch_count;
      
      EXIT WHEN v_batch_count = 0;
      
      -- Commit between batches to release locks
      COMMIT;
      
      -- Brief pause to reduce contention
      PERFORM pg_sleep(0.05);
    END LOOP;
    
    RETURN v_processed;
  END;
  $$ LANGUAGE plpgsql;
  
  -- ============================================================
  -- PATTERN 4: Handling Foreign Key Locks
  -- ============================================================
  
  /*
  PROBLEM: Inserting child can block on parent lock
  
  Transaction A: UPDATE parent SET name = 'x' WHERE id = 1;  -- X lock
  Transaction B: INSERT INTO child (parent_id) VALUES (1);   -- Needs S lock on parent
  */
  
  -- SOLUTION: Lock parent explicitly before child operations
  
  CREATE OR REPLACE FUNCTION create_order_with_items(
    p_customer_id INT,
    p_items JSONB
  ) RETURNS INT AS $$
  DECLARE
    v_order_id INT;
    v_item JSONB;
  BEGIN
    -- Lock customer first (parent) with FOR SHARE
    PERFORM 1 FROM customers WHERE id = p_customer_id FOR SHARE;
    
    -- Lock products (referenced) 
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
      PERFORM 1 FROM products 
      WHERE id = (v_item->>'product_id')::INT FOR SHARE;
    END LOOP;
    
    -- Now safe to create order and items
    INSERT INTO orders (customer_id, created_at)
    VALUES (p_customer_id, NOW())
    RETURNING id INTO v_order_id;
    
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
      INSERT INTO order_items (order_id, product_id, quantity)
      VALUES (
        v_order_id,
        (v_item->>'product_id')::INT,
        (v_item->>'quantity')::INT
      );
    END LOOP;
    
    RETURN v_order_id;
  END;
  $$ LANGUAGE plpgsql;
  
  -- ============================================================
  -- PATTERN 5: Deadlock Retry Logic
  -- ============================================================
  
  /*
  Python application code for deadlock retry:
  
  import psycopg2
  from psycopg2 import errors
  import time
  import random
  
  class DeadlockRetryError(Exception):
      pass
  
  def execute_with_deadlock_retry(
      conn,
      func,
      max_retries=3,
      base_delay=0.1,
      max_delay=2.0
  ):
      """
      Execute a database function with deadlock retry logic.
      Uses exponential backoff with jitter.
      """
      last_error = None
      
      for attempt in range(max_retries):
          try:
              with conn.cursor() as cur:
                  result = func(cur)
                  conn.commit()
                  return result
                  
          except errors.DeadlockDetected as e:
              last_error = e
              conn.rollback()
              
              if attempt == max_retries - 1:
                  raise DeadlockRetryError(
                      f"Max retries ({max_retries}) exceeded"
                  ) from e
              
              # Exponential backoff with jitter
              delay = min(
                  base_delay * (2 ** attempt) + random.uniform(0, 0.1),
                  max_delay
              )
              time.sleep(delay)
              
          except errors.SerializationFailure as e:
              # Handle serialization failures same way
              last_error = e
              conn.rollback()
              
              if attempt == max_retries - 1:
                  raise
              
              delay = min(
                  base_delay * (2 ** attempt) + random.uniform(0, 0.1),
                  max_delay
              )
              time.sleep(delay)
              
          except Exception as e:
              conn.rollback()
              raise
      
      raise last_error
  */
  
  -- ============================================================
  -- PATTERN 6: Deadlock Monitoring and Diagnosis
  -- ============================================================
  
  -- PostgreSQL: Find current lock conflicts
  SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    blocked.query AS blocked_query,
    blocked.state AS blocked_state,
    blocking.pid AS blocking_pid,
    blocking.usename AS blocking_user,
    blocking.query AS blocking_query,
    blocking.state AS blocking_state
  FROM pg_stat_activity blocked
  JOIN pg_locks blocked_locks ON blocked.pid = blocked_locks.pid
  JOIN pg_locks blocking_locks 
    ON blocked_locks.locktype = blocking_locks.locktype
    AND blocked_locks.relation = blocking_locks.relation
    AND blocked_locks.pid != blocking_locks.pid
  JOIN pg_stat_activity blocking ON blocking_locks.pid = blocking.pid
  WHERE NOT blocked_locks.granted
    AND blocking_locks.granted;
  
  -- PostgreSQL: Enable deadlock logging
  ALTER SYSTEM SET log_lock_waits = on;
  ALTER SYSTEM SET deadlock_timeout = '1s';
  SELECT pg_reload_conf();
  
  -- ============================================================
  -- PATTERN 7: MySQL/InnoDB Specific
  -- ============================================================
  
  -- Enable deadlock printing to error log
  SET GLOBAL innodb_print_all_deadlocks = ON;
  
  -- Check for current locks
  SELECT * FROM performance_schema.data_locks;
  
  -- Check lock waits
  SELECT * FROM performance_schema.data_lock_waits;
  
  -- Get recent deadlocks
  SHOW ENGINE INNODB STATUS;  -- Look for LATEST DETECTED DEADLOCK section
  
  -- ============================================================
  -- PATTERN 8: SQL Server Specific
  -- ============================================================
  
  -- Set deadlock priority (lower = more likely victim)
  SET DEADLOCK_PRIORITY LOW;
  -- Options: LOW (-5), NORMAL (0), HIGH (5), or -10 to 10
  
  -- Query current locks
  SELECT 
    request_session_id,
    resource_type,
    resource_database_id,
    resource_associated_entity_id,
    request_mode,
    request_status
  FROM sys.dm_tran_locks
  WHERE request_status = 'WAIT';
  
  -- Extended Events for deadlock capture
  CREATE EVENT SESSION [DeadlockCapture] ON SERVER
  ADD EVENT sqlserver.xml_deadlock_report
  ADD TARGET package0.event_file(
    SET filename = N'DeadlockCapture.xel',
    max_file_size = 10
  )
  WITH (
    MAX_MEMORY = 4096 KB,
    EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS
  );
  ALTER EVENT SESSION [DeadlockCapture] ON SERVER STATE = START;

# =============================================================================
# TEST CASES
# =============================================================================

fail_to_pass:
  - "test_no_deadlock_on_concurrent_transfers"
  - "test_lock_ordering_enforced"
  - "test_batch_update_no_escalation"
  - "test_fk_locking_explicit"
  - "test_deadlock_retry_succeeds"
  - "test_optimistic_locking_detects_conflict"
  - "test_skip_locked_no_blocking"
  - "test_long_transaction_timeout"

pass_to_pass:
  - "test_single_transaction_success"
  - "test_basic_crud_operations"
  - "test_sequential_transactions"
  - "test_read_only_queries"

# =============================================================================
# VARIABLES FOR TASK GENERATION
# =============================================================================

variables:
  - name: scenario_type
    type: string
    options:
      - "financial trading system"
      - "e-commerce inventory management"
      - "healthcare appointment scheduling"
      - "airline reservation system"
      - "real-time bidding platform"
      - "multi-tenant SaaS application"
      - "supply chain management"
      - "online gaming platform"
      - "social media feed service"
      - "IoT sensor data platform"
  
  - name: database_system
    type: string
    options: ["PostgreSQL", "MySQL", "SQL Server", "Oracle"]
  
  - name: database_version
    type: string
    options_by_system:
      PostgreSQL: ["12", "13", "14", "15", "16"]
      MySQL: ["5.7", "8.0", "8.1"]
      SQL_Server: ["2016", "2017", "2019", "2022"]
      Oracle: ["19c", "21c", "23c"]
  
  - name: isolation_level
    type: string
    options:
      - "READ COMMITTED"
      - "REPEATABLE READ"
      - "SERIALIZABLE"
      - "SNAPSHOT"
  
  - name: deadlock_frequency
    type: string
    options:
      - "intermittent (5-10 per hour)"
      - "frequent (50+ per hour)"
      - "rare but critical (1-2 per day)"
      - "burst patterns during peak load"
  
  - name: workload_pattern
    type: string
    options:
      - "OLTP with high concurrency"
      - "mixed OLTP and batch"
      - "event-driven processing"
      - "real-time streaming"
  
  - name: concurrent_connections
    type: int
    min: 50
    max: 5000
  
  - name: tps
    type: int
    min: 100
    max: 50000
  
  - name: avg_txn_duration
    type: string
    options: ["<10ms", "10-50ms", "50-200ms", ">200ms"]
  
  - name: table_sizes
    type: string
    options:
      - "millions of rows"
      - "hundreds of millions of rows"
      - "billions of rows"
  
  - name: retry_strategy
    type: string
    options:
      - "exponential backoff with jitter"
      - "fixed delay"
      - "immediate retry with limit"
      - "circuit breaker pattern"

# =============================================================================
# ANTI-PATTERNS - LLM Failure Modes
# =============================================================================

anti_patterns:
  llm_failure_modes:
    - "Applying generic SQL patterns without considering database-specific behavior"
    - "Missing isolation level interactions between concurrent transactions"
    - "Ignoring lock manager implementation details"
    - "Not considering query optimizer behavior changes across versions"
    - "Missing hidden full table scans in seemingly optimized queries"
    - "Overlooking index maintenance overhead during writes"
    - "Assuming ORM generates efficient queries"
    - "Missing deadlock potential in cross-schema operations"
    - "Ignoring transaction log and recovery implications"
    - "Assuming simple lock ordering prevents all deadlocks"
    - "Missing FK validation lock on parent table during child insert"
    - "Ignoring gap lock interactions in MySQL REPEATABLE READ"
    - "Assuming SELECT FOR UPDATE always acquires locks in predictable order"
    - "Overlooking index access path impact on lock acquisition order"
    - "Missing lock escalation threshold behavior under high concurrency"
    - "Assuming NOWAIT/SKIP LOCKED solve all contention scenarios"
    - "Ignoring trigger-induced lock acquisition during DML"
    - "Missing materialized view refresh lock interactions"
    - "Assuming advisory locks prevent database deadlocks"
    - "Overlooking partition-level lock granularity in partitioned tables"
    - "Missing implicit lock from constraint validation"
    - "Assuming READ COMMITTED prevents all lock waits"
    - "Ignoring intention lock propagation in hierarchical locking"
    - "Missing cross-database transaction lock interactions"
    - "Assuming batched operations reduce lock contention"
    - "Overlooking auto-increment lock contention in high-throughput inserts"
    - "Missing sequence lock interactions during concurrent access"
  
  query_optimizer_internals:
    plan_impact_on_locking:
      - "Index scan vs table scan lock differences"
      - "Join order impact on lock acquisition sequence"
      - "Parallel query worker lock coordination"
      - "Sort spill locking behavior"
    lock_prediction_challenges:
      - "Adaptive plan lock pattern changes"
      - "Statistics-based plan changes affecting locks"
      - "Parameterized query plan sharing lock implications"
      - "Deferred constraint lock timing"
    optimization_lock_tradeoffs:
      - "Index-organized access vs heap access locking"
      - "Covering index lock reduction"
      - "Materialized CTE lock duration"
      - "Semi-join conversion lock implications"

# =============================================================================
# ANTI-HARDCODING MEASURES
# =============================================================================

anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  randomize_identifiers: true
  randomize_values: true
  
  deadlock_patterns:
    - "inconsistent_lock_order"
    - "long_running_transaction"
    - "fk_constraint_locks"
    - "lock_escalation"
    - "gap_lock_conflicts"
    - "index_maintenance_locks"
    - "trigger_induced_locks"
    - "cross_table_updates"
    - "batch_processing_contention"
    - "distributed_transaction_locks"
  
  trap_injection:
    - inject_subtle_ordering_issue: true
    - inject_hidden_fk_lock: true
    - inject_escalation_trigger: true
    - inject_version_specific_quirk: true
  
  validation_randomization:
    - randomize_test_data: true
    - randomize_load_patterns: true
    - randomize_timing: true
