id: "net-socket-fd-exhaustion-001"
version: "2.0.0"
category: "networking"
subcategory: "sockets"

# ============================================================================
# SOCKET FILE DESCRIPTOR EXHAUSTION - COMPREHENSIVE FRAMEWORK
# ============================================================================
# This YAML enables generation of 10,000+ unique socket programming challenges
# covering FD leaks, socket options, multiplexing, non-blocking I/O, connection
# management, platform-specific behaviors, and resource lifecycle management.
# ============================================================================

# === LLM GENERATION FRAMEWORK ===
generation_framework:
  multi_conversation_workflow:
    phase_1_research: "Research obscure socket behaviors and platform-specific edge cases"
    phase_2_creation: "Create task with subtle FD leak scenarios"
    phase_3_amplification: "Add platform-specific complexity and race conditions"
    phase_4_verification:
      description: "Validate task requires deep systems programming expertise"
      validation_criteria:
        - "Has at least 12+ deeply interacting traps across OSI layers"
        - "Has cascading protocol layer interactions (L2/L3/L4/L7)"
        - "Requires knowledge of kernel network stack internals"
        - "Would take 90-180 minutes for senior network engineers with kernel development experience"
  
  multi_agent_orchestration:
    description: "Complex multi-agent coordination for deep socket internals debugging"
    required_agents:
      - agent: "packet_analyzer"
        role: "Deep packet inspection and protocol state tracking"
        capabilities: ["pcap analysis", "protocol dissection", "timing correlation"]
      - agent: "kernel_debugger"
        role: "Kernel-level socket and FD table analysis"
        capabilities: ["ftrace", "eBPF tracing", "kernel memory inspection"]
      - agent: "syscall_tracer"
        role: "System call interception and analysis"
        capabilities: ["strace analysis", "ptrace injection", "seccomp profiling"]
      - agent: "memory_analyzer"
        role: "Memory leak and buffer analysis"
        capabilities: ["valgrind", "AddressSanitizer", "heap profiling"]
      - agent: "network_fuzzer"
        role: "Protocol fuzzing and edge case generation"
        capabilities: ["AFL", "libFuzzer", "protocol mutation"]
      - agent: "state_machine_validator"
        role: "TCP/UDP state machine verification"
        capabilities: ["state diagram validation", "transition verification"]
      - agent: "resource_monitor"
        role: "System resource tracking and correlation"
        capabilities: ["FD tracking", "memory monitoring", "connection pooling analysis"]
      - agent: "cross_platform_tester"
        role: "Platform-specific behavior verification"
        capabilities: ["Linux/BSD/Windows testing", "kernel version differences"]
    
    cross_layer_attack_chains:
      - chain: "L2->L3->L4->L7 FD exhaustion"
        description: "VLAN hopping triggers ARP cache poisoning, causing TCP connection storms that exhaust FDs at application layer"
        stages:
          - "L2: VLAN tag manipulation causes switch flooding"
          - "L3: IP spoofing triggers routing table corruption"
          - "L4: TCP SYN floods with crafted sequences bypass SYN cookies"
          - "L7: Application accept() loops leak FDs due to SSL handshake failures"
      
      - chain: "L4->L3->L2 resource starvation"
        description: "TCP connection state manipulation causes kernel memory pressure affecting NIC driver"
        stages:
          - "L4: TIME_WAIT accumulation with crafted FIN sequences"
          - "L3: IP fragment reassembly buffer exhaustion"
          - "L2: NIC ring buffer overflow due to kernel memory pressure"
    
    parallel_analysis_requirements:
      - "Simultaneous packet capture on multiple interfaces with sub-microsecond correlation"
      - "Kernel tracing while maintaining application state coherence"
      - "Cross-process FD tracking with namespace awareness"
      - "Real-time correlation of syscall traces with network events"
    
    agent_handoff_protocols:
      - handoff: "packet_analyzer -> kernel_debugger"
        trigger: "Anomalous TCP state detected requiring kernel inspection"
        data_exchange: ["pcap buffer", "suspicious packet hashes", "timing data"]
      - handoff: "kernel_debugger -> memory_analyzer"
        trigger: "Kernel memory allocation patterns suggest leak"
        data_exchange: ["allocation traces", "slab cache info", "FD table snapshots"]
      - handoff: "network_fuzzer -> state_machine_validator"
        trigger: "Fuzzed input causes unexpected state transition"
        data_exchange: ["input corpus", "state transition log", "crash dumps"]
  
  complexity_requirements:
    minimum_lines: 1000
    unique_combinations: 10000
    difficulty_floor: "advanced"
    requires_expertise:
      - "Systems programming and resource management"
      - "Unix/Windows socket APIs"
      - "Asynchronous I/O patterns"
      - "Connection lifecycle management"
      - "Debugging resource leaks"

# ============================================================================
# PROBLEM STATEMENT SECTION
# ============================================================================
problem_statement: |
  A socket server application is experiencing file descriptor exhaustion under
  load. The server accepts connections but leaks file descriptors in various
  error conditions. After running for several hours, it fails with "Too many
  open files" errors.
  
  The leak occurs in multiple places:
  1. Error paths during SSL handshake
  2. Timeout handling for slow clients
  3. Fork/exec for child processes
  4. Temporary files for large uploads
  5. Connection pool management
  6. Proxy backend connections
  7. Health check connections
  8. WebSocket upgrade failures
  
  The server must handle 10,000 concurrent connections with proper resource
  cleanup in all error scenarios.
  
  Extended complexity:
  - Multi-process architecture with fork()
  - Connection pooling with limits
  - Graceful shutdown requirements
  - Hot reload without dropping connections
  - Metrics/monitoring endpoints

requirements: |
  - Identify all file descriptor leaks
  - Implement proper cleanup in error paths
  - Add file descriptor accounting
  - Set appropriate ulimits programmatically
  - Implement connection draining for graceful shutdown
  - Handle CLOEXEC for fork safety
  - Implement FD passing between processes
  - Support connection migration during reload

interface: |
  Input: Network connections on port 8080
  Output: Proper resource cleanup on all paths
  Monitoring: /proc/self/fd should stay bounded
  Metrics: FD count, leak rate, connection states

# ============================================================================
# TOPIC UNIVERSE - 100+ UNIQUE TOPICS
# ============================================================================
topic_universe:
  # --------------------------------------------------------------------------
  # SOCKET OPTIONS (20 topics)
  # --------------------------------------------------------------------------
  socket_options:
    - topic: "so_reuseaddr"
      description: "SO_REUSEADDR socket option behavior"
      complexity: "medium"
      api_reference: "socket(7)"
      behaviors:
        - "Allows bind to address in TIME_WAIT state"
        - "Does not allow duplicate active binds"
        - "Behavior differs between Unix and Windows"
      security_implications:
        - "Port hijacking attacks possible"
        - "Race condition with address reuse"
        - "TCP session hijacking risk"
      edge_cases:
        - "TIME_WAIT assassin scenario"
        - "Multi-process bind race"
        - "Address family mismatch"
        - "IPv4 vs IPv6 bind conflicts"
    
    - topic: "so_reuseport"
      description: "SO_REUSEPORT load balancing socket option"
      complexity: "hard"
      api_reference: "socket(7)"
      behaviors:
        - "Multiple sockets can bind to same address:port"
        - "Kernel distributes connections across sockets"
        - "Process with SO_REUSEPORT required to bind"
      load_balancing:
        - "Random distribution"
        - "Hash-based distribution"
        - "BPF-based distribution (Linux 4.5+)"
      edge_cases:
        - "Process death and redistribution"
        - "Different processes with different options"
        - "Interaction with SO_REUSEADDR"
        - "Hot reload scenarios"
    
    - topic: "tcp_nodelay"
      description: "TCP_NODELAY (Nagle's algorithm disable)"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Disables Nagle's algorithm"
        - "Each write() sends immediately"
        - "Reduces latency for small writes"
      performance_impact:
        - "Lower latency for interactive apps"
        - "More packets, higher overhead"
        - "Interaction with delayed ACK"
      edge_cases:
        - "Combined with TCP_CORK"
        - "Write coalescing in userspace"
        - "Small writes with nodelay"
        - "Nodelay with non-blocking I/O"
    
    - topic: "tcp_cork"
      description: "TCP_CORK (output corking)"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Buffer output until cork removed"
        - "Linux-specific (TCP_NOPUSH on BSD)"
        - "Useful for HTTP responses"
      use_patterns:
        - "Cork -> write headers -> write body -> uncork"
        - "Combine with sendfile()"
        - "Batch small writes"
      edge_cases:
        - "Cork timeout (200ms)"
        - "Close() with cork set"
        - "Multiple cork/uncork cycles"
        - "Cork with writev()"
    
    - topic: "tcp_quickack"
      description: "TCP_QUICKACK (immediate ACK)"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Disable delayed ACK temporarily"
        - "One-shot option (resets after use)"
        - "Reduces latency for request-response"
      edge_cases:
        - "Reset after each packet"
        - "Interaction with TCP_NODELAY"
        - "Impact on congestion control"
        - "Per-packet setting required"
    
    - topic: "tcp_fastopen"
      description: "TCP_FASTOPEN (TFO)"
      complexity: "hard"
      api_reference: "tcp(7)"
      behaviors:
        - "Send data in SYN packet"
        - "Cookie-based security"
        - "Client and server support required"
      security_concerns:
        - "Replay attacks for non-idempotent requests"
        - "Cookie management"
        - "Firewall/middlebox issues"
      edge_cases:
        - "TFO cookie expired"
        - "SYN with data dropped"
        - "Server rejects TFO"
        - "First connection (no cookie)"
    
    - topic: "so_keepalive"
      description: "SO_KEEPALIVE and TCP keepalive timers"
      complexity: "medium"
      api_reference: "socket(7), tcp(7)"
      timers:
        - "TCP_KEEPIDLE - time before first probe"
        - "TCP_KEEPINTVL - probe interval"
        - "TCP_KEEPCNT - probe count before failure"
      edge_cases:
        - "NAT timeout shorter than keepalive"
        - "Keepalive during data transfer"
        - "Half-open connection detection"
        - "System-wide vs per-socket settings"
    
    - topic: "so_linger"
      description: "SO_LINGER socket close behavior"
      complexity: "hard"
      api_reference: "socket(7)"
      behaviors:
        linger_off: "Close returns immediately, RST sent"
        linger_zero: "Close returns immediately, RST sent"
        linger_nonzero: "Close blocks until data sent or timeout"
      edge_cases:
        - "Linger with non-blocking socket"
        - "Linger timeout vs send buffer"
        - "RST vs graceful FIN"
        - "Linger in CLOSE_WAIT state"
    
    - topic: "so_rcvbuf_sndbuf"
      description: "SO_RCVBUF and SO_SNDBUF buffer sizes"
      complexity: "hard"
      api_reference: "socket(7)"
      behaviors:
        - "Kernel doubles the value set"
        - "rmem_max/wmem_max limits"
        - "Auto-tuning interaction"
      performance_impact:
        - "Bandwidth-delay product"
        - "Window scaling"
        - "Memory usage per connection"
      edge_cases:
        - "Buffer too small for BDP"
        - "Auto-tuning disabled"
        - "Memory pressure"
        - "Different values for different connections"
    
    - topic: "so_rcvtimeo_sndtimeo"
      description: "SO_RCVTIMEO and SO_SNDTIMEO timeouts"
      complexity: "medium"
      api_reference: "socket(7)"
      behaviors:
        - "Set timeout for recv/send operations"
        - "Returns EAGAIN/EWOULDBLOCK on timeout"
        - "Does not affect poll/select"
      edge_cases:
        - "Timeout with blocking socket"
        - "Partial read/write before timeout"
        - "Zero timeout behavior"
        - "Interaction with non-blocking"
    
    - topic: "tcp_user_timeout"
      description: "TCP_USER_TIMEOUT option"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Maximum time for data to remain unacknowledged"
        - "Aborts connection if exceeded"
        - "Linux 2.6.37+"
      edge_cases:
        - "Interaction with retransmit timeout"
        - "Value during connection establishment"
        - "Combined with keepalive"
        - "Behavior on zero value"
    
    - topic: "tcp_defer_accept"
      description: "TCP_DEFER_ACCEPT option"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Don't complete connection until data received"
        - "Reduces system calls for accept()"
        - "Timeout for defer period"
      edge_cases:
        - "Client sends no data"
        - "Defer timeout exceeded"
        - "Interaction with TCP Fast Open"
        - "Multiple SYN retries during defer"
    
    - topic: "ip_transparent"
      description: "IP_TRANSPARENT option"
      complexity: "expert"
      api_reference: "ip(7)"
      behaviors:
        - "Allow binding to non-local address"
        - "Used for transparent proxying"
        - "Requires CAP_NET_ADMIN"
      use_cases:
        - "Transparent proxy"
        - "Load balancer DSR mode"
        - "VPN gateways"
      edge_cases:
        - "Routing table requirements"
        - "iptables TPROXY rules"
        - "Return path routing"
        - "IPv4 vs IPv6 behavior"
    
    - topic: "ip_freebind"
      description: "IP_FREEBIND option"
      complexity: "medium"
      api_reference: "ip(7)"
      behaviors:
        - "Allow binding to non-existent address"
        - "Useful for VRRP/failover"
        - "Address can be added later"
      edge_cases:
        - "Address never appears"
        - "Interface goes down"
        - "Multiple interfaces"
        - "Interaction with SO_BINDTODEVICE"
    
    - topic: "so_bindtodevice"
      description: "SO_BINDTODEVICE option"
      complexity: "medium"
      api_reference: "socket(7)"
      behaviors:
        - "Bind socket to specific interface"
        - "Only sends/receives on that interface"
        - "Requires CAP_NET_RAW"
      edge_cases:
        - "Interface rename"
        - "Interface removal"
        - "Wildcard address with device"
        - "Multi-homed hosts"
    
    - topic: "so_priority"
      description: "SO_PRIORITY option"
      complexity: "medium"
      api_reference: "socket(7)"
      behaviors:
        - "Set packet priority for QoS"
        - "Used by iptables/nftables"
        - "0-6 without privileges"
      edge_cases:
        - "Interaction with DSCP"
        - "Qdisc processing"
        - "Priority inheritance"
        - "Protocol-specific handling"
    
    - topic: "so_mark"
      description: "SO_MARK socket option"
      complexity: "hard"
      api_reference: "socket(7)"
      behaviors:
        - "Set fwmark on outgoing packets"
        - "Used for policy routing"
        - "Requires CAP_NET_ADMIN"
      use_cases:
        - "VRF routing"
        - "Separate routing tables"
        - "Firewall bypass"
      edge_cases:
        - "Mark in connect vs send"
        - "UDP vs TCP behavior"
        - "Inherited by accept()"
        - "Multiple marks"
    
    - topic: "tcp_congestion"
      description: "TCP_CONGESTION algorithm selection"
      complexity: "hard"
      api_reference: "tcp(7)"
      algorithms:
        - "cubic (default)"
        - "bbr (Google)"
        - "reno"
        - "vegas"
      edge_cases:
        - "Algorithm not loaded"
        - "Per-socket vs system-wide"
        - "Algorithm change mid-connection"
        - "ECN interaction"
    
    - topic: "tcp_maxseg"
      description: "TCP_MAXSEG (MSS) option"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Set maximum segment size"
        - "Subject to minimum (536 IPv4)"
        - "Clamped by path MTU"
      edge_cases:
        - "Value below minimum"
        - "Jumbo frame networks"
        - "PMTUD interaction"
        - "TSO/GSO offload"
    
    - topic: "tcp_window_clamp"
      description: "TCP_WINDOW_CLAMP option"
      complexity: "hard"
      api_reference: "tcp(7)"
      behaviors:
        - "Limit advertised receive window"
        - "Useful for rate limiting"
        - "Independent of buffer size"
      edge_cases:
        - "Window scaling interaction"
        - "Zero window advertising"
        - "Combined with rcvbuf"
        - "Dynamic adjustment"

  # --------------------------------------------------------------------------
  # TCP CONNECTION STATES (10 topics)
  # --------------------------------------------------------------------------
  tcp_states:
    - topic: "tcp_timestamps"
      description: "TCP timestamp option handling"
      complexity: "medium"
      rfc_reference: "RFC 7323"
      behaviors:
        - "RTT measurement"
        - "PAWS (Protection Against Wrapped Sequence)"
        - "Per-segment timestamp"
      edge_cases:
        - "Timestamp clock wraparound"
        - "Timestamp echo reply"
        - "Missing timestamps"
        - "Timestamp with SACK"
    
    - topic: "tcp_window_scaling"
      description: "TCP window scaling option"
      complexity: "medium"
      rfc_reference: "RFC 7323"
      behaviors:
        - "Allows windows > 65535 bytes"
        - "Negotiated in SYN"
        - "Shift count 0-14"
      edge_cases:
        - "Middlebox stripping"
        - "Asymmetric scaling"
        - "Scale factor changes"
        - "Interaction with path MTU"
    
    - topic: "tcp_sack"
      description: "TCP Selective Acknowledgment"
      complexity: "hard"
      rfc_reference: "RFC 2018"
      behaviors:
        - "Acknowledge non-contiguous blocks"
        - "Up to 4 SACK blocks"
        - "D-SACK for duplicates"
      edge_cases:
        - "SACK block coalescing"
        - "SACK reneging"
        - "SACK-based recovery"
        - "SACK with reordering"
    
    - topic: "time_wait_handling"
      description: "TIME_WAIT state management"
      complexity: "hard"
      api_reference: "tcp(7)"
      behaviors:
        - "2MSL timeout (usually 60s)"
        - "Prevents delayed segment confusion"
        - "Consumes FD/memory resources"
      mitigation:
        - "SO_REUSEADDR"
        - "tcp_tw_reuse"
        - "tcp_tw_recycle (deprecated)"
        - "SO_LINGER with 0"
      edge_cases:
        - "TIME_WAIT accumulation"
        - "Port exhaustion"
        - "Client vs server TIME_WAIT"
        - "TIME_WAIT assassination"
    
    - topic: "close_wait_handling"
      description: "CLOSE_WAIT state management"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Received FIN, haven't sent FIN"
        - "Application must close socket"
        - "Can accumulate indefinitely"
      debugging:
        - "lsof for CLOSE_WAIT sockets"
        - "ss -t state close-wait"
        - "netstat for CLOSE_WAIT count"
      edge_cases:
        - "Application not reading EOF"
        - "Socket in event loop"
        - "Leaked socket reference"
        - "Half-close handling"
    
    - topic: "fin_wait_handling"
      description: "FIN_WAIT_1 and FIN_WAIT_2 states"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "FIN_WAIT_1: Sent FIN, waiting ACK"
        - "FIN_WAIT_2: Got ACK, waiting peer FIN"
        - "tcp_fin_timeout controls FIN_WAIT_2"
      edge_cases:
        - "FIN_WAIT_2 timeout"
        - "Orphan socket limits"
        - "Half-duplex close"
        - "FIN lost in transit"
    
    - topic: "syn_recv_handling"
      description: "SYN_RECV state and SYN queue"
      complexity: "hard"
      api_reference: "tcp(7)"
      behaviors:
        - "Half-open connection state"
        - "SYN queue limits"
        - "SYN cookies when full"
      attacks:
        - "SYN flood"
        - "SYN queue exhaustion"
        - "Source address spoofing"
      edge_cases:
        - "SYN retry timing"
        - "syncookies and TCP options"
        - "Per-socket vs global limits"
        - "Accept queue backlog"
    
    - topic: "established_state"
      description: "ESTABLISHED state management"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Full duplex data transfer"
        - "Keepalive monitoring"
        - "Window management"
      edge_cases:
        - "Zombie connections"
        - "Broken pipe detection"
        - "RST in ESTABLISHED"
        - "Peer crash detection"
    
    - topic: "last_ack_state"
      description: "LAST_ACK state handling"
      complexity: "medium"
      api_reference: "tcp(7)"
      behaviors:
        - "Sent FIN, waiting for ACK"
        - "After CLOSE_WAIT"
        - "Transitions to CLOSED"
      edge_cases:
        - "ACK lost"
        - "RST in LAST_ACK"
        - "Timeout behavior"
        - "Resource cleanup"
    
    - topic: "closing_state"
      description: "CLOSING state (simultaneous close)"
      complexity: "hard"
      api_reference: "tcp(7)"
      behaviors:
        - "Both sides sent FIN simultaneously"
        - "Rare in practice"
        - "FINs cross in transit"
      edge_cases:
        - "Detection of simultaneous close"
        - "Timeout handling"
        - "Transition to TIME_WAIT"
        - "Application behavior"

  # --------------------------------------------------------------------------
  # SOCKET BUFFERS AND FLOW CONTROL (10 topics)
  # --------------------------------------------------------------------------
  buffer_management:
    - topic: "send_buffer_management"
      description: "Socket send buffer handling"
      complexity: "hard"
      api_reference: "socket(7)"
      behaviors:
        - "Kernel buffers outgoing data"
        - "write() blocks when full (blocking mode)"
        - "Returns EAGAIN when full (non-blocking)"
      edge_cases:
        - "Buffer full with large write"
        - "Partial write handling"
        - "Zero-copy sendmsg"
        - "sendfile and send buffer"
    
    - topic: "receive_buffer_management"
      description: "Socket receive buffer handling"
      complexity: "hard"
      api_reference: "socket(7)"
      behaviors:
        - "Kernel buffers incoming data"
        - "read() returns available data"
        - "Window advertisement based on buffer"
      edge_cases:
        - "Buffer full (zero window)"
        - "Slow consumer"
        - "MSG_PEEK behavior"
        - "Out-of-band data"
    
    - topic: "tcp_memory_pressure"
      description: "TCP memory pressure handling"
      complexity: "expert"
      api_reference: "tcp(7)"
      parameters:
        - "tcp_mem (pages: low, pressure, high)"
        - "tcp_rmem (min, default, max)"
        - "tcp_wmem (min, default, max)"
      edge_cases:
        - "Global memory pressure"
        - "Per-socket limits"
        - "Orphan socket memory"
        - "Memory accounting"
    
    - topic: "zero_window_probe"
      description: "TCP zero window probe handling"
      complexity: "hard"
      rfc_reference: "RFC 793"
      behaviors:
        - "Persist timer probes when window is zero"
        - "Exponential backoff"
        - "Maximum persist time"
      edge_cases:
        - "Deadlock prevention"
        - "Window update notification"
        - "Probe data acceptance"
        - "Connection abort"
    
    - topic: "urgent_data_oob"
      description: "TCP urgent data (OOB) handling"
      complexity: "hard"
      rfc_reference: "RFC 793, RFC 6093"
      behaviors:
        - "SO_OOBINLINE option"
        - "SIGURG signal"
        - "MSG_OOB flag"
      edge_cases:
        - "Multiple URG pointers"
        - "OOB mark"
        - "Reading past URG"
        - "URG without data"
    
    - topic: "ancillary_data"
      description: "Socket ancillary data (cmsg)"
      complexity: "hard"
      api_reference: "cmsg(3)"
      data_types:
        - "SCM_RIGHTS (FD passing)"
        - "SCM_CREDENTIALS"
        - "IP_PKTINFO"
        - "IPV6_PKTINFO"
      edge_cases:
        - "Truncated cmsg"
        - "Multiple cmsg headers"
        - "FD passing and close"
        - "Credentials validation"
    
    - topic: "scatter_gather_io"
      description: "Scatter-gather I/O (readv/writev)"
      complexity: "medium"
      api_reference: "readv(2), writev(2)"
      behaviors:
        - "Multiple buffers in single syscall"
        - "UIO_MAXIOV limit"
        - "Atomic operation"
      edge_cases:
        - "Partial readv/writev"
        - "Zero-length iovec"
        - "Too many iovecs"
        - "Non-blocking with scatter-gather"
    
    - topic: "splice_sendfile"
      description: "Zero-copy data transfer"
      complexity: "hard"
      api_reference: "splice(2), sendfile(2)"
      behaviors:
        - "Kernel-to-kernel data transfer"
        - "Avoids user-space copy"
        - "Pipe as intermediary (splice)"
      edge_cases:
        - "Partial transfer"
        - "Non-seekable files"
        - "Socket options with sendfile"
        - "Error handling mid-transfer"
    
    - topic: "cork_and_flush"
      description: "Output corking and flushing patterns"
      complexity: "medium"
      api_reference: "tcp(7)"
      patterns:
        - "Cork -> multiple writes -> uncork"
        - "TCP_CORK vs TCP_NODELAY"
        - "MSG_MORE flag"
      edge_cases:
        - "Auto-flush timeout"
        - "Cork with close"
        - "Multiple cork/uncork"
        - "Cork with sendfile"
    
    - topic: "memory_mapped_io"
      description: "Memory-mapped socket I/O"
      complexity: "expert"
      api_reference: "packet(7)"
      technologies:
        - "PACKET_MMAP for raw sockets"
        - "Shared ring buffer"
        - "Zero-copy receive"
      edge_cases:
        - "Ring buffer wraparound"
        - "Frame ownership"
        - "Kernel version requirements"
        - "VLAN handling"

  # --------------------------------------------------------------------------
  # NON-BLOCKING I/O AND MULTIPLEXING (15 topics)
  # --------------------------------------------------------------------------
  async_io:
    - topic: "nonblocking_connect"
      description: "Non-blocking TCP connect"
      complexity: "medium"
      api_reference: "connect(2)"
      behaviors:
        - "Returns EINPROGRESS immediately"
        - "Use poll/select for completion"
        - "Check SO_ERROR for result"
      edge_cases:
        - "Immediate connection (localhost)"
        - "Connection refused"
        - "Timeout handling"
        - "Multiple simultaneous connects"
    
    - topic: "nonblocking_accept"
      description: "Non-blocking accept"
      complexity: "medium"
      api_reference: "accept(2)"
      behaviors:
        - "Returns EAGAIN if no pending connections"
        - "accept4 with SOCK_NONBLOCK"
        - "Level-triggered vs edge-triggered"
      edge_cases:
        - "Thundering herd"
        - "Connection abort before accept"
        - "EMFILE handling"
        - "Accept queue full"
    
    - topic: "select_polling"
      description: "select() system call"
      complexity: "medium"
      api_reference: "select(2)"
      behaviors:
        - "FD_SETSIZE limit (usually 1024)"
        - "Timeout handling"
        - "fd_set modification"
      limitations:
        - "Linear scan of fd_set"
        - "FD_SETSIZE limit"
        - "Rebuilding sets each call"
      edge_cases:
        - "FD above FD_SETSIZE"
        - "Timeout precision"
        - "Signal interruption"
        - "Empty fd_sets"
    
    - topic: "poll_polling"
      description: "poll() system call"
      complexity: "medium"
      api_reference: "poll(2)"
      behaviors:
        - "No FD limit"
        - "Events and revents separation"
        - "POLLHUP, POLLERR, POLLNVAL"
      edge_cases:
        - "Negative FD ignored"
        - "POLLHUP handling"
        - "POLLERR vs POLLNVAL"
        - "Empty poll array"
    
    - topic: "epoll_edge_triggered"
      description: "epoll edge-triggered mode"
      complexity: "hard"
      api_reference: "epoll(7)"
      behaviors:
        - "EPOLLET flag"
        - "Event only on state change"
        - "Must drain data completely"
      edge_cases:
        - "Missed events"
        - "Partial read/write"
        - "EAGAIN detection"
        - "Re-arming requirement"
    
    - topic: "epoll_level_triggered"
      description: "epoll level-triggered mode"
      complexity: "medium"
      api_reference: "epoll(7)"
      behaviors:
        - "Default mode"
        - "Event while data available"
        - "Similar to poll semantics"
      edge_cases:
        - "Busy loop potential"
        - "Starvation of FDs"
        - "Kernel overhead"
        - "Switching modes"
    
    - topic: "epoll_oneshot"
      description: "epoll one-shot mode"
      complexity: "medium"
      api_reference: "epoll(7)"
      behaviors:
        - "EPOLLONESHOT flag"
        - "FD disabled after event"
        - "Must re-arm explicitly"
      use_cases:
        - "Multi-threaded servers"
        - "Preventing concurrent handling"
        - "Explicit control"
      edge_cases:
        - "Re-arm race condition"
        - "Missed events during re-arm"
        - "Combined with EPOLLET"
        - "Close without re-arm"
    
    - topic: "epoll_exclusive"
      description: "EPOLLEXCLUSIVE flag"
      complexity: "hard"
      api_reference: "epoll(7)"
      behaviors:
        - "Kernel 4.5+ only"
        - "Prevents thundering herd"
        - "Only one waiter woken"
      edge_cases:
        - "Multiple events"
        - "With EPOLLET"
        - "Worker death"
        - "Not supported events"
    
    - topic: "kqueue_bsd"
      description: "kqueue (BSD/macOS)"
      complexity: "hard"
      api_reference: "kqueue(2)"
      differences_from_epoll:
        - "Single syscall for register and wait"
        - "Filter-based design"
        - "More event types"
      filters:
        - "EVFILT_READ"
        - "EVFILT_WRITE"
        - "EVFILT_TIMER"
        - "EVFILT_SIGNAL"
      edge_cases:
        - "EV_EOF handling"
        - "NOTE_LOWAT"
        - "Modification during kevent"
        - "Cross-platform compatibility"
    
    - topic: "io_uring"
      description: "Linux io_uring for async I/O"
      complexity: "expert"
      api_reference: "io_uring(7)"
      features:
        - "Submission/completion queues"
        - "Zero syscall operation"
        - "Vectored I/O support"
        - "Linked operations"
      operations:
        - "IORING_OP_ACCEPT"
        - "IORING_OP_RECV"
        - "IORING_OP_SEND"
        - "IORING_OP_CONNECT"
      edge_cases:
        - "SQE overflow"
        - "CQE ring wraparound"
        - "Cancelation"
        - "Fixed files and buffers"
    
    - topic: "iocp_windows"
      description: "Windows I/O Completion Ports"
      complexity: "expert"
      api_reference: "MSDN"
      features:
        - "Proactor pattern"
        - "Thread pool integration"
        - "Overlapped I/O"
      edge_cases:
        - "Completion packet ordering"
        - "WSARecv with WSAEMSGSIZE"
        - "AcceptEx buffer requirements"
        - "Completion port association"
    
    - topic: "aio_posix"
      description: "POSIX AIO interface"
      complexity: "hard"
      api_reference: "aio(7)"
      behaviors:
        - "Asynchronous file I/O"
        - "Signal or callback notification"
        - "Limited socket support"
      limitations:
        - "Not true async on Linux (thread pool)"
        - "Better alternatives (io_uring)"
        - "Complex error handling"
      edge_cases:
        - "aiocb lifetime"
        - "Signal delivery"
        - "Cancelation"
        - "List-based operations"
    
    - topic: "event_fd"
      description: "eventfd for event notification"
      complexity: "medium"
      api_reference: "eventfd(2)"
      behaviors:
        - "64-bit counter"
        - "Wake up poll/epoll waiters"
        - "EFD_SEMAPHORE mode"
      use_cases:
        - "Thread synchronization"
        - "User-space event queuing"
        - "Replacing pipes for wakeup"
      edge_cases:
        - "Counter overflow"
        - "Non-blocking read"
        - "Semaphore semantics"
        - "Multiple waiters"
    
    - topic: "signal_fd"
      description: "signalfd for signal handling"
      complexity: "medium"
      api_reference: "signalfd(2)"
      behaviors:
        - "Receive signals via file descriptor"
        - "Integrate with poll/epoll"
        - "sigprocmask required"
      edge_cases:
        - "Signal delivery timing"
        - "Multiple signals queued"
        - "RT signals"
        - "Signal mask management"
    
    - topic: "timer_fd"
      description: "timerfd for timer handling"
      complexity: "medium"
      api_reference: "timerfd_create(2)"
      behaviors:
        - "Timer events via file descriptor"
        - "Integrate with poll/epoll"
        - "Absolute or relative time"
      edge_cases:
        - "Timer overrun count"
        - "Clock source selection"
        - "TFD_TIMER_ABSTIME"
        - "Disarming timer"

  # --------------------------------------------------------------------------
  # UNIX DOMAIN SOCKETS (10 topics)
  # --------------------------------------------------------------------------
  unix_sockets:
    - topic: "unix_stream_socket"
      description: "Unix domain stream sockets"
      complexity: "medium"
      api_reference: "unix(7)"
      behaviors:
        - "Local IPC only"
        - "No network overhead"
        - "File system path or abstract"
      edge_cases:
        - "Path length limits"
        - "Socket file permissions"
        - "unlinking socket file"
        - "Abstract vs pathname"
    
    - topic: "unix_dgram_socket"
      description: "Unix domain datagram sockets"
      complexity: "medium"
      api_reference: "unix(7)"
      behaviors:
        - "Connectionless"
        - "Message boundaries preserved"
        - "Must bind for recv"
      edge_cases:
        - "Buffer full behavior"
        - "Message size limits"
        - "Anonymous source"
        - "Connected dgram socket"
    
    - topic: "unix_seqpacket"
      description: "Unix domain SOCK_SEQPACKET"
      complexity: "medium"
      api_reference: "unix(7)"
      behaviors:
        - "Connection-oriented"
        - "Message boundaries preserved"
        - "Reliable in-order delivery"
      edge_cases:
        - "Platform support"
        - "Maximum message size"
        - "Partial read behavior"
        - "Zero-length messages"
    
    - topic: "fd_passing"
      description: "File descriptor passing over Unix sockets"
      complexity: "hard"
      api_reference: "unix(7), cmsg(3)"
      behaviors:
        - "SCM_RIGHTS message type"
        - "Multiple FDs per message"
        - "FD numbers change"
      edge_cases:
        - "FD table full on receive"
        - "Sender closes before recv"
        - "Maximum FDs per message"
        - "FD passing with data"
    
    - topic: "credential_passing"
      description: "Credential passing (SCM_CREDENTIALS)"
      complexity: "hard"
      api_reference: "unix(7), cmsg(3)"
      behaviors:
        - "SO_PASSCRED option required"
        - "pid, uid, gid passed"
        - "Kernel validates credentials"
      edge_cases:
        - "Unprivileged spoofing attempts"
        - "PID namespace"
        - "Supplementary groups"
        - "Root override"
    
    - topic: "abstract_namespace"
      description: "Abstract namespace Unix sockets"
      complexity: "medium"
      api_reference: "unix(7)"
      behaviors:
        - "Linux-specific"
        - "Leading null byte in path"
        - "No file system entry"
      edge_cases:
        - "Automatic cleanup"
        - "Name collision"
        - "Maximum name length"
        - "Portability issues"
    
    - topic: "unix_socket_permissions"
      description: "Unix socket file permissions"
      complexity: "medium"
      api_reference: "unix(7)"
      behaviors:
        - "File permissions affect connect"
        - "umask affects creation"
        - "chmod after bind"
      edge_cases:
        - "Root can always connect"
        - "Directory permissions"
        - "Symlink handling"
        - "SELinux labels"
    
    - topic: "socketpair"
      description: "socketpair() for bidirectional IPC"
      complexity: "medium"
      api_reference: "socketpair(2)"
      behaviors:
        - "Creates connected pair"
        - "Often used with fork()"
        - "Stream or datagram"
      edge_cases:
        - "Close one end"
        - "FD inheritance to child"
        - "Blocking behavior"
        - "Peer credential retrieval"
    
    - topic: "unix_socket_buffers"
      description: "Unix socket buffer management"
      complexity: "medium"
      api_reference: "unix(7)"
      behaviors:
        - "SO_SNDBUF/SO_RCVBUF apply"
        - "Default buffer sizes"
        - "Backpressure handling"
      edge_cases:
        - "Send buffer full"
        - "Large message handling"
        - "Zero-copy mode"
        - "Memory pressure"
    
    - topic: "unix_socket_shutdown"
      description: "Unix socket shutdown semantics"
      complexity: "medium"
      api_reference: "shutdown(2)"
      behaviors:
        - "SHUT_RD, SHUT_WR, SHUT_RDWR"
        - "Half-close support"
        - "EOF signaling"
      edge_cases:
        - "Read after SHUT_RD"
        - "Write after SHUT_WR"
        - "Shutdown vs close"
        - "Pending data"

  # --------------------------------------------------------------------------
  # RAW AND PACKET SOCKETS (8 topics)
  # --------------------------------------------------------------------------
  raw_sockets:
    - topic: "raw_ip_socket"
      description: "Raw IP socket programming"
      complexity: "expert"
      api_reference: "raw(7), ip(7)"
      behaviors:
        - "SOCK_RAW socket type"
        - "Access to IP header"
        - "CAP_NET_RAW required"
      use_cases:
        - "ICMP ping implementation"
        - "Custom protocol development"
        - "Protocol debugging"
      edge_cases:
        - "IP_HDRINCL option"
        - "Receiving all protocols"
        - "Fragmentation handling"
        - "Checksum calculation"
    
    - topic: "packet_socket"
      description: "Packet socket for link-layer access"
      complexity: "expert"
      api_reference: "packet(7)"
      behaviors:
        - "PF_PACKET family"
        - "SOCK_RAW vs SOCK_DGRAM"
        - "Promiscuous mode"
      edge_cases:
        - "VLAN tagging"
        - "TPACKET versions"
        - "Fanout modes"
        - "Hardware timestamps"
    
    - topic: "icmp_socket"
      description: "ICMP socket (non-raw)"
      complexity: "medium"
      api_reference: "icmp(7)"
      behaviors:
        - "SOCK_DGRAM + IPPROTO_ICMP"
        - "Ping without root"
        - "Kernel handles some ICMP"
      edge_cases:
        - "ping_group_range sysctl"
        - "ICMP identifier handling"
        - "Error messages"
        - "Rate limiting"
    
    - topic: "bpf_classic"
      description: "Classic BPF for packet filtering"
      complexity: "hard"
      api_reference: "bpf(4)"
      behaviors:
        - "SO_ATTACH_FILTER"
        - "Register-based VM"
        - "Per-packet filtering"
      edge_cases:
        - "BPF program limits"
        - "Verification failures"
        - "Return value meaning"
        - "cbpf vs ebpf"
    
    - topic: "netfilter_queue"
      description: "NFQUEUE for userspace packet handling"
      complexity: "expert"
      api_reference: "libnetfilter_queue"
      behaviors:
        - "Packets sent to userspace"
        - "Accept/drop/modify verdicts"
        - "iptables/nftables integration"
      edge_cases:
        - "Queue overflow"
        - "Copy mode (metadata vs full)"
        - "Verdict timeout"
        - "Multi-threaded handling"
    
    - topic: "tuntap_interface"
      description: "TUN/TAP virtual interfaces"
      complexity: "hard"
      api_reference: "tuntap(7)"
      behaviors:
        - "TUN: IP layer"
        - "TAP: Ethernet layer"
        - "Character device interface"
      use_cases:
        - "VPN implementations"
        - "Network virtualization"
        - "Containers"
      edge_cases:
        - "IFF_NO_PI flag"
        - "Multi-queue TUN"
        - "Persistent mode"
        - "vnet header"
    
    - topic: "xdp_programs"
      description: "XDP for high-performance packet processing"
      complexity: "expert"
      api_reference: "bpf(2)"
      behaviors:
        - "Process packets at driver level"
        - "Verdict: drop, pass, redirect, tx"
        - "eBPF program type"
      edge_cases:
        - "Driver support"
        - "Generic XDP"
        - "XDP metadata"
        - "XDP and tc interaction"
    
    - topic: "af_xdp"
      description: "AF_XDP for zero-copy packet I/O"
      complexity: "expert"
      api_reference: "af_xdp(7)"
      behaviors:
        - "User-space network stack"
        - "Shared UMEM"
        - "Ring buffer interface"
      edge_cases:
        - "UMEM registration"
        - "Fill and completion rings"
        - "Kernel vs driver mode"
        - "Copy mode fallback"

  # --------------------------------------------------------------------------
  # SCTP AND DCCP (6 topics)
  # --------------------------------------------------------------------------
  sctp_dccp:
    - topic: "sctp_multihoming"
      description: "SCTP multi-homing support"
      complexity: "expert"
      rfc_reference: "RFC 4960"
      behaviors:
        - "Multiple IP addresses per association"
        - "Automatic failover"
        - "Path monitoring"
      edge_cases:
        - "Primary path selection"
        - "Address change during association"
        - "Heartbeat configuration"
        - "Path MTU per destination"
    
    - topic: "sctp_multistreaming"
      description: "SCTP multi-streaming"
      complexity: "hard"
      rfc_reference: "RFC 4960"
      behaviors:
        - "Multiple independent streams"
        - "Avoid head-of-line blocking"
        - "Per-stream ordering"
      edge_cases:
        - "Stream reset"
        - "Unordered delivery"
        - "Stream ID limits"
        - "Stream scheduling"
    
    - topic: "sctp_message_oriented"
      description: "SCTP message-oriented semantics"
      complexity: "medium"
      rfc_reference: "RFC 4960"
      behaviors:
        - "Message boundaries preserved"
        - "Fragmentation by SCTP"
        - "Maximum message size"
      edge_cases:
        - "Partial delivery"
        - "Bundling"
        - "Message priority"
        - "Notification messages"
    
    - topic: "sctp_socket_api"
      description: "SCTP socket API extensions"
      complexity: "hard"
      api_reference: "sctp(7)"
      functions:
        - "sctp_bindx"
        - "sctp_connectx"
        - "sctp_sendmsg"
        - "sctp_recvmsg"
      edge_cases:
        - "One-to-one vs one-to-many style"
        - "Notification subscriptions"
        - "Association change events"
        - "Peer address change events"
    
    - topic: "dccp_congestion"
      description: "DCCP congestion control"
      complexity: "expert"
      rfc_reference: "RFC 4340"
      ccids:
        - "CCID2: TCP-like"
        - "CCID3: TFRC"
      edge_cases:
        - "CCID negotiation"
        - "Service code"
        - "Feature negotiation"
        - "Ack vectors"
    
    - topic: "dccp_unreliable"
      description: "DCCP unreliable semantics"
      complexity: "hard"
      rfc_reference: "RFC 4340"
      behaviors:
        - "Congestion-controlled UDP"
        - "Datagram service"
        - "Sequence numbers"
      edge_cases:
        - "Slow receiver"
        - "Reordering"
        - "Connection setup"
        - "Half-connections"

  # --------------------------------------------------------------------------
  # CONNECTION MANAGEMENT (10 topics)
  # --------------------------------------------------------------------------
  connection_management:
    - topic: "connection_pooling"
      description: "TCP connection pool implementation"
      complexity: "hard"
      patterns:
        - "Keep-alive connection reuse"
        - "Idle timeout management"
        - "Pool size limits"
      edge_cases:
        - "Stale connection detection"
        - "Connection validation"
        - "Pool exhaustion handling"
        - "Cross-thread access"
    
    - topic: "graceful_shutdown"
      description: "Graceful server shutdown"
      complexity: "hard"
      patterns:
        - "Stop accepting new connections"
        - "Drain existing connections"
        - "Timeout for drain"
      edge_cases:
        - "Long-running requests"
        - "WebSocket connections"
        - "Cascading shutdown"
        - "Signal handling"
    
    - topic: "connection_draining"
      description: "Connection draining for zero-downtime"
      complexity: "hard"
      patterns:
        - "Health check failure -> drain"
        - "Active request completion"
        - "New connection rejection"
      edge_cases:
        - "Streaming responses"
        - "Drain timeout"
        - "Client retry behavior"
        - "Load balancer integration"
    
    - topic: "hot_reload"
      description: "Hot reload without connection drops"
      complexity: "expert"
      patterns:
        - "FD passing to new process"
        - "Socket inheritance"
        - "Dual process handoff"
      edge_cases:
        - "In-flight requests"
        - "SSL session continuity"
        - "Shared state migration"
        - "Rollback on failure"
    
    - topic: "connection_limiting"
      description: "Connection rate and count limiting"
      complexity: "medium"
      patterns:
        - "Per-IP connection limits"
        - "Global connection limits"
        - "Rate limiting new connections"
      edge_cases:
        - "Limit exceeded handling"
        - "NAT/proxy considerations"
        - "IPv6 prefix limiting"
        - "Gradual increase"
    
    - topic: "backpressure_handling"
      description: "Backpressure propagation"
      complexity: "hard"
      patterns:
        - "Stop reading to apply backpressure"
        - "TCP window -> producer slowdown"
        - "Explicit backpressure signals"
      edge_cases:
        - "Unbounded queues"
        - "Memory exhaustion"
        - "Timeout vs backpressure"
        - "Multi-hop backpressure"
    
    - topic: "half_close_handling"
      description: "Half-close (shutdown) handling"
      complexity: "medium"
      patterns:
        - "Client closes write, server continues"
        - "Detect EOF vs error"
        - "Graceful termination"
      edge_cases:
        - "Write after read EOF"
        - "Timeout after half-close"
        - "Protocol-specific handling"
        - "Bidirectional close ordering"
    
    - topic: "keepalive_management"
      description: "Application-level keepalive"
      complexity: "medium"
      patterns:
        - "Periodic ping/pong"
        - "Idle timeout"
        - "Dead connection detection"
      edge_cases:
        - "Keepalive vs TCP keepalive"
        - "NAT timeout"
        - "Mobile networks"
        - "Proxy keepalive"
    
    - topic: "connection_upgrade"
      description: "Protocol upgrade (HTTP -> WebSocket)"
      complexity: "hard"
      patterns:
        - "HTTP 101 Switching Protocols"
        - "Connection reuse for upgrade"
        - "Buffered data handling"
      edge_cases:
        - "Failed upgrade"
        - "Buffered HTTP data"
        - "TLS upgrade (STARTTLS)"
        - "Proxy upgrade"
    
    - topic: "multiplexed_connections"
      description: "Multiplexing multiple streams"
      complexity: "hard"
      patterns:
        - "HTTP/2 streams"
        - "SSH channels"
        - "SCTP streams"
      edge_cases:
        - "Stream priority"
        - "Head-of-line blocking"
        - "Stream cancellation"
        - "Flow control per stream"

  # --------------------------------------------------------------------------
  # NAT TRAVERSAL (6 topics)
  # --------------------------------------------------------------------------
  nat_traversal:
    - topic: "stun_protocol"
      description: "STUN for NAT type detection"
      complexity: "hard"
      rfc_reference: "RFC 8489"
      behaviors:
        - "Server reflexive address discovery"
        - "NAT type classification"
        - "XOR-MAPPED-ADDRESS"
      edge_cases:
        - "Symmetric NAT"
        - "STUN over TCP"
        - "Hairpinning support"
        - "Multiple NAT layers"
    
    - topic: "turn_protocol"
      description: "TURN relay for NAT traversal"
      complexity: "hard"
      rfc_reference: "RFC 8656"
      behaviors:
        - "Relay through server"
        - "Allocation and permissions"
        - "Channel binding optimization"
      edge_cases:
        - "Allocation lifetime"
        - "Permission expiry"
        - "TCP relay"
        - "TURN over TLS"
    
    - topic: "ice_negotiation"
      description: "ICE for connectivity establishment"
      complexity: "expert"
      rfc_reference: "RFC 8445"
      behaviors:
        - "Candidate gathering"
        - "Connectivity checks"
        - "Nomination"
      edge_cases:
        - "Aggressive nomination"
        - "Trickle ICE"
        - "ICE restart"
        - "Consent freshness"
    
    - topic: "upnp_nat_pmp"
      description: "UPnP and NAT-PMP port mapping"
      complexity: "medium"
      behaviors:
        - "Automatic port forward"
        - "Temporary mapping"
        - "Router support detection"
      edge_cases:
        - "Unsupported router"
        - "Mapping conflict"
        - "Mapping lifetime"
        - "Multiple gateways"
    
    - topic: "tcp_hole_punching"
      description: "TCP hole punching technique"
      complexity: "expert"
      behaviors:
        - "Simultaneous TCP open"
        - "Rendezvous server coordination"
        - "Low success rate"
      edge_cases:
        - "Port prediction"
        - "Firewall interference"
        - "Timeout tuning"
        - "Fallback to relay"
    
    - topic: "udp_hole_punching"
      description: "UDP hole punching technique"
      complexity: "hard"
      behaviors:
        - "Both sides send to each other"
        - "NAT binding creation"
        - "Higher success than TCP"
      edge_cases:
        - "Symmetric NAT failure"
        - "Port mapping types"
        - "Binding timeout"
        - "Multiple NAT layers"

# ============================================================================
# VULNERABILITY PATTERNS - 50+ UNIQUE PATTERNS
# ============================================================================
vulnerability_patterns:
  fd_leak_patterns:
    - pattern: "error_path_fd_leak"
      description: "FD not closed when function returns error"
      severity: "high"
      cwe: "CWE-775"
      trigger_conditions:
        - "Early return without cleanup"
        - "Exception before close"
        - "Conditional close not reached"
      example: |
        fd = socket(AF_INET, SOCK_STREAM, 0);
        if (connect(fd, addr, len) < 0) {
            return -1;  // BUG: fd leaked
        }
    
    - pattern: "ssl_handshake_leak"
      description: "Socket leaked when SSL handshake fails"
      severity: "high"
      cwe: "CWE-775"
      trigger_conditions:
        - "SSL_accept/SSL_connect fails"
        - "Socket closed but not SSL"
        - "Timeout during handshake"
    
    - pattern: "accept_leak"
      description: "Accepted socket leaked"
      severity: "high"
      cwe: "CWE-775"
      trigger_conditions:
        - "accept() succeeds but subsequent init fails"
        - "Worker thread creation fails"
        - "Memory allocation fails after accept"
    
    - pattern: "dup_fd_leak"
      description: "Duplicated FD leaked"
      severity: "medium"
      cwe: "CWE-775"
      trigger_conditions:
        - "dup/dup2/dup3 without closing original"
        - "FD passed to thread then leaked"
        - "Redirected FD not restored"
    
    - pattern: "fork_fd_inheritance"
      description: "FDs inherited by fork() child"
      severity: "medium"
      cwe: "CWE-403"
      trigger_conditions:
        - "Fork without FD_CLOEXEC"
        - "Exec with inherited FDs"
        - "Parent FDs kept open in child"
    
    - pattern: "timeout_callback_leak"
      description: "Timeout handler doesn't close socket"
      severity: "high"
      cwe: "CWE-775"
      trigger_conditions:
        - "Timer fires but socket not closed"
        - "Timer cancelled but socket leaked"
        - "Race between timeout and close"
    
    - pattern: "event_loop_leak"
      description: "Socket removed from event loop but not closed"
      severity: "high"
      cwe: "CWE-775"
      trigger_conditions:
        - "epoll_ctl DEL without close"
        - "Socket unreachable after remove"
        - "Error during event handling"
    
    - pattern: "pipe_leak"
      description: "Pipe FDs leaked"
      severity: "medium"
      cwe: "CWE-775"
      trigger_conditions:
        - "pipe() succeeds but one end leaked"
        - "Writer closes, reader forgotten"
        - "Pipe in signal handler"
    
    - pattern: "temporary_file_leak"
      description: "Temporary file FD leaked"
      severity: "medium"
      cwe: "CWE-775"
      trigger_conditions:
        - "Upload processing creates temp file"
        - "Error during processing"
        - "File unlinked but FD open"
    
    - pattern: "socket_pair_leak"
      description: "socketpair FD leaked"
      severity: "medium"
      cwe: "CWE-775"
      trigger_conditions:
        - "One end closed, other forgotten"
        - "Fork and both ends kept"
        - "Error after socketpair"

  resource_exhaustion:
    - pattern: "fd_table_exhaustion"
      description: "Exhaust process FD table"
      severity: "high"
      cwe: "CWE-774"
      trigger_conditions:
        - "Too many open files"
        - "accept() returns EMFILE"
        - "socket() returns EMFILE"
      mitigation:
        - "Reserve FDs for critical operations"
        - "Implement FD accounting"
        - "Set appropriate rlimits"
    
    - pattern: "ephemeral_port_exhaustion"
      description: "Exhaust ephemeral ports"
      severity: "high"
      cwe: "CWE-400"
      trigger_conditions:
        - "Many outbound connections"
        - "TIME_WAIT accumulation"
        - "Port range too small"
    
    - pattern: "connection_table_exhaustion"
      description: "Exhaust connection tracking table"
      severity: "high"
      cwe: "CWE-400"
      trigger_conditions:
        - "Many connections through NAT"
        - "Conntrack table full"
        - "DDoS attack"
    
    - pattern: "memory_exhaustion_buffers"
      description: "Socket buffer memory exhaustion"
      severity: "high"
      cwe: "CWE-400"
      trigger_conditions:
        - "Many connections with large buffers"
        - "Slow clients not consuming data"
        - "No memory limits"
    
    - pattern: "thread_exhaustion"
      description: "Exhaust thread pool"
      severity: "high"
      cwe: "CWE-400"
      trigger_conditions:
        - "Thread per connection model"
        - "Slow requests block threads"
        - "Thread creation fails"

  race_conditions:
    - pattern: "close_race"
      description: "Race between close and other operations"
      severity: "high"
      cwe: "CWE-362"
      trigger_conditions:
        - "Thread closes while another reads"
        - "FD reused after close"
        - "Double close"
    
    - pattern: "accept_race"
      description: "Race in accept handling"
      severity: "medium"
      cwe: "CWE-362"
      trigger_conditions:
        - "Multiple threads accepting"
        - "Thundering herd"
        - "Accept and fork race"
    
    - pattern: "connect_race"
      description: "Race in non-blocking connect"
      severity: "medium"
      cwe: "CWE-362"
      trigger_conditions:
        - "Check SO_ERROR race"
        - "Multiple connect attempts"
        - "Timeout vs completion race"
    
    - pattern: "shutdown_race"
      description: "Race between shutdown and send/recv"
      severity: "medium"
      cwe: "CWE-362"
      trigger_conditions:
        - "Writer shuts down while reader active"
        - "Partial shutdown handling"
        - "Half-close race"

  security_issues:
    - pattern: "fd_passing_vulnerability"
      description: "Improper FD validation after passing"
      severity: "high"
      cwe: "CWE-20"
      trigger_conditions:
        - "Accept FD from untrusted source"
        - "No validation of passed FD type"
        - "FD capabilities not checked"
    
    - pattern: "socket_reuse_attack"
      description: "Attacker reuses server socket"
      severity: "high"
      cwe: "CWE-403"
      trigger_conditions:
        - "SO_REUSEADDR allows hijack"
        - "Port still bound after crash"
        - "Race with legitimate server"
    
    - pattern: "credential_spoofing"
      description: "Unix socket credential spoofing"
      severity: "medium"
      cwe: "CWE-287"
      trigger_conditions:
        - "Trusting SCM_CREDENTIALS without validation"
        - "Root can spoof any credentials"
        - "PID namespace confusion"
    
    - pattern: "symlink_socket_attack"
      description: "Symlink attack on socket path"
      severity: "medium"
      cwe: "CWE-59"
      trigger_conditions:
        - "Create symlink to target socket"
        - "Predictable socket path"
        - "World-writable directory"

# ============================================================================
# EDGE CASES - 100+ UNIQUE CASES
# ============================================================================
edge_cases:
  fd_limits:
    - case: "emfile_handling"
      description: "EMFILE (per-process FD limit)"
      tests:
        - "socket() returns EMFILE"
        - "accept() returns EMFILE"
        - "open() returns EMFILE"
        - "Reserved FD strategy"
      mitigation: "setrlimit(RLIMIT_NOFILE)"
    
    - case: "enfile_handling"
      description: "ENFILE (system-wide FD limit)"
      tests:
        - "System exhaustion"
        - "Different error than EMFILE"
        - "Recovery strategies"
      mitigation: "sysctl fs.file-max"
    
    - case: "fd_number_wrap"
      description: "FD number close to maximum"
      tests:
        - "FD > 1024 with select()"
        - "Large FD numbers"
        - "FD number reuse"
    
    - case: "reserved_fds"
      description: "Reserving FDs for critical operations"
      tests:
        - "Reserve FDs at startup"
        - "Use reserved FD when exhausted"
        - "Close reserved FD to proceed"

  socket_errors:
    - case: "econnrefused"
      description: "Connection refused handling"
      tests:
        - "Nothing listening on port"
        - "Service restarting"
        - "Retry with backoff"
    
    - case: "econnreset"
      description: "Connection reset by peer"
      tests:
        - "RST received"
        - "Write after reset"
        - "Read returning 0 vs error"
    
    - case: "etimedout"
      description: "Connection timeout"
      tests:
        - "Connect timeout"
        - "TCP retransmit timeout"
        - "Custom timeout handling"
    
    - case: "epipe_sigpipe"
      description: "Broken pipe handling"
      tests:
        - "SIGPIPE signal"
        - "MSG_NOSIGNAL flag"
        - "SO_NOSIGPIPE option"
        - "Signal handler setup"
    
    - case: "eagain_ewouldblock"
      description: "Would block handling"
      tests:
        - "Non-blocking operation"
        - "Buffer full"
        - "No data available"
        - "Retry strategy"
    
    - case: "eintr_handling"
      description: "Interrupted system call"
      tests:
        - "Signal during syscall"
        - "Retry loop"
        - "SA_RESTART flag"
        - "Partial operation"
    
    - case: "enetunreach"
      description: "Network unreachable"
      tests:
        - "No route to host"
        - "Interface down"
        - "Routing change"
    
    - case: "ehostunreach"
      description: "Host unreachable"
      tests:
        - "ICMP host unreachable"
        - "ARP failure"
        - "Timeout vs unreachable"
    
    - case: "eaddrinuse"
      description: "Address already in use"
      tests:
        - "Port conflict"
        - "TIME_WAIT state"
        - "SO_REUSEADDR behavior"
    
    - case: "eaddrnotavail"
      description: "Address not available"
      tests:
        - "Binding to non-local address"
        - "Interface not configured"
        - "IP_FREEBIND usage"

  buffer_edge_cases:
    - case: "zero_length_recv"
      description: "recv() returns 0"
      tests:
        - "Peer closed connection"
        - "Zero-length datagram"
        - "EOF detection"
    
    - case: "partial_send"
      description: "send() returns less than requested"
      tests:
        - "Buffer full"
        - "Signal interruption"
        - "Loop until complete"
    
    - case: "large_message"
      description: "Message larger than buffer"
      tests:
        - "Streaming read"
        - "Maximum MTU"
        - "UDP truncation"
    
    - case: "urgent_data"
      description: "Out-of-band data"
      tests:
        - "OOB mark detection"
        - "SIGURG handling"
        - "Inline OOB"

  timing_edge_cases:
    - case: "connect_timeout"
      description: "Connect timeout behavior"
      tests:
        - "SYN timeout"
        - "Custom timeout"
        - "Partial handshake"
    
    - case: "accept_backlog"
      description: "Listen backlog behavior"
      tests:
        - "Backlog full"
        - "SYN queue vs accept queue"
        - "Connection refused vs timeout"
    
    - case: "keepalive_timeout"
      description: "TCP keepalive timeout"
      tests:
        - "Idle connection probe"
        - "Probe failure"
        - "NAT timeout interaction"
    
    - case: "linger_timeout"
      description: "SO_LINGER timeout"
      tests:
        - "Close blocks until sent"
        - "Linger timeout exceeded"
        - "RST on timeout"

  platform_specific:
    - case: "linux_accept4"
      description: "Linux accept4() flags"
      tests:
        - "SOCK_NONBLOCK"
        - "SOCK_CLOEXEC"
        - "Combined flags"
        - "Fallback on older kernels"
    
    - case: "bsd_accept_filter"
      description: "BSD accept filter"
      tests:
        - "SO_ACCEPTFILTER"
        - "httpready filter"
        - "dataready filter"
    
    - case: "windows_winsock"
      description: "Windows WinSock differences"
      tests:
        - "WSAStartup requirement"
        - "SOCKET type vs int"
        - "Error code mapping"
        - "closesocket vs close"
    
    - case: "macos_connectx"
      description: "macOS connectx() for multiple addresses"
      tests:
        - "Happy Eyeballs"
        - "Interface selection"
        - "Fallback behavior"

# ============================================================================
# PLATFORM-SPECIFIC ISSUES
# ============================================================================
platform_issues:
  linux:
    fd_inheritance:
      - issue: "CLOEXEC race"
        description: "Between open/socket and fcntl"
        solution: "Use SOCK_CLOEXEC, O_CLOEXEC"
      - issue: "Fork without exec"
        description: "Child inherits all FDs"
        solution: "Close unnecessary FDs after fork"
    
    kernel_parameters:
      - param: "fs.file-max"
        description: "System-wide FD limit"
        default: "varies"
      - param: "fs.nr_open"
        description: "Per-process FD limit ceiling"
        default: 1048576
      - param: "net.core.somaxconn"
        description: "Maximum listen backlog"
        default: 4096
      - param: "net.ipv4.tcp_max_orphans"
        description: "Maximum orphaned sockets"
        default: 65536
      - param: "net.ipv4.tcp_fin_timeout"
        description: "FIN_WAIT_2 timeout"
        default: 60
      - param: "net.ipv4.tcp_max_tw_buckets"
        description: "Maximum TIME_WAIT sockets"
        default: 65536
    
    debugging_tools:
      - tool: "lsof -p PID"
        description: "List open files for process"
      - tool: "ls -la /proc/PID/fd"
        description: "View open FDs"
      - tool: "cat /proc/PID/fdinfo/FD"
        description: "FD details"
      - tool: "ss -t"
        description: "Socket statistics"
      - tool: "strace -e trace=network"
        description: "Trace network syscalls"

  bsd_macos:
    differences:
      - area: "kqueue vs epoll"
        detail: "Different event interface"
      - area: "TCP_NOPUSH vs TCP_CORK"
        detail: "Different name, similar function"
      - area: "SO_NOSIGPIPE"
        detail: "BSD/macOS specific, Linux uses MSG_NOSIGNAL"
      - area: "accept filter"
        detail: "SO_ACCEPTFILTER for connection filtering"
    
    debugging_tools:
      - tool: "lsof"
        description: "List open files"
      - tool: "netstat"
        description: "Network statistics"
      - tool: "dtrace"
        description: "Dynamic tracing"

  windows:
    differences:
      - area: "SOCKET type"
        detail: "SOCKET instead of int"
      - area: "closesocket"
        detail: "closesocket() instead of close()"
      - area: "IOCP"
        detail: "I/O Completion Ports for async"
      - area: "WSAStartup"
        detail: "Must initialize WinSock"
      - area: "Error codes"
        detail: "WSAGetLastError() vs errno"
    
    debugging_tools:
      - tool: "handle.exe"
        description: "Sysinternals handle viewer"
      - tool: "netstat -a"
        description: "Network connections"
      - tool: "Resource Monitor"
        description: "GUI resource viewer"

# ============================================================================
# DIFFICULTY CONFIGURATION
# ============================================================================
difficulty:
  estimated: "hard"
  time_range: [1800, 5400]
  command_steps: [20, 50]
  
  difficulty_matrix:
    beginner:
      time_range: [600, 1200]
      complexity: "Single FD leak, obvious path"
      example: "Missing close() on error return"
    
    intermediate:
      time_range: [1200, 2400]
      complexity: "Multiple leaks, error handling"
      example: "SSL handshake failure cleanup"
    
    advanced:
      time_range: [2400, 3600]
      complexity: "Race conditions, platform-specific"
      example: "Fork/exec FD inheritance issues"
    
    expert:
      time_range: [3600, 7200]
      complexity: "Complex lifecycle, async patterns"
      example: "Hot reload with zero-downtime"
  
  difficulty_amplifiers:
    nightmare:
      multiplier: 3.0
      description: "Production network incident requiring deep protocol expertise"
      requirements:
        - "12+ deeply interacting traps across OSI layers"
        - "Requires understanding of kernel network stack implementation"
        - "Time estimate: 90-180 minutes for senior network engineers with kernel development experience"
        - "Cross-platform protocol behavior differences"
        - "Requires synthesizing protocol specs, OS internals, and security knowledge"
    
    nightmare_plus:
      multiplier: 5.0
      estimated_time: [28800, 86400]  # 8-24 hours
      command_steps: [400, 1500]
      techniques_required: 12
      description: "Kernel-level debugging difficulty requiring intimate knowledge of TCP/IP stack implementation"
      requirements:
        - "20+ deeply interacting traps across all OSI layers and kernel subsystems"
        - "Requires kernel source-level debugging with ftrace/eBPF/SystemTap"
        - "Time estimate: 8-24 hours for kernel networking developers"
        - "Must understand socket layer implementation details across Linux/BSD/Windows"
        - "Requires reproducing issues under specific kernel memory pressure conditions"
        - "Must analyze NIC driver behavior and hardware offload interactions"
        - "Requires understanding of netfilter/iptables/nftables internal state machines"
        - "Must correlate user-space, kernel-space, and hardware-level events"
        - "Requires custom kernel module development for diagnosis"
        - "Must handle NUMA-aware socket buffer allocation edge cases"
  
  kernel_internals_requirements:
    linux_networking_stack:
      - component: "netfilter"
        knowledge_required:
          - "Connection tracking table internals (nf_conntrack)"
          - "Hook priorities and chain traversal"
          - "NAT implementation and expectation helpers"
          - "Defragmentation and reassembly caching"
      - component: "tc (Traffic Control)"
        knowledge_required:
          - "Qdisc implementation and packet scheduling"
          - "HTB/TBF token bucket algorithms"
          - "eBPF TC programs and packet modification"
          - "fq_codel and AQM algorithms"
      - component: "XDP (eXpress Data Path)"
        knowledge_required:
          - "XDP modes (native, generic, offloaded)"
          - "XDP actions and redirect chains"
          - "AF_XDP socket implementation"
          - "XDP metadata and custom headers"
      - component: "eBPF"
        knowledge_required:
          - "BPF map types for networking"
          - "Socket filter programs"
          - "Cgroup socket programs"
          - "sk_buff manipulation from eBPF"
    
    bsd_socket_layer:
      - component: "Socket buffer management"
        knowledge_required:
          - "mbuf chains and clusters"
          - "socket buffer watermarks"
          - "zero-copy receive implementation"
          - "sendfile and sosplice internals"
      - component: "Protocol switch table"
        knowledge_required:
          - "protosw structure and dispatch"
          - "PRU_* request handling"
          - "domain initialization sequence"
    
    windows_winsock:
      - component: "AFD (Ancillary Function Driver)"
        knowledge_required:
          - "TDI to WinSock mapping"
          - "IRP handling for socket operations"
          - "Completion port internals"
          - "Winsock Kernel (WSK) programming"
      - component: "NDIS (Network Driver Interface)"
        knowledge_required:
          - "NBL (NET_BUFFER_LIST) handling"
          - "Filter driver stacking"
          - "RSS (Receive Side Scaling) queue affinity"
    
    hardware_offload:
      - feature: "TSO (TCP Segmentation Offload)"
        edge_cases:
          - "TSO with VLAN tagging"
          - "TSO and GRO interaction"
          - "MTU changes with active TSO"
      - feature: "RSS (Receive Side Scaling)"
        edge_cases:
          - "Hash collision causing CPU imbalance"
          - "RSS reconfiguration under load"
          - "Symmetric RSS for bidirectional flows"
      - feature: "LRO (Large Receive Offload)"
        edge_cases:
          - "LRO breaking packet timestamps"
          - "LRO with connection tracking"
          - "LRO timeout and flushing"
  
  protocol_specification_depth:
    rfc_knowledge:
      - rfc: "RFC 793 (TCP)"
        deep_knowledge:
          - "Segment arrival processing algorithm"
          - "Retransmission timeout calculation"
          - "Silly window syndrome avoidance"
      - rfc: "RFC 7323 (TCP Extensions)"
        deep_knowledge:
          - "Window scaling implementation quirks"
          - "PAWS (Protection Against Wrapped Sequences)"
          - "Timestamp option with SACK"
      - rfc: "RFC 2018 (TCP SACK)"
        deep_knowledge:
          - "SACK block generation and processing"
          - "SACK-based loss recovery"
          - "D-SACK (Duplicate SACK)"
    
    implementation_variance:
      - protocol: "TCP"
        variances:
          - "Linux vs BSD initial window size selection"
          - "Windows vs Linux keepalive default behavior"
          - "macOS TCP_NOPUSH vs Linux TCP_CORK semantics"
          - "SO_REUSEADDR interpretation differences"
    
    state_machine_exploitation:
      - state: "TIME_WAIT"
        attacks:
          - "TIME_WAIT assassination with old duplicates"
          - "Port exhaustion through TIME_WAIT accumulation"
          - "Recycled connection data leakage"
      - state: "CLOSE_WAIT"
        attacks:
          - "CLOSE_WAIT accumulation from unread data"
          - "Half-closed connection resource exhaustion"
    
    timing_side_channels:
      - channel: "TCP timestamp"
        exploitation: "System uptime and connection tracking inference"
      - channel: "Retransmission timing"
        exploitation: "Congestion state inference"
      - channel: "ICMP response timing"
        exploitation: "Path MTU and firewall detection"
  
  hardware_considerations:
    nic_driver_edge_cases:
      - scenario: "Ring buffer exhaustion"
        symptoms: ["Packet drops", "High CPU softirq", "Interface reset"]
        diagnosis: ["ethtool -S", "watch /proc/net/softnet_stat"]
      - scenario: "TX queue stall"
        symptoms: ["Increasing latency", "TCP retransmits", "Connection timeouts"]
        diagnosis: ["ethtool -g", "tc -s qdisc", "perf top"]
      - scenario: "RSS hash collision"
        symptoms: ["Uneven CPU utilization", "Single core saturation"]
        diagnosis: ["mpstat -P ALL", "ethtool -x", "bpftrace scripts"]
    
    offload_failures:
      - feature: "Checksum offload"
        failure_modes:
          - "Incorrect checksums on loopback"
          - "Checksum errors with VLAN stripping"
          - "UDP checksum offload with fragmentation"
      - feature: "Scatter-gather"
        failure_modes:
          - "SG with too many fragments"
          - "SG and TSO interaction"
          - "Driver SG limit violations"
    
    numa_socket_affinity:
      - issue: "Cross-NUMA socket allocation"
        symptoms: ["High memory latency", "Cache thrashing"]
        solution: ["SO_INCOMING_CPU", "RPS/RFS configuration"]
      - issue: "Interrupt affinity mismatch"
        symptoms: ["Poor locality", "IPI storms"]
        solution: ["irqbalance tuning", "manual IRQ pinning"]
  
  quality_requirements:
    minimum_difficulty: "90-180 minutes for senior network engineers with kernel development experience"

anti_patterns:
  llm_failure_modes:
    - "Applying generic network debugging without considering protocol state"
    - "Missing socket option inheritance and default value issues"
    - "Ignoring MTU and fragmentation edge cases"
    - "Not considering DNS resolver library differences"
    - "Missing TIME_WAIT and connection state machine issues"
    - "Overlooking TLS handshake and certificate chain problems"
    - "Assuming network behavior is consistent across cloud providers"
    - "Missing race conditions in async network operations"
    - "Ignoring kernel parameter tuning effects on network behavior"
    - "Failing to correlate user-space FD leaks with kernel socket state"
    - "Ignoring CLOEXEC race conditions between socket() and fcntl()"
    - "Missing FD inheritance issues across fork()/exec() boundaries"
    - "Not considering SO_REUSEPORT load balancing in multi-process architectures"
    - "Overlooking epoll edge-triggered mode starvation scenarios"
    - "Ignoring socket buffer memory pressure effects on FD operations"
    - "Missing connection pool stale connection detection failures"
    - "Not correlating FD exhaustion with kernel slab allocator pressure"
    - "Failing to account for NIC hardware queue FD resource consumption"
    - "Ignoring containerized namespace FD limit isolation differences"
    - "Missing io_uring registered FD lifecycle management issues"
    - "Not considering kTLS offload FD ownership semantics"
    - "Overlooking Unix domain socket credential passing FD limits"
    - "Ignoring multipath TCP (MPTCP) subflow FD accounting"
    - "Missing SCTP association FD mapping complexities"
    - "Not handling SO_BINDTODEVICE FD/interface lifecycle coupling"
    - "Failing to trace FD passing over Unix sockets (SCM_RIGHTS)"
    - "Ignoring BPF program FD lifecycle in networking contexts"

generation_targets:
  minimum_difficulty: "90-180 minutes for senior network engineers with kernel development experience"

# ============================================================================
# LLM TRAP CONFIGURATIONS
# ============================================================================
traps:
  - type: "error_path_leak"
    description: "FD not closed when accept() succeeds but SSL handshake fails"
    trigger: "Only closing socket on success path"
    detection_method: "lsof before/after stress test"
    common_mistakes:
      - "Early return without cleanup"
      - "Exception not caught"
      - "Only closing in happy path"
  
  - type: "timeout_leak"
    description: "Timeout callback doesn't close socket properly"
    trigger: "Timer cancellation without socket cleanup"
    detection_method: "/proc/self/fd count monitoring"
    common_mistakes:
      - "Timer fires but socket left open"
      - "Timer cancelled but cleanup skipped"
      - "Race between timeout and completion"
  
  - type: "fork_inheritance"
    description: "Child process inherits parent FDs, keeping them open"
    trigger: "Not setting CLOEXEC or closing FDs after fork"
    detection_method: "Check child /proc/PID/fd"
    common_mistakes:
      - "Forgetting SOCK_CLOEXEC"
      - "Race between socket and fcntl"
      - "exec preserves non-CLOEXEC FDs"
  
  - type: "event_loop_leak"
    description: "Socket removed from epoll but not closed"
    trigger: "epoll_ctl(DEL) without close()"
    common_mistakes:
      - "Assuming remove closes socket"
      - "Error during event handling"
      - "Object destruction order"
  
  - type: "double_close"
    description: "Closing same FD twice"
    trigger: "Error handling closes, then normal path closes"
    common_mistakes:
      - "FD reused between closes"
      - "Closing wrong FD"
      - "Missing FD tracking"
  
  - type: "pool_leak"
    description: "Connection pool leaks FDs"
    trigger: "Pool eviction without close"
    common_mistakes:
      - "Stale connection not closed"
      - "Pool size exceeded without cleanup"
      - "Error during pool return"

# ============================================================================
# TASK GENERATION TEMPLATES
# ============================================================================
instruction_template: |
  You are debugging a {{ scenario_type }} server that's leaking file descriptors.
  The server code is at {{ path }}.
  
  Symptoms:
  {{ symptoms }}
  
  Your task:
  {{ task_steps }}
  
  Current ulimit: {{ fd_limit }} file descriptors

task_templates:
  fd_leak_investigation:
    template: |
      A {{ scenario_type }} server is leaking file descriptors.
      After {{ runtime }} of operation, FD count exceeds {{ fd_limit }}.
      
      Server code: {{ path }}
      
      Investigation steps:
      1. Use lsof/strace to identify leak sources
      2. Analyze error handling paths
      3. Check fork/exec FD inheritance
      4. Review connection pool lifecycle
      5. Implement proper cleanup
      
      Current FD count: {{ current_fd_count }}
      Expected maximum: {{ expected_max }}
  
  graceful_shutdown:
    template: |
      Implement graceful shutdown for {{ server_type }} server.
      
      Requirements:
      - Stop accepting new connections
      - Allow {{ drain_timeout }} seconds for drain
      - Force close after timeout
      - Zero FD leaks after shutdown
      - Clean process exit
      
      Current issues:
      {{ current_issues }}
  
  hot_reload:
    template: |
      Implement hot reload for {{ server_type }} server.
      
      Requirements:
      - No dropped connections during reload
      - FD passing to new process
      - Graceful handoff of existing connections
      - Rollback on failure
      
      Constraints:
      - Maximum {{ downtime }} ms of unavailability
      - Memory limit: {{ memory_limit }}

# ============================================================================
# REFERENCE SOLUTION
# ============================================================================
reference_solution: |
  #!/usr/bin/env python3
  """
  Fix FD leaks by ensuring cleanup in all paths.
  Key fixes:
  1. Context managers for socket operations
  2. CLOEXEC on all file descriptors
  3. Explicit cleanup in error handlers
  4. FD accounting for monitoring
  """
  
  import socket
  import ssl
  import os
  import fcntl
  from contextlib import contextmanager
  from typing import Optional
  import threading
  import logging
  
  logger = logging.getLogger(__name__)
  
  class FDTracker:
      """
      Track open file descriptors for debugging and monitoring.
      
      Thread-safe implementation that tracks FD allocation sources.
      """
      
      def __init__(self):
          self._lock = threading.Lock()
          self._fds: dict[int, str] = {}
      
      def register(self, fd: int, description: str) -> None:
          """Register an FD with a description of its purpose."""
          with self._lock:
              if fd in self._fds:
                  logger.warning(f"FD {fd} already tracked: {self._fds[fd]}")
              self._fds[fd] = description
              logger.debug(f"FD registered: {fd} ({description})")
      
      def unregister(self, fd: int) -> None:
          """Unregister an FD when closed."""
          with self._lock:
              if fd in self._fds:
                  logger.debug(f"FD unregistered: {fd} ({self._fds[fd]})")
                  del self._fds[fd]
              else:
                  logger.warning(f"Unregistering untracked FD: {fd}")
      
      def count(self) -> int:
          """Return current number of tracked FDs."""
          with self._lock:
              return len(self._fds)
      
      def report(self) -> dict[int, str]:
          """Return copy of current FD tracking state."""
          with self._lock:
              return dict(self._fds)
  
  # Global FD tracker instance
  fd_tracker = FDTracker()
  
  def set_cloexec(fd: int) -> None:
      """
      Set close-on-exec flag to prevent FD inheritance across exec.
      
      This is critical for preventing FD leaks when forking/executing
      child processes.
      """
      flags = fcntl.fcntl(fd, fcntl.F_GETFD)
      fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)
  
  def create_socket_safe(family: int, type_: int, proto: int = 0) -> socket.socket:
      """
      Create a socket with CLOEXEC set atomically.
      
      Uses SOCK_CLOEXEC where available to avoid race condition
      between socket() and fcntl().
      """
      try:
          # Try to use SOCK_CLOEXEC (Linux 2.6.27+)
          sock = socket.socket(family, type_ | socket.SOCK_CLOEXEC, proto)
      except (AttributeError, OSError):
          # Fallback for older systems
          sock = socket.socket(family, type_, proto)
          set_cloexec(sock.fileno())
      
      fd_tracker.register(sock.fileno(), f"socket({family}, {type_})")
      return sock
  
  @contextmanager
  def managed_socket(sock: socket.socket, description: str):
      """
      Context manager that guarantees socket closure.
      
      Ensures the socket is closed even if an exception occurs,
      and properly unregisters from FD tracking.
      """
      fd = sock.fileno()
      set_cloexec(fd)
      fd_tracker.register(fd, description)
      
      try:
          yield sock
      finally:
          try:
              # Attempt graceful shutdown first
              sock.shutdown(socket.SHUT_RDWR)
          except OSError:
              # Socket may already be closed or not connected
              pass
          
          try:
              sock.close()
          except OSError as e:
              logger.warning(f"Error closing socket {fd}: {e}")
          
          fd_tracker.unregister(fd)
  
  def accept_connection_safe(
      server_sock: socket.socket,
      ssl_ctx: Optional[ssl.SSLContext] = None,
      timeout: float = 30.0
  ) -> tuple[socket.socket, tuple]:
      """
      Accept connection with guaranteed cleanup on all error paths.
      
      Key safety measures:
      1. Set CLOEXEC immediately after accept
      2. Set timeout before SSL handshake
      3. Close socket on any failure
      4. Track FD for monitoring
      """
      client_sock = None
      
      try:
          # Accept with SOCK_CLOEXEC if available (Linux 2.6.28+)
          try:
              client_sock, addr = server_sock.accept()
              # Immediately set CLOEXEC
              set_cloexec(client_sock.fileno())
          except AttributeError:
              # Older API
              client_sock, addr = server_sock.accept()
              set_cloexec(client_sock.fileno())
          
          fd_tracker.register(client_sock.fileno(), f"client from {addr}")
          
          # Set timeout BEFORE SSL handshake
          client_sock.settimeout(timeout)
          
          if ssl_ctx:
              # SSL handshake can fail - MUST cleanup on failure
              try:
                  ssl_sock = ssl_ctx.wrap_socket(
                      client_sock,
                      server_side=True
                  )
                  # Update tracking to reflect SSL
                  fd_tracker.unregister(client_sock.fileno())
                  fd_tracker.register(ssl_sock.fileno(), f"SSL client from {addr}")
                  return ssl_sock, addr
              except ssl.SSLError as e:
                  logger.warning(f"SSL handshake failed for {addr}: {e}")
                  # Critical: close socket on SSL failure
                  fd_tracker.unregister(client_sock.fileno())
                  client_sock.close()
                  raise
          
          return client_sock, addr
          
      except Exception as e:
          # Ensure cleanup on ANY error
          if client_sock is not None:
              try:
                  fd_tracker.unregister(client_sock.fileno())
                  client_sock.close()
              except Exception:
                  pass
          raise
  
  def close_on_exec_all_fds(exclude: set[int] = None) -> None:
      """
      Set CLOEXEC on all open FDs (for use before fork).
      
      Alternatively, close all FDs except essential ones after fork.
      """
      if exclude is None:
          exclude = {0, 1, 2}  # stdin, stdout, stderr
      
      max_fd = os.sysconf('SC_OPEN_MAX')
      for fd in range(3, max_fd):
          if fd in exclude:
              continue
          try:
              flags = fcntl.fcntl(fd, fcntl.F_GETFD)
              fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)
          except OSError:
              # FD not open
              pass

# ============================================================================
# TEST CASES
# ============================================================================
fail_to_pass:
  - "test_fd_count_stable_under_load"
  - "test_ssl_handshake_failure_cleanup"
  - "test_timeout_cleanup"
  - "test_fork_no_inheritance"
  - "test_graceful_shutdown_no_leak"
  - "test_error_path_cleanup"

pass_to_pass:
  - "test_accept_connection"
  - "test_graceful_shutdown"
  - "test_fd_tracking_accuracy"
  - "test_cloexec_set"

test_scenarios:
  - name: "SSL handshake failure"
    setup: "Server with SSL, client sends invalid SSL data"
    expected: "Socket closed, FD count unchanged"
    severity: "high"
  
  - name: "Timeout during handshake"
    setup: "Server with timeout, client connects but doesn't complete"
    expected: "Socket closed after timeout"
    severity: "high"
  
  - name: "Fork FD inheritance"
    setup: "Server forks child process"
    expected: "Child doesn't inherit server sockets"
    severity: "medium"
  
  - name: "Load test stability"
    setup: "10000 connections over 1 hour"
    expected: "FD count stable within 10% of baseline"
    severity: "critical"

# ============================================================================
# VARIABLES FOR TASK GENERATION
# ============================================================================
variables:
  - name: scenario_type
    type: string
    options:
      - "production"
      - "high-traffic"
      - "edge"
      - "proxy"
      - "API gateway"
      - "WebSocket"
      - "gRPC"
      - "streaming"
  
  - name: path
    type: path
    generator: random_path
    patterns:
      - "src/server/{component}.py"
      - "lib/network/{component}.rs"
      - "core/transport/{component}.go"
  
  - name: fd_limit
    type: int
    min: 1024
    max: 65536
    default: 4096
  
  - name: symptoms
    type: template
    value: |
      - "Too many open files" after {{ runtime }} hours
      - Memory slowly increases
      - lsof shows thousands of {{ socket_state }} sockets
      - /proc/self/fd count: {{ fd_count }}
  
  - name: task_steps
    type: template
    value: |
      1. Profile FD usage with lsof and /proc/self/fd
      2. Identify leak sources in error paths
      3. Implement proper cleanup in all code paths
      4. Add CLOEXEC to prevent fork inheritance
      5. Verify fix under load test
      6. Add FD monitoring metrics

# ============================================================================
# ANTI-HARDCODING MEASURES
# ============================================================================
anti_hardcoding:
  canary_tokens: true
  randomize_paths: true
  dynamic_content: true
  
  randomization_strategies:
    - strategy: "FD limit variation"
      description: "Vary ulimit values"
    - strategy: "Connection count variation"
      description: "Different load levels"
    - strategy: "Error path variation"
      description: "Different failure modes"
    - strategy: "Platform variation"
      description: "Linux/BSD/Windows differences"

# ============================================================================
# SOCKET STATE DIAGRAM
# ============================================================================
#
# TCP Connection State Machine:
#
#                              
#                                  CLOSED    
#                              
#                                     
#                     
#                                                   
#                                                   
#                            
#                LISTEN       SYN_SENT           
#                            
#                                                  
#                                                  
#                            
#               SYN_RCVD       ESTAB   
#                  
#                                  
#                   
#                           
#              
#                                      
#                                      
#           
#         FIN_WAIT1  CLOSING   CLOSE_WAIT
#           
#                                     
#                                     
#                     
#         FIN_WAIT2             LAST_ACK 
#                     
#                                    
#                         
#                                     
#                                     
#                          
#              TIME_WAIT             
#                          
#                                     
#                   
#                            
#                            
#                     
#                       CLOSED  
#                     
#
# FD Lifecycle:
#
# socket()/accept()  fcntl(CLOEXEC)  connect()/bind()  I/O  shutdown()  close()
#                           
#                            fork()  exec() [FD closed automatically with CLOEXEC]
#
# ============================================================================
# END OF SOCKET FD EXHAUSTION FRAMEWORK
# ============================================================================
