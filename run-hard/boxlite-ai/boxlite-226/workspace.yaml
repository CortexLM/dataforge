id: boxlite-ai/boxlite-226
repo: boxlite-ai/boxlite
base_commit: a28dd4792025f145a593af3bd40fa8806d0b3a9f
merge_commit: 0f5b39077ae8ef978c9b98948efd5579bf8735c9
language: rust
difficulty_score: 3
created_at: 2026-02-14T14:30:23.462738851Z
patch: "diff --git a/Cargo.lock b/Cargo.lock\nindex 33428ba6..c3d8e045 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -365,11 +365,8 @@ dependencies = [\n name = \"boxlite-c\"\n version = \"0.5.10\"\n dependencies = [\n- \"boxlite\",\n+ \"boxlite-ffi\",\n  \"cbindgen\",\n- \"futures\",\n- \"serde_json\",\n- \"tokio\",\n ]\n \n [[package]]\n@@ -402,6 +399,17 @@ dependencies = [\n  \"ulid\",\n ]\n \n+[[package]]\n+name = \"boxlite-ffi\"\n+version = \"0.5.10\"\n+dependencies = [\n+ \"boxlite\",\n+ \"futures\",\n+ \"serde_json\",\n+ \"tempfile\",\n+ \"tokio\",\n+]\n+\n [[package]]\n name = \"boxlite-guest\"\n version = \"0.5.10\"\ndiff --git a/Cargo.toml b/Cargo.toml\nindex df06b120..feb9227f 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -7,6 +7,7 @@ members = [\n     \"boxlite/deps/libkrun-sys\",\n     \"boxlite-shared\",\n     \"guest\",\n+    \"sdks/boxlite-ffi\",\n     \"sdks/c\",\n     \"sdks/python\",\n     \"sdks/node\",\ndiff --git a/Makefile b/Makefile\nindex c556789e..cc1a05dd 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -30,6 +30,7 @@ help:\n \t@echo \"  Testing:\"\n \t@echo \"    make test           - Run all unit tests (Rust + Python + Node.js)\"\n \t@echo \"    make test:rust      - Run Rust unit tests\"\n+\t@echo \"    make test:ffi       - Run BoxLite FFI unit tests\"\n \t@echo \"    make test:python    - Run Python SDK unit tests\"\n \t@echo \"    make test:node      - Run Node.js SDK unit tests\"\n \t@echo \"    make test:cli       - Run CLI integration tests (prepares runtime first)\"\n@@ -177,8 +178,10 @@ dev\\:node: runtime-debug\n # Run all unit tests (excludes integration tests that require VMs)\n test:\n \t@$(MAKE) test:rust\n+\t@$(MAKE) test:ffi\n \t@$(MAKE) test:python\n \t@$(MAKE) test:node\n+\t@$(MAKE) test:c\n \t@echo \"âœ… All tests passed\"\n \n # Run Rust unit tests (single-threaded, without gvproxy to avoid Go runtime issues)\n@@ -187,6 +190,12 @@ test\\:rust:\n \t@cargo test -p boxlite --no-default-features --lib -- --test-threads=1\n \t@cargo test -p boxlite-shared --lib -- --test-threads=1\n \n+# Run BoxLite FFI unit tests\n+test\\:ffi:\n+\t@echo \"ðŸ§ª Running BoxLite FFI unit tests...\"\n+\t@cargo test -p boxlite-ffi\n+\n+\n # Run Python SDK unit tests (excludes integration tests)\n test\\:python:\n \t@echo \"ðŸ§ª Running Python SDK unit tests...\"\ndiff --git a/boxlite/src/litebox/box_impl.rs b/boxlite/src/litebox/box_impl.rs\nindex e8c72ca8..df0d57fc 100644\n--- a/boxlite/src/litebox/box_impl.rs\n+++ b/boxlite/src/litebox/box_impl.rs\n@@ -329,8 +329,13 @@ impl BoxImpl {\n         // Update state\n         {\n             let mut state = self.state.write();\n-            state.set_status(BoxStatus::Stopped);\n-            state.set_pid(None);\n+\n+            // Only transition to Stopped if we were Running (or other active state).\n+            // If we were Configured (never started), stay Configured so next start()\n+            // triggers full initialization (creating disks).\n+            if !state.status.is_configured() {\n+                state.mark_stop();\n+            }\n \n             if was_persisted {\n                 // Box was persisted - sync to DB\ndiff --git a/boxlite/src/runtime/options.rs b/boxlite/src/runtime/options.rs\nindex ae9b9c2e..f4655bb6 100644\n--- a/boxlite/src/runtime/options.rs\n+++ b/boxlite/src/runtime/options.rs\n@@ -550,6 +550,7 @@ impl Default for BoxliteOptions {\n \n /// Options used when constructing a box.\n #[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\n+#[serde(default)]\n pub struct BoxOptions {\n     pub cpus: Option<u8>,\n     pub memory_mib: Option<u32>,\ndiff --git a/sdks/boxlite-ffi/Cargo.toml b/sdks/boxlite-ffi/Cargo.toml\nnew file mode 100644\nindex 00000000..b8c7ab62\n--- /dev/null\n+++ b/sdks/boxlite-ffi/Cargo.toml\n@@ -0,0 +1,26 @@\n+[package]\n+name = \"boxlite-ffi\"\n+version.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+license.workspace = true\n+description = \"Shared FFI layer for BoxLite SDKs\"\n+\n+[lib]\n+crate-type = [\"rlib\"]\n+\n+[features]\n+default = []\n+gvproxy-backend = [\"boxlite/gvproxy-backend\"]\n+libslirp-backend = [\"boxlite/libslirp-backend\"]\n+\n+[dependencies]\n+boxlite = { path = \"../../boxlite\" }\n+\n+tokio = { version = \"1.37\", features = [\"rt\", \"rt-multi-thread\"] }\n+serde_json = \"1.0\"\n+futures = \"0.3\"\n+\n+[dev-dependencies]\n+tempfile = \"3.10\"\n+\ndiff --git a/sdks/boxlite-ffi/src/error.rs b/sdks/boxlite-ffi/src/error.rs\nnew file mode 100644\nindex 00000000..0941cfe8\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/error.rs\n@@ -0,0 +1,144 @@\n+//! Error handling utilities for BoxLite FFI\n+//!\n+//! Provides error codes and conversion functions for C API error handling.\n+\n+use std::ffi::CString;\n+use std::os::raw::c_char;\n+use std::ptr;\n+\n+use boxlite::BoxliteError;\n+\n+// ============================================================================\n+// Error Code Enum - Maps to BoxliteError variants\n+// ============================================================================\n+\n+/// Error codes returned by BoxLite C API functions.\n+///\n+/// These codes map directly to Rust's BoxliteError variants,\n+/// allowing programmatic error handling in C.\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum BoxliteErrorCode {\n+    /// Operation succeeded\n+    Ok = 0,\n+    /// Internal error\n+    Internal = 1,\n+    /// Resource not found\n+    NotFound = 2,\n+    /// Resource already exists\n+    AlreadyExists = 3,\n+    /// Invalid state for operation\n+    InvalidState = 4,\n+    /// Invalid argument provided\n+    InvalidArgument = 5,\n+    /// Configuration error\n+    Config = 6,\n+    /// Storage error\n+    Storage = 7,\n+    /// Image error\n+    Image = 8,\n+    /// Network error\n+    Network = 9,\n+    /// Execution error\n+    Execution = 10,\n+    /// Resource stopped\n+    Stopped = 11,\n+    /// Engine error\n+    Engine = 12,\n+    /// Unsupported operation\n+    Unsupported = 13,\n+    /// Database error\n+    Database = 14,\n+    /// Portal/communication error\n+    Portal = 15,\n+    /// RPC error\n+    Rpc = 16,\n+    /// RPC transport error\n+    RpcTransport = 17,\n+    /// Metadata error\n+    Metadata = 18,\n+    /// Unsupported engine error\n+    UnsupportedEngine = 19,\n+}\n+\n+/// Extended error information for C API.\n+///\n+/// Contains both an error code (for programmatic handling)\n+/// and an optional detailed message (for debugging).\n+#[repr(C)]\n+pub struct FFIError {\n+    /// Error code\n+    pub code: BoxliteErrorCode,\n+    /// Detailed error message (NULL if none, caller must free with boxlite_error_free)\n+    pub message: *mut c_char,\n+}\n+\n+impl Default for FFIError {\n+    fn default() -> Self {\n+        FFIError {\n+            code: BoxliteErrorCode::Ok,\n+            message: ptr::null_mut(),\n+        }\n+    }\n+}\n+\n+/// Map BoxliteError to BoxliteErrorCode\n+pub fn error_to_code(err: &BoxliteError) -> BoxliteErrorCode {\n+    match err {\n+        BoxliteError::Internal(_) => BoxliteErrorCode::Internal,\n+        BoxliteError::NotFound(_) => BoxliteErrorCode::NotFound,\n+        BoxliteError::AlreadyExists(_) => BoxliteErrorCode::AlreadyExists,\n+        BoxliteError::InvalidState(_) => BoxliteErrorCode::InvalidState,\n+        BoxliteError::InvalidArgument(_) => BoxliteErrorCode::InvalidArgument,\n+        BoxliteError::Config(_) => BoxliteErrorCode::Config,\n+        BoxliteError::Storage(_) => BoxliteErrorCode::Storage,\n+        BoxliteError::Image(_) => BoxliteErrorCode::Image,\n+        BoxliteError::Network(_) => BoxliteErrorCode::Network,\n+        BoxliteError::Execution(_) => BoxliteErrorCode::Execution,\n+        BoxliteError::Stopped(_) => BoxliteErrorCode::Stopped,\n+        BoxliteError::Engine(_) => BoxliteErrorCode::Engine,\n+        BoxliteError::Unsupported(_) => BoxliteErrorCode::Unsupported,\n+        BoxliteError::UnsupportedEngine => BoxliteErrorCode::UnsupportedEngine,\n+        BoxliteError::Database(_) => BoxliteErrorCode::Database,\n+        BoxliteError::Portal(_) => BoxliteErrorCode::Portal,\n+        BoxliteError::Rpc(_) => BoxliteErrorCode::Rpc,\n+        BoxliteError::RpcTransport(_) => BoxliteErrorCode::RpcTransport,\n+        BoxliteError::MetadataError(_) => BoxliteErrorCode::Metadata,\n+    }\n+}\n+\n+/// Convert Rust error to C string (caller must free)\n+pub fn error_to_c_string(err: &BoxliteError) -> *mut c_char {\n+    let msg = format!(\"{}\", err);\n+    match CString::new(msg) {\n+        Ok(s) => s.into_raw(),\n+        Err(_) => {\n+            let fallback = CString::new(\"Failed to format error message\").unwrap();\n+            fallback.into_raw()\n+        }\n+    }\n+}\n+\n+/// Convert Rust error to C error struct\n+pub fn error_to_c_error(err: BoxliteError) -> FFIError {\n+    let code = error_to_code(&err);\n+    let message = error_to_c_string(&err);\n+    FFIError { code, message }\n+}\n+\n+/// Write error to output parameter (if not NULL)\n+///\n+/// # Safety\n+/// out_error must be null or a valid pointer to FFIError\n+pub unsafe fn write_error(out_error: *mut FFIError, err: BoxliteError) {\n+    unsafe {\n+        if !out_error.is_null() {\n+            *out_error = error_to_c_error(err);\n+        }\n+    }\n+}\n+\n+/// Helper to create InvalidArgument error for NULL pointers\n+pub fn null_pointer_error(param_name: &str) -> BoxliteError {\n+    BoxliteError::InvalidArgument(format!(\"{} is null\", param_name))\n+}\ndiff --git a/sdks/boxlite-ffi/src/json.rs b/sdks/boxlite-ffi/src/json.rs\nnew file mode 100644\nindex 00000000..3bc546fb\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/json.rs\n@@ -0,0 +1,33 @@\n+//! JSON serialization utilities for BoxLite FFI\n+//!\n+//! Provides functions for converting BoxLite types to JSON.\n+\n+use boxlite::runtime::types::{BoxInfo, BoxStatus};\n+\n+/// Convert BoxStatus to string representation\n+pub fn status_to_string(status: BoxStatus) -> &'static str {\n+    match status {\n+        BoxStatus::Unknown => \"unknown\",\n+        BoxStatus::Configured => \"configured\",\n+        BoxStatus::Running => \"running\",\n+        BoxStatus::Stopping => \"stopping\",\n+        BoxStatus::Stopped => \"stopped\",\n+    }\n+}\n+\n+/// Convert BoxInfo to JSON with nested state structure\n+pub fn box_info_to_json(info: &BoxInfo) -> serde_json::Value {\n+    serde_json::json!({\n+        \"id\": info.id.to_string(),\n+        \"name\": info.name,\n+        \"state\": {\n+            \"status\": status_to_string(info.status),\n+            \"running\": info.status.is_running(),\n+            \"pid\": info.pid\n+        },\n+        \"created_at\": info.created_at.to_rfc3339(),\n+        \"image\": info.image,\n+        \"cpus\": info.cpus,\n+        \"memory_mib\": info.memory_mib\n+    })\n+}\ndiff --git a/sdks/boxlite-ffi/src/lib.rs b/sdks/boxlite-ffi/src/lib.rs\nnew file mode 100644\nindex 00000000..30040151\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/lib.rs\n@@ -0,0 +1,20 @@\n+//! Shared FFI layer for BoxLite SDKs\n+//!\n+//! This crate provides common utilities for C FFI bindings across all BoxLite SDKs:\n+//! - Error handling and error codes\n+//! - C string allocation and parsing\n+//! - JSON serialization helpers\n+//! - Runtime management (Tokio + BoxliteRuntime)\n+//! - Core FFI operations implementation\n+\n+pub mod error;\n+pub mod json;\n+pub mod ops;\n+pub mod runner;\n+pub mod runtime;\n+pub mod string;\n+\n+pub use error::*;\n+pub use json::*;\n+pub use runtime::*;\n+pub use string::*;\ndiff --git a/sdks/boxlite-ffi/src/ops.rs b/sdks/boxlite-ffi/src/ops.rs\nnew file mode 100644\nindex 00000000..1eb826aa\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/ops.rs\n@@ -0,0 +1,1386 @@\n+//! Core FFI operations for BoxLite\n+//!\n+//! This module contains the internal implementation of FFI operations.\n+//! These functions are called by the SDK-specific FFI exports.\n+\n+use futures::StreamExt;\n+use std::ffi::{CString, c_void};\n+use std::os::raw::{c_char, c_int};\n+use std::ptr;\n+\n+use boxlite::litebox::LiteBox;\n+use boxlite::runtime::BoxliteRuntime;\n+use boxlite::runtime::options::{BoxOptions, BoxliteOptions};\n+use boxlite::runtime::types::BoxID;\n+use boxlite::{BoxliteError, RootfsSpec};\n+\n+use crate::error::{BoxliteErrorCode, FFIError, error_to_code, null_pointer_error, write_error};\n+use crate::json::box_info_to_json;\n+use crate::runtime::{BoxHandle, RuntimeHandle, create_tokio_runtime};\n+use crate::string::c_str_to_string;\n+\n+/// Create a new BoxliteRuntime\n+///\n+/// # Parameters\n+/// * `home_dir`: Optional path to home directory (or null for default `~/.boxlite`)\n+/// * `registries_json`: Optional JSON array of registry URLs (or null)\n+/// * `out_runtime`: Output pointer for the created `RuntimeHandle`\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// This function initializes both the Tokio runtime and the BoxLite runtime.\n+/// It parses the optional `home_dir` and `registries_json` arguments.\n+/// If `registries_json` is provided, it attempts to parse it as a JSON array of strings.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null. `out_runtime` must be a valid pointer to a pointer.\n+pub unsafe fn runtime_new(\n+    home_dir: *const c_char,\n+    registries_json: *const c_char,\n+    out_runtime: *mut *mut RuntimeHandle,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if out_runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        // Create tokio runtime\n+        let tokio_rt = match create_tokio_runtime() {\n+            Ok(rt) => rt,\n+            Err(e) => {\n+                let err = BoxliteError::Internal(e);\n+                write_error(out_error, err);\n+                return BoxliteErrorCode::Internal;\n+            }\n+        };\n+\n+        // Parse options\n+        let mut options = BoxliteOptions::default();\n+        if !home_dir.is_null() {\n+            match c_str_to_string(home_dir) {\n+                Ok(path) => options.home_dir = path.into(),\n+                Err(e) => {\n+                    write_error(out_error, e);\n+                    return BoxliteErrorCode::InvalidArgument;\n+                }\n+            }\n+        }\n+\n+        // Parse image registries (JSON array)\n+        if !registries_json.is_null() {\n+            match c_str_to_string(registries_json) {\n+                Ok(json_str) => match serde_json::from_str::<Vec<String>>(&json_str) {\n+                    Ok(registries) => options.image_registries = registries,\n+                    Err(e) => {\n+                        let err = BoxliteError::Internal(format!(\"Invalid registries JSON: {}\", e));\n+                        write_error(out_error, err);\n+                        return BoxliteErrorCode::Internal;\n+                    }\n+                },\n+                Err(e) => {\n+                    write_error(out_error, e);\n+                    return BoxliteErrorCode::InvalidArgument;\n+                }\n+            }\n+        }\n+\n+        // Create runtime\n+        let runtime = match BoxliteRuntime::new(options) {\n+            Ok(rt) => rt,\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                return code;\n+            }\n+        };\n+\n+        *out_runtime = Box::into_raw(Box::new(RuntimeHandle { runtime, tokio_rt }));\n+        BoxliteErrorCode::Ok\n+    }\n+}\n+\n+/// Create a new box\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `options_json`: JSON string defining the box configuration\n+/// * `name`: Optional name for the box (or null)\n+/// * `out_box`: Output pointer for the created `BoxHandle`\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// This function creates a new box within the given runtime.\n+/// It parses the `options_json` string into `BoxOptions`.\n+/// The operation is asynchronous, so it blocks on the runtime's Tokio executor.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_create(\n+    runtime: *mut RuntimeHandle,\n+    options_json: *const c_char,\n+    name: *const c_char,\n+    out_box: *mut *mut BoxHandle,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_box.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_box\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &mut *runtime;\n+\n+        // Parse JSON options\n+        let options_str = match c_str_to_string(options_json) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        // Parse optional name\n+        let name_opt = if name.is_null() {\n+            None\n+        } else {\n+            match c_str_to_string(name) {\n+                Ok(s) => Some(s),\n+                Err(e) => {\n+                    write_error(out_error, e);\n+                    return BoxliteErrorCode::InvalidArgument;\n+                }\n+            }\n+        };\n+\n+        let options: BoxOptions = match serde_json::from_str(&options_str) {\n+            Ok(opts) => opts,\n+            Err(e) => {\n+                let err = BoxliteError::Internal(format!(\"Invalid JSON options: {}\", e));\n+                write_error(out_error, err);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        // Create box\n+        // create() is async, so we block on the tokio runtime\n+        let result = runtime_ref\n+            .tokio_rt\n+            .block_on(runtime_ref.runtime.create(options, name_opt));\n+\n+        match result {\n+            Ok(handle) => {\n+                let box_id = handle.id().clone();\n+                *out_box = Box::into_raw(Box::new(BoxHandle {\n+                    handle,\n+                    box_id,\n+                    tokio_rt: runtime_ref.tokio_rt.clone(),\n+                }));\n+                BoxliteErrorCode::Ok\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// List all boxes as JSON\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `out_json`: Output pointer for the JSON string (must be freed)\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Retrieves the list of all boxes from the runtime and serializes them to a JSON string.\n+/// The JSON string is allocated as a CString and must be freed by the caller using `string_free`.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_list(\n+    runtime: *mut RuntimeHandle,\n+    out_json: *mut *mut c_char,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_json.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_json\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &*runtime;\n+\n+        let result = runtime_ref\n+            .tokio_rt\n+            .block_on(runtime_ref.runtime.list_info());\n+\n+        match result {\n+            Ok(boxes) => {\n+                let json_array: Vec<serde_json::Value> =\n+                    boxes.iter().map(box_info_to_json).collect();\n+                let json_str = match serde_json::to_string(&json_array) {\n+                    Ok(s) => s,\n+                    Err(e) => {\n+                        let err =\n+                            BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n+                        write_error(out_error, err);\n+                        return BoxliteErrorCode::Internal;\n+                    }\n+                };\n+\n+                match CString::new(json_str) {\n+                    Ok(s) => {\n+                        *out_json = s.into_raw();\n+                        BoxliteErrorCode::Ok\n+                    }\n+                    Err(e) => {\n+                        let err =\n+                            BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n+                        write_error(out_error, err);\n+                        BoxliteErrorCode::Internal\n+                    }\n+                }\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Stop a box\n+///\n+/// # Parameters\n+/// * `handle`: Pointer to the `BoxHandle`\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Stops the execution of a box. This is an async operation that is blocked on.\n+///\n+/// # Safety\n+/// handle must be a valid pointer to `BoxHandle`.\n+pub unsafe fn box_stop(handle: *mut BoxHandle, out_error: *mut FFIError) -> BoxliteErrorCode {\n+    unsafe {\n+        if handle.is_null() {\n+            write_error(out_error, null_pointer_error(\"handle\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let handle_ref = Box::from_raw(handle);\n+\n+        // Block on async stop using the stored tokio runtime\n+        let result = handle_ref.tokio_rt.block_on(handle_ref.handle.stop());\n+        match result {\n+            Ok(_) => BoxliteErrorCode::Ok,\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Inspect single box info as JSON\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `id_or_name`: ID or name of the box to inspect\n+/// * `out_json`: Output pointer for the JSON string\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Retrieves detailed information about a specific box identified by ID or name.\n+/// The result is serialized to JSON.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_inspect(\n+    runtime: *mut RuntimeHandle,\n+    id_or_name: *const c_char,\n+    out_json: *mut *mut c_char,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_json.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_json\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &*runtime;\n+\n+        let id_str = match c_str_to_string(id_or_name) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        let result = runtime_ref\n+            .tokio_rt\n+            .block_on(runtime_ref.runtime.get_info(&id_str));\n+\n+        match result {\n+            Ok(Some(info)) => {\n+                let json_str = match serde_json::to_string(&box_info_to_json(&info)) {\n+                    Ok(s) => s,\n+                    Err(e) => {\n+                        let err =\n+                            BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n+                        write_error(out_error, err);\n+                        return BoxliteErrorCode::Internal;\n+                    }\n+                };\n+\n+                match CString::new(json_str) {\n+                    Ok(s) => {\n+                        *out_json = s.into_raw();\n+                        BoxliteErrorCode::Ok\n+                    }\n+                    Err(e) => {\n+                        let err =\n+                            BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n+                        write_error(out_error, err);\n+                        BoxliteErrorCode::Internal\n+                    }\n+                }\n+            }\n+            Ok(None) => {\n+                let err = BoxliteError::NotFound(format!(\"Box not found: {}\", id_str));\n+                write_error(out_error, err);\n+                BoxliteErrorCode::NotFound\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Attach to an existing box\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `id_or_name`: ID or name of the box to attach to\n+/// * `out_handle`: Output pointer for the attached `BoxHandle`\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Gets a handle to an existing box. This allows performing operations on a box\n+/// that was created previously or listed.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_attach(\n+    runtime: *mut RuntimeHandle,\n+    id_or_name: *const c_char,\n+    out_handle: *mut *mut BoxHandle,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_handle.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_handle\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &*runtime;\n+\n+        let id_str = match c_str_to_string(id_or_name) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        let result = runtime_ref\n+            .tokio_rt\n+            .block_on(runtime_ref.runtime.get(&id_str));\n+\n+        match result {\n+            Ok(Some(handle)) => {\n+                let box_id = handle.id().clone();\n+                *out_handle = Box::into_raw(Box::new(BoxHandle {\n+                    handle,\n+                    box_id,\n+                    tokio_rt: runtime_ref.tokio_rt.clone(),\n+                }));\n+                BoxliteErrorCode::Ok\n+            }\n+            Ok(None) => {\n+                let err = BoxliteError::NotFound(format!(\"Box not found: {}\", id_str));\n+                write_error(out_error, err);\n+                BoxliteErrorCode::NotFound\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Remove a box\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `id_or_name`: ID or name of the box to remove\n+/// * `force`: If true, force remove even if running\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Removes a box from the runtime. If `force` is true, it attempts to stop the box if running.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_remove(\n+    runtime: *mut RuntimeHandle,\n+    id_or_name: *const c_char,\n+    force: bool,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &*runtime;\n+\n+        let id_str = match c_str_to_string(id_or_name) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        let result = runtime_ref\n+            .tokio_rt\n+            .block_on(runtime_ref.runtime.remove(&id_str, force));\n+\n+        match result {\n+            Ok(_) => BoxliteErrorCode::Ok,\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Get runtime metrics as JSON\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `out_json`: Output pointer for the JSON string\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Aggregates metrics for the entire runtime and serializes them to JSON.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn runtime_metrics(\n+    runtime: *mut RuntimeHandle,\n+    out_json: *mut *mut c_char,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_json.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_json\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &*runtime;\n+        let metrics = runtime_ref.tokio_rt.block_on(runtime_ref.runtime.metrics());\n+\n+        let json = serde_json::json!({\n+            \"boxes_created_total\": metrics.boxes_created_total(),\n+            \"boxes_failed_total\": metrics.boxes_failed_total(),\n+            \"num_running_boxes\": metrics.num_running_boxes(),\n+            \"total_commands_executed\": metrics.total_commands_executed(),\n+            \"total_exec_errors\": metrics.total_exec_errors()\n+        });\n+\n+        let json_str = match serde_json::to_string(&json) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n+                write_error(out_error, err);\n+                return BoxliteErrorCode::Internal;\n+            }\n+        };\n+\n+        match CString::new(json_str) {\n+            Ok(s) => {\n+                *out_json = s.into_raw();\n+                BoxliteErrorCode::Ok\n+            }\n+            Err(e) => {\n+                let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n+                write_error(out_error, err);\n+                BoxliteErrorCode::Internal\n+            }\n+        }\n+    }\n+}\n+\n+/// Gracefully shutdown all boxes in this runtime\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to the `RuntimeHandle`\n+/// * `timeout`: Optional timeout in seconds\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Attempts to stop all running boxes. Accepts an optional timeout via `Option<i32>`.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn runtime_shutdown(\n+    runtime: *mut RuntimeHandle,\n+    timeout: Option<i32>,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runtime.is_null() {\n+            write_error(out_error, null_pointer_error(\"runtime\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runtime_ref = &*runtime;\n+\n+        let result = runtime_ref\n+            .tokio_rt\n+            .block_on(runtime_ref.runtime.shutdown(timeout));\n+\n+        match result {\n+            Ok(()) => BoxliteErrorCode::Ok,\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+pub type OutputCallback = extern \"C\" fn(*const c_char, c_int, *mut c_void);\n+\n+/// Execute a command in a box\n+///\n+/// # Parameters\n+/// * `handle`: Pointer to the `BoxHandle`\n+/// * `command`: Command to execute (e.g., \"/bin/sh\")\n+/// * `args_json`: JSON string of arguments (e.g., `[\"-c\", \"echo hello\"]`)\n+/// * `callback`: Optional callback function for streaming output\n+/// * `user_data`: User data pointer to be passed to the callback\n+/// * `out_exit_code`: Output pointer for the exit code\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Executes a command inside the container. Supports streaming output via a callback function.\n+/// Takes arguments as a JSON string.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+///\n+pub unsafe fn box_exec(\n+    handle: *mut BoxHandle,\n+    command: *const c_char,\n+    args_json: *const c_char,\n+    callback: Option<OutputCallback>,\n+    user_data: *mut c_void,\n+    out_exit_code: *mut c_int,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if handle.is_null() {\n+            write_error(out_error, null_pointer_error(\"handle\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        if out_exit_code.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_exit_code\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let handle_ref = &mut *handle;\n+\n+        // Parse command\n+        let cmd_str = match c_str_to_string(command) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                return code;\n+            }\n+        };\n+\n+        // Parse args\n+        let args: Vec<String> = if !args_json.is_null() {\n+            match c_str_to_string(args_json) {\n+                Ok(json_str) => match serde_json::from_str(&json_str) {\n+                    Ok(a) => a,\n+                    Err(e) => {\n+                        let err = BoxliteError::Internal(format!(\"Invalid args JSON: {}\", e));\n+                        write_error(out_error, err);\n+                        return BoxliteErrorCode::InvalidArgument;\n+                    }\n+                },\n+                Err(e) => {\n+                    let code = error_to_code(&e);\n+                    write_error(out_error, e);\n+                    return code;\n+                }\n+            }\n+        } else {\n+            vec![]\n+        };\n+\n+        let mut cmd = boxlite::BoxCommand::new(cmd_str);\n+        cmd = cmd.args(args);\n+\n+        // Execute command using new API\n+        let result = handle_ref.tokio_rt.block_on(async {\n+            let mut execution = handle_ref.handle.exec(cmd).await?;\n+\n+            // Stream output to callback if provided\n+            if let Some(cb) = callback {\n+                use futures::StreamExt;\n+\n+                // Take stdout and stderr\n+                let mut stdout = execution.stdout();\n+                let mut stderr = execution.stderr();\n+\n+                // Read both streams\n+                loop {\n+                    tokio::select! {\n+                        Some(line) = async {\n+                            match &mut stdout {\n+                                Some(s) => s.next().await,\n+                                None => None,\n+                            }\n+                        } => {\n+                            let c_text = CString::new(line).unwrap_or_default();\n+                            cb(c_text.as_ptr(), 0, user_data); // 0 = stdout\n+                        }\n+                        Some(line) = async {\n+                            match &mut stderr {\n+                                Some(s) => s.next().await,\n+                                None => None,\n+                            }\n+                        } => {\n+                            let c_text = CString::new(line).unwrap_or_default();\n+                            cb(c_text.as_ptr(), 1, user_data); // 1 = stderr\n+                        }\n+                        else => break,\n+                    }\n+                }\n+            }\n+            // Now wait for completion (should not deadlock due to output backpressure)\n+            let status = execution.wait().await?;\n+            Ok::<i32, BoxliteError>(status.exit_code)\n+        });\n+\n+        match result {\n+            Ok(exit_code) => {\n+                *out_exit_code = exit_code;\n+                BoxliteErrorCode::Ok\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Get box info from handle as JSON\n+///\n+/// # Parameters\n+/// * `handle`: Pointer to the `BoxHandle`\n+/// * `out_json`: Output pointer for the JSON string\n+/// * `out_error`: Output pointer for error details\n+///\n+/// # Implementation Note\n+/// Retrieves info for a box handle. Useful for getting the status of an attached box.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_inspect_handle(\n+    handle: *mut BoxHandle,\n+    out_json: *mut *mut c_char,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if handle.is_null() {\n+            write_error(out_error, null_pointer_error(\"handle\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_json.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_json\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let handle_ref = &*handle;\n+        let info = handle_ref.handle.info();\n+\n+        let json_str = match serde_json::to_string(&box_info_to_json(&info)) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n+                write_error(out_error, err);\n+                return BoxliteErrorCode::Internal;\n+            }\n+        };\n+\n+        match CString::new(json_str) {\n+            Ok(s) => {\n+                *out_json = s.into_raw();\n+                BoxliteErrorCode::Ok\n+            }\n+            Err(e) => {\n+                let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n+                write_error(out_error, err);\n+                BoxliteErrorCode::Internal\n+            }\n+        }\n+    }\n+}\n+\n+/// Get box metrics from handle as JSON\n+///\n+/// # Implementation Note\n+/// Retrieves real-time metrics for a specific box.\n+///\n+/// # Safety\n+/// All pointer parameters must be valid or null.\n+pub unsafe fn box_metrics(\n+    handle: *mut BoxHandle,\n+    out_json: *mut *mut c_char,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if handle.is_null() {\n+            write_error(out_error, null_pointer_error(\"handle\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_json.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_json\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let handle_ref = &*handle;\n+\n+        let result = handle_ref.tokio_rt.block_on(handle_ref.handle.metrics());\n+\n+        match result {\n+            Ok(metrics) => {\n+                let json = serde_json::json!({\n+                    \"cpu_percent\": metrics.cpu_percent,\n+                    \"memory_bytes\": metrics.memory_bytes,\n+                    \"commands_executed_total\": metrics.commands_executed_total,\n+                    \"exec_errors_total\": metrics.exec_errors_total,\n+                    \"bytes_sent_total\": metrics.bytes_sent_total,\n+                    \"bytes_received_total\": metrics.bytes_received_total,\n+                    \"total_create_duration_ms\": metrics.total_create_duration_ms,\n+                    \"guest_boot_duration_ms\": metrics.guest_boot_duration_ms,\n+                    \"network_bytes_sent\": metrics.network_bytes_sent,\n+                    \"network_bytes_received\": metrics.network_bytes_received,\n+                    \"network_tcp_connections\": metrics.network_tcp_connections,\n+                    \"network_tcp_errors\": metrics.network_tcp_errors\n+                });\n+\n+                let json_str = match serde_json::to_string(&json) {\n+                    Ok(s) => s,\n+                    Err(e) => {\n+                        let err =\n+                            BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n+                        write_error(out_error, err);\n+                        return BoxliteErrorCode::Internal;\n+                    }\n+                };\n+\n+                match CString::new(json_str) {\n+                    Ok(s) => {\n+                        *out_json = s.into_raw();\n+                        BoxliteErrorCode::Ok\n+                    }\n+                    Err(e) => {\n+                        let err =\n+                            BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n+                        write_error(out_error, err);\n+                        BoxliteErrorCode::Internal\n+                    }\n+                }\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Free a runtime instance\n+///\n+/// # Parameters\n+/// * `runtime`: Pointer to `RuntimeHandle`\n+///\n+/// # Implementation Note\n+/// Releases the `RuntimeHandle` and drops the Tokio runtime.\n+///\n+/// # Safety\n+/// runtime must be null or a valid pointer to RuntimeHandle\n+pub unsafe fn runtime_free(runtime: *mut RuntimeHandle) {\n+    if !runtime.is_null() {\n+        unsafe {\n+            drop(Box::from_raw(runtime));\n+        }\n+    }\n+}\n+\n+/// Free a string allocated by BoxLite\n+///\n+/// # Parameters\n+/// * `str`: Pointer to the string\n+///\n+/// # Implementation Note\n+/// Frees a `CString` that was allocated by Rust and passed to C.\n+///\n+/// # Safety\n+/// str must be null or a valid pointer to c_char allocated by CString\n+pub unsafe fn string_free(str: *mut c_char) {\n+    if !str.is_null() {\n+        unsafe {\n+            drop(CString::from_raw(str));\n+        }\n+    }\n+}\n+\n+/// Free error struct\n+///\n+/// # Implementation Note\n+/// Frees the `message` string within the `FFIError` struct and resets the code.\n+///\n+/// # Safety\n+/// error must be null or a valid pointer to FFIError\n+pub unsafe fn error_free(error: *mut FFIError) {\n+    if !error.is_null() {\n+        unsafe {\n+            let err = &mut *error;\n+            if !err.message.is_null() {\n+                drop(CString::from_raw(err.message));\n+                err.message = ptr::null_mut();\n+            }\n+            err.code = BoxliteErrorCode::Ok;\n+        }\n+    }\n+}\n+\n+/// Get BoxLite version string\n+///\n+/// # Implementation Note\n+/// Returns a static C string containing the package version.\n+/// This string is statically allocated and should NOT be freed.\n+///\n+/// # Returns\n+/// Static string containing the version (e.g., \"0.1.0\")\n+pub extern \"C\" fn version() -> *const c_char {\n+    // Static string, safe to return pointer\n+    concat!(env!(\"CARGO_PKG_VERSION\"), \"\\0\").as_ptr() as *const c_char\n+}\n+\n+/// Create and start a box runner\n+///\n+/// # Implementation Note\n+/// Creates a `BoxRunner` which encapsulates a runtime and a single box.\n+/// Simplified API for quick execution.\n+///\n+/// # Safety\n+/// All pointers must be valid\n+pub unsafe fn runner_new(\n+    image: *const c_char,\n+    cpus: c_int,\n+    memory_mib: c_int,\n+    out_runner: *mut *mut crate::runner::BoxRunner,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if image.is_null() {\n+            write_error(out_error, null_pointer_error(\"image\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_runner.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_runner\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let image_str = match c_str_to_string(image) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        let tokio_rt = match create_tokio_runtime() {\n+            Ok(rt) => rt,\n+            Err(e) => {\n+                let err = BoxliteError::Internal(format!(\"Failed to create async runtime: {}\", e));\n+                write_error(out_error, err);\n+                return BoxliteErrorCode::Internal;\n+            }\n+        };\n+\n+        let runtime = match BoxliteRuntime::new(BoxliteOptions::default()) {\n+            Ok(rt) => rt,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::Internal;\n+            }\n+        };\n+\n+        let options = BoxOptions {\n+            rootfs: RootfsSpec::Image(image_str),\n+            cpus: if cpus > 0 { Some(cpus as u8) } else { None },\n+            memory_mib: if memory_mib > 0 {\n+                Some(memory_mib as u32)\n+            } else {\n+                None\n+            },\n+            ..Default::default()\n+        };\n+\n+        let result = tokio_rt.block_on(async {\n+            let handle = runtime.create(options, None).await?;\n+            let box_id = handle.id().clone();\n+            Ok::<(LiteBox, BoxID), BoxliteError>((handle, box_id))\n+        });\n+\n+        match result {\n+            Ok((handle, box_id)) => {\n+                let runner = Box::new(crate::runner::BoxRunner::new(\n+                    runtime, handle, box_id, tokio_rt,\n+                ));\n+                *out_runner = Box::into_raw(runner);\n+                BoxliteErrorCode::Ok\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Run a command using the runner\n+///\n+/// # Implementation Note\n+/// Executes a command on the runner's box. Returns buffered stdout/stderr.\n+///\n+/// # Safety\n+/// All pointers must be valid\n+pub unsafe fn runner_exec(\n+    runner: *mut crate::runner::BoxRunner,\n+    command: *const c_char,\n+    args: *const *const c_char,\n+    argc: c_int,\n+    out_result: *mut *mut crate::runner::ExecResult,\n+    out_error: *mut FFIError,\n+) -> BoxliteErrorCode {\n+    unsafe {\n+        if runner.is_null() {\n+            write_error(out_error, null_pointer_error(\"runner\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if command.is_null() {\n+            write_error(out_error, null_pointer_error(\"command\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+        if out_result.is_null() {\n+            write_error(out_error, null_pointer_error(\"out_result\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let runner_ref = &mut *runner;\n+\n+        let cmd_str = match c_str_to_string(command) {\n+            Ok(s) => s,\n+            Err(e) => {\n+                write_error(out_error, e);\n+                return BoxliteErrorCode::InvalidArgument;\n+            }\n+        };\n+\n+        let mut arg_vec = Vec::new();\n+        if !args.is_null() {\n+            for i in 0..argc {\n+                let arg_ptr = *args.offset(i as isize);\n+                if arg_ptr.is_null() {\n+                    break;\n+                }\n+                match c_str_to_string(arg_ptr) {\n+                    Ok(s) => arg_vec.push(s),\n+                    Err(e) => {\n+                        write_error(out_error, e);\n+                        return BoxliteErrorCode::InvalidArgument;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let handle = match &runner_ref.handle {\n+            Some(h) => h,\n+            None => {\n+                write_error(\n+                    out_error,\n+                    BoxliteError::InvalidState(\"Box not initialized\".to_string()),\n+                );\n+                return BoxliteErrorCode::InvalidState;\n+            }\n+        };\n+\n+        let result = runner_ref.tokio_rt.block_on(async {\n+            let mut cmd = boxlite::BoxCommand::new(cmd_str);\n+            cmd = cmd.args(arg_vec);\n+\n+            let mut execution = handle.exec(cmd).await?;\n+\n+            let mut stdout_lines = Vec::new();\n+            let mut stderr_lines = Vec::new();\n+\n+            let mut stdout_stream = execution.stdout();\n+            let mut stderr_stream = execution.stderr();\n+\n+            loop {\n+                tokio::select! {\n+                    Some(line) = async {\n+                        match &mut stdout_stream {\n+                            Some(s) => s.next().await,\n+                            None => None,\n+                        }\n+                    } => {\n+                        stdout_lines.push(line);\n+                    }\n+                    Some(line) = async {\n+                        match &mut stderr_stream {\n+                            Some(s) => s.next().await,\n+                            None => None,\n+                        }\n+                    } => {\n+                        stderr_lines.push(line);\n+                    }\n+                    else => break,\n+                }\n+            }\n+\n+            let status = execution.wait().await?;\n+\n+            Ok::<(i32, String, String), BoxliteError>((\n+                status.exit_code,\n+                stdout_lines.join(\"\\n\"),\n+                stderr_lines.join(\"\\n\"),\n+            ))\n+        });\n+\n+        match result {\n+            Ok((exit_code, stdout, stderr)) => {\n+                let stdout_c = match CString::new(stdout) {\n+                    Ok(s) => s.into_raw(),\n+                    Err(_) => ptr::null_mut(),\n+                };\n+                let stderr_c = match CString::new(stderr) {\n+                    Ok(s) => s.into_raw(),\n+                    Err(_) => ptr::null_mut(),\n+                };\n+\n+                let exec_result = Box::new(crate::runner::ExecResult {\n+                    exit_code,\n+                    stdout_text: stdout_c,\n+                    stderr_text: stderr_c,\n+                });\n+                *out_result = Box::into_raw(exec_result);\n+                BoxliteErrorCode::Ok\n+            }\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Free execution result\n+///\n+/// # Implementation Note\n+/// Frees the `ExecResult` struct and its contained strings.\n+///\n+/// # Safety\n+/// result must be null or valid pointer\n+pub unsafe fn result_free(result: *mut crate::runner::ExecResult) {\n+    if !result.is_null() {\n+        unsafe {\n+            let result_box = Box::from_raw(result);\n+            if !result_box.stdout_text.is_null() {\n+                drop(CString::from_raw(result_box.stdout_text));\n+            }\n+            if !result_box.stderr_text.is_null() {\n+                drop(CString::from_raw(result_box.stderr_text));\n+            }\n+        }\n+    }\n+}\n+\n+/// Free runner (auto-cleanup)\n+///\n+/// # Implementation Note\n+/// Frees the `BoxRunner`. This triggers cleanup of the box (stopping and removing it).\n+///\n+/// # Safety\n+/// runner must be null or valid pointer\n+pub unsafe fn runner_free(runner: *mut crate::runner::BoxRunner) {\n+    if !runner.is_null() {\n+        unsafe {\n+            let mut runner_box = Box::from_raw(runner);\n+\n+            if let Some(handle) = runner_box.handle.take() {\n+                let _ = runner_box.tokio_rt.block_on(handle.stop());\n+            }\n+\n+            if let Some(box_id) = runner_box.box_id.take() {\n+                let _ = runner_box\n+                    .tokio_rt\n+                    .block_on(runner_box.runtime.remove(box_id.as_ref(), true));\n+            }\n+\n+            drop(runner_box);\n+        }\n+    }\n+}\n+\n+/// Start or restart a stopped box\n+///\n+/// # Implementation Note\n+/// Starts the box execution.\n+///\n+/// # Safety\n+/// handle must be valid or null\n+pub unsafe fn box_start(handle: *mut BoxHandle, out_error: *mut FFIError) -> BoxliteErrorCode {\n+    unsafe {\n+        if handle.is_null() {\n+            write_error(out_error, null_pointer_error(\"handle\"));\n+            return BoxliteErrorCode::InvalidArgument;\n+        }\n+\n+        let handle_ref = &*handle;\n+\n+        match handle_ref.tokio_rt.block_on(handle_ref.handle.start()) {\n+            Ok(_) => BoxliteErrorCode::Ok,\n+            Err(e) => {\n+                let code = error_to_code(&e);\n+                write_error(out_error, e);\n+                code\n+            }\n+        }\n+    }\n+}\n+\n+/// Get box ID string from handle\n+///\n+/// # Implementation Note\n+/// Returns the Box ID as a newly allocated C string. Caller must free.\n+///\n+/// # Safety\n+/// handle must be valid or null\n+pub unsafe fn box_id(handle: *mut BoxHandle) -> *mut c_char {\n+    unsafe {\n+        if handle.is_null() {\n+            return ptr::null_mut();\n+        }\n+\n+        let handle_ref = &*handle;\n+        let id_str = handle_ref.handle.id().to_string();\n+\n+        match CString::new(id_str) {\n+            Ok(s) => s.into_raw(),\n+            Err(_) => ptr::null_mut(),\n+        }\n+    }\n+}\n+\n+/// Free a box handle\n+///\n+/// # Implementation Note\n+/// Frees the `BoxHandle`. Note that this does NOT destroy the box itself, only the handle.\n+/// To destroy the box, use `box_remove`.\n+///\n+/// # Safety\n+/// handle must be null or a valid pointer to BoxHandle\n+pub unsafe fn box_free(handle: *mut BoxHandle) {\n+    if !handle.is_null() {\n+        unsafe {\n+            drop(Box::from_raw(handle));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::error::error_to_c_error;\n+    use crate::json::status_to_string;\n+    use boxlite::runtime::types::BoxStatus;\n+    use std::ffi::CStr;\n+\n+    #[test]\n+    fn test_version_string() {\n+        let ver = version();\n+        assert!(!ver.is_null());\n+        let ver_str = unsafe { CStr::from_ptr(ver) }.to_str().unwrap();\n+        assert!(!ver_str.is_empty());\n+        assert!(ver_str.contains('.'));\n+    }\n+\n+    #[test]\n+    fn test_error_code_mapping() {\n+        assert_eq!(\n+            error_to_code(&BoxliteError::NotFound(\"test\".into())),\n+            BoxliteErrorCode::NotFound\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::AlreadyExists(\"test\".into())),\n+            BoxliteErrorCode::AlreadyExists\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::InvalidState(\"test\".into())),\n+            BoxliteErrorCode::InvalidState\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::InvalidArgument(\"test\".into())),\n+            BoxliteErrorCode::InvalidArgument\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::Internal(\"test\".into())),\n+            BoxliteErrorCode::Internal\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::Config(\"test\".into())),\n+            BoxliteErrorCode::Config\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::Storage(\"test\".into())),\n+            BoxliteErrorCode::Storage\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::Image(\"test\".into())),\n+            BoxliteErrorCode::Image\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::Network(\"test\".into())),\n+            BoxliteErrorCode::Network\n+        );\n+        assert_eq!(\n+            error_to_code(&BoxliteError::Execution(\"test\".into())),\n+            BoxliteErrorCode::Execution\n+        );\n+    }\n+\n+    #[test]\n+    fn test_error_struct_creation() {\n+        let err = BoxliteError::NotFound(\"box123\".into());\n+        let mut c_err = error_to_c_error(err);\n+        assert_eq!(c_err.code, BoxliteErrorCode::NotFound);\n+        assert!(!c_err.message.is_null());\n+        unsafe {\n+            error_free(&mut c_err as *mut _);\n+        }\n+        assert!(c_err.message.is_null());\n+        assert_eq!(c_err.code, BoxliteErrorCode::Ok);\n+    }\n+\n+    #[test]\n+    fn test_null_pointer_validation() {\n+        unsafe {\n+            let mut error = FFIError::default();\n+            // runtime_new with null out_runtime should return InvalidArgument\n+            let code = runtime_new(\n+                ptr::null(),\n+                ptr::null(),\n+                ptr::null_mut(),\n+                &mut error as *mut _,\n+            );\n+            assert_eq!(code, BoxliteErrorCode::InvalidArgument);\n+            assert!(!error.message.is_null());\n+            error_free(&mut error as *mut _);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_c_string_conversion_logic() {\n+        let test_str = CString::new(\"hello\").unwrap();\n+        unsafe {\n+            let result = c_str_to_string(test_str.as_ptr());\n+            assert!(result.is_ok());\n+            assert_eq!(result.unwrap(), \"hello\");\n+        }\n+    }\n+\n+    #[test]\n+    fn test_status_to_string_mapping() {\n+        assert_eq!(status_to_string(BoxStatus::Unknown), \"unknown\");\n+        assert_eq!(status_to_string(BoxStatus::Configured), \"configured\");\n+        assert_eq!(status_to_string(BoxStatus::Running), \"running\");\n+        assert_eq!(status_to_string(BoxStatus::Stopping), \"stopping\");\n+        assert_eq!(status_to_string(BoxStatus::Stopped), \"stopped\");\n+    }\n+\n+    #[test]\n+    fn test_free_functions_null_safe() {\n+        unsafe {\n+            runtime_free(ptr::null_mut());\n+            box_free(ptr::null_mut());\n+            string_free(ptr::null_mut());\n+            error_free(ptr::null_mut());\n+            result_free(ptr::null_mut());\n+            runner_free(ptr::null_mut());\n+        }\n+    }\n+}\ndiff --git a/sdks/boxlite-ffi/src/runner.rs b/sdks/boxlite-ffi/src/runner.rs\nnew file mode 100644\nindex 00000000..d5e4a115\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/runner.rs\n@@ -0,0 +1,45 @@\n+//! High-level \"Runner\" API for quick box execution\n+//!\n+//! Provides a simplified API for creating a box, running a command, and cleaning up.\n+//! Useful for scripting and simple integrations.\n+\n+use std::os::raw::{c_char, c_int};\n+use std::sync::Arc;\n+\n+use tokio::runtime::Runtime as TokioRuntime;\n+\n+use boxlite::BoxID;\n+use boxlite::litebox::LiteBox;\n+use boxlite::runtime::BoxliteRuntime;\n+\n+/// Opaque handle for Runner API (auto-manages runtime)\n+pub struct BoxRunner {\n+    pub runtime: BoxliteRuntime,\n+    pub handle: Option<LiteBox>,\n+    pub box_id: Option<BoxID>,\n+    pub tokio_rt: Arc<TokioRuntime>,\n+}\n+\n+/// Result structure for runner command execution\n+#[repr(C)]\n+pub struct ExecResult {\n+    pub exit_code: c_int,\n+    pub stdout_text: *mut c_char,\n+    pub stderr_text: *mut c_char,\n+}\n+\n+impl BoxRunner {\n+    pub fn new(\n+        runtime: BoxliteRuntime,\n+        handle: LiteBox,\n+        box_id: BoxID,\n+        tokio_rt: Arc<TokioRuntime>,\n+    ) -> Self {\n+        Self {\n+            runtime,\n+            handle: Some(handle),\n+            box_id: Some(box_id),\n+            tokio_rt,\n+        }\n+    }\n+}\ndiff --git a/sdks/boxlite-ffi/src/runtime.rs b/sdks/boxlite-ffi/src/runtime.rs\nnew file mode 100644\nindex 00000000..f09c7995\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/runtime.rs\n@@ -0,0 +1,37 @@\n+//! Runtime management for BoxLite FFI\n+//!\n+//! Provides Tokio runtime and BoxliteRuntime handle management.\n+\n+use std::sync::Arc;\n+\n+use tokio::runtime::Runtime as TokioRuntime;\n+\n+use boxlite::BoxID;\n+use boxlite::litebox::LiteBox;\n+use boxlite::runtime::BoxliteRuntime;\n+\n+/// Opaque handle to a BoxliteRuntime instance with associated Tokio runtime\n+pub struct RuntimeHandle {\n+    pub runtime: BoxliteRuntime,\n+    pub tokio_rt: Arc<TokioRuntime>,\n+}\n+\n+/// Opaque handle to a running box\n+pub struct BoxHandle {\n+    pub handle: LiteBox,\n+    #[allow(dead_code)]\n+    pub box_id: BoxID,\n+    pub tokio_rt: Arc<TokioRuntime>,\n+}\n+\n+/// Create a new Tokio runtime\n+pub fn create_tokio_runtime() -> Result<Arc<TokioRuntime>, String> {\n+    TokioRuntime::new()\n+        .map(Arc::new)\n+        .map_err(|e| format!(\"Failed to create async runtime: {}\", e))\n+}\n+\n+/// Block on a future using the provided Tokio runtime\n+pub fn block_on<F: std::future::Future>(tokio_rt: &TokioRuntime, future: F) -> F::Output {\n+    tokio_rt.block_on(future)\n+}\ndiff --git a/sdks/boxlite-ffi/src/string.rs b/sdks/boxlite-ffi/src/string.rs\nnew file mode 100644\nindex 00000000..a5413f9d\n--- /dev/null\n+++ b/sdks/boxlite-ffi/src/string.rs\n@@ -0,0 +1,65 @@\n+//! C string utilities for BoxLite FFI\n+//!\n+//! Provides functions for converting between Rust strings and C strings.\n+\n+use std::ffi::{CStr, CString};\n+use std::os::raw::c_char;\n+use std::ptr;\n+\n+use boxlite::BoxliteError;\n+\n+/// Allocate a C string from a Rust string.\n+///\n+/// Caller must free with the corresponding free function.\n+/// Returns NULL if the string contains null bytes.\n+pub fn alloc_c_string(s: &str) -> *mut c_char {\n+    match CString::new(s) {\n+        Ok(cs) => cs.into_raw(),\n+        Err(_) => ptr::null_mut(),\n+    }\n+}\n+\n+/// Parse a C string to Rust &str (borrowed).\n+///\n+/// Returns None if the pointer is null or contains invalid UTF-8.\n+///\n+/// # Safety\n+/// ptr must be null or a valid pointer to a null-terminated C string\n+pub unsafe fn parse_c_str<'a>(ptr: *const c_char) -> Option<&'a str> {\n+    unsafe {\n+        if ptr.is_null() {\n+            return None;\n+        }\n+        CStr::from_ptr(ptr).to_str().ok()\n+    }\n+}\n+\n+/// Convert C string to Rust String (owned).\n+///\n+/// Returns an error if the pointer is null or contains invalid UTF-8.\n+///\n+/// # Safety\n+/// s must be null or a valid pointer to a null-terminated C string\n+pub unsafe fn c_str_to_string(s: *const c_char) -> Result<String, BoxliteError> {\n+    unsafe {\n+        if s.is_null() {\n+            return Err(BoxliteError::Internal(\"null pointer\".to_string()));\n+        }\n+        CStr::from_ptr(s)\n+            .to_str()\n+            .map(|s| s.to_string())\n+            .map_err(|e| BoxliteError::Internal(format!(\"invalid UTF-8: {}\", e)))\n+    }\n+}\n+\n+/// Free a C string allocated by alloc_c_string.\n+///\n+/// # Safety\n+/// s must be null or a valid pointer to a C string allocated by alloc_c_string\n+pub unsafe fn free_c_string(s: *mut c_char) {\n+    unsafe {\n+        if !s.is_null() {\n+            drop(CString::from_raw(s));\n+        }\n+    }\n+}\ndiff --git a/sdks/c/Cargo.toml b/sdks/c/Cargo.toml\nindex d0854247..c736ba9c 100644\n--- a/sdks/c/Cargo.toml\n+++ b/sdks/c/Cargo.toml\n@@ -12,15 +12,11 @@ crate-type = [\"cdylib\", \"staticlib\"]\n \n [features]\n default = []\n-gvproxy-backend = [\"boxlite/gvproxy-backend\"]\n-libslirp-backend = [\"boxlite/libslirp-backend\"]\n+gvproxy-backend = [\"boxlite-ffi/gvproxy-backend\"]\n+libslirp-backend = [\"boxlite-ffi/libslirp-backend\"]\n \n [dependencies]\n-boxlite = { path = \"../../boxlite\" }\n-\n-tokio = { version = \"1.37\", features = [\"rt\", \"rt-multi-thread\"] }\n-serde_json = \"1.0\"\n-futures = \"0.3\"\n+boxlite-ffi = { path = \"../boxlite-ffi\" }\n \n [build-dependencies]\n-cbindgen = \"0.29\"\n+cbindgen = \"0.29\"\n\\ No newline at end of file\ndiff --git a/sdks/c/build.rs b/sdks/c/build.rs\nindex 4829ab21..0e424f40 100644\n--- a/sdks/c/build.rs\n+++ b/sdks/c/build.rs\n@@ -9,17 +9,18 @@ fn main() {\n     std::fs::create_dir_all(output_file.parent().unwrap())\n         .expect(\"Failed to create include directory\");\n \n-    // Generate C header from Rust code\n+    // Load cbindgen configuration from cbindgen.toml\n+    let config_path = PathBuf::from(&crate_dir).join(\"cbindgen.toml\");\n+    let config = cbindgen::Config::from_file(&config_path).expect(\"Failed to load cbindgen.toml\");\n+\n+    // Generate C header from Rust code (including boxlite-ffi types via parse_deps)\n     cbindgen::Builder::new()\n         .with_crate(&crate_dir)\n-        .with_language(cbindgen::Language::C)\n-        .with_pragma_once(true)\n-        .with_include_guard(\"BOXLITE_H\")\n-        .with_documentation(true)\n-        .with_cpp_compat(true)\n+        .with_config(config)\n         .generate()\n         .expect(\"Unable to generate C bindings\")\n         .write_to_file(&output_file);\n \n     println!(\"cargo:rerun-if-changed=src/\");\n+    println!(\"cargo:rerun-if-changed=cbindgen.toml\");\n }\ndiff --git a/sdks/c/cbindgen.toml b/sdks/c/cbindgen.toml\nnew file mode 100644\nindex 00000000..edab0553\n--- /dev/null\n+++ b/sdks/c/cbindgen.toml\n@@ -0,0 +1,19 @@\n+# cbindgen configuration for boxlite-c\n+# See: https://github.com/mozilla/cbindgen/blob/master/docs.md\n+\n+language = \"C\"\n+include_guard = \"BOXLITE_H\"\n+pragma_once = true\n+cpp_compat = true\n+documentation = true\n+documentation_style = \"c99\"\n+\n+# Style settings\n+style = \"both\"\n+usize_is_size_t = true\n+\n+[parse]\n+# Enable parsing dependency crates to resolve types defined in boxlite-ffi\n+parse_deps = true\n+# Only parse boxlite-ffi (avoid scanning the entire boxlite core crate)\n+include = [\"boxlite-ffi\"]\ndiff --git a/sdks/c/include/boxlite.h b/sdks/c/include/boxlite.h\nindex 977934c1..7767aad3 100644\n--- a/sdks/c/include/boxlite.h\n+++ b/sdks/c/include/boxlite.h\n@@ -5,455 +5,450 @@\n \n #include <stdarg.h>\n #include <stdbool.h>\n+#include <stddef.h>\n #include <stdint.h>\n #include <stdlib.h>\n \n-/**\n- * Error codes returned by BoxLite C API functions.\n- *\n- * These codes map directly to Rust's BoxliteError variants,\n- * allowing programmatic error handling in C.\n- */\n+// Error codes returned by BoxLite C API functions.\n+//\n+// These codes map directly to Rust's BoxliteError variants,\n+// allowing programmatic error handling in C.\n typedef enum BoxliteErrorCode {\n-  /**\n-   * Operation succeeded\n-   */\n+  // Operation succeeded\n   Ok = 0,\n-  /**\n-   * Internal error\n-   */\n+  // Internal error\n   Internal = 1,\n-  /**\n-   * Resource not found\n-   */\n+  // Resource not found\n   NotFound = 2,\n-  /**\n-   * Resource already exists\n-   */\n+  // Resource already exists\n   AlreadyExists = 3,\n-  /**\n-   * Invalid state for operation\n-   */\n+  // Invalid state for operation\n   InvalidState = 4,\n-  /**\n-   * Invalid argument provided\n-   */\n+  // Invalid argument provided\n   InvalidArgument = 5,\n-  /**\n-   * Configuration error\n-   */\n+  // Configuration error\n   Config = 6,\n-  /**\n-   * Storage error\n-   */\n+  // Storage error\n   Storage = 7,\n-  /**\n-   * Image error\n-   */\n+  // Image error\n   Image = 8,\n-  /**\n-   * Network error\n-   */\n+  // Network error\n   Network = 9,\n-  /**\n-   * Execution error\n-   */\n+  // Execution error\n   Execution = 10,\n-  /**\n-   * Resource stopped\n-   */\n+  // Resource stopped\n   Stopped = 11,\n-  /**\n-   * Engine error\n-   */\n+  // Engine error\n   Engine = 12,\n-  /**\n-   * Unsupported operation\n-   */\n+  // Unsupported operation\n   Unsupported = 13,\n-  /**\n-   * Database error\n-   */\n+  // Database error\n   Database = 14,\n-  /**\n-   * Portal/communication error\n-   */\n+  // Portal/communication error\n   Portal = 15,\n-  /**\n-   * RPC error\n-   */\n+  // RPC error\n   Rpc = 16,\n+  // RPC transport error\n+  RpcTransport = 17,\n+  // Metadata error\n+  Metadata = 18,\n+  // Unsupported engine error\n+  UnsupportedEngine = 19,\n } BoxliteErrorCode;\n \n-/**\n- * Opaque handle to a running box\n- */\n-typedef struct CBoxHandle CBoxHandle;\n-\n-/**\n- * Opaque handle to a BoxliteRuntime instance\n- */\n-typedef struct CBoxliteRuntime CBoxliteRuntime;\n-\n-/**\n- * Opaque handle for simple API (auto-manages runtime)\n- */\n-typedef struct CBoxliteSimple CBoxliteSimple;\n-\n-/**\n- * Extended error information for C API.\n- *\n- * Contains both an error code (for programmatic handling)\n- * and an optional detailed message (for debugging).\n- */\n-typedef struct CBoxliteError {\n-  /**\n-   * Error code\n-   */\n+// Opaque handle to a running box\n+typedef struct BoxHandle BoxHandle;\n+\n+// Opaque handle for Runner API (auto-manages runtime)\n+typedef struct BoxRunner BoxRunner;\n+\n+// Opaque handle to a BoxliteRuntime instance with associated Tokio runtime\n+typedef struct RuntimeHandle RuntimeHandle;\n+\n+typedef struct RuntimeHandle CBoxliteRuntime;\n+\n+// Extended error information for C API.\n+//\n+// Contains both an error code (for programmatic handling)\n+// and an optional detailed message (for debugging).\n+typedef struct FFIError {\n+  // Error code\n   enum BoxliteErrorCode code;\n-  /**\n-   * Detailed error message (NULL if none, caller must free with boxlite_error_free)\n-   */\n+  // Detailed error message (NULL if none, caller must free with boxlite_error_free)\n   char *message;\n-} CBoxliteError;\n+} FFIError;\n+\n+typedef struct FFIError CBoxliteError;\n \n-/**\n- * Result structure for simple API command execution\n- */\n-typedef struct CBoxliteExecResult {\n+typedef struct BoxHandle CBoxHandle;\n+\n+typedef struct BoxRunner CBoxliteSimple;\n+\n+// Result structure for runner command execution\n+typedef struct ExecResult {\n   int exit_code;\n   char *stdout_text;\n   char *stderr_text;\n-} CBoxliteExecResult;\n+} ExecResult;\n+\n+typedef struct ExecResult CBoxliteExecResult;\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif // __cplusplus\n \n-/**\n- * Get BoxLite version string\n- *\n- * # Returns\n- * Static string containing the version (e.g., \"0.1.0\")\n- */\n+// Get BoxLite version string\n+//\n+// # Returns\n+// A pointer to a static C string containing the version. Do not free this string.\n+//\n+// # Example\n+// ```c\n+// printf(\"BoxLite Version: %s\\n\", boxlite_version());\n+// ```\n const char *boxlite_version(void);\n \n-/**\n- * Create a new BoxLite runtime\n- *\n- * # Arguments\n- * * `home_dir` - Path to BoxLite home directory (stores images, rootfs, etc.)\n- *                If NULL, uses default: ~/.boxlite\n- * * `registries_json` - JSON array of registries to search for unqualified images,\n- *                       e.g. `[\"ghcr.io\", \"quay.io\"]`. If NULL, uses default (docker.io).\n- *                       Registries are tried in order; first successful pull wins.\n- * * `out_error` - Output parameter for error message (caller must free with boxlite_free_string)\n- *\n- * # Returns\n- * Pointer to CBoxliteRuntime on success, NULL on failure\n- *\n- * # Example\n- * ```c\n- * char *error = NULL;\n- * const char *registries = \"[\\\"ghcr.io\\\", \\\"docker.io\\\"]\";\n- * BoxliteRuntime *runtime = boxlite_runtime_new(\"/tmp/boxlite\", registries, &error);\n- * if (!runtime) {\n- *     fprintf(stderr, \"Error: %s\\n\", error);\n- *     boxlite_free_string(error);\n- *     return 1;\n- * }\n- * ```\n- */\n+// Create a new BoxLite runtime configuration.\n+//\n+// # Arguments\n+// * `home_dir` - Optional path to the home directory. If NULL, defaults to `~/.boxlite`.\n+// * `registries_json` - Optional JSON array of registry configurations.\n+// * `out_runtime` - Output parameter to store the created `CBoxliteRuntime` pointer.\n+// * `out_error` - Output parameter for error information.\n+//\n+// # Returns\n+// `BoxliteErrorCode::Ok` on success, or an error code on failure.\n+//\n+// # Example\n+// ```c\n+// CBoxliteRuntime *runtime;\n+// CBoxliteError *error = malloc(sizeof(CBoxliteError));\n+// if (boxlite_runtime_new(NULL, NULL, &runtime, error) != BOXLITE_OK) {\n+//     fprintf(stderr, \"Failed to create runtime\\n\");\n+// }\n+// ```\n enum BoxliteErrorCode boxlite_runtime_new(const char *home_dir,\n                                           const char *registries_json,\n-                                          struct CBoxliteRuntime **out_runtime,\n-                                          struct CBoxliteError *out_error);\n-\n-/**\n- * Create a new box with the given options (JSON)\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `options_json` - JSON-encoded BoxOptions, e.g.:\n- *                    `{\"rootfs\": {\"Image\": \"alpine:3.19\"}, \"working_dir\": \"/workspace\"}`\n- * * `out_error` - Output parameter for error message\n- *\n- * # Returns\n- * Pointer to CBoxHandle on success, NULL on failure\n- *\n- * # Example\n- * ```c\n- * const char *opts = \"{\\\"rootfs\\\":{\\\"Image\\\":\\\"alpine:3.19\\\"}}\";\n- * BoxHandle *box = boxlite_create_box(runtime, opts, &error);\n- * ```\n- */\n-enum BoxliteErrorCode boxlite_create_box(struct CBoxliteRuntime *runtime,\n+                                          CBoxliteRuntime **out_runtime,\n+                                          CBoxliteError *out_error);\n+\n+// Create a new box with the given options (JSON).\n+//\n+// # Arguments\n+// * `runtime` - Pointer to the active `CBoxliteRuntime`.\n+// * `options_json` - JSON string defining the box (e.g., image, resources).\n+// * `out_box` - Output parameter to store the created `CBoxHandle`.\n+// * `out_error` - Output parameter for error information.\n+//\n+// # Returns\n+// `BoxliteErrorCode::Ok` on success.\n+//\n+// # Example\n+// ```c\n+// const char *options = \"{\\\"rootfs\\\": {\\\"Image\\\": \\\"alpine:latest\\\"}}\";\n+// CBoxHandle *box;\n+// if (boxlite_create_box(runtime, options, &box, error) == BOXLITE_OK) {\n+//     // Use box...\n+// }\n+// ```\n+enum BoxliteErrorCode boxlite_create_box(CBoxliteRuntime *runtime,\n                                          const char *options_json,\n-                                         struct CBoxHandle **out_box,\n-                                         struct CBoxliteError *out_error);\n-\n-/**\n- * Execute a command in a box\n- *\n- * # Arguments\n- * * `handle` - Box handle\n- * * `command` - Command to execute\n- * * `args_json` - JSON array of arguments, e.g.: `[\"arg1\", \"arg2\"]`\n- * * `callback` - Optional callback for streaming output (chunk_text, is_stderr, user_data)\n- * * `user_data` - User data passed to callback\n- * * `out_exit_code` - Output parameter for command exit code\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- *\n- * # Example\n- * ```c\n- * int exit_code;\n- * CBoxliteError error = {0};\n- * const char *args = \"[\\\"hello\\\"]\";\n- * BoxliteErrorCode code = boxlite_execute(box, \"echo\", args, NULL, NULL, &exit_code, &error);\n- * if (code == BOXLITE_OK) {\n- *     printf(\"Command exited with code: %d\\n\", exit_code);\n- * }\n- * ```\n- */\n-enum BoxliteErrorCode boxlite_execute(struct CBoxHandle *handle,\n+                                         CBoxHandle **out_box,\n+                                         CBoxliteError *out_error);\n+\n+// Execute a command in a box.\n+//\n+// # Arguments\n+// * `handle` - Box handle.\n+// * `command` - Command to execute (e.g., \"/bin/sh\").\n+// * `args_json` - JSON array of arguments, e.g.: `[\"-c\", \"echo hello\"]`.\n+// * `callback` - Optional callback for streaming output.\n+// * `user_data` - User data passed to callback.\n+// * `out_exit_code` - Output parameter for command exit code.\n+// * `out_error` - Output parameter for error information.\n+//\n+// # Returns\n+// `BoxliteErrorCode::Ok` on success.\n+//\n+// # Example\n+// ```c\n+// int exit_code;\n+// const char *args = \"[\\\"hello\\\"]\";\n+// if (boxlite_execute(box, \"echo\", args, NULL, NULL, &exit_code, error) == BOXLITE_OK) {\n+//     printf(\"Exit code: %d\\n\", exit_code);\n+// }\n+// ```\n+enum BoxliteErrorCode boxlite_execute(CBoxHandle *handle,\n                                       const char *command,\n                                       const char *args_json,\n                                       void (*callback)(const char*, int, void*),\n                                       void *user_data,\n                                       int *out_exit_code,\n-                                      struct CBoxliteError *out_error);\n-\n-/**\n- * Stop a box\n- *\n- * # Arguments\n- * * `handle` - Box handle (will be consumed/freed)\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_stop_box(struct CBoxHandle *handle, struct CBoxliteError *out_error);\n-\n-/**\n- * List all boxes as JSON\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `out_json` - Output parameter for JSON array of box info\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- *\n- * # JSON Format\n- * ```json\n- * [\n- *   {\n- *     \"id\": \"01HJK4TNRPQSXYZ8WM6NCVT9R5\",\n- *     \"name\": \"my-box\",\n- *     \"state\": { \"status\": \"running\", \"running\": true, \"pid\": 12345 },\n- *     \"created_at\": \"2024-01-15T10:30:00Z\",\n- *     \"image\": \"alpine:3.19\",\n- *     \"cpus\": 2,\n- *     \"memory_mib\": 512\n- *   }\n- * ]\n- * ```\n- */\n-enum BoxliteErrorCode boxlite_list_info(struct CBoxliteRuntime *runtime,\n+                                      CBoxliteError *out_error);\n+\n+// Stop a box.\n+//\n+// # Arguments\n+// * `handle` - Box handle.\n+// * `out_error` - output error.\n+//\n+// # Example\n+// ```c\n+// boxlite_stop_box(box, error);\n+// ```\n+enum BoxliteErrorCode boxlite_stop_box(CBoxHandle *handle, CBoxliteError *out_error);\n+\n+// List all boxes as JSON.\n+//\n+// # Arguments\n+// * `runtime` - Runtime handle.\n+// * `out_json` - Output pointer for JSON string. Caller must free this with `boxlite_free_string`.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// char *json;\n+// if (boxlite_list_info(runtime, &json, error) == BOXLITE_OK) {\n+//     printf(\"Boxes: %s\\n\", json);\n+//     boxlite_free_string(json);\n+// }\n+// ```\n+enum BoxliteErrorCode boxlite_list_info(CBoxliteRuntime *runtime,\n                                         char **out_json,\n-                                        struct CBoxliteError *out_error);\n-\n-/**\n- * Get single box info as JSON\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `id_or_name` - Box ID (full or prefix) or name\n- * * `out_json` - Output parameter for JSON object\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure (including box not found)\n- */\n-enum BoxliteErrorCode boxlite_get_info(struct CBoxliteRuntime *runtime,\n+                                        CBoxliteError *out_error);\n+\n+// Get single box info as JSON.\n+//\n+// # Arguments\n+// * `runtime` - Runtime handle.\n+// * `id_or_name` - ID or name of the box.\n+// * `out_json` - Output pointer for JSON string.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// char *json;\n+// boxlite_get_info(runtime, \"my-box\", &json, error);\n+// ```\n+enum BoxliteErrorCode boxlite_get_info(CBoxliteRuntime *runtime,\n                                        const char *id_or_name,\n                                        char **out_json,\n-                                       struct CBoxliteError *out_error);\n-\n-/**\n- * Get box handle for reattaching to an existing box\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `id_or_name` - Box ID (full or prefix) or name\n- * * `out_handle` - Output parameter for box handle\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure (including box not found)\n- */\n-enum BoxliteErrorCode boxlite_get(struct CBoxliteRuntime *runtime,\n+                                       CBoxliteError *out_error);\n+\n+// Attach to an existing box.\n+//\n+// # Arguments\n+// * `runtime` - Runtime handle.\n+// * `id_or_name` - ID or name of the box.\n+// * `out_handle` - Output pointer for box handle.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// CBoxHandle *handle;\n+// if (boxlite_get(runtime, \"my-box\", &handle, error) == BOXLITE_OK) {\n+//     // Use handle...\n+// }\n+// ```\n+enum BoxliteErrorCode boxlite_get(CBoxliteRuntime *runtime,\n                                   const char *id_or_name,\n-                                  struct CBoxHandle **out_handle,\n-                                  struct CBoxliteError *out_error);\n-\n-/**\n- * Remove a box\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `id_or_name` - Box ID (full or prefix) or name\n- * * `force` - If non-zero, force remove even if running\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_remove(struct CBoxliteRuntime *runtime,\n+                                  CBoxHandle **out_handle,\n+                                  CBoxliteError *out_error);\n+\n+// Remove a box.\n+//\n+// # Arguments\n+// * `runtime` - Runtime handle.\n+// * `id_or_name` - ID or name of the box.\n+// * `force` - 1 to force remove (stop if running), 0 otherwise.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// boxlite_remove(runtime, \"my-box\", 1, error);\n+// ```\n+enum BoxliteErrorCode boxlite_remove(CBoxliteRuntime *runtime,\n                                      const char *id_or_name,\n                                      int force,\n-                                     struct CBoxliteError *out_error);\n-\n-/**\n- * Get runtime metrics as JSON\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `out_json` - Output parameter for JSON object\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_runtime_metrics(struct CBoxliteRuntime *runtime,\n+                                     CBoxliteError *out_error);\n+\n+// Get runtime metrics as JSON.\n+//\n+// # Arguments\n+// * `runtime` - Runtime handle.\n+// * `out_json` - Output pointer for JSON string.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// char *json;\n+// boxlite_runtime_metrics(runtime, &json, error);\n+// ```\n+enum BoxliteErrorCode boxlite_runtime_metrics(CBoxliteRuntime *runtime,\n                                               char **out_json,\n-                                              struct CBoxliteError *out_error);\n-\n-/**\n- * Gracefully shutdown all boxes in this runtime.\n- *\n- * This method stops all running boxes, waiting up to `timeout` seconds\n- * for each box to stop gracefully before force-killing it.\n- *\n- * After calling this method, the runtime is permanently shut down and\n- * will return errors for any new operations (like `create()`).\n- *\n- * # Arguments\n- * * `runtime` - BoxLite runtime instance\n- * * `timeout` - Seconds to wait before force-killing each box:\n- *   - 0 - Use default timeout (10 seconds)\n- *   - Positive integer - Wait that many seconds\n- *   - -1 - Wait indefinitely (no timeout)\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_runtime_shutdown(struct CBoxliteRuntime *runtime,\n+                                              CBoxliteError *out_error);\n+\n+// Gracefully shutdown all boxes in this runtime.\n+//\n+// # Arguments\n+// * `runtime` - Runtime handle.\n+// * `timeout` - Seconds to wait before force-killing each box:\n+//   - 0 - Use default timeout (10 seconds)\n+//   - Positive integer - Wait that many seconds\n+//   - -1 - Wait indefinitely (no timeout)\n+// * `out_error` - Output parameter for error information\n+//\n+// # Example\n+// ```c\n+// boxlite_runtime_shutdown(runtime, 5, error);\n+// ```\n+enum BoxliteErrorCode boxlite_runtime_shutdown(CBoxliteRuntime *runtime,\n                                                int timeout,\n-                                               struct CBoxliteError *out_error);\n-\n-/**\n- * Get box info from handle as JSON\n- *\n- * # Arguments\n- * * `handle` - Box handle\n- * * `out_json` - Output parameter for JSON object\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_box_info(struct CBoxHandle *handle,\n+                                               CBoxliteError *out_error);\n+\n+// Get info for a box handle as JSON.\n+//\n+// # Arguments\n+// * `handle` - Box handle.\n+// * `out_json` - Output pointer for JSON string.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// char *json;\n+// boxlite_box_info(handle, &json, error);\n+// ```\n+enum BoxliteErrorCode boxlite_box_info(CBoxHandle *handle,\n                                        char **out_json,\n-                                       struct CBoxliteError *out_error);\n-\n-/**\n- * Get box metrics from handle as JSON\n- *\n- * # Arguments\n- * * `handle` - Box handle\n- * * `out_json` - Output parameter for JSON object\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_box_metrics(struct CBoxHandle *handle,\n+                                       CBoxliteError *out_error);\n+\n+// Get metrics for a box handle as JSON.\n+//\n+// # Arguments\n+// * `handle` - Box handle.\n+// * `out_json` - Output pointer for JSON string.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// char *json;\n+// boxlite_box_metrics(handle, &json, error);\n+// ```\n+enum BoxliteErrorCode boxlite_box_metrics(CBoxHandle *handle,\n                                           char **out_json,\n-                                          struct CBoxliteError *out_error);\n-\n-/**\n- * Start or restart a stopped box\n- *\n- * # Arguments\n- * * `handle` - Box handle\n- * * `out_error` - Output parameter for error information\n- *\n- * # Returns\n- * BoxliteErrorCode::Ok on success, error code on failure\n- */\n-enum BoxliteErrorCode boxlite_start_box(struct CBoxHandle *handle, struct CBoxliteError *out_error);\n-\n-/**\n- * Get box ID string from handle\n- *\n- * # Arguments\n- * * `handle` - Box handle\n- *\n- * # Returns\n- * Pointer to C string (caller must free with boxlite_free_string), NULL on failure\n- */\n-char *boxlite_box_id(struct CBoxHandle *handle);\n-\n-/**\n- * Create and start a box using simple API\n- */\n+                                          CBoxliteError *out_error);\n+\n+// Start a stopped box.\n+//\n+// # Arguments\n+// * `handle` - Box handle.\n+// * `out_error` - output error.\n+//\n+// # Example\n+// ```c\n+// boxlite_start_box(handle, error);\n+// ```\n+enum BoxliteErrorCode boxlite_start_box(CBoxHandle *handle, CBoxliteError *out_error);\n+\n+// Get box ID.\n+//\n+// # Arguments\n+// * `handle` - Box handle.\n+//\n+// # Returns\n+// Pointer to a C string containing the ID. Must be freed with `boxlite_free_string`.\n+//\n+// # Example\n+// ```c\n+// char *id = boxlite_box_id(handle);\n+// printf(\"Box ID: %s\\n\", id);\n+// boxlite_free_string(id);\n+// ```\n+char *boxlite_box_id(CBoxHandle *handle);\n+\n+// Create a simplified box runner.\n+//\n+// # Arguments\n+// * `image` - Container image.\n+// * `cpus` - Number of CPUs.\n+// * `memory_mib` - Memory in MiB.\n+// * `out_box` - Output pointer for `CBoxliteSimple,`.\n+// * `out_error` - Output error.\n+//\n+// # Returns\n+// `BoxliteErrorCode::Ok` on success.\n+//\n+// # Example\n+// ```c\n+// CBoxliteSimple, *runner;\n+// if (boxlite_simple_new(\"alpine\", 1, 128, &runner, error) == BOXLITE_OK) {\n+//     // Use runner...\n+// }\n+// ```\n enum BoxliteErrorCode boxlite_simple_new(const char *image,\n                                          int cpus,\n                                          int memory_mib,\n-                                         struct CBoxliteSimple **out_box,\n-                                         struct CBoxliteError *out_error);\n-\n-/**\n- * Run a command and get buffered result\n- */\n-enum BoxliteErrorCode boxlite_simple_run(struct CBoxliteSimple *simple_box,\n+                                         CBoxliteSimple **out_box,\n+                                         CBoxliteError *out_error);\n+\n+// Run a command using the simplified runner.\n+//\n+// # Arguments\n+// * `box_runner` - Runner handle.\n+// * `command` - Command to execute.\n+// * `args` - Array of argument strings.\n+// * `argc` - Count of arguments.\n+// * `out_result` - Output pointer for `CBoxliteExecResult`.\n+// * `out_error` - Output error.\n+//\n+// # Example\n+// ```c\n+// CBoxliteExecResult *result;\n+// const char *args[] = {\"hello\"};\n+// boxlite_simple_run(runner, \"echo\", args, 1, &result, error);\n+// ```\n+enum BoxliteErrorCode boxlite_simple_run(CBoxliteSimple *box_runner,\n                                          const char *command,\n                                          const char *const *args,\n                                          int argc,\n-                                         struct CBoxliteExecResult **out_result,\n-                                         struct CBoxliteError *out_error);\n-\n-/**\n- * Free execution result\n- */\n-void boxlite_result_free(struct CBoxliteExecResult *result);\n-\n-/**\n- * Free simple box (auto-cleanup)\n- */\n-void boxlite_simple_free(struct CBoxliteSimple *simple_box);\n-\n-/**\n- * Free a runtime instance\n- */\n-void boxlite_runtime_free(struct CBoxliteRuntime *runtime);\n-\n-/**\n- * Free a string allocated by BoxLite\n- */\n-void boxlite_free_string(char *str);\n-\n-/**\n- * Free error struct\n- */\n-void boxlite_error_free(struct CBoxliteError *error);\n+                                         CBoxliteExecResult **out_result,\n+                                         CBoxliteError *out_error);\n+\n+// Free an execution result.\n+//\n+// # Arguments\n+// * `result` - Pointer to `CBoxliteExecResult` to free.\n+void boxlite_result_free(CBoxliteExecResult *result);\n+\n+// Free a simple runner.\n+//\n+// # Arguments\n+// * `box_runner` - Pointer to `CBoxliteSimple,` to free.\n+void boxlite_simple_free(CBoxliteSimple *box_runner);\n+\n+// Free a box handle.\n+//\n+// # Arguments\n+// * `handle` - Pointer to `CBoxHandle` to free.\n+void boxlite_box_free(CBoxHandle *handle);\n+\n+// Free a runtime handle.\n+//\n+// # Arguments\n+// * `runtime` - Pointer to `CBoxliteRuntime` to free.\n+void boxlite_runtime_free(CBoxliteRuntime *runtime);\n+\n+// Free a string allocated by the library.\n+//\n+// # Arguments\n+// * `s` - Pointer to string to free.\n+void boxlite_free_string(char *s);\n+\n+// Free an error object.\n+//\n+// # Arguments\n+// * `error` - Pointer to `CBoxliteError` to free.\n+void boxlite_error_free(CBoxliteError *error);\n \n #ifdef __cplusplus\n }  // extern \"C\"\ndiff --git a/sdks/c/src/ffi.rs b/sdks/c/src/ffi.rs\nindex 11ce79c2..8c270adb 100644\n--- a/sdks/c/src/ffi.rs\n+++ b/sdks/c/src/ffi.rs\n@@ -14,244 +14,55 @@\n #![allow(clippy::missing_safety_doc)]\n #![allow(clippy::doc_overindented_list_items)]\n \n-use std::ffi::{CStr, CString};\n use std::os::raw::{c_char, c_int, c_void};\n-use std::ptr;\n-use std::sync::Arc;\n \n-use tokio::runtime::Runtime as TokioRuntime;\n+// Import internal FFI types from shared layer\n+use boxlite_ffi::error::{BoxliteErrorCode, FFIError};\n+use boxlite_ffi::runner::{BoxRunner, ExecResult};\n+use boxlite_ffi::runtime::{BoxHandle, RuntimeHandle};\n \n-use boxlite::BoxID;\n-use boxlite::BoxliteError;\n-use boxlite::litebox::LiteBox;\n-use boxlite::runtime::BoxliteRuntime;\n-use boxlite::runtime::options::{BoxOptions, BoxliteOptions, RootfsSpec};\n-use boxlite::runtime::types::{BoxInfo, BoxStatus};\n+// Define C-compatible type aliases for the C header\n+pub type CBoxliteRuntime = RuntimeHandle;\n+pub type CBoxHandle = BoxHandle;\n+pub type CBoxliteSimple = BoxRunner;\n+pub type CBoxliteError = FFIError;\n+pub type CBoxliteExecResult = ExecResult;\n \n // ============================================================================\n-// Error Code Enum - Maps to BoxliteError variants\n+// Public API Functions\n // ============================================================================\n \n-/// Error codes returned by BoxLite C API functions.\n-///\n-/// These codes map directly to Rust's BoxliteError variants,\n-/// allowing programmatic error handling in C.\n-#[repr(C)]\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum BoxliteErrorCode {\n-    /// Operation succeeded\n-    Ok = 0,\n-    /// Internal error\n-    Internal = 1,\n-    /// Resource not found\n-    NotFound = 2,\n-    /// Resource already exists\n-    AlreadyExists = 3,\n-    /// Invalid state for operation\n-    InvalidState = 4,\n-    /// Invalid argument provided\n-    InvalidArgument = 5,\n-    /// Configuration error\n-    Config = 6,\n-    /// Storage error\n-    Storage = 7,\n-    /// Image error\n-    Image = 8,\n-    /// Network error\n-    Network = 9,\n-    /// Execution error\n-    Execution = 10,\n-    /// Resource stopped\n-    Stopped = 11,\n-    /// Engine error\n-    Engine = 12,\n-    /// Unsupported operation\n-    Unsupported = 13,\n-    /// Database error\n-    Database = 14,\n-    /// Portal/communication error\n-    Portal = 15,\n-    /// RPC error\n-    Rpc = 16,\n-}\n-\n-/// Extended error information for C API.\n-///\n-/// Contains both an error code (for programmatic handling)\n-/// and an optional detailed message (for debugging).\n-#[repr(C)]\n-pub struct CBoxliteError {\n-    /// Error code\n-    pub code: BoxliteErrorCode,\n-    /// Detailed error message (NULL if none, caller must free with boxlite_error_free)\n-    pub message: *mut c_char,\n-}\n-\n-impl Default for CBoxliteError {\n-    fn default() -> Self {\n-        CBoxliteError {\n-            code: BoxliteErrorCode::Ok,\n-            message: ptr::null_mut(),\n-        }\n-    }\n-}\n-\n-/// Opaque handle to a BoxliteRuntime instance\n-pub struct CBoxliteRuntime {\n-    runtime: BoxliteRuntime,\n-    tokio_rt: Arc<TokioRuntime>,\n-}\n-\n-/// Opaque handle to a running box\n-pub struct CBoxHandle {\n-    handle: LiteBox,\n-    #[allow(dead_code)]\n-    box_id: BoxID,\n-    tokio_rt: Arc<TokioRuntime>,\n-}\n-\n-/// Opaque handle for simple API (auto-manages runtime)\n-pub struct CBoxliteSimple {\n-    runtime: BoxliteRuntime,\n-    handle: Option<LiteBox>,\n-    box_id: Option<BoxID>,\n-    tokio_rt: Arc<TokioRuntime>,\n-}\n-\n-// ============================================================================\n-// Error Conversion Helpers\n-// ============================================================================\n-\n-/// Map BoxliteError to BoxliteErrorCode\n-fn error_to_code(err: &BoxliteError) -> BoxliteErrorCode {\n-    match err {\n-        BoxliteError::Internal(_) => BoxliteErrorCode::Internal,\n-        BoxliteError::NotFound(_) => BoxliteErrorCode::NotFound,\n-        BoxliteError::AlreadyExists(_) => BoxliteErrorCode::AlreadyExists,\n-        BoxliteError::InvalidState(_) => BoxliteErrorCode::InvalidState,\n-        BoxliteError::InvalidArgument(_) => BoxliteErrorCode::InvalidArgument,\n-        BoxliteError::Config(_) => BoxliteErrorCode::Config,\n-        BoxliteError::Storage(_) => BoxliteErrorCode::Storage,\n-        BoxliteError::Image(_) => BoxliteErrorCode::Image,\n-        BoxliteError::Network(_) => BoxliteErrorCode::Network,\n-        BoxliteError::Execution(_) => BoxliteErrorCode::Execution,\n-        BoxliteError::Stopped(_) => BoxliteErrorCode::Stopped,\n-        BoxliteError::Engine(_) => BoxliteErrorCode::Engine,\n-        BoxliteError::Unsupported(_) => BoxliteErrorCode::Unsupported,\n-        BoxliteError::UnsupportedEngine => BoxliteErrorCode::Unsupported,\n-        BoxliteError::Database(_) => BoxliteErrorCode::Database,\n-        BoxliteError::Portal(_) => BoxliteErrorCode::Portal,\n-        BoxliteError::Rpc(_) | BoxliteError::RpcTransport(_) => BoxliteErrorCode::Rpc,\n-        BoxliteError::MetadataError(_) => BoxliteErrorCode::Internal,\n-    }\n-}\n-\n-/// Convert Rust error to C error struct\n-fn error_to_c_error(err: BoxliteError) -> CBoxliteError {\n-    let code = error_to_code(&err);\n-    let message = error_to_c_string(err);\n-    CBoxliteError { code, message }\n-}\n-\n-/// Write error to output parameter (if not NULL)\n-fn write_error(out_error: *mut CBoxliteError, err: BoxliteError) {\n-    if !out_error.is_null() {\n-        unsafe {\n-            *out_error = error_to_c_error(err);\n-        }\n-    }\n-}\n-\n-/// Helper to create InvalidArgument error for NULL pointers\n-fn null_pointer_error(param_name: &str) -> BoxliteError {\n-    BoxliteError::InvalidArgument(format!(\"{} is null\", param_name))\n-}\n-\n-/// Helper to convert Rust error to C string\n-fn error_to_c_string(err: BoxliteError) -> *mut c_char {\n-    let msg = format!(\"{}\", err);\n-    match CString::new(msg) {\n-        Ok(s) => s.into_raw(),\n-        Err(_) => {\n-            let fallback = CString::new(\"Failed to format error message\").unwrap();\n-            fallback.into_raw()\n-        }\n-    }\n-}\n-\n-/// Helper to convert C string to Rust string\n-unsafe fn c_str_to_string(s: *const c_char) -> Result<String, BoxliteError> {\n-    if s.is_null() {\n-        return Err(BoxliteError::Internal(\"null pointer\".to_string()));\n-    }\n-    unsafe {\n-        CStr::from_ptr(s)\n-            .to_str()\n-            .map(|s| s.to_string())\n-            .map_err(|e| BoxliteError::Internal(format!(\"invalid UTF-8: {}\", e)))\n-    }\n-}\n-\n-/// Convert BoxStatus to string\n-fn status_to_string(status: BoxStatus) -> &'static str {\n-    match status {\n-        BoxStatus::Unknown => \"unknown\",\n-        BoxStatus::Configured => \"configured\",\n-        BoxStatus::Running => \"running\",\n-        BoxStatus::Stopping => \"stopping\",\n-        BoxStatus::Stopped => \"stopped\",\n-    }\n-}\n-\n-/// Convert BoxInfo to JSON with nested state structure\n-fn box_info_to_json(info: &BoxInfo) -> serde_json::Value {\n-    serde_json::json!({\n-        \"id\": info.id.to_string(),\n-        \"name\": info.name,\n-        \"state\": {\n-            \"status\": status_to_string(info.status),\n-            \"running\": info.status.is_running(),\n-            \"pid\": info.pid\n-        },\n-        \"created_at\": info.created_at.to_rfc3339(),\n-        \"image\": info.image,\n-        \"cpus\": info.cpus,\n-        \"memory_mib\": info.memory_mib\n-    })\n-}\n-\n /// Get BoxLite version string\n ///\n /// # Returns\n-/// Static string containing the version (e.g., \"0.1.0\")\n+/// A pointer to a static C string containing the version. Do not free this string.\n+///\n+/// # Example\n+/// ```c\n+/// printf(\"BoxLite Version: %s\\n\", boxlite_version());\n+/// ```\n #[unsafe(no_mangle)]\n pub extern \"C\" fn boxlite_version() -> *const c_char {\n-    // Static string, safe to return pointer\n-    concat!(env!(\"CARGO_PKG_VERSION\"), \"\\0\").as_ptr() as *const c_char\n+    boxlite_ffi::ops::version()\n }\n \n-/// Create a new BoxLite runtime\n+/// Create a new BoxLite runtime configuration.\n ///\n /// # Arguments\n-/// * `home_dir` - Path to BoxLite home directory (stores images, rootfs, etc.)\n-///                If NULL, uses default: ~/.boxlite\n-/// * `registries_json` - JSON array of registries to search for unqualified images,\n-///                       e.g. `[\"ghcr.io\", \"quay.io\"]`. If NULL, uses default (docker.io).\n-///                       Registries are tried in order; first successful pull wins.\n-/// * `out_error` - Output parameter for error message (caller must free with boxlite_free_string)\n+/// * `home_dir` - Optional path to the home directory. If NULL, defaults to `~/.boxlite`.\n+/// * `registries_json` - Optional JSON array of registry configurations.\n+/// * `out_runtime` - Output parameter to store the created `CBoxliteRuntime` pointer.\n+/// * `out_error` - Output parameter for error information.\n ///\n /// # Returns\n-/// Pointer to CBoxliteRuntime on success, NULL on failure\n+/// `BoxliteErrorCode::Ok` on success, or an error code on failure.\n ///\n /// # Example\n /// ```c\n-/// char *error = NULL;\n-/// const char *registries = \"[\\\"ghcr.io\\\", \\\"docker.io\\\"]\";\n-/// BoxliteRuntime *runtime = boxlite_runtime_new(\"/tmp/boxlite\", registries, &error);\n-/// if (!runtime) {\n-///     fprintf(stderr, \"Error: %s\\n\", error);\n-///     boxlite_free_string(error);\n-///     return 1;\n+/// CBoxliteRuntime *runtime;\n+/// CBoxliteError *error = malloc(sizeof(CBoxliteError));\n+/// if (boxlite_runtime_new(NULL, NULL, &runtime, error) != BOXLITE_OK) {\n+///     fprintf(stderr, \"Failed to create runtime\\n\");\n /// }\n /// ```\n #[unsafe(no_mangle)]\n@@ -261,80 +72,27 @@ pub unsafe extern \"C\" fn boxlite_runtime_new(\n     out_runtime: *mut *mut CBoxliteRuntime,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if out_runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    // Create tokio runtime\n-    let tokio_rt = match TokioRuntime::new() {\n-        Ok(rt) => Arc::new(rt),\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"Failed to create async runtime: {}\", e));\n-            write_error(out_error, err);\n-            return BoxliteErrorCode::Internal;\n-        }\n-    };\n-\n-    // Parse options\n-    let mut options = BoxliteOptions::default();\n-    if !home_dir.is_null() {\n-        match c_str_to_string(home_dir) {\n-            Ok(path) => options.home_dir = path.into(),\n-            Err(e) => {\n-                write_error(out_error, e);\n-                return BoxliteErrorCode::InvalidArgument;\n-            }\n-        }\n-    }\n-\n-    // Parse image registries (JSON array)\n-    if !registries_json.is_null() {\n-        match c_str_to_string(registries_json) {\n-            Ok(json_str) => match serde_json::from_str::<Vec<String>>(&json_str) {\n-                Ok(registries) => options.image_registries = registries,\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"Invalid registries JSON: {}\", e));\n-                    write_error(out_error, err);\n-                    return BoxliteErrorCode::Internal;\n-                }\n-            },\n-            Err(e) => {\n-                write_error(out_error, e);\n-                return BoxliteErrorCode::InvalidArgument;\n-            }\n-        }\n-    }\n-\n-    // Create runtime\n-    let runtime = match BoxliteRuntime::new(options) {\n-        Ok(rt) => rt,\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            return code;\n-        }\n-    };\n-\n-    *out_runtime = Box::into_raw(Box::new(CBoxliteRuntime { runtime, tokio_rt }));\n-    BoxliteErrorCode::Ok\n+    boxlite_ffi::ops::runtime_new(home_dir, registries_json, out_runtime, out_error)\n }\n \n-/// Create a new box with the given options (JSON)\n+/// Create a new box with the given options (JSON).\n ///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n-/// * `options_json` - JSON-encoded BoxOptions, e.g.:\n-///                    `{\"rootfs\": {\"Image\": \"alpine:3.19\"}, \"working_dir\": \"/workspace\"}`\n-/// * `out_error` - Output parameter for error message\n+/// * `runtime` - Pointer to the active `CBoxliteRuntime`.\n+/// * `options_json` - JSON string defining the box (e.g., image, resources).\n+/// * `out_box` - Output parameter to store the created `CBoxHandle`.\n+/// * `out_error` - Output parameter for error information.\n ///\n /// # Returns\n-/// Pointer to CBoxHandle on success, NULL on failure\n+/// `BoxliteErrorCode::Ok` on success.\n ///\n /// # Example\n /// ```c\n-/// const char *opts = \"{\\\"rootfs\\\":{\\\"Image\\\":\\\"alpine:3.19\\\"}}\";\n-/// BoxHandle *box = boxlite_create_box(runtime, opts, &error);\n+/// const char *options = \"{\\\"rootfs\\\": {\\\"Image\\\": \\\"alpine:latest\\\"}}\";\n+/// CBoxHandle *box;\n+/// if (boxlite_create_box(runtime, options, &box, error) == BOXLITE_OK) {\n+///     // Use box...\n+/// }\n /// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_create_box(\n@@ -343,81 +101,29 @@ pub unsafe extern \"C\" fn boxlite_create_box(\n     out_box: *mut *mut CBoxHandle,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_box.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_box\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &mut *runtime;\n-\n-    // Parse JSON options\n-    let options_str = match c_str_to_string(options_json) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::InvalidArgument;\n-        }\n-    };\n-\n-    let options: BoxOptions = match serde_json::from_str(&options_str) {\n-        Ok(opts) => opts,\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"Invalid JSON options: {}\", e));\n-            write_error(out_error, err);\n-            return BoxliteErrorCode::Internal;\n-        }\n-    };\n-\n-    // Create box (no name support in C API yet)\n-    // create() is async, so we block on the tokio runtime\n-    let result = runtime_ref\n-        .tokio_rt\n-        .block_on(runtime_ref.runtime.create(options, None));\n-\n-    match result {\n-        Ok(handle) => {\n-            let box_id = handle.id().clone();\n-            *out_box = Box::into_raw(Box::new(CBoxHandle {\n-                handle,\n-                box_id,\n-                tokio_rt: runtime_ref.tokio_rt.clone(),\n-            }));\n-            BoxliteErrorCode::Ok\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_create(runtime, options_json, std::ptr::null(), out_box, out_error)\n }\n \n-/// Execute a command in a box\n+/// Execute a command in a box.\n ///\n /// # Arguments\n-/// * `handle` - Box handle\n-/// * `command` - Command to execute\n-/// * `args_json` - JSON array of arguments, e.g.: `[\"arg1\", \"arg2\"]`\n-/// * `callback` - Optional callback for streaming output (chunk_text, is_stderr, user_data)\n-/// * `user_data` - User data passed to callback\n-/// * `out_exit_code` - Output parameter for command exit code\n-/// * `out_error` - Output parameter for error information\n+/// * `handle` - Box handle.\n+/// * `command` - Command to execute (e.g., \"/bin/sh\").\n+/// * `args_json` - JSON array of arguments, e.g.: `[\"-c\", \"echo hello\"]`.\n+/// * `callback` - Optional callback for streaming output.\n+/// * `user_data` - User data passed to callback.\n+/// * `out_exit_code` - Output parameter for command exit code.\n+/// * `out_error` - Output parameter for error information.\n ///\n /// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// `BoxliteErrorCode::Ok` on success.\n ///\n /// # Example\n /// ```c\n /// int exit_code;\n-/// CBoxliteError error = {0};\n /// const char *args = \"[\\\"hello\\\"]\";\n-/// BoxliteErrorCode code = boxlite_execute(box, \"echo\", args, NULL, NULL, &exit_code, &error);\n-/// if (code == BOXLITE_OK) {\n-///     printf(\"Command exited with code: %d\\n\", exit_code);\n+/// if (boxlite_execute(box, \"echo\", args, NULL, NULL, &exit_code, error) == BOXLITE_OK) {\n+///     printf(\"Exit code: %d\\n\", exit_code);\n /// }\n /// ```\n #[unsafe(no_mangle)]\n@@ -430,168 +136,49 @@ pub unsafe extern \"C\" fn boxlite_execute(\n     out_exit_code: *mut c_int,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if handle.is_null() {\n-        write_error(out_error, null_pointer_error(\"handle\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    if out_exit_code.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_exit_code\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let handle_ref = &mut *handle;\n-\n-    // Parse command\n-    let cmd_str = match c_str_to_string(command) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            return code;\n-        }\n-    };\n-\n-    // Parse args\n-    let args: Vec<String> = if !args_json.is_null() {\n-        match c_str_to_string(args_json) {\n-            Ok(json_str) => match serde_json::from_str(&json_str) {\n-                Ok(a) => a,\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"Invalid args JSON: {}\", e));\n-                    write_error(out_error, err);\n-                    return BoxliteErrorCode::InvalidArgument;\n-                }\n-            },\n-            Err(e) => {\n-                let code = error_to_code(&e);\n-                write_error(out_error, e);\n-                return code;\n-            }\n-        }\n-    } else {\n-        vec![]\n-    };\n-\n-    let mut cmd = boxlite::BoxCommand::new(cmd_str);\n-    cmd = cmd.args(args);\n-\n-    // Execute command using new API\n-    let result = handle_ref.tokio_rt.block_on(async {\n-        let mut execution = handle_ref.handle.exec(cmd).await?;\n-\n-        // Stream output to callback if provided\n-        if let Some(cb) = callback {\n-            use futures::StreamExt;\n-\n-            // Take stdout and stderr\n-            let mut stdout = execution.stdout();\n-            let mut stderr = execution.stderr();\n-\n-            // Read both streams\n-            loop {\n-                tokio::select! {\n-                    Some(line) = async {\n-                        match &mut stdout {\n-                            Some(s) => s.next().await,\n-                            None => None,\n-                        }\n-                    } => {\n-                        let c_text = CString::new(line).unwrap_or_default();\n-                        cb(c_text.as_ptr(), 0, user_data); // 0 = stdout\n-                    }\n-                    Some(line) = async {\n-                        match &mut stderr {\n-                            Some(s) => s.next().await,\n-                            None => None,\n-                        }\n-                    } => {\n-                        let c_text = CString::new(line).unwrap_or_default();\n-                        cb(c_text.as_ptr(), 1, user_data); // 1 = stderr\n-                    }\n-                    else => break,\n-                }\n-            }\n-        }\n-\n-        // Wait for execution to complete\n-        let status = execution.wait().await?;\n-        Ok::<i32, BoxliteError>(status.exit_code)\n-    });\n-\n-    match result {\n-        Ok(exit_code) => {\n-            *out_exit_code = exit_code;\n-            BoxliteErrorCode::Ok\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_exec(\n+        handle,\n+        command,\n+        args_json,\n+        callback,\n+        user_data,\n+        out_exit_code,\n+        out_error,\n+    )\n }\n \n-/// Stop a box\n+/// Stop a box.\n ///\n /// # Arguments\n-/// * `handle` - Box handle (will be consumed/freed)\n-/// * `out_error` - Output parameter for error information\n+/// * `handle` - Box handle.\n+/// * `out_error` - output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// boxlite_stop_box(box, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_stop_box(\n     handle: *mut CBoxHandle,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if handle.is_null() {\n-        write_error(out_error, null_pointer_error(\"handle\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let handle_box = Box::from_raw(handle);\n-\n-    // Block on async stop using the stored tokio runtime\n-    let result = handle_box.tokio_rt.block_on(handle_box.handle.stop());\n-\n-    match result {\n-        Ok(_) => BoxliteErrorCode::Ok,\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_stop(handle, out_error)\n }\n \n-// ============================================================================\n-// NEW API FUNCTIONS - Python SDK Parity\n-// ============================================================================\n-\n-/// List all boxes as JSON\n+/// List all boxes as JSON.\n ///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n-/// * `out_json` - Output parameter for JSON array of box info\n-/// * `out_error` - Output parameter for error information\n+/// * `runtime` - Runtime handle.\n+/// * `out_json` - Output pointer for JSON string. Caller must free this with `boxlite_free_string`.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n-///\n-/// # JSON Format\n-/// ```json\n-/// [\n-///   {\n-///     \"id\": \"01HJK4TNRPQSXYZ8WM6NCVT9R5\",\n-///     \"name\": \"my-box\",\n-///     \"state\": { \"status\": \"running\", \"running\": true, \"pid\": 12345 },\n-///     \"created_at\": \"2024-01-15T10:30:00Z\",\n-///     \"image\": \"alpine:3.19\",\n-///     \"cpus\": 2,\n-///     \"memory_mib\": 512\n-///   }\n-/// ]\n+/// # Example\n+/// ```c\n+/// char *json;\n+/// if (boxlite_list_info(runtime, &json, error) == BOXLITE_OK) {\n+///     printf(\"Boxes: %s\\n\", json);\n+///     boxlite_free_string(json);\n+/// }\n /// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_list_info(\n@@ -599,63 +186,22 @@ pub unsafe extern \"C\" fn boxlite_list_info(\n     out_json: *mut *mut c_char,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_json.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_json\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &*runtime;\n-\n-    let result = runtime_ref\n-        .tokio_rt\n-        .block_on(runtime_ref.runtime.list_info());\n-\n-    match result {\n-        Ok(boxes) => {\n-            let json_array: Vec<serde_json::Value> = boxes.iter().map(box_info_to_json).collect();\n-            let json_str = match serde_json::to_string(&json_array) {\n-                Ok(s) => s,\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n-                    write_error(out_error, err);\n-                    return BoxliteErrorCode::Internal;\n-                }\n-            };\n-\n-            match CString::new(json_str) {\n-                Ok(s) => {\n-                    *out_json = s.into_raw();\n-                    BoxliteErrorCode::Ok\n-                }\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n-                    write_error(out_error, err);\n-                    BoxliteErrorCode::Internal\n-                }\n-            }\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_list(runtime, out_json, out_error)\n }\n \n-/// Get single box info as JSON\n+/// Get single box info as JSON.\n ///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n-/// * `id_or_name` - Box ID (full or prefix) or name\n-/// * `out_json` - Output parameter for JSON object\n-/// * `out_error` - Output parameter for error information\n+/// * `runtime` - Runtime handle.\n+/// * `id_or_name` - ID or name of the box.\n+/// * `out_json` - Output pointer for JSON string.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure (including box not found)\n+/// # Example\n+/// ```c\n+/// char *json;\n+/// boxlite_get_info(runtime, \"my-box\", &json, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_get_info(\n     runtime: *mut CBoxliteRuntime,\n@@ -663,75 +209,24 @@ pub unsafe extern \"C\" fn boxlite_get_info(\n     out_json: *mut *mut c_char,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_json.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_json\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &*runtime;\n-\n-    let id_str = match c_str_to_string(id_or_name) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::InvalidArgument;\n-        }\n-    };\n-\n-    let result = runtime_ref\n-        .tokio_rt\n-        .block_on(runtime_ref.runtime.get_info(&id_str));\n-\n-    match result {\n-        Ok(Some(info)) => {\n-            let json_str = match serde_json::to_string(&box_info_to_json(&info)) {\n-                Ok(s) => s,\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n-                    write_error(out_error, err);\n-                    return BoxliteErrorCode::Internal;\n-                }\n-            };\n-\n-            match CString::new(json_str) {\n-                Ok(s) => {\n-                    *out_json = s.into_raw();\n-                    BoxliteErrorCode::Ok\n-                }\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n-                    write_error(out_error, err);\n-                    BoxliteErrorCode::Internal\n-                }\n-            }\n-        }\n-        Ok(None) => {\n-            let err = BoxliteError::NotFound(id_str.clone());\n-            write_error(out_error, err);\n-            BoxliteErrorCode::NotFound\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_inspect(runtime, id_or_name, out_json, out_error)\n }\n \n-/// Get box handle for reattaching to an existing box\n+/// Attach to an existing box.\n ///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n-/// * `id_or_name` - Box ID (full or prefix) or name\n-/// * `out_handle` - Output parameter for box handle\n-/// * `out_error` - Output parameter for error information\n+/// * `runtime` - Runtime handle.\n+/// * `id_or_name` - ID or name of the box.\n+/// * `out_handle` - Output pointer for box handle.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure (including box not found)\n+/// # Example\n+/// ```c\n+/// CBoxHandle *handle;\n+/// if (boxlite_get(runtime, \"my-box\", &handle, error) == BOXLITE_OK) {\n+///     // Use handle...\n+/// }\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_get(\n     runtime: *mut CBoxliteRuntime,\n@@ -739,62 +234,21 @@ pub unsafe extern \"C\" fn boxlite_get(\n     out_handle: *mut *mut CBoxHandle,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_handle.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_handle\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &*runtime;\n-\n-    let id_str = match c_str_to_string(id_or_name) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::InvalidArgument;\n-        }\n-    };\n-\n-    let result = runtime_ref\n-        .tokio_rt\n-        .block_on(runtime_ref.runtime.get(&id_str));\n-\n-    match result {\n-        Ok(Some(handle)) => {\n-            let box_id = handle.id().clone();\n-            *out_handle = Box::into_raw(Box::new(CBoxHandle {\n-                handle,\n-                box_id,\n-                tokio_rt: runtime_ref.tokio_rt.clone(),\n-            }));\n-            BoxliteErrorCode::Ok\n-        }\n-        Ok(None) => {\n-            let err = BoxliteError::NotFound(id_str.clone());\n-            write_error(out_error, err);\n-            BoxliteErrorCode::NotFound\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_attach(runtime, id_or_name, out_handle, out_error)\n }\n \n-/// Remove a box\n+/// Remove a box.\n ///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n-/// * `id_or_name` - Box ID (full or prefix) or name\n-/// * `force` - If non-zero, force remove even if running\n-/// * `out_error` - Output parameter for error information\n+/// * `runtime` - Runtime handle.\n+/// * `id_or_name` - ID or name of the box.\n+/// * `force` - 1 to force remove (stop if running), 0 otherwise.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// boxlite_remove(runtime, \"my-box\", 1, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_remove(\n     runtime: *mut CBoxliteRuntime,\n@@ -802,331 +256,156 @@ pub unsafe extern \"C\" fn boxlite_remove(\n     force: c_int,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &*runtime;\n-\n-    let id_str = match c_str_to_string(id_or_name) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::InvalidArgument;\n-        }\n-    };\n-\n-    let result = runtime_ref\n-        .tokio_rt\n-        .block_on(runtime_ref.runtime.remove(&id_str, force != 0));\n-\n-    match result {\n-        Ok(_) => BoxliteErrorCode::Ok,\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_remove(runtime, id_or_name, force != 0, out_error)\n }\n \n-/// Get runtime metrics as JSON\n+/// Get runtime metrics as JSON.\n ///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n-/// * `out_json` - Output parameter for JSON object\n-/// * `out_error` - Output parameter for error information\n+/// * `runtime` - Runtime handle.\n+/// * `out_json` - Output pointer for JSON string.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// char *json;\n+/// boxlite_runtime_metrics(runtime, &json, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_runtime_metrics(\n     runtime: *mut CBoxliteRuntime,\n     out_json: *mut *mut c_char,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_json.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_json\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &*runtime;\n-\n-    let metrics = runtime_ref.tokio_rt.block_on(runtime_ref.runtime.metrics());\n-\n-    let json = serde_json::json!({\n-        \"boxes_created_total\": metrics.boxes_created_total(),\n-        \"boxes_failed_total\": metrics.boxes_failed_total(),\n-        \"num_running_boxes\": metrics.num_running_boxes(),\n-        \"total_commands_executed\": metrics.total_commands_executed(),\n-        \"total_exec_errors\": metrics.total_exec_errors()\n-    });\n-\n-    let json_str = match serde_json::to_string(&json) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n-            write_error(out_error, err);\n-            return BoxliteErrorCode::Internal;\n-        }\n-    };\n-\n-    match CString::new(json_str) {\n-        Ok(s) => {\n-            *out_json = s.into_raw();\n-            BoxliteErrorCode::Ok\n-        }\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n-            write_error(out_error, err);\n-            BoxliteErrorCode::Internal\n-        }\n-    }\n+    boxlite_ffi::ops::runtime_metrics(runtime, out_json, out_error)\n }\n \n /// Gracefully shutdown all boxes in this runtime.\n ///\n-/// This method stops all running boxes, waiting up to `timeout` seconds\n-/// for each box to stop gracefully before force-killing it.\n-///\n-/// After calling this method, the runtime is permanently shut down and\n-/// will return errors for any new operations (like `create()`).\n-///\n /// # Arguments\n-/// * `runtime` - BoxLite runtime instance\n+/// * `runtime` - Runtime handle.\n /// * `timeout` - Seconds to wait before force-killing each box:\n ///   - 0 - Use default timeout (10 seconds)\n ///   - Positive integer - Wait that many seconds\n ///   - -1 - Wait indefinitely (no timeout)\n /// * `out_error` - Output parameter for error information\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// boxlite_runtime_shutdown(runtime, 5, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_runtime_shutdown(\n     runtime: *mut CBoxliteRuntime,\n     timeout: c_int,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if runtime.is_null() {\n-        write_error(out_error, null_pointer_error(\"runtime\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let runtime_ref = &*runtime;\n-\n-    // C API: 0 = default (maps to Rust None), positive = timeout, -1 = infinite\n     let timeout_opt = if timeout == 0 { None } else { Some(timeout) };\n-\n-    let result = runtime_ref\n-        .tokio_rt\n-        .block_on(runtime_ref.runtime.shutdown(timeout_opt));\n-\n-    match result {\n-        Ok(()) => BoxliteErrorCode::Ok,\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::runtime_shutdown(runtime, timeout_opt, out_error)\n }\n \n-/// Get box info from handle as JSON\n+/// Get info for a box handle as JSON.\n ///\n /// # Arguments\n-/// * `handle` - Box handle\n-/// * `out_json` - Output parameter for JSON object\n-/// * `out_error` - Output parameter for error information\n+/// * `handle` - Box handle.\n+/// * `out_json` - Output pointer for JSON string.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// char *json;\n+/// boxlite_box_info(handle, &json, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_box_info(\n     handle: *mut CBoxHandle,\n     out_json: *mut *mut c_char,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if handle.is_null() {\n-        write_error(out_error, null_pointer_error(\"handle\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_json.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_json\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let handle_ref = &*handle;\n-    let info = handle_ref.handle.info();\n-\n-    let json_str = match serde_json::to_string(&box_info_to_json(&info)) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n-            write_error(out_error, err);\n-            return BoxliteErrorCode::Internal;\n-        }\n-    };\n-\n-    match CString::new(json_str) {\n-        Ok(s) => {\n-            *out_json = s.into_raw();\n-            BoxliteErrorCode::Ok\n-        }\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n-            write_error(out_error, err);\n-            BoxliteErrorCode::Internal\n-        }\n-    }\n+    boxlite_ffi::ops::box_inspect_handle(handle, out_json, out_error)\n }\n \n-/// Get box metrics from handle as JSON\n+/// Get metrics for a box handle as JSON.\n ///\n /// # Arguments\n-/// * `handle` - Box handle\n-/// * `out_json` - Output parameter for JSON object\n-/// * `out_error` - Output parameter for error information\n+/// * `handle` - Box handle.\n+/// * `out_json` - Output pointer for JSON string.\n+/// * `out_error` - Output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// char *json;\n+/// boxlite_box_metrics(handle, &json, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_box_metrics(\n     handle: *mut CBoxHandle,\n     out_json: *mut *mut c_char,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if handle.is_null() {\n-        write_error(out_error, null_pointer_error(\"handle\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_json.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_json\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let handle_ref = &*handle;\n-\n-    let result = handle_ref.tokio_rt.block_on(handle_ref.handle.metrics());\n-\n-    match result {\n-        Ok(metrics) => {\n-            let json = serde_json::json!({\n-                \"cpu_percent\": metrics.cpu_percent,\n-                \"memory_bytes\": metrics.memory_bytes,\n-                \"commands_executed_total\": metrics.commands_executed_total,\n-                \"exec_errors_total\": metrics.exec_errors_total,\n-                \"bytes_sent_total\": metrics.bytes_sent_total,\n-                \"bytes_received_total\": metrics.bytes_received_total,\n-                \"total_create_duration_ms\": metrics.total_create_duration_ms,\n-                \"guest_boot_duration_ms\": metrics.guest_boot_duration_ms,\n-                \"network_bytes_sent\": metrics.network_bytes_sent,\n-                \"network_bytes_received\": metrics.network_bytes_received,\n-                \"network_tcp_connections\": metrics.network_tcp_connections,\n-                \"network_tcp_errors\": metrics.network_tcp_errors\n-            });\n-\n-            let json_str = match serde_json::to_string(&json) {\n-                Ok(s) => s,\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"JSON serialization failed: {}\", e));\n-                    write_error(out_error, err);\n-                    return BoxliteErrorCode::Internal;\n-                }\n-            };\n-\n-            match CString::new(json_str) {\n-                Ok(s) => {\n-                    *out_json = s.into_raw();\n-                    BoxliteErrorCode::Ok\n-                }\n-                Err(e) => {\n-                    let err = BoxliteError::Internal(format!(\"CString conversion failed: {}\", e));\n-                    write_error(out_error, err);\n-                    BoxliteErrorCode::Internal\n-                }\n-            }\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_metrics(handle, out_json, out_error)\n }\n \n-/// Start or restart a stopped box\n+/// Start a stopped box.\n ///\n /// # Arguments\n-/// * `handle` - Box handle\n-/// * `out_error` - Output parameter for error information\n+/// * `handle` - Box handle.\n+/// * `out_error` - output error.\n ///\n-/// # Returns\n-/// BoxliteErrorCode::Ok on success, error code on failure\n+/// # Example\n+/// ```c\n+/// boxlite_start_box(handle, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_start_box(\n     handle: *mut CBoxHandle,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if handle.is_null() {\n-        write_error(out_error, null_pointer_error(\"handle\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let handle_ref = &*handle;\n-\n-    let result = handle_ref.tokio_rt.block_on(handle_ref.handle.start());\n-\n-    match result {\n-        Ok(_) => BoxliteErrorCode::Ok,\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::box_start(handle, out_error)\n }\n \n-/// Get box ID string from handle\n+/// Get box ID.\n ///\n /// # Arguments\n-/// * `handle` - Box handle\n+/// * `handle` - Box handle.\n ///\n /// # Returns\n-/// Pointer to C string (caller must free with boxlite_free_string), NULL on failure\n+/// Pointer to a C string containing the ID. Must be freed with `boxlite_free_string`.\n+///\n+/// # Example\n+/// ```c\n+/// char *id = boxlite_box_id(handle);\n+/// printf(\"Box ID: %s\\n\", id);\n+/// boxlite_free_string(id);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_box_id(handle: *mut CBoxHandle) -> *mut c_char {\n-    if handle.is_null() {\n-        return ptr::null_mut();\n-    }\n-\n-    let handle_ref = &*handle;\n-    let id_str = handle_ref.handle.id().to_string();\n-\n-    match CString::new(id_str) {\n-        Ok(s) => s.into_raw(),\n-        Err(_) => ptr::null_mut(),\n-    }\n+    boxlite_ffi::ops::box_id(handle)\n }\n \n // ============================================================================\n-// Simple Convenience API\n+// Runner API (formerly Simple API)\n // ============================================================================\n \n-/// Result structure for simple API command execution\n-#[repr(C)]\n-pub struct CBoxliteExecResult {\n-    pub exit_code: c_int,\n-    pub stdout_text: *mut c_char,\n-    pub stderr_text: *mut c_char,\n-}\n-\n-/// Create and start a box using simple API\n+/// Create a simplified box runner.\n+///\n+/// # Arguments\n+/// * `image` - Container image.\n+/// * `cpus` - Number of CPUs.\n+/// * `memory_mib` - Memory in MiB.\n+/// * `out_box` - Output pointer for `CBoxliteSimple,`.\n+/// * `out_error` - Output error.\n+///\n+/// # Returns\n+/// `BoxliteErrorCode::Ok` on success.\n+///\n+/// # Example\n+/// ```c\n+/// CBoxliteSimple, *runner;\n+/// if (boxlite_simple_new(\"alpine\", 1, 128, &runner, error) == BOXLITE_OK) {\n+///     // Use runner...\n+/// }\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_simple_new(\n     image: *const c_char,\n@@ -1135,420 +414,91 @@ pub unsafe extern \"C\" fn boxlite_simple_new(\n     out_box: *mut *mut CBoxliteSimple,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if image.is_null() {\n-        write_error(out_error, null_pointer_error(\"image\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_box.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_box\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let image_str = match c_str_to_string(image) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::InvalidArgument;\n-        }\n-    };\n-\n-    let tokio_rt = match TokioRuntime::new() {\n-        Ok(rt) => Arc::new(rt),\n-        Err(e) => {\n-            let err = BoxliteError::Internal(format!(\"Failed to create async runtime: {}\", e));\n-            write_error(out_error, err);\n-            return BoxliteErrorCode::Internal;\n-        }\n-    };\n-\n-    let runtime = match BoxliteRuntime::new(BoxliteOptions::default()) {\n-        Ok(rt) => rt,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::Internal;\n-        }\n-    };\n-\n-    let options = BoxOptions {\n-        rootfs: RootfsSpec::Image(image_str),\n-        cpus: if cpus > 0 { Some(cpus as u8) } else { None },\n-        memory_mib: if memory_mib > 0 {\n-            Some(memory_mib as u32)\n-        } else {\n-            None\n-        },\n-        ..Default::default()\n-    };\n-\n-    let result = tokio_rt.block_on(async {\n-        let handle = runtime.create(options, None).await?;\n-        let box_id = handle.id().clone();\n-        Ok::<(LiteBox, BoxID), BoxliteError>((handle, box_id))\n-    });\n-\n-    match result {\n-        Ok((handle, box_id)) => {\n-            let simple_box = Box::new(CBoxliteSimple {\n-                runtime,\n-                handle: Some(handle),\n-                box_id: Some(box_id),\n-                tokio_rt,\n-            });\n-            *out_box = Box::into_raw(simple_box);\n-            BoxliteErrorCode::Ok\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::runner_new(image, cpus, memory_mib, out_box, out_error)\n }\n \n-/// Run a command and get buffered result\n+/// Run a command using the simplified runner.\n+///\n+/// # Arguments\n+/// * `box_runner` - Runner handle.\n+/// * `command` - Command to execute.\n+/// * `args` - Array of argument strings.\n+/// * `argc` - Count of arguments.\n+/// * `out_result` - Output pointer for `CBoxliteExecResult`.\n+/// * `out_error` - Output error.\n+///\n+/// # Example\n+/// ```c\n+/// CBoxliteExecResult *result;\n+/// const char *args[] = {\"hello\"};\n+/// boxlite_simple_run(runner, \"echo\", args, 1, &result, error);\n+/// ```\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_simple_run(\n-    simple_box: *mut CBoxliteSimple,\n+    box_runner: *mut CBoxliteSimple,\n     command: *const c_char,\n     args: *const *const c_char,\n     argc: c_int,\n     out_result: *mut *mut CBoxliteExecResult,\n     out_error: *mut CBoxliteError,\n ) -> BoxliteErrorCode {\n-    if simple_box.is_null() {\n-        write_error(out_error, null_pointer_error(\"simple_box\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if command.is_null() {\n-        write_error(out_error, null_pointer_error(\"command\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-    if out_result.is_null() {\n-        write_error(out_error, null_pointer_error(\"out_result\"));\n-        return BoxliteErrorCode::InvalidArgument;\n-    }\n-\n-    let simple_ref = &mut *simple_box;\n-\n-    let cmd_str = match c_str_to_string(command) {\n-        Ok(s) => s,\n-        Err(e) => {\n-            write_error(out_error, e);\n-            return BoxliteErrorCode::InvalidArgument;\n-        }\n-    };\n-\n-    let mut arg_vec = Vec::new();\n-    if !args.is_null() {\n-        for i in 0..argc {\n-            let arg_ptr = *args.offset(i as isize);\n-            if arg_ptr.is_null() {\n-                break;\n-            }\n-            match c_str_to_string(arg_ptr) {\n-                Ok(s) => arg_vec.push(s),\n-                Err(e) => {\n-                    write_error(out_error, e);\n-                    return BoxliteErrorCode::InvalidArgument;\n-                }\n-            }\n-        }\n-    }\n-\n-    let handle = match &simple_ref.handle {\n-        Some(h) => h,\n-        None => {\n-            write_error(\n-                out_error,\n-                BoxliteError::InvalidState(\"Box not initialized\".to_string()),\n-            );\n-            return BoxliteErrorCode::InvalidState;\n-        }\n-    };\n-\n-    let result = simple_ref.tokio_rt.block_on(async {\n-        let mut cmd = boxlite::BoxCommand::new(cmd_str);\n-        cmd = cmd.args(arg_vec);\n-\n-        let mut execution = handle.exec(cmd).await?;\n-\n-        use futures::StreamExt;\n-        let mut stdout_lines = Vec::new();\n-        let mut stderr_lines = Vec::new();\n-\n-        let mut stdout_stream = execution.stdout();\n-        let mut stderr_stream = execution.stderr();\n-\n-        loop {\n-            tokio::select! {\n-                Some(line) = async {\n-                    match &mut stdout_stream {\n-                        Some(s) => s.next().await,\n-                        None => None,\n-                    }\n-                } => {\n-                    stdout_lines.push(line);\n-                }\n-                Some(line) = async {\n-                    match &mut stderr_stream {\n-                        Some(s) => s.next().await,\n-                        None => None,\n-                    }\n-                } => {\n-                    stderr_lines.push(line);\n-                }\n-                else => break,\n-            }\n-        }\n-\n-        let status = execution.wait().await?;\n-\n-        Ok::<(i32, String, String), BoxliteError>((\n-            status.exit_code,\n-            stdout_lines.join(\"\\n\"),\n-            stderr_lines.join(\"\\n\"),\n-        ))\n-    });\n-\n-    match result {\n-        Ok((exit_code, stdout, stderr)) => {\n-            let stdout_c = match CString::new(stdout) {\n-                Ok(s) => s.into_raw(),\n-                Err(_) => ptr::null_mut(),\n-            };\n-            let stderr_c = match CString::new(stderr) {\n-                Ok(s) => s.into_raw(),\n-                Err(_) => ptr::null_mut(),\n-            };\n-\n-            let exec_result = Box::new(CBoxliteExecResult {\n-                exit_code,\n-                stdout_text: stdout_c,\n-                stderr_text: stderr_c,\n-            });\n-            *out_result = Box::into_raw(exec_result);\n-            BoxliteErrorCode::Ok\n-        }\n-        Err(e) => {\n-            let code = error_to_code(&e);\n-            write_error(out_error, e);\n-            code\n-        }\n-    }\n+    boxlite_ffi::ops::runner_exec(box_runner, command, args, argc, out_result, out_error)\n }\n \n-/// Free execution result\n+// ============================================================================\n+// Memory Management\n+// ============================================================================\n+\n+/// Free an execution result.\n+///\n+/// # Arguments\n+/// * `result` - Pointer to `CBoxliteExecResult` to free.\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_result_free(result: *mut CBoxliteExecResult) {\n-    if !result.is_null() {\n-        let result_box = Box::from_raw(result);\n-        if !result_box.stdout_text.is_null() {\n-            drop(CString::from_raw(result_box.stdout_text));\n-        }\n-        if !result_box.stderr_text.is_null() {\n-            drop(CString::from_raw(result_box.stderr_text));\n-        }\n-    }\n+    boxlite_ffi::ops::result_free(result)\n }\n \n-/// Free simple box (auto-cleanup)\n+/// Free a simple runner.\n+///\n+/// # Arguments\n+/// * `box_runner` - Pointer to `CBoxliteSimple,` to free.\n #[unsafe(no_mangle)]\n-pub unsafe extern \"C\" fn boxlite_simple_free(simple_box: *mut CBoxliteSimple) {\n-    if !simple_box.is_null() {\n-        let mut simple = Box::from_raw(simple_box);\n-\n-        if let Some(handle) = simple.handle.take() {\n-            let _ = simple.tokio_rt.block_on(handle.stop());\n-        }\n-\n-        if let Some(box_id) = simple.box_id.take() {\n-            let _ = simple\n-                .tokio_rt\n-                .block_on(simple.runtime.remove(box_id.as_ref(), true));\n-        }\n-\n-        drop(simple);\n-    }\n+pub unsafe extern \"C\" fn boxlite_simple_free(box_runner: *mut CBoxliteSimple) {\n+    boxlite_ffi::ops::runner_free(box_runner)\n }\n \n-// ============================================================================\n-// Memory Management\n-// ============================================================================\n+/// Free a box handle.\n+///\n+/// # Arguments\n+/// * `handle` - Pointer to `CBoxHandle` to free.\n+#[unsafe(no_mangle)]\n+pub unsafe extern \"C\" fn boxlite_box_free(handle: *mut CBoxHandle) {\n+    boxlite_ffi::ops::box_free(handle)\n+}\n \n-/// Free a runtime instance\n+/// Free a runtime handle.\n+///\n+/// # Arguments\n+/// * `runtime` - Pointer to `CBoxliteRuntime` to free.\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_runtime_free(runtime: *mut CBoxliteRuntime) {\n-    if !runtime.is_null() {\n-        unsafe {\n-            drop(Box::from_raw(runtime));\n-        }\n-    }\n+    boxlite_ffi::ops::runtime_free(runtime)\n }\n \n-/// Free a string allocated by BoxLite\n+/// Free a string allocated by the library.\n+///\n+/// # Arguments\n+/// * `s` - Pointer to string to free.\n #[unsafe(no_mangle)]\n-pub unsafe extern \"C\" fn boxlite_free_string(str: *mut c_char) {\n-    if !str.is_null() {\n-        unsafe {\n-            drop(CString::from_raw(str));\n-        }\n-    }\n+pub unsafe extern \"C\" fn boxlite_free_string(s: *mut c_char) {\n+    boxlite_ffi::ops::string_free(s)\n }\n \n-/// Free error struct\n+/// Free an error object.\n+///\n+/// # Arguments\n+/// * `error` - Pointer to `CBoxliteError` to free.\n #[unsafe(no_mangle)]\n pub unsafe extern \"C\" fn boxlite_error_free(error: *mut CBoxliteError) {\n-    if !error.is_null() {\n-        let err = &mut *error;\n-        if !err.message.is_null() {\n-            drop(CString::from_raw(err.message));\n-            err.message = ptr::null_mut();\n-        }\n-        err.code = BoxliteErrorCode::Ok;\n-    }\n-}\n-\n-// ============================================================================\n-// Unit Tests\n-// ============================================================================\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_version() {\n-        unsafe {\n-            let version = CStr::from_ptr(boxlite_version()).to_str().unwrap();\n-            assert!(!version.is_empty());\n-            assert!(version.contains('.'));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_error_code_mapping() {\n-        assert_eq!(\n-            error_to_code(&BoxliteError::NotFound(\"test\".into())),\n-            BoxliteErrorCode::NotFound\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::AlreadyExists(\"test\".into())),\n-            BoxliteErrorCode::AlreadyExists\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::InvalidState(\"test\".into())),\n-            BoxliteErrorCode::InvalidState\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::InvalidArgument(\"test\".into())),\n-            BoxliteErrorCode::InvalidArgument\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::Internal(\"test\".into())),\n-            BoxliteErrorCode::Internal\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::Config(\"test\".into())),\n-            BoxliteErrorCode::Config\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::Storage(\"test\".into())),\n-            BoxliteErrorCode::Storage\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::Image(\"test\".into())),\n-            BoxliteErrorCode::Image\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::Network(\"test\".into())),\n-            BoxliteErrorCode::Network\n-        );\n-        assert_eq!(\n-            error_to_code(&BoxliteError::Execution(\"test\".into())),\n-            BoxliteErrorCode::Execution\n-        );\n-    }\n-\n-    #[test]\n-    fn test_error_struct_creation() {\n-        let err = BoxliteError::NotFound(\"box123\".into());\n-        let c_err = error_to_c_error(err);\n-        assert_eq!(c_err.code, BoxliteErrorCode::NotFound);\n-        assert!(!c_err.message.is_null());\n-        unsafe {\n-            boxlite_error_free(&mut CBoxliteError {\n-                code: c_err.code,\n-                message: c_err.message,\n-            } as *mut _);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_null_pointer_validation() {\n-        unsafe {\n-            let mut error = CBoxliteError::default();\n-            let code = boxlite_simple_new(ptr::null(), 0, 0, ptr::null_mut(), &mut error as *mut _);\n-            assert_eq!(code, BoxliteErrorCode::InvalidArgument);\n-            assert!(!error.message.is_null());\n-            boxlite_error_free(&mut error as *mut _);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_c_string_conversion() {\n-        let test_str = CString::new(\"hello\").unwrap();\n-        unsafe {\n-            let result = c_str_to_string(test_str.as_ptr());\n-            assert!(result.is_ok());\n-            assert_eq!(result.unwrap(), \"hello\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_c_string_null_handling() {\n-        unsafe {\n-            let result = c_str_to_string(ptr::null());\n-            assert!(result.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_status_to_string() {\n-        assert_eq!(status_to_string(BoxStatus::Unknown), \"unknown\");\n-        assert_eq!(status_to_string(BoxStatus::Configured), \"configured\");\n-        assert_eq!(status_to_string(BoxStatus::Running), \"running\");\n-        assert_eq!(status_to_string(BoxStatus::Stopping), \"stopping\");\n-        assert_eq!(status_to_string(BoxStatus::Stopped), \"stopped\");\n-    }\n-\n-    #[test]\n-    fn test_default_error_struct() {\n-        let err = CBoxliteError::default();\n-        assert_eq!(err.code, BoxliteErrorCode::Ok);\n-        assert!(err.message.is_null());\n-    }\n-\n-    #[test]\n-    fn test_error_free_null_safe() {\n-        unsafe {\n-            boxlite_error_free(ptr::null_mut());\n-            // Should not panic\n-        }\n-    }\n-\n-    #[test]\n-    fn test_result_free_null_safe() {\n-        unsafe {\n-            boxlite_result_free(ptr::null_mut());\n-            // Should not panic\n-        }\n-    }\n-\n-    #[test]\n-    fn test_simple_free_null_safe() {\n-        unsafe {\n-            boxlite_simple_free(ptr::null_mut());\n-            // Should not panic\n-        }\n-    }\n+    boxlite_ffi::ops::error_free(error)\n }\ndiff --git a/sdks/c/tests/CMakeLists.txt b/sdks/c/tests/CMakeLists.txt\nindex abfc5903..9fc64191 100644\n--- a/sdks/c/tests/CMakeLists.txt\n+++ b/sdks/c/tests/CMakeLists.txt\n@@ -63,22 +63,51 @@ endforeach()\n # Enable testing\n enable_testing()\n \n-# Add tests\n-add_test(NAME basic COMMAND test_basic)\n-add_test(NAME lifecycle COMMAND test_lifecycle)\n-add_test(NAME execute COMMAND test_execute)\n-add_test(NAME errors COMMAND test_errors)\n-add_test(NAME simple_api COMMAND test_simple_api)\n-add_test(NAME streaming COMMAND test_streaming)\n-add_test(NAME memory COMMAND test_memory)\n-add_test(NAME integration COMMAND test_integration)\n+# Auto-discover runtime directory\n+# Priority: BOXLITE_RUNTIME_DIR env > target/boxlite-runtime (from `make runtime`)\n+# The runtime directory contains: boxlite-guest, mke2fs, debugfs, libkrun, libgvproxy, etc.\n+if(DEFINED ENV{BOXLITE_RUNTIME_DIR})\n+    set(BOXLITE_RUNTIME_DIR \"$ENV{BOXLITE_RUNTIME_DIR}\")\n+elseif(EXISTS \"${BOXLITE_ROOT}/target/boxlite-runtime\")\n+    set(BOXLITE_RUNTIME_DIR \"${BOXLITE_ROOT}/target/boxlite-runtime\")\n+else()\n+    # Fallback: try to find the build output from boxlite crate\n+    file(GLOB _RUNTIME_CANDIDATES \"${BOXLITE_ROOT}/target/release/build/boxlite-*/out/runtime\")\n+    list(LENGTH _RUNTIME_CANDIDATES _NUM_CANDIDATES)\n+    if(_NUM_CANDIDATES GREATER 0)\n+        list(GET _RUNTIME_CANDIDATES 0 BOXLITE_RUNTIME_DIR)\n+    else()\n+        set(BOXLITE_RUNTIME_DIR \"\")\n+    endif()\n+endif()\n+\n+# Add tests with runtime environment\n+foreach(TARGET ${TEST_TARGETS})\n+    add_test(NAME ${TARGET} COMMAND ${TARGET})\n+    if(BOXLITE_RUNTIME_DIR)\n+        set_tests_properties(${TARGET} PROPERTIES\n+            ENVIRONMENT \"BOXLITE_RUNTIME_DIR=${BOXLITE_RUNTIME_DIR};DYLD_LIBRARY_PATH=${BOXLITE_RUNTIME_DIR}:${BOXLITE_LIB_DIR}\"\n+        )\n+    endif()\n+endforeach()\n \n # Print instructions\n+if(BOXLITE_RUNTIME_DIR)\n+    message(STATUS \"  Runtime dir: ${BOXLITE_RUNTIME_DIR}\")\n+else()\n+    message(WARNING \"Runtime directory not found. Tests requiring VM (execute, streaming, etc.) will fail.\")\n+    message(WARNING \"Run 'make runtime' from the project root first, or set BOXLITE_RUNTIME_DIR.\")\n+endif()\n+\n message(STATUS \"BoxLite C Tests Configuration:\")\n message(STATUS \"  Include dir: ${BOXLITE_INCLUDE_DIR}\")\n message(STATUS \"  Library: ${BOXLITE_LIB}\")\n message(STATUS \"  Test targets: ${TEST_TARGETS}\")\n message(STATUS \"\")\n+message(STATUS \"Prerequisites:\")\n+message(STATUS \"  1. cargo build --release -p boxlite-c   (build libboxlite)\")\n+message(STATUS \"  2. make runtime                         (build runtime binaries)\")\n+message(STATUS \"\")\n message(STATUS \"To build and run tests:\")\n message(STATUS \"  mkdir -p build && cd build\")\n message(STATUS \"  cmake ..\")\n"
test_patch: ''
fail_to_pass: []
pass_to_pass: []
install_config:
  install: cargo fetch
  rust: '1.75'
  test_cmd: cargo test
meta:
  added_lines: '2486'
  difficulty: hard
  files_changed: '19'
  pr_title: 'Refactor: Extract FFI code to dedicated crate'
  removed_lines: '1716'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  boxlite-ai/boxlite (#226): Refactor: Extract FFI code to dedicated crate

  Refactor the SDK so the core FFI logic is housed in a dedicated shared crate that can be reused by multiple language bindings (C, Go, Node.js, Python). Update the C SDK to use this shared crate. The end result should reduce duplication and simplify maintenance without changing user-visible behavior.
original_pr_body: "boxlite-ai/boxlite (#226): Refactor: Extract FFI code to dedicated crate\n\nClose #225 \r\nThis PR extracts the FFI logic from the C SDK into a dedicated `boxlite-ffi` crate.\r\n\r\n### Changes\r\n- Moved core FFI operations from `sdks/c/src/ffi.rs` to `sdks/boxlite-ffi/src/ops.rs`.\r\n- Created shared utility modules `error.rs`, `json.rs`, and `string.rs` in `boxlite-ffi`.\r\n- Updated `sdks/c` to depend on the new shared crate.\r\n\r\n### Motivation\r\nThis refactoring allows reusing the core FFI implementation across multiple language bindings (C, Go, Node.js, Python), significantly reducing code duplication and simplifying maintenance. It is a necessary step for cleaner SDK architecture.\r\n\r\nThis work also prepares the codebase for the Go SDK implementation. As noted in #202, the Go SDK development will be completed after this PR is merged."
quality_score: 0.8
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
