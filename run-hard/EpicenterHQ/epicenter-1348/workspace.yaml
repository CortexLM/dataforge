id: EpicenterHQ/epicenter-1348
repo: EpicenterHQ/epicenter
base_commit: 87b46c8f572d76bc121cebace2e3b87ada12d2cb
merge_commit: 43857e71560cc9a990e29fc31f5a7cbf267d1db8
language: typescript
difficulty_score: 3
created_at: 2026-02-14T14:30:21.946085273Z
patch: "diff --git a/bun.lock b/bun.lock\nindex 4bf092b24a..49f266c14a 100644\n--- a/bun.lock\n+++ b/bun.lock\n@@ -271,7 +271,6 @@\n       },\n       \"dependencies\": {\n         \"@ark/json-schema\": \"^0.0.4\",\n-        \"@elysiajs/openapi\": \"^1.4.11\",\n         \"@epicenter/y-sweet\": \"workspace:*\",\n         \"@sindresorhus/slugify\": \"^3.0.0\",\n         \"@standard-schema/spec\": \"^1.1.0\",\n@@ -324,6 +323,26 @@\n         \"typescript\": \"catalog:\",\n       },\n     },\n+    \"packages/server\": {\n+      \"name\": \"@epicenter/server\",\n+      \"version\": \"0.0.1\",\n+      \"dependencies\": {\n+        \"@elysiajs/openapi\": \"^1.4.11\",\n+        \"elysia\": \"^1.2.25\",\n+        \"lib0\": \"^0.2.99\",\n+        \"wellcrafted\": \"catalog:\",\n+        \"y-protocols\": \"^1.0.6\",\n+        \"yjs\": \"^13.6.27\",\n+      },\n+      \"devDependencies\": {\n+        \"@types/bun\": \"catalog:\",\n+        \"arktype\": \"catalog:\",\n+        \"typescript\": \"catalog:\",\n+      },\n+      \"peerDependencies\": {\n+        \"@epicenter/hq\": \"workspace:*\",\n+      },\n+    },\n     \"packages/shared\": {\n       \"name\": \"@epicenter/shared\",\n       \"version\": \"0.0.0\",\n@@ -591,6 +610,8 @@\n \n     \"@epicenter/posthog-reverse-proxy\": [\"@epicenter/posthog-reverse-proxy@workspace:apps/posthog-reverse-proxy\"],\n \n+    \"@epicenter/server\": [\"@epicenter/server@workspace:packages/server\"],\n+\n     \"@epicenter/shared\": [\"@epicenter/shared@workspace:packages/shared\"],\n \n     \"@epicenter/svelte-utils\": [\"@epicenter/svelte-utils@workspace:packages/svelte-utils\"],\ndiff --git a/docs/articles/discriminated-unions-over-optional-fields.md b/docs/articles/discriminated-unions-over-optional-fields.md\nnew file mode 100644\nindex 0000000000..2a78acce02\n--- /dev/null\n+++ b/docs/articles/discriminated-unions-over-optional-fields.md\n@@ -0,0 +1,160 @@\n+# Three Auth Modes, One Config Object, Zero Invalid States\n+\n+You're building a sync provider. It connects to a WebSocket server and syncs data. Authentication has three modes: no auth (local network), a static token (self-hosted), or a dynamic token function (cloud). The first instinct is a config object with optional fields:\n+\n+```typescript\n+type SyncProviderConfig = {\n+\turl: string;\n+\t/** Static shared secret, set once when the server starts. */\n+\ttoken?: string;\n+\t/** Fetches a short-lived JWT from your auth service on each connection. */\n+\tgetToken?: (workspaceId: string) => Promise<string>;\n+};\n+```\n+\n+This works. You can pass just a URL, or a URL with a token, or a URL with a getToken callback. Three valid combinations. But there's a fourth combination TypeScript won't stop you from writing:\n+\n+```typescript\n+createSyncProvider({\n+\turl: 'wss://sync.example.com',\n+\ttoken: 'my-static-secret',\n+\tgetToken: async (id) => fetchJwt(id),\n+});\n+```\n+\n+Both `token` and `getToken` present. Which one wins? The spec says \"mutually exclusive\" in a JSDoc comment, but comments don't compile.\n+\n+## The Real Cost\n+\n+The JSDoc comment `Mutually exclusive with getToken` is documentation debt. Someone will miss it. The provider implementation has to handle the impossible state anyway:\n+\n+```typescript\n+function createSyncProvider(config: SyncProviderConfig) {\n+\tif (config.token && config.getToken) {\n+\t\tthrow new Error('Cannot specify both token and getToken');\n+\t}\n+\t// ...\n+}\n+```\n+\n+Runtime validation for something the type system should catch at compile time. Every consumer reads the docs, hopes they got it right, and finds out at runtime if they didn't.\n+\n+## Discriminated Unions Fix the Type Problem\n+\n+Instead of optional fields, model the three modes as explicit variants:\n+\n+```typescript\n+type SyncProviderConfig =\n+\t| { mode: 'open'; url: string }\n+\t| { mode: 'static-token'; url: string; token: string }\n+\t| {\n+\t\t\tmode: 'dynamic-token';\n+\t\t\turl: string;\n+\t\t\tgetToken: (workspaceId: string) => Promise<string>;\n+\t  };\n+```\n+\n+Now the invalid state is unrepresentable. TypeScript won't let you pass `token` when `mode` is `'dynamic-token'`. The `mode` discriminant tells both the type system and the reader exactly which auth path this config uses.\n+\n+The implementation can use an exhaustive switch instead of defensive checks:\n+\n+```typescript\n+function createSyncProvider(config: SyncProviderConfig) {\n+\tswitch (config.mode) {\n+\t\tcase 'open':\n+\t\t\treturn connect(config.url);\n+\t\tcase 'static-token':\n+\t\t\treturn connect(config.url, { protocol: config.token });\n+\t\tcase 'dynamic-token':\n+\t\t\treturn connect(config.url, { getProtocol: config.getToken });\n+\t\tdefault: {\n+\t\t\tconst _exhaustive: never = config;\n+\t\t\tthrow new Error(\n+\t\t\t\t`Unknown mode: ${(_exhaustive as SyncProviderConfig).mode}`,\n+\t\t\t);\n+\t\t}\n+\t}\n+}\n+```\n+\n+No runtime validation for invalid combinations. The type system already eliminated them.\n+\n+## The DX Problem\n+\n+Discriminated unions solve the correctness problem but add friction. Every call site now needs the discriminant key:\n+\n+```typescript\n+// Before: just pass what you need\n+createSyncProvider({ url: 'ws://localhost:3913' });\n+\n+// After: always spell out the mode\n+createSyncProvider({ mode: 'open', url: 'ws://localhost:3913' });\n+createSyncProvider({\n+\tmode: 'static-token',\n+\turl: 'ws://my-server:3913',\n+\ttoken: 'secret',\n+});\n+createSyncProvider({\n+\tmode: 'dynamic-token',\n+\turl: 'wss://cloud.example.com',\n+\tgetToken: fetchJwt,\n+});\n+```\n+\n+The `mode` key is redundant information. When you pass only a URL, the mode is obviously \"open.\" When you pass a token string, the mode is obviously \"static-token.\" The developer already knows which mode they're using by the fields they provide. Forcing them to also declare it is boilerplate.\n+\n+For an internal API or a library with few consumers, this is fine. For a developer-facing config that people type out by hand, the extra key feels like ceremony.\n+\n+## Factory Functions as the Final Layer\n+\n+The solution is to keep the discriminated union as the internal representation but give consumers named factory functions that construct each variant:\n+\n+```typescript\n+function openSync(url: string): SyncProviderConfig {\n+\treturn { mode: 'open', url };\n+}\n+\n+function staticTokenSync(url: string, token: string): SyncProviderConfig {\n+\treturn { mode: 'static-token', url, token };\n+}\n+\n+function dynamicTokenSync(\n+\turl: string,\n+\tgetToken: (workspaceId: string) => Promise<string>,\n+): SyncProviderConfig {\n+\treturn { mode: 'dynamic-token', url, getToken };\n+}\n+```\n+\n+Consumers pick the function that matches their auth model. The function name is the discriminant:\n+\n+```typescript\n+createSyncProvider(openSync('ws://localhost:3913'));\n+\n+createSyncProvider(staticTokenSync('ws://my-server:3913', 'my-shared-secret'));\n+\n+createSyncProvider(\n+\tdynamicTokenSync('wss://cloud.example.com', async (workspaceId) => {\n+\t\tconst res = await fetch('/api/sync/token', {\n+\t\t\tmethod: 'POST',\n+\t\t\tbody: JSON.stringify({ workspaceId }),\n+\t\t});\n+\t\treturn (await res.json()).token;\n+\t}),\n+);\n+```\n+\n+Each function accepts only the fields valid for its mode. You can't accidentally pass both `token` and `getToken` because no single function accepts both. The discriminant `mode` key is injected automatically; the consumer never sees it.\n+\n+The internal implementation still gets a clean discriminated union to switch on. The external API is a set of focused functions with obvious names and tight signatures.\n+\n+| Layer    | Sees                            | Guarantees                             |\n+| -------- | ------------------------------- | -------------------------------------- |\n+| Consumer | Factory function per mode       | Can't construct invalid config         |\n+| Internal | Discriminated union with `mode` | Exhaustive switch, no defensive checks |\n+\n+## When This Pattern Fits\n+\n+The optional-fields-to-discriminated-union-to-factory-functions progression applies whenever you have a config object with mutually exclusive groups of fields. The trigger is a JSDoc comment that says \"mutually exclusive with X.\" If you're writing that comment, you have a type that permits invalid states.\n+\n+The factory function layer is optional. If the discriminant key carries meaningful information that consumers should see (like an error `kind` or an event `type`), keep it in the public API. Add factory functions when the discriminant is an implementation detail that the consumer's choice of function already communicates.\ndiff --git a/docs/articles/three-gradations-of-websocket-auth.md b/docs/articles/three-gradations-of-websocket-auth.md\nnew file mode 100644\nindex 0000000000..00902cdb5c\n--- /dev/null\n+++ b/docs/articles/three-gradations-of-websocket-auth.md\n@@ -0,0 +1,133 @@\n+# Three Gradations of WebSocket Auth\n+\n+You own a WebSocket server. Clients connect to sync data in real time. The question is: who gets to connect? There are three levels, each adding one piece to the handshake. Pick the one that matches your threat model.\n+\n+## Level 1: URL Only\n+\n+The client knows the URL. That's it. No credentials, no handshake, no token exchange. The server accepts any connection.\n+\n+```typescript\n+// Client\n+const ws = new WebSocket('ws://localhost:3913/sync/my-doc');\n+```\n+\n+```typescript\n+// Server\n+server.ws('/sync/:docId', {\n+\topen(ws) {\n+\t\t// Everyone's welcome\n+\t\tconst doc = getDoc(ws.data.params.docId);\n+\t\tstartSync(ws, doc);\n+\t},\n+});\n+```\n+\n+This is fine when the network itself is the boundary: localhost, a Tailscale mesh, a LAN. If you can reach the URL, you're trusted. No secret to leak, no token to expire, no auth service to keep running. Local dev, private networks, air-gapped environments.\n+\n+## Level 2: URL + Static Token\n+\n+The person who runs the server picks a secret when they start it. Anyone who knows both the URL and the secret can connect; everyone else gets rejected.\n+\n+Say you're self-hosting a sync server on your home network. You start it with a token you choose:\n+\n+```bash\n+# Server owner picks a secret at startup\n+sync-server start --token my-shared-secret --port 3913\n+```\n+\n+The server reads that token and checks it on every incoming WebSocket connection:\n+\n+```typescript\n+// Server\n+function startSyncServer(options: { token: string; port: number }) {\n+\tconst server = Bun.serve({\n+\t\tport: options.port,\n+\t\twebsocket: {\n+\t\t\topen(ws) {\n+\t\t\t\tconst url = new URL(ws.data.url, 'http://localhost');\n+\t\t\t\tif (url.searchParams.get('token') !== options.token) {\n+\t\t\t\t\tws.close(4001, 'Unauthorized');\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tconst doc = getDoc(ws.data.params.docId);\n+\t\t\t\tstartSync(ws, doc);\n+\t\t\t},\n+\t\t},\n+\t});\n+}\n+```\n+\n+Clients pass the same secret as a query parameter:\n+\n+```typescript\n+// Client\n+const ws = new WebSocket(\n+\t'ws://my-server:3913/sync/my-doc?token=my-shared-secret',\n+);\n+```\n+\n+One step up from open access. The token is long-lived and shared across all clients, but the server owner controls it. It works for self-hosted setups where you trust every client: a personal sync server, a family home lab, a small team's internal tool. If the token leaks, the server owner picks a new one and restarts.\n+\n+## Level 3: URL + Dynamic Token (getToken)\n+\n+The client calls an async function before each connection to fetch a short-lived token from your auth service. The server validates the token's signature and expiry on every connection attempt.\n+\n+```typescript\n+// Client\n+async function getToken(\n+\tdocId: string,\n+): Promise<{ url: string; token: string }> {\n+\tconst res = await fetch('/api/sync/token', {\n+\t\tmethod: 'POST',\n+\t\theaders: { Authorization: `Bearer ${sessionToken}` },\n+\t\tbody: JSON.stringify({ docId }),\n+\t});\n+\treturn res.json(); // { url: 'wss://sync.example.com/sync/my-doc', token: 'eyJhbG...' }\n+}\n+\n+const { url, token } = await getToken('my-doc');\n+const ws = new WebSocket(`${url}?token=${token}`);\n+```\n+\n+```typescript\n+// Server\n+server.ws('/sync/:docId', {\n+\topen(ws) {\n+\t\tconst url = new URL(ws.data.url, 'http://localhost');\n+\t\tconst token = url.searchParams.get('token');\n+\t\tconst payload = verifyJwt(token); // checks signature + expiry\n+\t\tif (!payload) {\n+\t\t\tws.close(4001, 'Unauthorized');\n+\t\t\treturn;\n+\t\t}\n+\t\tconst doc = getDoc(ws.data.params.docId);\n+\t\tstartSync(ws, doc);\n+\t},\n+});\n+```\n+\n+This is the production pattern. Tokens are short-lived (minutes, not months), per-connection, scoped to a specific document, and tied to an authenticated user. If a token leaks, it expires before anyone can use it. If a user loses access, the next `getToken` call fails and the connection never opens.\n+\n+Every major real-time service uses this exact flow: Firebase Realtime Database, Supabase Realtime, Liveblocks, Y-Sweet, Pusher, Ably. The details vary (some use WebSocket subprotocols instead of query params, some embed claims differently), but the shape is always the same: client asks auth service for a short-lived credential, passes it on the WebSocket handshake, server validates before accepting.\n+\n+## The Comparison\n+\n+| Concern          | URL only                    | URL + static token              | URL + getToken           |\n+| ---------------- | --------------------------- | ------------------------------- | ------------------------ |\n+| Who can connect  | Anyone who knows the URL    | Anyone with the shared secret   | Anyone with a valid JWT  |\n+| Token lifetime   | N/A                         | Months (until manually rotated) | Minutes (auto-expires)   |\n+| Per-user scoping | No                          | No (same token for everyone)    | Yes (claims in JWT)      |\n+| Revocation       | Change the URL              | Rotate the secret, redeploy     | Stop issuing tokens      |\n+| Good for         | Local dev, private networks | Self-hosted, small teams        | Production, multi-tenant |\n+\n+| Concern          | Mode 1 (URL only)      | Mode 2 (URL + token)   | Mode 3 (URL + getToken)             |\n+| ---------------- | ---------------------- | ---------------------- | ----------------------------------- |\n+| Who can connect  | Anyone                 | Anyone with the secret | Anyone with a valid JWT             |\n+| Encryption       | Same AES-256-GCM       | Same                   | Same                                |\n+| Key distribution | QR / passphrase        | QR / passphrase        | Server-side key vault (wrapped DKs) |\n+| Recovery         | Recovery secret only   | Recovery secret only   | Password + recovery code            |\n+| Multi-device     | Manual secret transfer | Manual secret transfer | Login → auto-fetch wrapped DK       |\n+\n+The jump from level 2 to level 3 is where self-hosted becomes production-ready. Static tokens can't distinguish between users, can't expire gracefully, and can't be scoped to specific resources. Dynamic tokens solve all three, at the cost of running an auth service that issues them.\n+\n+Most apps start at level 1 during local development, skip level 2 entirely, and jump straight to level 3 when they ship. The middle ground exists for the cases where you trust the network but want a basic gate: a shared family server, a Tailscale-connected home lab, an internal company tool that doesn't justify a full auth stack.\ndiff --git a/docs/articles/use-functions-to-wrap-discriminated-unions.md b/docs/articles/use-functions-to-wrap-discriminated-unions.md\nnew file mode 100644\nindex 0000000000..37c0d0e117\n--- /dev/null\n+++ b/docs/articles/use-functions-to-wrap-discriminated-unions.md\n@@ -0,0 +1,114 @@\n+# Use Functions to Wrap Discriminated Unions\n+\n+Discriminated unions eliminate invalid states. They also make every call site spell out a discriminant key the developer already communicated by choosing which fields to pass. The fix: replace one function with N discriminant keys with N functions that each inject the discriminant internally.\n+\n+## The Problem\n+\n+A discriminated union with three variants means every consumer writes the discriminant by hand:\n+\n+```typescript\n+type Auth =\n+\t| { kind: 'none'; url: string }\n+\t| { kind: 'static'; url: string; token: string }\n+\t| { kind: 'dynamic'; url: string; getToken: () => Promise<string> };\n+\n+// Consumer has to write `kind` every time\n+connect({ kind: 'none', url: 'ws://localhost:3913' });\n+connect({ kind: 'static', url: 'ws://my-server:3913', token: 'secret' });\n+connect({\n+\tkind: 'dynamic',\n+\turl: 'wss://cloud.example.com',\n+\tgetToken: fetchJwt,\n+});\n+```\n+\n+The `kind` field is load-bearing for the implementation but redundant for the caller. If you're passing a `token`, you already know the kind. If you're passing `getToken`, same thing. The discriminant is just restating what the arguments already say.\n+\n+## The Fix\n+\n+Three functions, one per variant. Each injects the discriminant:\n+\n+```typescript\n+function noAuth(url: string): Auth {\n+\treturn { kind: 'none', url };\n+}\n+\n+function staticToken(url: string, token: string): Auth {\n+\treturn { kind: 'static', url, token };\n+}\n+\n+function dynamicToken(url: string, getToken: () => Promise<string>): Auth {\n+\treturn { kind: 'dynamic', url, getToken };\n+}\n+```\n+\n+The call sites become:\n+\n+```typescript\n+connect(noAuth('ws://localhost:3913'));\n+connect(staticToken('ws://my-server:3913', 'secret'));\n+connect(dynamicToken('wss://cloud.example.com', fetchJwt));\n+```\n+\n+The function name replaces the discriminant key. The consumer picks which function to call; the implementation still gets a clean union to switch on.\n+\n+## Why This Works Better Than Overloads\n+\n+You might think function overloads solve this:\n+\n+```typescript\n+function connect(url: string): void;\n+function connect(url: string, token: string): void;\n+function connect(url: string, getToken: () => Promise<string>): void;\n+```\n+\n+But `token` and `getToken` are both functions or strings in other contexts. Overloads rely on TypeScript distinguishing argument types at the call site, which gets fragile when types overlap or when you need to store the config before passing it. Separate functions are unambiguous: the name carries the intent, not the argument types.\n+\n+The other advantage: the config object is a first-class value. You can store it, pass it around, serialize it. Overloads disappear at the call boundary.\n+\n+```typescript\n+// Config can travel through your app as data\n+const auth = staticToken('ws://my-server:3913', 'secret');\n+saveToSettings(auth);\n+// later\n+connect(loadFromSettings());\n+```\n+\n+## The Pattern Generalized\n+\n+Any discriminated union where the discriminant is an implementation detail (not something the consumer cares about naming) benefits from wrapper functions. The shape is always the same:\n+\n+```typescript\n+// Internal: discriminated union\n+type Action =\n+\t| { type: 'create'; name: string }\n+\t| { type: 'rename'; id: string; name: string }\n+\t| { type: 'delete'; id: string };\n+\n+// External: one function per variant\n+function create(name: string): Action {\n+\treturn { type: 'create', name };\n+}\n+\n+function rename(id: string, name: string): Action {\n+\treturn { type: 'rename', id, name };\n+}\n+\n+function remove(id: string): Action {\n+\treturn { type: 'delete', id };\n+}\n+```\n+\n+The functions are trivial. That's the point. Each one does exactly one thing: construct the right variant with the right discriminant. No logic, no validation, no branching. The type system guarantees correctness at the boundary; the implementation gets a union it can exhaustively switch on.\n+\n+| What the consumer sees | What the implementation sees          |\n+| ---------------------- | ------------------------------------- |\n+| `create('my-doc')`     | `{ type: 'create', name: 'my-doc' }`  |\n+| `rename(id, 'new')`    | `{ type: 'rename', id, name: 'new' }` |\n+| `remove(id)`           | `{ type: 'delete', id }`              |\n+\n+One function per variant. The function name is the discriminant.\n+\n+## Related\n+\n+- [Three Auth Modes, One Config Object, Zero Invalid States](./discriminated-unions-over-optional-fields.md) — the full progression from optional fields to discriminated unions to factory functions\ndiff --git a/packages/epicenter/package.json b/packages/epicenter/package.json\nindex 8eee57d79c..f1b9761d9a 100644\n--- a/packages/epicenter/package.json\n+++ b/packages/epicenter/package.json\n@@ -17,7 +17,6 @@\n \t\t\"./extensions/y-sweet-persist-sync/desktop\": \"./src/extensions/y-sweet-persist-sync/desktop.ts\",\n \t\t\"./extensions/websocket-sync\": \"./src/extensions/websocket-sync.ts\",\n \t\t\"./cli\": \"./src/cli/index.ts\",\n-\t\t\"./server\": \"./src/server/index.ts\",\n \t\t\"./ingest\": \"./src/ingest/index.ts\",\n \t\t\"./ingest/reddit\": \"./src/ingest/reddit/index.ts\",\n \t},\n@@ -31,7 +30,6 @@\n \t},\n \t\"dependencies\": {\n \t\t\"@ark/json-schema\": \"^0.0.4\",\n-\t\t\"@elysiajs/openapi\": \"^1.4.11\",\n \t\t\"@sindresorhus/slugify\": \"^3.0.0\",\n \t\t\"@standard-schema/spec\": \"^1.1.0\",\n \t\t\"@tursodatabase/database\": \"^0.3.2\",\ndiff --git a/packages/epicenter/src/cli/cli.ts b/packages/epicenter/src/cli/cli.ts\nindex 1e548bfb77..fa76ee7560 100644\n--- a/packages/epicenter/src/cli/cli.ts\n+++ b/packages/epicenter/src/cli/cli.ts\n@@ -1,5 +1,4 @@\n import yargs from 'yargs';\n-import { createServer, DEFAULT_PORT } from '../server/server';\n import { buildActionCommands } from './command-builder';\n import { buildKvCommands } from './commands/kv-commands';\n import { buildMetaCommands } from './commands/meta-commands';\n@@ -20,12 +19,22 @@ export function createCLI(client: AnyWorkspaceClient) {\n \t\t\t\tyargs.option('port', {\n \t\t\t\t\ttype: 'number',\n \t\t\t\t\tdescription: 'Port to run the server on',\n-\t\t\t\t\tdefault: DEFAULT_PORT,\n+\t\t\t\t\tdefault: 3913,\n \t\t\t\t}),\n-\t\t\t(argv) => {\n-\t\t\t\tcreateServer(client, {\n-\t\t\t\t\tport: argv.port,\n-\t\t\t\t}).start();\n+\t\t\tasync (argv) => {\n+\t\t\t\ttry {\n+\t\t\t\t\tconst { createServer } = await import('@epicenter/server');\n+\t\t\t\t\tcreateServer(client, {\n+\t\t\t\t\t\tport: argv.port,\n+\t\t\t\t\t}).start();\n+\t\t\t\t} catch {\n+\t\t\t\t\tconsole.error(\n+\t\t\t\t\t\t'Error: @epicenter/server is not installed.\\n\\n' +\n+\t\t\t\t\t\t\t'Install it to use the serve command:\\n' +\n+\t\t\t\t\t\t\t'  bun add @epicenter/server\\n',\n+\t\t\t\t\t);\n+\t\t\t\t\tprocess.exit(1);\n+\t\t\t\t}\n \t\t\t},\n \t\t);\n \ndiff --git a/packages/epicenter/src/static/index.ts b/packages/epicenter/src/static/index.ts\nindex c37cf0d2e6..4e67c7d12d 100644\n--- a/packages/epicenter/src/static/index.ts\n+++ b/packages/epicenter/src/static/index.ts\n@@ -125,6 +125,8 @@ export { createUnionSchema } from './schema-union.js';\n // ════════════════════════════════════════════════════════════════════════════\n \n export type {\n+\t// Any-typed client (for duck-typing in CLI/server)\n+\tAnyWorkspaceClient,\n \tDeleteResult,\n \tExtension,\n \t// Extension types\ndiff --git a/packages/epicenter/src/server/README.md b/packages/server/README.md\nsimilarity index 100%\nrename from packages/epicenter/src/server/README.md\nrename to packages/server/README.md\ndiff --git a/packages/server/package.json b/packages/server/package.json\nnew file mode 100644\nindex 0000000000..43cedfb0d8\n--- /dev/null\n+++ b/packages/server/package.json\n@@ -0,0 +1,29 @@\n+{\n+\t\"name\": \"@epicenter/server\",\n+\t\"version\": \"0.0.1\",\n+\t\"main\": \"./src/index.ts\",\n+\t\"types\": \"./src/index.ts\",\n+\t\"exports\": {\n+\t\t\".\": \"./src/index.ts\"\n+\t},\n+\t\"license\": \"AGPL-3.0\",\n+\t\"scripts\": {\n+\t\t\"typecheck\": \"tsc --noEmit\"\n+\t},\n+\t\"dependencies\": {\n+\t\t\"@elysiajs/openapi\": \"^1.4.11\",\n+\t\t\"elysia\": \"^1.2.25\",\n+\t\t\"lib0\": \"^0.2.99\",\n+\t\t\"wellcrafted\": \"catalog:\",\n+\t\t\"y-protocols\": \"^1.0.6\",\n+\t\t\"yjs\": \"^13.6.27\"\n+\t},\n+\t\"peerDependencies\": {\n+\t\t\"@epicenter/hq\": \"workspace:*\"\n+\t},\n+\t\"devDependencies\": {\n+\t\t\"@types/bun\": \"catalog:\",\n+\t\t\"arktype\": \"catalog:\",\n+\t\t\"typescript\": \"catalog:\"\n+\t}\n+}\ndiff --git a/packages/epicenter/src/server/actions.test.ts b/packages/server/src/actions.test.ts\nsimilarity index 98%\nrename from packages/epicenter/src/server/actions.test.ts\nrename to packages/server/src/actions.test.ts\nindex de01378c3d..2469d5ba3d 100644\n--- a/packages/epicenter/src/server/actions.test.ts\n+++ b/packages/server/src/actions.test.ts\n@@ -1,6 +1,6 @@\n import { describe, expect, test } from 'bun:test';\n+import { defineMutation, defineQuery } from '@epicenter/hq';\n import { type } from 'arktype';\n-import { defineMutation, defineQuery } from '../shared/actions';\n import { collectActionPaths, createActionsRouter } from './actions';\n \n // Mock client for closure-based actions\ndiff --git a/packages/epicenter/src/server/actions.ts b/packages/server/src/actions.ts\nsimilarity index 94%\nrename from packages/epicenter/src/server/actions.ts\nrename to packages/server/src/actions.ts\nindex 6402bec38f..61bf3618cf 100644\n--- a/packages/epicenter/src/server/actions.ts\n+++ b/packages/server/src/actions.ts\n@@ -1,6 +1,6 @@\n+import type { Actions } from '@epicenter/hq';\n+import { iterateActions } from '@epicenter/hq';\n import { Elysia } from 'elysia';\n-import type { Actions } from '../shared/actions';\n-import { iterateActions } from '../shared/actions';\n \n type ActionsRouterOptions = {\n \tclient: unknown;\ndiff --git a/packages/epicenter/src/server/index.ts b/packages/server/src/index.ts\nsimilarity index 100%\nrename from packages/epicenter/src/server/index.ts\nrename to packages/server/src/index.ts\ndiff --git a/packages/epicenter/src/server/server.ts b/packages/server/src/server.ts\nsimilarity index 98%\nrename from packages/epicenter/src/server/server.ts\nrename to packages/server/src/server.ts\nindex 5938aeed1f..f0eedb2e7d 100644\n--- a/packages/epicenter/src/server/server.ts\n+++ b/packages/server/src/server.ts\n@@ -1,6 +1,6 @@\n import { openapi } from '@elysiajs/openapi';\n+import type { AnyWorkspaceClient } from '@epicenter/hq/static';\n import { Elysia } from 'elysia';\n-import type { AnyWorkspaceClient } from '../static/types';\n import { collectActionPaths, createActionsRouter } from './actions';\n import { createSyncPlugin } from './sync';\n import { createTablesPlugin } from './tables';\ndiff --git a/packages/epicenter/src/server/sync/index.ts b/packages/server/src/sync/index.ts\nsimilarity index 100%\nrename from packages/epicenter/src/server/sync/index.ts\nrename to packages/server/src/sync/index.ts\ndiff --git a/packages/epicenter/src/server/sync/protocol.test.ts b/packages/server/src/sync/protocol.test.ts\nsimilarity index 100%\nrename from packages/epicenter/src/server/sync/protocol.test.ts\nrename to packages/server/src/sync/protocol.test.ts\ndiff --git a/packages/epicenter/src/server/sync/protocol.ts b/packages/server/src/sync/protocol.ts\nsimilarity index 100%\nrename from packages/epicenter/src/server/sync/protocol.ts\nrename to packages/server/src/sync/protocol.ts\ndiff --git a/packages/epicenter/src/server/tables.ts b/packages/server/src/tables.ts\nsimilarity index 96%\nrename from packages/epicenter/src/server/tables.ts\nrename to packages/server/src/tables.ts\nindex ff524e7639..1f21c5048c 100644\n--- a/packages/epicenter/src/server/tables.ts\n+++ b/packages/server/src/tables.ts\n@@ -1,5 +1,5 @@\n+import type { AnyWorkspaceClient, TableHelper } from '@epicenter/hq/static';\n import { Elysia } from 'elysia';\n-import type { AnyWorkspaceClient, TableHelper } from '../static/types';\n \n export function createTablesPlugin(\n \tworkspaceClients: Record<string, AnyWorkspaceClient>,\ndiff --git a/packages/server/tsconfig.json b/packages/server/tsconfig.json\nnew file mode 100644\nindex 0000000000..214810dc38\n--- /dev/null\n+++ b/packages/server/tsconfig.json\n@@ -0,0 +1,29 @@\n+{\n+\t\"compilerOptions\": {\n+\t\t\"lib\": [\"ESNext\", \"DOM\"],\n+\t\t\"target\": \"es2022\",\n+\t\t\"module\": \"Preserve\",\n+\t\t\"moduleDetection\": \"force\",\n+\t\t\"allowJs\": true,\n+\t\t\"resolveJsonModule\": true,\n+\t\t\"esModuleInterop\": true,\n+\t\t\"isolatedModules\": true,\n+\n+\t\t\"moduleResolution\": \"bundler\",\n+\t\t\"allowImportingTsExtensions\": true,\n+\t\t\"verbatimModuleSyntax\": true,\n+\t\t\"noEmit\": true,\n+\n+\t\t\"sourceMap\": true,\n+\n+\t\t\"strict\": true,\n+\t\t\"skipLibCheck\": true,\n+\t\t\"noFallthroughCasesInSwitch\": true,\n+\t\t\"noUncheckedIndexedAccess\": true,\n+\t\t\"noImplicitOverride\": true,\n+\n+\t\t\"noUnusedLocals\": true,\n+\t\t\"noUnusedParameters\": true,\n+\t\t\"noPropertyAccessFromIndexSignature\": false\n+\t}\n+}\ndiff --git a/specs/20260213T120800-extract-epicenter-server-package.md b/specs/20260213T120800-extract-epicenter-server-package.md\nnew file mode 100644\nindex 0000000000..9502e57e62\n--- /dev/null\n+++ b/specs/20260213T120800-extract-epicenter-server-package.md\n@@ -0,0 +1,688 @@\n+# @epicenter/server: Package Extraction + Sync Core\n+\n+**Date**: 2026-02-13\n+**Status**: Phase 1 Complete, Phase 2 Design Revised\n+**Related specs**: `20260213T120800-cloud-sync-durable-objects.md`, `20260213T120813-encryption-at-rest-architecture.md`\n+\n+## Overview\n+\n+Extract the server code from `@epicenter/hq` (currently at `packages/epicenter/src/server/`) into a standalone `@epicenter/server` package at `packages/server/`. Then build the sync core: a transport-agnostic room manager and three-mode authentication system that serve as the shared foundation for both the self-hosted Elysia server and the Cloudflare Durable Objects cloud path.\n+\n+**Scope boundary**: This spec covers `@epicenter/server` — the self-hosted Elysia/Bun sync server and the transport-agnostic sync core (`createRoom()`, `createAuthValidator()`, `Connection` type) that both deployment paths depend on. It also defines the **canonical client-side provider API** consumed by all three specs. The Cloudflare Durable Objects cloud path is a separate codebase documented in `20260213T120800-cloud-sync-durable-objects.md`. Client-side E2EE is documented in `20260213T120813-encryption-at-rest-architecture.md`.\n+\n+## Motivation\n+\n+### Current State\n+\n+The server lives inside `@epicenter/hq` at `src/server/`:\n+\n+```\n+packages/epicenter/src/server/\n+├── server.ts         # createServer() factory, Elysia + Bun.serve()\n+├── actions.ts        # Action → HTTP route mapping with Standard Schema validation\n+├── tables.ts         # RESTful CRUD for workspace tables\n+├── sync/\n+│   ├── index.ts      # WebSocket sync plugin (y-websocket protocol)\n+│   └── protocol.ts   # Pure encode/decode for y-websocket messages\n+├── index.ts          # Re-exports createServer, DEFAULT_PORT, ServerOptions\n+├── actions.test.ts   # 10 tests for action routing\n+└── sync/\n+    └── protocol.test.ts  # Protocol encode/decode tests\n+```\n+\n+The CLI at `src/cli/cli.ts` imports directly:\n+\n+```typescript\n+import { createServer, DEFAULT_PORT } from '../server/server';\n+```\n+\n+And `package.json` exports it as:\n+\n+```json\n+{ \"./server\": \"./src/server/index.ts\" }\n+```\n+\n+This creates problems:\n+\n+1. **Server code is coupled to the library package.** Users who want a self-hostable server must install `@epicenter/hq`, which includes the entire workspace system, CLI, providers, and ingest modules.\n+2. **No authentication.** `MESSAGE_AUTH=2` is reserved in the protocol but unimplemented. Anyone who can reach the WebSocket can read and write all data.\n+3. **No encryption at rest.** Yjs documents are stored and synced as plaintext. Sensitive data (API keys, tokens) stored in Yjs is visible to anyone with disk or network access.\n+4. **Topology is implicit.** Multi-device sync works but there's no formal server identity, discovery, or trust model for self-hosted deployments.\n+\n+### Desired State\n+\n+A standalone `@epicenter/server` package that:\n+\n+- Is installable independently for self-hosting (`bun add @epicenter/server`)\n+- Has a three-mode auth system: open (no auth), shared secret, or external JWT validation\n+- Exports a transport-agnostic room manager that can be reused by the Durable Objects cloud path\n+- Does NOT embed Better Auth, OAuth, user databases, or encryption — those live in separate concerns\n+\n+## Research Findings\n+\n+### Server Code Dependency Map\n+\n+The server imports from two internal modules:\n+\n+| Import              | Source          | What's Used                             |\n+| ------------------- | --------------- | --------------------------------------- |\n+| `../static/types`   | `@epicenter/hq` | `AnyWorkspaceClient`, `TableHelper`     |\n+| `../shared/actions` | `@epicenter/hq` | `Actions`, `iterateActions`, `isAction` |\n+\n+External dependencies:\n+\n+| Package             | Used In                                         | Purpose                       |\n+| ------------------- | ----------------------------------------------- | ----------------------------- |\n+| `elysia`            | server.ts, actions.ts, tables.ts, sync/index.ts | HTTP framework                |\n+| `@elysiajs/openapi` | server.ts                                       | API documentation             |\n+| `lib0`              | sync/index.ts, sync/protocol.ts                 | Binary encoding/decoding      |\n+| `y-protocols`       | sync/index.ts, sync/protocol.ts                 | Yjs sync + awareness protocol |\n+| `yjs`               | sync/protocol.ts (type-only)                    | Y.Doc type                    |\n+| `wellcrafted`       | sync/index.ts                                   | `trySync` for error handling  |\n+\n+**Key finding**: The server's dependency on `@epicenter/hq` is narrow — just 5 type imports and 2 function imports (`iterateActions`, `isAction`). The types can be imported from `@epicenter/hq` as a peer dependency.\n+\n+### Elysia.js and Cloudflare Durable Objects\n+\n+**Elysia cannot manage Durable Object WebSockets.** Durable Objects use the Hibernation API — a class-based lifecycle where the DO _is_ the WebSocket server via `this.ctx.acceptWebSocket()`, `webSocketMessage()`, `webSocketClose()` methods. There is no HTTP framework in the middle. Elysia has experimental CF Worker support (since v1.2) for basic HTTP routes, but its WebSocket handling uses `WebSocketPair` on Workers, which is the wrong model for DOs.\n+\n+**Implication**: The self-hosted path (Elysia/Bun) and the cloud path (CF Workers + DOs) are fundamentally different codebases at the transport layer. They share:\n+\n+- `protocol.ts` — pure encode/decode (already transport-agnostic)\n+- `room.ts` — transport-agnostic room management (to be extracted)\n+\n+But they have completely different:\n+\n+- HTTP routing (Elysia vs bare `fetch()` handler or Hono)\n+- WebSocket lifecycle (Elysia `.ws()` plugin vs DO class methods)\n+- Persistence (filesystem vs DO SQLite storage)\n+- Auth validation location (Elysia middleware vs CF Worker `fetch()`)\n+\n+### Auth Architecture: Two Servers, Not One\n+\n+Better Auth does NOT run inside the sync server. The architecture is:\n+\n+1. **Auth server** (Epicenter's cloud infrastructure) — Better Auth, user accounts, OAuth, org membership. Issues JWTs.\n+2. **Sync server** (`@epicenter/server`) — Elysia WebSocket relay. Validates connections. Does NOT know about users, sessions, or OAuth.\n+\n+The sync server's only auth question: **\"should I let this WebSocket connection in?\"** This is answered by one of three modes depending on deployment context.\n+\n+## Design Decisions\n+\n+| Decision                     | Choice                                                                          | Rationale                                                                                                    |\n+| ---------------------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n+| Package dependency direction | `@epicenter/server` depends on `@epicenter/hq` as peer dep                      | Server needs workspace types; keeping them in `@epicenter/hq` avoids a types-only package                    |\n+| Backward compatibility       | Breaking change, no re-export from `@epicenter/hq/server`                       | Clean break. The server export path was pre-1.0 and has few consumers.                                       |\n+| No circular deps             | `@epicenter/hq` must NEVER depend on `@epicenter/server`                        | One-way dependency: `server → hq`. CLI uses dynamic import for `serve` command until CLI is extracted later. |\n+| CLI extraction (future)      | Extract `@epicenter/cli` that depends on both `hq` and `server`                 | Clean leaf package that composes everything. Deferred — not in scope for Phase 1.                            |\n+| Auth model                   | Three modes: open, shared secret, external JWT — NOT Better Auth on the server  | Sync server is a relay, not an auth authority. Auth complexity belongs in a separate service.                |\n+| Auth default                 | Mode 1 (open, no auth) is the default                                           | Self-hosted on a trusted network shouldn't require OAuth setup to sync your own devices.                     |\n+| No encryption in sync server | Encryption is a client-side concern (E2EE), not server-side                     | Server relays opaque Uint8Array blobs. E2EE means server never needs to decrypt. See encryption spec.        |\n+| Cloud path is separate       | Durable Objects adapter is a different codebase, NOT an Elysia plugin           | DO Hibernation API is incompatible with Elysia's WebSocket model. Shared code = protocol + room layers only. |\n+| Room manager extraction      | Transport-agnostic `createRoom()` shared by both Elysia plugin and DO class     | Both deployment targets have identical room logic; only the WebSocket transport differs.                     |\n+| Credential sync              | API keys in encrypted Yjs (client-side E2EE), refresh tokens in device keychain | CRDTs can't safely handle token rotation. See encryption spec for details.                                   |\n+\n+## Architecture\n+\n+### Phase 1: Package Structure (COMPLETE)\n+\n+```\n+packages/server/\n+├── package.json              # @epicenter/server\n+├── tsconfig.json\n+├── src/\n+│   ├── index.ts              # Public exports\n+│   ├── server.ts             # createServer() factory\n+│   ├── actions.ts            # Action → HTTP route mapping\n+│   ├── tables.ts             # RESTful CRUD plugin\n+│   ├── sync/\n+│   │   ├── index.ts          # WebSocket sync plugin (Elysia-coupled)\n+│   │   └── protocol.ts       # Protocol encode/decode (transport-agnostic)\n+│   ├── actions.test.ts       # Moved tests\n+│   └── sync/\n+│       └── protocol.test.ts  # Moved tests\n+```\n+\n+Dependency graph after extraction (no circular deps):\n+\n+```\n+                    ┌──────────────────┐\n+                    │  @epicenter/cli   │  (future extraction)\n+                    │                   │\n+                    │  epicenter serve   │\n+                    │  epicenter posts   │\n+                    └─────┬────────┬────┘\n+                          │        │\n+                 depends  │        │  depends\n+                          ▼        ▼\n+┌──────────────────┐              ┌──────────────────┐\n+│ @epicenter/server │──────────►  │  @epicenter/hq   │\n+│                   │  peer dep   │                   │\n+│ createServer()    │             │ AnyWorkspaceClient│\n+│ createSyncPlugin  │             │ TableHelper       │\n+│ createTablesPlugin│             │ Actions           │\n+│                   │             │ iterateActions    │\n+└──────────────────┘              └──────────────────┘\n+        │\n+        │ direct deps\n+        ▼\n+  elysia, @elysiajs/openapi,\n+  lib0, y-protocols, yjs,\n+  wellcrafted\n+```\n+\n+**Key constraint**: `@epicenter/hq` NEVER depends on `@epicenter/server`. The arrow is one-way.\n+\n+### Phase 2: Three-Mode Auth + Room Extraction\n+\n+#### The Three Auth Modes\n+\n+The sync server answers one question: **\"should I let this WebSocket connection in?\"** Three modes, escalating in complexity:\n+\n+```\n+┌─────────────────────────────────────────────────────────────────────┐\n+│  Mode 1: Open (default)                                              │\n+│  No auth. Anyone who can reach the port can sync.                    │\n+│  Use case: localhost, Tailscale, home network.                       │\n+│                                                                      │\n+│  Mode 2: Shared Secret                                               │\n+│  Static token set at server startup. Clients must present it.        │\n+│  Use case: Self-hosted server exposed to the internet.               │\n+│                                                                      │\n+│  Mode 3: External JWT                                                │\n+│  Short-lived JWTs issued by an external auth service.                │\n+│  Use case: Epicenter Cloud (Durable Objects), or power users         │\n+│  who run their own auth service separately.                          │\n+└─────────────────────────────────────────────────────────────────────┘\n+```\n+\n+#### Mode 1: Open (No Auth)\n+\n+```typescript\n+import { createServer } from '@epicenter/server';\n+\n+const server = createServer(client, { port: 3913 });\n+server.start();\n+```\n+\n+Client:\n+\n+```typescript\n+new WebSocket('ws://localhost:3913/workspaces/blog/sync');\n+// No headers, no tokens, just connect.\n+```\n+\n+Validation: `() => ({ allowed: true })` — everyone's welcome.\n+\n+#### Mode 2: Shared Secret\n+\n+```typescript\n+const server = createServer(client, {\n+\tport: 3913,\n+\tauth: { secret: 'my-long-random-string' },\n+});\n+```\n+\n+Client:\n+\n+```typescript\n+// Token in Sec-WebSocket-Protocol header (works in browsers)\n+new WebSocket(url, ['yjs-sync-v1', 'my-long-random-string']);\n+```\n+\n+Validation: string comparison. `extractToken(req) === auth.secret`. No database, no OAuth, no crypto.\n+\n+The user picks the secret when starting the server and enters it in their Epicenter app settings on each device.\n+\n+#### Mode 3: External JWT\n+\n+```typescript\n+const server = createServer(client, {\n+\tport: 3913,\n+\tauth: { jwtSecret: process.env.SYNC_JWT_SECRET },\n+});\n+```\n+\n+The sync server only has the signing key. It validates JWT signatures without calling any external service.\n+\n+Token flow:\n+\n+```\n+1. Client → Auth Server (separate, e.g. auth.epicenter.so)\n+   POST /api/sync/token\n+   Cookie: better_auth_session=...\n+   Body: { workspaceId: \"blog\", epoch: 0 }\n+\n+2. Auth Server → Client\n+   { token: \"eyJhbG...\", url: \"wss://sync.epicenter.so/...\" }\n+   (JWT: { docId: \"org_acme:blog-0\", scope: \"full\", exp: +5min })\n+\n+3. Client → Sync Server\n+   new WebSocket(url, ['yjs-sync-v1', token])\n+\n+4. Sync Server validates:\n+   - JWT signature matches jwtSecret ✓\n+   - Not expired ✓\n+   - docId claim matches requested workspace ✓\n+   - Connection accepted.\n+```\n+\n+**Key point**: The sync server never talks to the auth server. They share only a `jwtSecret`. The auth server can be Better Auth, or anything else that produces signed JWTs.\n+\n+#### Auth Type Definition\n+\n+All three modes collapse to one type:\n+\n+```typescript\n+type SyncAuth =\n+\t| undefined // Mode 1: open\n+\t| { secret: string } // Mode 2: shared secret\n+\t| { jwtSecret: string }; // Mode 3: external JWT\n+\n+type ServerOptions = {\n+\tport?: number;\n+\tauth?: SyncAuth;\n+\tcors?: CorsOptions;\n+};\n+```\n+\n+Inside the sync plugin, one validator function handles all three:\n+\n+```typescript\n+function createAuthValidator(auth: SyncAuth | undefined) {\n+\tif (!auth) {\n+\t\treturn () => ({ allowed: true as const });\n+\t}\n+\tif ('secret' in auth) {\n+\t\treturn (req: Request) => {\n+\t\t\tconst token = extractToken(req);\n+\t\t\treturn { allowed: token === auth.secret } as const;\n+\t\t};\n+\t}\n+\tif ('jwtSecret' in auth) {\n+\t\treturn (req: Request, workspaceId: string) => {\n+\t\t\tconst token = extractToken(req);\n+\t\t\tconst claims = verifyJwt(token, auth.jwtSecret);\n+\t\t\tif (!claims || claims.exp < Date.now() / 1000)\n+\t\t\t\treturn { allowed: false } as const;\n+\t\t\tif (claims.docId && !claims.docId.endsWith(workspaceId))\n+\t\t\t\treturn { allowed: false } as const;\n+\t\t\treturn { allowed: true as const, userId: claims.sub };\n+\t\t};\n+\t}\n+}\n+```\n+\n+#### Where Each Mode Applies\n+\n+| Deployment                    | Mode            | Sync Server                         | Auth Server             |\n+| ----------------------------- | --------------- | ----------------------------------- | ----------------------- |\n+| `bun dev` locally             | Mode 1 (open)   | localhost:3913                      | none                    |\n+| Mac Mini on home network      | Mode 1 or 2     | 192.168.x.x:3913                    | none                    |\n+| VPS / exposed to internet     | Mode 2 (secret) | vps.example.com:3913                | none                    |\n+| Epicenter Cloud               | Mode 3 (JWT)    | Durable Objects (separate codebase) | auth.epicenter.so       |\n+| Power user self-hosted + auth | Mode 3 (JWT)    | their Elysia server                 | their own auth instance |\n+\n+**Note**: Mode 3 on the Elysia server is supported but uncommon. The primary Mode 3 consumer is the Durable Objects cloud path, which is a separate codebase that shares the same JWT validation logic and room manager. See `20260213T120800-cloud-sync-durable-objects.md`.\n+\n+#### Room Manager Extraction\n+\n+The current `sync/index.ts` has room management logic (connection tracking, awareness lifecycle, broadcast) interleaved with Elysia WebSocket bindings. Phase 2 extracts this into a transport-agnostic `createRoom()` that both the Elysia plugin and the Durable Objects adapter can use.\n+\n+```\n+packages/server/src/sync/\n+  ├── protocol.ts         ← EXISTING: Pure encode/decode (unchanged)\n+  ├── room.ts             ← NEW: Transport-agnostic room manager\n+  ├── elysia-plugin.ts    ← REFACTORED from index.ts: thin Elysia WS adapter\n+  ├── auth.ts             ← NEW: Auth validator factory (three modes)\n+  └── index.ts            ← Re-exports\n+```\n+\n+The room manager:\n+\n+```typescript\n+// sync/room.ts — Transport-agnostic room management\n+\n+type Connection = {\n+\tsend(data: Uint8Array): void;\n+\tid: string;\n+};\n+\n+type RoomConfig = {\n+\tdoc: Y.Doc;\n+};\n+\n+function createRoom(config: RoomConfig) {\n+\tconst { doc } = config;\n+\tconst connections = new Map<string, Connection>();\n+\tconst awareness = new Awareness(doc);\n+\tconst controlledClients = new Map<string, Set<number>>();\n+\n+\tdoc.on('update', (update: Uint8Array, origin: unknown) => {\n+\t\tconst message = encodeSyncUpdate({ update });\n+\t\tfor (const [id, conn] of connections) {\n+\t\t\tif (id !== origin) conn.send(message);\n+\t\t}\n+\t});\n+\n+\treturn {\n+\t\tget connectionCount() {\n+\t\t\treturn connections.size;\n+\t\t},\n+\t\tget awareness() {\n+\t\t\treturn awareness;\n+\t\t},\n+\n+\t\taddConnection(conn: Connection) {\n+\t\t\t/* ... */\n+\t\t},\n+\t\thandleMessage(connId: string, data: Uint8Array) {\n+\t\t\t/* ... */\n+\t\t},\n+\t\tremoveConnection(connId: string) {\n+\t\t\t/* ... */\n+\t\t},\n+\t\tdestroy() {\n+\t\t\t/* ... */\n+\t\t},\n+\t};\n+}\n+```\n+\n+The Elysia plugin becomes a thin adapter:\n+\n+```typescript\n+// sync/elysia-plugin.ts — Maps Elysia WS events → Room methods\n+function createSyncPlugin(config: { getDoc; auth? }) {\n+\tconst rooms = new Map<string, Room>();\n+\tconst validator = createAuthValidator(config.auth);\n+\n+\treturn new Elysia().ws('/workspaces/:workspaceId/sync', {\n+\t\topen(ws) {\n+\t\t\tif (!validator(ws.raw.request, ws.data.params.workspaceId).allowed) {\n+\t\t\t\tws.close(4001, 'Unauthorized');\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tconst room = getOrCreateRoom(rooms, workspaceId, config.getDoc);\n+\t\t\troom.addConnection({ id: connId, send: (d) => ws.send(Buffer.from(d)) });\n+\t\t},\n+\t\tmessage(ws, data) {\n+\t\t\troom.handleMessage(connId, data);\n+\t\t},\n+\t\tclose(ws) {\n+\t\t\troom.removeConnection(connId);\n+\t\t\tif (room.connectionCount === 0) rooms.delete(workspaceId);\n+\t\t},\n+\t});\n+}\n+```\n+\n+#### Client-Side Ergonomics\n+\n+```typescript\n+// Mode 1: local, no auth\n+createWebsocketSyncProvider({\n+\turl: 'ws://localhost:3913/workspaces/{id}/sync',\n+});\n+\n+// Mode 2: self-hosted with shared secret\n+createWebsocketSyncProvider({\n+\turl: 'ws://my-server:3913/workspaces/{id}/sync',\n+\ttoken: 'my-shared-secret',\n+});\n+\n+// Mode 3: Epicenter Cloud (or any external auth)\n+createWebsocketSyncProvider({\n+\turl: 'wss://sync.epicenter.so/workspaces/{id}/sync',\n+\tgetToken: async (workspaceId) => {\n+\t\tconst res = await fetch('https://auth.epicenter.so/api/sync/token', {\n+\t\t\tmethod: 'POST',\n+\t\t\tcredentials: 'include',\n+\t\t\tbody: JSON.stringify({ workspaceId }),\n+\t\t});\n+\t\treturn (await res.json()).token;\n+\t},\n+});\n+```\n+\n+Mode 2 uses a static `token` string. Mode 3 uses a `getToken` function that fetches a fresh short-lived JWT on each connect/reconnect.\n+\n+#### Network Topology\n+\n+The primary model is **single server** — one sync server that all your devices connect to.\n+\n+```\n+PRIMARY: Single Self-Hosted Server\n+────────────────────────────────────\n+\n+  Phone ──────► Mac Mini ◄────── Laptop\n+    WS            :3913            WS\n+                   │\n+              ┌────┴────┐\n+              │ *.yjs    │\n+              └──────────┘\n+\n+  All devices connect to one server.\n+  Server handles sync and persistence. No auth database.\n+```\n+\n+**Hot-swapping** between self-hosted and cloud is a client-side concern — the client changes which URL it connects to. No server-to-server communication needed because clients bridge data via CRDTs.\n+\n+```typescript\n+// Connect to both simultaneously — client bridges via CRDTs\n+.withExtension('syncLocal', createWebsocketSyncProvider({\n+  url: 'ws://mac-mini.local:3913/workspaces/{id}/sync',\n+}))\n+.withExtension('syncCloud', createWebsocketSyncProvider({\n+  url: 'wss://sync.epicenter.so/workspaces/{id}/sync',\n+  getToken: async (wsId) => { /* ... */ },\n+}))\n+```\n+\n+### What This Spec Does NOT Cover\n+\n+These are handled by companion specs:\n+\n+| Concern                    | Spec                                                 | Summary                                                                                                                 |\n+| -------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |\n+| Client-side E2EE           | `20260213T120813-encryption-at-rest-architecture.md` | AES-256-GCM encryption of Yjs updates before they leave the client. Key hierarchy (KEK → DK). Server is zero-knowledge. |\n+| Cloudflare Durable Objects | `20260213T120800-cloud-sync-durable-objects.md`      | Separate codebase. DO class wraps `createRoom()`. CF Worker validates JWTs. Hibernation API for cost efficiency.        |\n+| Credential storage         | `20260213T120813-encryption-at-rest-architecture.md` | API keys in E2EE Yjs, refresh tokens in device keychain, OAuth per-device.                                              |\n+\n+## Implementation Plan\n+\n+### Phase 1: Package Extraction (COMPLETE)\n+\n+- [x] **1.1** Create `packages/server/` directory with `package.json`, `tsconfig.json`\n+  - Name: `@epicenter/server`\n+  - Peer dep: `@epicenter/hq` (for types)\n+  - Direct deps: `elysia`, `@elysiajs/openapi`, `lib0`, `y-protocols`, `yjs`, `wellcrafted`\n+- [x] **1.2** Copy server source files from `packages/epicenter/src/server/` to `packages/server/src/`\n+  - `server.ts`, `actions.ts`, `tables.ts`, `index.ts`\n+  - `sync/index.ts`, `sync/protocol.ts`\n+  - `actions.test.ts`, `sync/protocol.test.ts`\n+- [x] **1.3** Update imports in copied files\n+  - `../static/types` → `@epicenter/hq/static` (for `AnyWorkspaceClient`, `TableHelper`)\n+  - `../shared/actions` → `@epicenter/hq` (for `Actions`, `iterateActions`, `isAction`)\n+  - Verify all imports resolve correctly\n+- [x] **1.4** Update `packages/epicenter/src/cli/cli.ts` to use dynamic import\n+  - Changed static import to `const { createServer } = await import('@epicenter/server')` with try/catch\n+  - `@epicenter/server` is NOT a dependency of `@epicenter/hq` — no circular deps\n+  - If `@epicenter/server` is not installed, the `serve` command prints a helpful error and exits\n+- [x] **1.5** Remove `./server` export from `packages/epicenter/package.json`\n+  - Deleted the `\"./server\": \"./src/server/index.ts\"` entry\n+  - Also removed `@elysiajs/openapi` from `@epicenter/hq` dependencies (now owned by `@epicenter/server`)\n+- [x] **1.6** Delete `packages/epicenter/src/server/` directory entirely\n+- [x] **1.7** Verify the server README at `packages/epicenter/src/server/README.md` is moved to `packages/server/README.md`\n+- [x] **1.8** Run existing tests in new location: `bun test` from `packages/server/` — 50 pass, 0 fail\n+- [x] **1.9** Run `bun typecheck` on both `@epicenter/server` and `@epicenter/hq` — all errors are pre-existing upstream, none related to extraction\n+- [x] **1.10** No documentation references to `@epicenter/hq/server` found outside the spec itself\n+\n+### Phase 2: Room Extraction + Three-Mode Auth (Design Only — Implementation Deferred)\n+\n+- [ ] **2.1** Extract `createRoom()` into `sync/room.ts`\n+  - Move connection tracking, awareness lifecycle, broadcast logic out of `sync/index.ts`\n+  - Define `Connection` interface: `{ send(data: Uint8Array): void; id: string }`\n+  - Room is transport-agnostic — no Elysia, no Buffer, no WebSocket types\n+  - Export from package for reuse by Durable Objects adapter (separate codebase)\n+- [ ] **2.2** Create `sync/auth.ts` with `createAuthValidator()`\n+  - Implement all three modes: open, shared secret, JWT\n+  - Token extraction: parse `Sec-WebSocket-Protocol` header (primary) and `?token=` query param (fallback)\n+  - JWT validation: `jose` library (works on Bun and CF Workers) — verify signature, check `exp`, check `docId` claim\n+  - Return `{ allowed: boolean; userId?: string }`\n+- [ ] **2.3** Refactor `sync/index.ts` → `sync/elysia-plugin.ts`\n+  - Thin adapter: maps Elysia WS events to `room.addConnection`, `room.handleMessage`, `room.removeConnection`\n+  - Calls auth validator on WebSocket upgrade — reject with 4001 if not allowed\n+  - Manages multiple rooms (one per workspace), evicts empty rooms\n+- [ ] **2.4** Update `createServer()` to accept `auth` option\n+  - `auth?: { secret: string } | { jwtSecret: string }` — undefined means open (Mode 1)\n+  - Pass auth config through to `createSyncPlugin`\n+  - Also gate REST table endpoints (not just WebSocket)\n+- [ ] **2.5** Verify existing tests pass with no behavioral changes\n+  - Default (no auth) should behave identically to current code\n+  - Add tests for Mode 2 (secret) and Mode 3 (JWT) rejection/acceptance\n+- [ ] **2.6** Add CORS configuration\n+  - Default: allow localhost origins\n+  - Configurable: trusted origins list\n+  - Auto-detect Tauri app origins\n+- [ ] **2.7** Update exports in `sync/index.ts` barrel\n+  - Export `createRoom`, `createAuthValidator`, `createSyncPlugin`\n+  - Export `Connection` type for Durable Objects adapter\n+\n+## Edge Cases\n+\n+### Phase 1: CLI `serve` Command Without Circular Dependency\n+\n+1. `@epicenter/hq` currently exports the server AND defines the types the server uses\n+2. After extraction, `@epicenter/server` depends on `@epicenter/hq` for types\n+3. The CLI's `serve` command (in `@epicenter/hq`) needs `createServer` from `@epicenter/server`\n+4. **`@epicenter/hq` must NEVER depend on `@epicenter/server`** — no circular deps\n+\n+**Resolution**: The CLI uses a dynamic import: `const { createServer } = await import('@epicenter/server')`. This makes `@epicenter/server` an optional peer dep. If not installed, the `serve` command prints \"Install @epicenter/server to use this command.\" Later, the entire CLI will be extracted to `@epicenter/cli` which depends on both packages normally.\n+\n+### Phase 2: Mode 2 Secret in URL Logs\n+\n+If using `?token=secret` query param fallback, the secret appears in server access logs and potentially browser history.\n+\n+**Resolution**: `Sec-WebSocket-Protocol` header is the primary transport — it's not logged by default. Query param is documented as a fallback for environments where protocol headers can't be set. Documentation should warn about log exposure.\n+\n+### Phase 2: Mode 3 JWT Expiry During Active Sync\n+\n+1. Client connects with a 5-minute JWT\n+2. Client syncs happily for 30 minutes\n+3. JWT has been expired for 25 minutes\n+\n+**Resolution**: Validate JWT only at connection time. Once connected, the client is trusted for the duration of that WebSocket session. If the auth service revokes access, the client will fail to get a new token on next reconnect. Periodic revalidation adds complexity for marginal security gain — defer unless a security audit requires it.\n+\n+### Phase 2: Shared Secret Rotation\n+\n+1. User changes the shared secret on the server\n+2. Connected clients still have the old secret\n+3. Clients reconnect after a network blip → rejected\n+\n+**Resolution**: Server restart is required to change the secret (it's a config value). Connected WebSockets survive until the next disconnect. Clients need to update their configured token. This is acceptable for Mode 2's use case (single user, few devices).\n+\n+## Resolved Decisions\n+\n+| Question                   | Decision                                                                   | Rationale                                                                         |\n+| -------------------------- | -------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |\n+| Auth default               | No auth (Mode 1) is the default                                            | Self-hosted on trusted network shouldn't require OAuth setup.                     |\n+| Better Auth on sync server | No. Auth lives in a separate service.                                      | Sync server is a relay, not an identity provider.                                 |\n+| Server-side encryption     | No. Encryption is client-side (E2EE).                                      | Server relays opaque blobs. See encryption spec.                                  |\n+| Elysia on Durable Objects  | Not possible. DO Hibernation API is class-based, incompatible with Elysia. | Cloud path is a separate codebase sharing only protocol + room layers.            |\n+| Token transport            | `Sec-WebSocket-Protocol` header (primary), query param (fallback)          | Browser WS API can't set custom headers. Protocol header is clean and not logged. |\n+| JWT library                | `jose` (works on Bun, Node, and CF Workers)                                | Cross-runtime compatibility for shared auth validation code.                      |\n+| Server-to-server sync      | Deferred entirely                                                          | Clients bridge servers via CRDTs. Single-server covers 90%+ of use cases.         |\n+\n+## Remaining Open Questions\n+\n+1. **Should Mode 3 JWT validation also be exported as a standalone function?** The Durable Objects adapter (separate codebase) needs the same JWT validation. Exporting `validateSyncToken(token, jwtSecret)` from `@epicenter/server` means the DO codebase depends on this package — which adds `elysia` as a transitive dep. Alternative: extract JWT validation into a tiny shared package like `@epicenter/sync-auth`.\n+\n+2. **REST endpoint auth**: Should table REST endpoints (`/workspaces/{id}/tables/...`) also be gated by the same auth modes? Currently they're public. Mode 2 (secret) and Mode 3 (JWT) should probably gate them too, but the token transport differs (HTTP headers vs WebSocket protocol headers).\n+\n+3. **Room eviction for idle workspaces**: When the self-hosted server has many workspaces, should idle rooms be evicted from memory (unload Y.Doc, reload from persistence on next connection)? Deferred to a future phase, but the `createRoom()` interface should support a `destroy()` method to enable this later.\n+\n+## Success Criteria\n+\n+### Phase 1 (COMPLETE)\n+\n+- [x] `@epicenter/server` package exists at `packages/server/`\n+- [x] `bun test` passes in `packages/server/` (50 pass, 0 fail)\n+- [x] `bun typecheck` passes in both packages (all errors pre-existing, none from extraction)\n+- [x] `epicenter serve` CLI command uses dynamic import from `@epicenter/server`\n+- [x] `@epicenter/hq` no longer contains server code in `src/server/`\n+- [x] No `./server` export in `@epicenter/hq/package.json`\n+- [x] `@epicenter/hq` has NO dependency (direct or peer) on `@epicenter/server` in package.json\n+- [x] Dependency direction is strictly one-way: `@epicenter/server` → `@epicenter/hq`\n+\n+### Phase 2\n+\n+- [ ] `createRoom()` extracted to `sync/room.ts`, transport-agnostic\n+- [ ] `createAuthValidator()` in `sync/auth.ts` handles all three modes\n+- [ ] `createSyncPlugin()` refactored to use room + validator\n+- [ ] Default (no auth) behaves identically to current code — zero regressions\n+- [ ] Mode 2: connect with correct secret → accepted; wrong secret → 4001\n+- [ ] Mode 3: connect with valid JWT → accepted; expired/invalid/wrong-docId JWT → 4001\n+- [ ] `createRoom`, `Connection` type exported for Durable Objects adapter consumption\n+- [ ] Existing tests pass; new tests cover auth modes\n+\n+## References\n+\n+- `packages/server/src/server.ts` — `createServer()` factory (176 lines)\n+- `packages/server/src/actions.ts` — Action router (79 lines)\n+- `packages/server/src/tables.ts` — Tables CRUD plugin (78 lines)\n+- `packages/server/src/sync/index.ts` — WebSocket sync plugin (294 lines) — refactor target\n+- `packages/server/src/sync/protocol.ts` — Protocol encode/decode (276 lines) — unchanged\n+- `specs/20260213T120800-cloud-sync-durable-objects.md` — Durable Objects cloud path (separate codebase)\n+- `specs/20260213T120813-encryption-at-rest-architecture.md` — Client-side E2EE architecture\n+- [jose](https://github.com/panva/jose) — JWT library (works on Bun, Node, CF Workers)\n+- [Secsync](https://github.com/nikgraf/secsync) — E2EE CRDT architecture reference\n+- [Elysia CF Worker adapter](https://elysiajs.com/integrations/cloudflare-worker) — Experimental, HTTP only, not for DOs\n+\n+## Review: Phase 1 Extraction (2026-02-13)\n+\n+### Summary\n+\n+Phase 1 was a pure extraction — ~95% move/rename, ~5% glue code. No business logic was changed.\n+\n+### What Changed\n+\n+**New package: `packages/server/`**\n+\n+- `package.json` — `@epicenter/server`, peer dep on `@epicenter/hq`, direct deps on `elysia`, `@elysiajs/openapi`, `lib0`, `y-protocols`, `yjs`, `wellcrafted`\n+- `tsconfig.json` — mirrors `@epicenter/hq` compiler options\n+- `src/index.ts` — 1-line re-export of `createServer`, `DEFAULT_PORT`, `ServerOptions`\n+- `src/server.ts` — moved from `packages/epicenter/src/server/server.ts`, import paths updated\n+- `src/actions.ts` — moved, import paths updated (`../shared/actions` → `@epicenter/hq`)\n+- `src/tables.ts` — moved, import paths updated (`../static/types` → `@epicenter/hq/static`)\n+- `src/sync/index.ts` — moved verbatim (no import changes needed, all deps are external)\n+- `src/sync/protocol.ts` — moved verbatim\n+- `src/actions.test.ts` — moved, import paths updated\n+- `src/sync/protocol.test.ts` — moved verbatim\n+- `README.md` — moved verbatim\n+\n+**Modified in `@epicenter/hq`:**\n+\n+- `src/static/index.ts` — added `AnyWorkspaceClient` to type exports (was missing, needed by server package)\n+- `src/cli/cli.ts` — replaced static `import { createServer }` with dynamic `await import('@epicenter/server')` + try/catch error handling\n+- `package.json` — removed `\"./server\"` export, removed `@elysiajs/openapi` dependency\n+\n+**Deleted from `@epicenter/hq`:**\n+\n+- `src/server/` — entire directory\n+\n+### Verification Results\n+\n+| Check                                | Result                                          |\n+| ------------------------------------ | ----------------------------------------------- |\n+| `bun install`                        | 1257 packages, no errors                        |\n+| `bun test` (packages/server)         | 50 pass, 0 fail                                 |\n+| `bun test` (packages/epicenter)      | 560 pass, 0 fail, 0 regressions                 |\n+| `bun typecheck` (packages/server)    | 7 errors — all pre-existing upstream            |\n+| `bun typecheck` (packages/epicenter) | 28 errors — all pre-existing, 0 from extraction |\n+\n+### Notes for Phase 2\n+\n+- The `DEFAULT_PORT` constant (3913) is now hardcoded in the CLI fallback since it can't import from `@epicenter/server` at module level. When Phase 2 adds auth config, the CLI will need `@epicenter/server` installed anyway, so this becomes moot.\n+- `AnyWorkspaceClient` was not previously exported from `@epicenter/hq/static`. It is now. This is the only new public API surface from Phase 1.\n+- The `@elysiajs/openapi` dependency moved from `@epicenter/hq` to `@epicenter/server`. If anything else in `@epicenter/hq` used it, it would break — but nothing does.\n"
test_patch: ''
fail_to_pass:
- cd /tmp/.tmpOebznq/packages/server && /root/.bun/bin/bun test
pass_to_pass:
- cd /tmp/.tmpOebznq/packages/filesystem && /root/.bun/bin/bun test
- cd /tmp/.tmpOebznq/packages/epicenter && /root/.bun/bin/bun test src/server/actions.test.ts
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '1197'
  difficulty: hard
  files_changed: '19'
  pr_title: 'refactor: extract @epicenter/server into standalone package'
  removed_lines: '14'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  EpicenterHQ/epicenter (#1348): refactor: extract @epicenter/server into standalone package

  Extract the sync server into its own installable package so users can self-host without installing the full workspace system. Ensure the server can be used independently from the core library and that the CLI’s serve command continues to work without introducing circular dependencies. Expose any required public types so external consumers can use the server. Update documentation accordingly.
original_pr_body: |-
  EpicenterHQ/epicenter (#1348): refactor: extract @epicenter/server into standalone package

  Extracts the server code from `@epicenter/hq` into a standalone `@epicenter/server` package at `packages/server/`. The server was coupled to the core library — anyone who wanted to self-host a sync server had to install the entire workspace system. Now it's independently installable.

  The CLI's `serve` command uses a dynamic import to avoid a circular dependency. `AnyWorkspaceClient` was added to `@epicenter/hq/static` exports since it was needed by the server but wasn't previously exported. All 50 server tests and 560 epicenter tests pass with zero regressions.

  Also includes three docs articles and draft encryption specs for future work. Phase 2 (room manager extraction + three-mode auth) is deferred to a follow-up.
quality_score: 0.78
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
