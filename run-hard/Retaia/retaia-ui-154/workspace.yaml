id: Retaia/retaia-ui-154
repo: Retaia/retaia-ui
base_commit: 2885317d969897b767780c21ba319b9ad57f0e92
merge_commit: d7409f58e0f866ea24b97e2b68e18a1be5540c93
language: typescript
difficulty_score: 3
created_at: 2026-02-14T14:46:39.224008915Z
patch: "diff --git a/src/App.test.tsx b/src/App.test.tsx\nindex 9599ced..fd38d27 100644\n--- a/src/App.test.tsx\n+++ b/src/App.test.tsx\n@@ -1,10 +1,14 @@\n import { screen, waitFor, within } from '@testing-library/react'\n import userEvent from '@testing-library/user-event'\n-import { describe, expect, it, vi } from 'vitest'\n+import { beforeEach, describe, expect, it, vi } from 'vitest'\n \n import { getAssetsPanel, getDetailPanel, setupApp } from './test-utils/appTestUtils'\n \n describe('App', () => {\n+  beforeEach(() => {\n+    window.localStorage.clear()\n+  })\n+\n   it('renders a simple user review UI with assets', () => {\n     setupApp()\n \n@@ -246,7 +250,7 @@ describe('App', () => {\n     }\n   })\n \n-  it('shows API connection panel in API source mode and saves settings locally', async () => {\n+  it('shows API connection panel in API source mode and saves base URL locally', async () => {\n     const previous = import.meta.env.VITE_ASSET_SOURCE\n     try {\n       import.meta.env.VITE_ASSET_SOURCE = 'api'\n@@ -267,12 +271,9 @@ describe('App', () => {\n       expect(await screen.findByLabelText('Connexion API')).toBeInTheDocument()\n       await user.clear(screen.getByTestId('api-base-url-input'))\n       await user.type(screen.getByTestId('api-base-url-input'), 'https://api.local/v1')\n-      await user.clear(screen.getByTestId('api-token-input'))\n-      await user.type(screen.getByTestId('api-token-input'), 'token-123')\n       await user.click(screen.getByTestId('api-connection-save'))\n \n       expect(window.localStorage.getItem('retaia_api_base_url')).toBe('https://api.local/v1')\n-      expect(window.localStorage.getItem('retaia_api_token')).toBe('token-123')\n       expect(screen.getByTestId('api-connection-status')).toHaveTextContent(\n         'Configuration API enregistrée.',\n       )\n@@ -282,12 +283,43 @@ describe('App', () => {\n     }\n   })\n \n-  it('tests API connection with saved base url and token', async () => {\n+  it('authenticates then tests API connection with bearer token', async () => {\n     const previous = import.meta.env.VITE_ASSET_SOURCE\n     try {\n       import.meta.env.VITE_ASSET_SOURCE = 'api'\n-      const fetchMock = vi.fn(() =>\n-        Promise.resolve(\n+      const fetchMock = vi.fn((input: RequestInfo | URL) => {\n+        const url = String(input)\n+        if (url.endsWith('/auth/login')) {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                access_token: 'token-xyz',\n+                token_type: 'Bearer',\n+                client_kind: 'UI_RUST',\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        if (url.endsWith('/auth/me')) {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                email: 'user@example.com',\n+                display_name: 'Test User',\n+                mfa_enabled: false,\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        return Promise.resolve(\n           new Response(\n             JSON.stringify({\n               items: [],\n@@ -298,21 +330,24 @@ describe('App', () => {\n               headers: { 'content-type': 'application/json' },\n             },\n           ),\n-        ))\n+        )\n+      })\n       vi.spyOn(globalThis, 'fetch').mockImplementation(fetchMock)\n       const { user } = setupApp('/review?source=api')\n \n       expect(await screen.findByLabelText('Connexion API')).toBeInTheDocument()\n       await user.clear(screen.getByTestId('api-base-url-input'))\n       await user.type(screen.getByTestId('api-base-url-input'), 'https://api.local/v1')\n-      await user.clear(screen.getByTestId('api-token-input'))\n-      await user.type(screen.getByTestId('api-token-input'), 'token-xyz')\n-      await user.click(screen.getByTestId('api-connection-save'))\n+      await user.clear(screen.getByTestId('auth-email-input'))\n+      await user.type(screen.getByTestId('auth-email-input'), 'user@example.com')\n+      await user.clear(screen.getByTestId('auth-password-input'))\n+      await user.type(screen.getByTestId('auth-password-input'), 'secret')\n+      await user.click(screen.getByTestId('auth-login'))\n       await user.click(screen.getByTestId('api-connection-test'))\n \n       await waitFor(() => {\n         expect(fetchMock).toHaveBeenCalledWith(\n-          'https://api.local/v1/assets?limit=1',\n+          'https://api.local/v1/auth/me',\n           expect.objectContaining({\n             headers: expect.objectContaining({\n               Authorization: 'Bearer token-xyz',\n@@ -327,6 +362,235 @@ describe('App', () => {\n     }\n   })\n \n+  it('handles MFA_REQUIRED during login and retries with OTP', async () => {\n+    const previous = import.meta.env.VITE_ASSET_SOURCE\n+    try {\n+      import.meta.env.VITE_ASSET_SOURCE = 'api'\n+      const fetchMock = vi.fn((input: RequestInfo | URL, init?: RequestInit) => {\n+        const url = String(input)\n+        if (url.endsWith('/auth/login')) {\n+          const body = JSON.parse(String(init?.body ?? '{}')) as { otp_code?: string }\n+          if (!body.otp_code) {\n+            return Promise.resolve(\n+              new Response(\n+                JSON.stringify({\n+                  code: 'MFA_REQUIRED',\n+                  message: 'mfa required',\n+                  retryable: false,\n+                  correlation_id: 'mfa-1',\n+                }),\n+                {\n+                  status: 401,\n+                  headers: { 'content-type': 'application/json' },\n+                },\n+              ),\n+            )\n+          }\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                access_token: 'token-mfa-1',\n+                token_type: 'Bearer',\n+                client_kind: 'UI_RUST',\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        if (url.endsWith('/auth/me')) {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                email: 'user@example.com',\n+                display_name: 'MFA User',\n+                mfa_enabled: true,\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        if (url.endsWith('/auth/me/features')) {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                user_feature_enabled: { 'features.auth.2fa': true },\n+                effective_feature_enabled: { 'features.auth.2fa': true },\n+                feature_governance: [\n+                  {\n+                    key: 'features.auth.2fa',\n+                    tier: 'OPTIONAL',\n+                    user_can_disable: true,\n+                    dependencies: [],\n+                    disable_escalation: [],\n+                  },\n+                ],\n+                core_v1_global_features: ['features.core.auth'],\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        return Promise.resolve(\n+          new Response(\n+            JSON.stringify({\n+              items: [],\n+              next_cursor: null,\n+            }),\n+            {\n+              status: 200,\n+              headers: { 'content-type': 'application/json' },\n+            },\n+          ),\n+        )\n+      })\n+      vi.spyOn(globalThis, 'fetch').mockImplementation(fetchMock)\n+      const { user } = setupApp('/review?source=api')\n+\n+      await user.type(screen.getByTestId('auth-email-input'), 'user@example.com')\n+      await user.type(screen.getByTestId('auth-password-input'), 'secret')\n+      await user.click(screen.getByTestId('auth-login'))\n+      expect(await screen.findByTestId('auth-status')).toHaveTextContent('La 2FA est requise')\n+\n+      await user.type(screen.getByTestId('auth-otp-input'), '123456')\n+      await user.click(screen.getByTestId('auth-login'))\n+\n+      await waitFor(() => {\n+        expect(screen.getByTestId('auth-status')).toHaveTextContent('Authentification réussie.')\n+      })\n+      expect(window.localStorage.getItem('retaia_api_token')).toBe('token-mfa-1')\n+      expect(screen.getByTestId('auth-user-status')).toHaveTextContent(\n+        'Connecté en tant que MFA User',\n+      )\n+    } finally {\n+      import.meta.env.VITE_ASSET_SOURCE = previous\n+      vi.restoreAllMocks()\n+    }\n+  })\n+\n+  it('shows 2FA controls only when feature is enabled globally and for user', async () => {\n+    const previous = import.meta.env.VITE_ASSET_SOURCE\n+    try {\n+      import.meta.env.VITE_ASSET_SOURCE = 'api'\n+      const fetchMock = vi.fn((input: RequestInfo | URL, init?: RequestInit) => {\n+        const url = String(input)\n+        if (url.endsWith('/auth/login')) {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                access_token: 'token-feature-1',\n+                token_type: 'Bearer',\n+                client_kind: 'UI_RUST',\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        if (url.endsWith('/auth/me')) {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                email: 'user@example.com',\n+                display_name: 'Feature User',\n+                mfa_enabled: false,\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        if (url.endsWith('/auth/me/features') && (init?.method ?? 'GET') === 'GET') {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                user_feature_enabled: { 'features.auth.2fa': true },\n+                effective_feature_enabled: { 'features.auth.2fa': true },\n+                feature_governance: [\n+                  {\n+                    key: 'features.auth.2fa',\n+                    tier: 'OPTIONAL',\n+                    user_can_disable: true,\n+                    dependencies: [],\n+                    disable_escalation: [],\n+                  },\n+                ],\n+                core_v1_global_features: ['features.core.auth'],\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        if (url.endsWith('/auth/me/features') && init?.method === 'PATCH') {\n+          return Promise.resolve(\n+            new Response(\n+              JSON.stringify({\n+                user_feature_enabled: { 'features.auth.2fa': false },\n+                effective_feature_enabled: { 'features.auth.2fa': false },\n+                feature_governance: [\n+                  {\n+                    key: 'features.auth.2fa',\n+                    tier: 'OPTIONAL',\n+                    user_can_disable: true,\n+                    dependencies: [],\n+                    disable_escalation: [],\n+                  },\n+                ],\n+                core_v1_global_features: ['features.core.auth'],\n+              }),\n+              {\n+                status: 200,\n+                headers: { 'content-type': 'application/json' },\n+              },\n+            ),\n+          )\n+        }\n+        return Promise.resolve(\n+          new Response(\n+            JSON.stringify({\n+              items: [],\n+              next_cursor: null,\n+            }),\n+            {\n+              status: 200,\n+              headers: { 'content-type': 'application/json' },\n+            },\n+          ),\n+        )\n+      })\n+      vi.spyOn(globalThis, 'fetch').mockImplementation(fetchMock)\n+      const { user } = setupApp('/review?source=api')\n+\n+      await user.type(screen.getByTestId('auth-email-input'), 'user@example.com')\n+      await user.type(screen.getByTestId('auth-password-input'), 'secret')\n+      await user.click(screen.getByTestId('auth-login'))\n+\n+      expect(await screen.findByLabelText('Authentification à deux facteurs')).toBeInTheDocument()\n+      expect(screen.getByTestId('auth-mfa-state')).toHaveTextContent('Statut 2FA: désactivée')\n+\n+      await user.click(screen.getByTestId('auth-mfa-user-toggle'))\n+      expect(await screen.findByTestId('auth-mfa-feature-disabled')).toBeInTheDocument()\n+    } finally {\n+      import.meta.env.VITE_ASSET_SOURCE = previous\n+      vi.restoreAllMocks()\n+    }\n+  })\n+\n   it('renders API asset list when source mode succeeds', async () => {\n     const previous = import.meta.env.VITE_ASSET_SOURCE\n     try {\ndiff --git a/src/App.tsx b/src/App.tsx\nindex dabacc8..b3281f4 100644\n--- a/src/App.tsx\n+++ b/src/App.tsx\n@@ -49,6 +49,7 @@ const SELECTED_ASSET_QUERY_KEY = 'asset'\n const REVIEW_BASE_PATH = '/review'\n const API_TOKEN_STORAGE_KEY = 'retaia_api_token'\n const API_BASE_URL_STORAGE_KEY = 'retaia_api_base_url'\n+const API_LOGIN_EMAIL_STORAGE_KEY = 'retaia_auth_email'\n \n function isStateConflictError(error: unknown) {\n   return error instanceof ApiError && error.payload?.code === 'STATE_CONFLICT'\n@@ -95,6 +96,47 @@ function App() {\n       return ''\n     }\n   })\n+  const [authEmailInput, setAuthEmailInput] = useState(() => {\n+    if (typeof window === 'undefined') {\n+      return ''\n+    }\n+    try {\n+      return window.localStorage.getItem(API_LOGIN_EMAIL_STORAGE_KEY) ?? ''\n+    } catch {\n+      return ''\n+    }\n+  })\n+  const [authPasswordInput, setAuthPasswordInput] = useState('')\n+  const [authOtpInput, setAuthOtpInput] = useState('')\n+  const [authStatus, setAuthStatus] = useState<{\n+    kind: 'success' | 'error'\n+    message: string\n+  } | null>(null)\n+  const [authLoading, setAuthLoading] = useState(false)\n+  const [authRequiresOtp, setAuthRequiresOtp] = useState(false)\n+  const [authUser, setAuthUser] = useState<{\n+    email: string\n+    displayName: string | null\n+    mfaEnabled: boolean\n+  } | null>(null)\n+  const [userFeatureState, setUserFeatureState] = useState<{\n+    userFeatureEnabled: Record<string, boolean>\n+    effectiveFeatureEnabled: Record<string, boolean>\n+    featureGovernance: Array<{\n+      key: string\n+      user_can_disable: boolean\n+    }>\n+  } | null>(null)\n+  const [authMfaStatus, setAuthMfaStatus] = useState<{\n+    kind: 'success' | 'error'\n+    message: string\n+  } | null>(null)\n+  const [authMfaBusy, setAuthMfaBusy] = useState(false)\n+  const [authMfaSetup, setAuthMfaSetup] = useState<{\n+    secret: string\n+    otpauthUri: string\n+  } | null>(null)\n+  const [authMfaOtpAction, setAuthMfaOtpAction] = useState('')\n   const [apiBaseUrlInput, setApiBaseUrlInput] = useState(() => {\n     if (typeof window === 'undefined') {\n       return ''\n@@ -112,7 +154,9 @@ function App() {\n   const effectiveApiBaseUrl =\n     import.meta.env.VITE_API_BASE_URL ?? (apiBaseUrlInput.trim() || '/api/v1')\n   const effectiveApiToken = import.meta.env.VITE_API_TOKEN ?? (apiTokenInput.trim() || null)\n-  const isApiConfigLockedByEnv = !!(import.meta.env.VITE_API_BASE_URL || import.meta.env.VITE_API_TOKEN)\n+  const isApiBaseUrlLockedByEnv = !!import.meta.env.VITE_API_BASE_URL\n+  const isApiAuthLockedByEnv = !!import.meta.env.VITE_API_TOKEN\n+  const isApiConfigLockedByEnv = isApiBaseUrlLockedByEnv || isApiAuthLockedByEnv\n   const apiClient = useMemo(\n     () =>\n       createApiClient({\n@@ -416,7 +460,6 @@ function App() {\n     }\n     try {\n       window.localStorage.setItem(API_BASE_URL_STORAGE_KEY, apiBaseUrlInput.trim())\n-      window.localStorage.setItem(API_TOKEN_STORAGE_KEY, apiTokenInput.trim())\n       setApiConnectionStatus({\n         kind: 'success',\n         message: t('app.apiConnectionSaved'),\n@@ -427,7 +470,7 @@ function App() {\n         message: t('app.apiConnectionSaveError'),\n       })\n     }\n-  }, [apiBaseUrlInput, apiTokenInput, t])\n+  }, [apiBaseUrlInput, t])\n \n   const clearApiConnectionSettings = useCallback(() => {\n     if (typeof window === 'undefined') {\n@@ -435,9 +478,7 @@ function App() {\n     }\n     try {\n       window.localStorage.removeItem(API_BASE_URL_STORAGE_KEY)\n-      window.localStorage.removeItem(API_TOKEN_STORAGE_KEY)\n       setApiBaseUrlInput('')\n-      setApiTokenInput('')\n       setApiConnectionStatus({\n         kind: 'success',\n         message: t('app.apiConnectionCleared'),\n@@ -450,10 +491,142 @@ function App() {\n     }\n   }, [t])\n \n+  const persistAuthToken = useCallback((token: string) => {\n+    if (typeof window === 'undefined') {\n+      return\n+    }\n+    window.localStorage.setItem(API_TOKEN_STORAGE_KEY, token)\n+  }, [])\n+\n+  const clearPersistedAuthToken = useCallback(() => {\n+    if (typeof window === 'undefined') {\n+      return\n+    }\n+    window.localStorage.removeItem(API_TOKEN_STORAGE_KEY)\n+  }, [])\n+\n+  const persistLoginEmail = useCallback((email: string) => {\n+    if (typeof window === 'undefined') {\n+      return\n+    }\n+    window.localStorage.setItem(API_LOGIN_EMAIL_STORAGE_KEY, email)\n+  }, [])\n+\n+  const handleLogin = useCallback(async () => {\n+    if (authEmailInput.trim().length === 0 || authPasswordInput.length === 0) {\n+      setAuthStatus({\n+        kind: 'error',\n+        message: t('app.authMissingCredentials'),\n+      })\n+      return\n+    }\n+    setAuthLoading(true)\n+    setAuthStatus(null)\n+    try {\n+      const login = await apiClient.login({\n+        email: authEmailInput.trim(),\n+        password: authPasswordInput,\n+        ...(authOtpInput.trim() ? { otp_code: authOtpInput.trim() } : {}),\n+      })\n+      setApiTokenInput(login.access_token)\n+      persistAuthToken(login.access_token)\n+      persistLoginEmail(authEmailInput.trim())\n+      const currentUser = await apiClient.getCurrentUser()\n+      const userFeatures = await apiClient.getUserFeatures()\n+      const governance = userFeatures.feature_governance\n+        .filter((item) => typeof item.key === 'string')\n+        .map((item) => ({\n+          key: item.key,\n+          user_can_disable: item.user_can_disable === true,\n+        }))\n+      const userFeatureEnabled = Object.entries(userFeatures.user_feature_enabled ?? {}).reduce<Record<string, boolean>>(\n+        (acc, [key, value]) => {\n+          if (typeof value === 'boolean') {\n+            acc[key] = value\n+          }\n+          return acc\n+        },\n+        {},\n+      )\n+      const effectiveFeatureEnabled = Object.entries(\n+        userFeatures.effective_feature_enabled ?? {},\n+      ).reduce<Record<string, boolean>>((acc, [key, value]) => {\n+        if (typeof value === 'boolean') {\n+          acc[key] = value\n+        }\n+        return acc\n+      }, {})\n+      setUserFeatureState({\n+        userFeatureEnabled,\n+        effectiveFeatureEnabled,\n+        featureGovernance: governance,\n+      })\n+      setAuthUser({\n+        email: currentUser.email,\n+        displayName:\n+          typeof currentUser.display_name === 'string' ? currentUser.display_name : null,\n+        mfaEnabled: currentUser.mfa_enabled === true,\n+      })\n+      setAuthMfaStatus(null)\n+      setAuthMfaSetup(null)\n+      setAuthMfaOtpAction('')\n+      setAuthPasswordInput('')\n+      setAuthOtpInput('')\n+      setAuthRequiresOtp(false)\n+      setAuthStatus({\n+        kind: 'success',\n+        message: t('app.authLoginSuccess'),\n+      })\n+    } catch (error) {\n+      if (error instanceof ApiError && error.payload?.code === 'MFA_REQUIRED') {\n+        setAuthRequiresOtp(true)\n+        setAuthStatus({\n+          kind: 'error',\n+          message: t('app.authMfaRequired'),\n+        })\n+      } else {\n+        setAuthStatus({\n+          kind: 'error',\n+          message: t('app.authLoginError', {\n+            message: mapApiErrorToMessage(error, t),\n+          }),\n+        })\n+      }\n+    } finally {\n+      setAuthLoading(false)\n+    }\n+  }, [apiClient, authEmailInput, authOtpInput, authPasswordInput, persistAuthToken, persistLoginEmail, t])\n+\n+  const handleLogout = useCallback(async () => {\n+    setAuthLoading(true)\n+    setAuthStatus(null)\n+    try {\n+      await apiClient.logout()\n+    } catch {\n+      // Logout should still clear local auth state even if API returns an error.\n+    } finally {\n+      setApiTokenInput('')\n+      clearPersistedAuthToken()\n+      setAuthPasswordInput('')\n+      setAuthOtpInput('')\n+      setAuthRequiresOtp(false)\n+      setAuthUser(null)\n+      setUserFeatureState(null)\n+      setAuthMfaStatus(null)\n+      setAuthMfaSetup(null)\n+      setAuthMfaOtpAction('')\n+      setAuthLoading(false)\n+      setAuthStatus({\n+        kind: 'success',\n+        message: t('app.authLogoutSuccess'),\n+      })\n+    }\n+  }, [apiClient, clearPersistedAuthToken, t])\n+\n   const testApiConnection = useCallback(async () => {\n     setApiConnectionStatus(null)\n     try {\n-      await apiClient.listAssetSummaries({ limit: 1 })\n+      await apiClient.getCurrentUser()\n       setApiConnectionStatus({\n         kind: 'success',\n         message: t('app.apiConnectionTestOk'),\n@@ -468,6 +641,273 @@ function App() {\n     }\n   }, [apiClient, t])\n \n+  useEffect(() => {\n+    if (!isApiAssetSource || !effectiveApiToken) {\n+      setAuthUser(null)\n+      setUserFeatureState(null)\n+      return\n+    }\n+\n+    let canceled = false\n+    const loadCurrentUser = async () => {\n+      try {\n+        const currentUser = await apiClient.getCurrentUser()\n+        const userFeatures = await apiClient.getUserFeatures()\n+        if (canceled) {\n+          return\n+        }\n+        const governance = userFeatures.feature_governance\n+          .filter((item) => typeof item.key === 'string')\n+          .map((item) => ({\n+            key: item.key,\n+            user_can_disable: item.user_can_disable === true,\n+          }))\n+        const userFeatureEnabled = Object.entries(userFeatures.user_feature_enabled ?? {}).reduce<Record<string, boolean>>(\n+          (acc, [key, value]) => {\n+            if (typeof value === 'boolean') {\n+              acc[key] = value\n+            }\n+            return acc\n+          },\n+          {},\n+        )\n+        const effectiveFeatureEnabled = Object.entries(\n+          userFeatures.effective_feature_enabled ?? {},\n+        ).reduce<Record<string, boolean>>((acc, [key, value]) => {\n+          if (typeof value === 'boolean') {\n+            acc[key] = value\n+          }\n+          return acc\n+        }, {})\n+        setUserFeatureState({\n+          userFeatureEnabled,\n+          effectiveFeatureEnabled,\n+          featureGovernance: governance,\n+        })\n+        setAuthUser({\n+          email: currentUser.email,\n+          displayName:\n+            typeof currentUser.display_name === 'string' ? currentUser.display_name : null,\n+          mfaEnabled: currentUser.mfa_enabled === true,\n+        })\n+      } catch (error) {\n+        if (canceled) {\n+          return\n+        }\n+        setAuthUser(null)\n+        setUserFeatureState(null)\n+        if (!isApiAuthLockedByEnv && error instanceof ApiError && (error.status === 401 || error.status === 403)) {\n+          setApiTokenInput('')\n+          clearPersistedAuthToken()\n+          setAuthStatus({\n+            kind: 'error',\n+            message: t('app.authSessionExpired'),\n+          })\n+        }\n+      }\n+    }\n+\n+    void loadCurrentUser()\n+    return () => {\n+      canceled = true\n+    }\n+  }, [apiClient, clearPersistedAuthToken, effectiveApiToken, isApiAssetSource, isApiAuthLockedByEnv, t])\n+\n+  const mfaFeatureKey = useMemo(() => {\n+    if (!userFeatureState) {\n+      return null\n+    }\n+    const fromGovernance = userFeatureState.featureGovernance.find((item) =>\n+      /(2fa|mfa|totp)/i.test(item.key),\n+    )\n+    if (fromGovernance) {\n+      return fromGovernance.key\n+    }\n+    const fromEffective = Object.keys(userFeatureState.effectiveFeatureEnabled).find((key) =>\n+      /(2fa|mfa|totp)/i.test(key),\n+    )\n+    return fromEffective ?? null\n+  }, [userFeatureState])\n+\n+  const mfaFeatureAvailable = useMemo(() => {\n+    if (!mfaFeatureKey || !userFeatureState) {\n+      return false\n+    }\n+    return userFeatureState.effectiveFeatureEnabled[mfaFeatureKey] === true\n+  }, [mfaFeatureKey, userFeatureState])\n+\n+  const mfaFeatureUserEnabled = useMemo(() => {\n+    if (!mfaFeatureKey || !userFeatureState) {\n+      return false\n+    }\n+    const current = userFeatureState.userFeatureEnabled[mfaFeatureKey]\n+    return current !== false\n+  }, [mfaFeatureKey, userFeatureState])\n+\n+  const mfaFeatureUserCanDisable = useMemo(() => {\n+    if (!mfaFeatureKey || !userFeatureState) {\n+      return false\n+    }\n+    const governance = userFeatureState.featureGovernance.find((item) => item.key === mfaFeatureKey)\n+    return governance?.user_can_disable === true\n+  }, [mfaFeatureKey, userFeatureState])\n+\n+  const setUserFeature = useCallback(\n+    async (enabled: boolean) => {\n+      if (!mfaFeatureKey || !userFeatureState) {\n+        return\n+      }\n+      setAuthMfaBusy(true)\n+      setAuthMfaStatus(null)\n+      try {\n+        const response = await apiClient.updateUserFeatures({\n+          user_feature_enabled: {\n+            ...userFeatureState.userFeatureEnabled,\n+            [mfaFeatureKey]: enabled,\n+          },\n+        })\n+        const userFeatureEnabled = Object.entries(response.user_feature_enabled ?? {}).reduce<Record<string, boolean>>(\n+          (acc, [key, value]) => {\n+            if (typeof value === 'boolean') {\n+              acc[key] = value\n+            }\n+            return acc\n+          },\n+          {},\n+        )\n+        const effectiveFeatureEnabled = Object.entries(\n+          response.effective_feature_enabled ?? {},\n+        ).reduce<Record<string, boolean>>((acc, [key, value]) => {\n+          if (typeof value === 'boolean') {\n+            acc[key] = value\n+          }\n+          return acc\n+        }, {})\n+        setUserFeatureState({\n+          userFeatureEnabled,\n+          effectiveFeatureEnabled,\n+          featureGovernance: userFeatureState.featureGovernance,\n+        })\n+        setAuthMfaStatus({\n+          kind: 'success',\n+          message: enabled ? t('app.authMfaFeatureEnabled') : t('app.authMfaFeatureDisabled'),\n+        })\n+      } catch (error) {\n+        setAuthMfaStatus({\n+          kind: 'error',\n+          message: t('app.authMfaFeatureError', {\n+            message: mapApiErrorToMessage(error, t),\n+          }),\n+        })\n+      } finally {\n+        setAuthMfaBusy(false)\n+      }\n+    },\n+    [apiClient, mfaFeatureKey, t, userFeatureState],\n+  )\n+\n+  const startMfaSetup = useCallback(async () => {\n+    setAuthMfaBusy(true)\n+    setAuthMfaStatus(null)\n+    try {\n+      const setup = await apiClient.setup2fa()\n+      setAuthMfaSetup({\n+        secret: setup.secret,\n+        otpauthUri: setup.otpauth_uri,\n+      })\n+      setAuthMfaStatus({\n+        kind: 'success',\n+        message: t('app.authMfaSetupReady'),\n+      })\n+    } catch (error) {\n+      setAuthMfaStatus({\n+        kind: 'error',\n+        message: t('app.authMfaSetupError', {\n+          message: mapApiErrorToMessage(error, t),\n+        }),\n+      })\n+    } finally {\n+      setAuthMfaBusy(false)\n+    }\n+  }, [apiClient, t])\n+\n+  const enableMfa = useCallback(async () => {\n+    if (authMfaOtpAction.trim().length === 0) {\n+      setAuthMfaStatus({\n+        kind: 'error',\n+        message: t('app.authOtpRequired'),\n+      })\n+      return\n+    }\n+    setAuthMfaBusy(true)\n+    setAuthMfaStatus(null)\n+    try {\n+      await apiClient.enable2fa({ otp_code: authMfaOtpAction.trim() })\n+      const currentUser = await apiClient.getCurrentUser()\n+      setAuthUser((current) =>\n+        current\n+          ? {\n+            ...current,\n+            mfaEnabled: currentUser.mfa_enabled === true,\n+          }\n+          : current,\n+      )\n+      setAuthMfaOtpAction('')\n+      setAuthMfaSetup(null)\n+      setAuthMfaStatus({\n+        kind: 'success',\n+        message: t('app.authMfaEnabledNow'),\n+      })\n+    } catch (error) {\n+      setAuthMfaStatus({\n+        kind: 'error',\n+        message: t('app.authMfaEnableError', {\n+          message: mapApiErrorToMessage(error, t),\n+        }),\n+      })\n+    } finally {\n+      setAuthMfaBusy(false)\n+    }\n+  }, [apiClient, authMfaOtpAction, t])\n+\n+  const disableMfa = useCallback(async () => {\n+    if (authMfaOtpAction.trim().length === 0) {\n+      setAuthMfaStatus({\n+        kind: 'error',\n+        message: t('app.authOtpRequired'),\n+      })\n+      return\n+    }\n+    setAuthMfaBusy(true)\n+    setAuthMfaStatus(null)\n+    try {\n+      await apiClient.disable2fa({ otp_code: authMfaOtpAction.trim() })\n+      const currentUser = await apiClient.getCurrentUser()\n+      setAuthUser((current) =>\n+        current\n+          ? {\n+            ...current,\n+            mfaEnabled: currentUser.mfa_enabled === true,\n+          }\n+          : current,\n+      )\n+      setAuthMfaOtpAction('')\n+      setAuthMfaStatus({\n+        kind: 'success',\n+        message: t('app.authMfaDisabledNow'),\n+      })\n+    } catch (error) {\n+      setAuthMfaStatus({\n+        kind: 'error',\n+        message: t('app.authMfaDisableError', {\n+          message: mapApiErrorToMessage(error, t),\n+        }),\n+      })\n+    } finally {\n+      setAuthMfaBusy(false)\n+    }\n+  }, [apiClient, authMfaOtpAction, t])\n+\n   const batchScope = useMemo(() => {\n     const summary = { pending: 0, keep: 0, reject: 0 }\n     const selectedSet = new Set(batchIds)\n@@ -1135,11 +1575,225 @@ function App() {\n         <Card as=\"section\" className=\"shadow-sm border-0 mt-3\" aria-label={t('app.apiConnectionTitle')}>\n           <Card.Body>\n             <h2 className=\"h6 mb-3\">{t('app.apiConnectionTitle')}</h2>\n+            <section className=\"border border-2 border-secondary-subtle rounded p-3 mb-3\" aria-label={t('app.authTitle')}>\n+              <h3 className=\"h6 mb-2\">{t('app.authTitle')}</h3>\n+              {authUser ? (\n+                <p className=\"small mb-2 text-secondary\" data-testid=\"auth-user-status\">\n+                  {t('app.authSignedInAs', {\n+                    identity: authUser.displayName ?? authUser.email,\n+                  })}\n+                  {authUser.mfaEnabled ? ` · ${t('app.authMfaEnabled')}` : ''}\n+                </p>\n+              ) : (\n+                <p className=\"small mb-2 text-secondary\" data-testid=\"auth-user-status\">\n+                  {t('app.authSignedOut')}\n+                </p>\n+              )}\n+              {!isApiAuthLockedByEnv && !authUser ? (\n+                <>\n+                  <Row className=\"g-2\">\n+                    <Col md={4}>\n+                      <Form.Label htmlFor=\"auth-email-input\" className=\"small mb-1\">\n+                        {t('app.authEmailLabel')}\n+                      </Form.Label>\n+                      <Form.Control\n+                        id=\"auth-email-input\"\n+                        data-testid=\"auth-email-input\"\n+                        value={authEmailInput}\n+                        type=\"email\"\n+                        onChange={(event) => setAuthEmailInput(event.target.value)}\n+                        autoComplete=\"username\"\n+                        disabled={authLoading}\n+                      />\n+                    </Col>\n+                    <Col md={4}>\n+                      <Form.Label htmlFor=\"auth-password-input\" className=\"small mb-1\">\n+                        {t('app.authPasswordLabel')}\n+                      </Form.Label>\n+                      <Form.Control\n+                        id=\"auth-password-input\"\n+                        data-testid=\"auth-password-input\"\n+                        value={authPasswordInput}\n+                        type=\"password\"\n+                        onChange={(event) => setAuthPasswordInput(event.target.value)}\n+                        autoComplete=\"current-password\"\n+                        disabled={authLoading}\n+                      />\n+                    </Col>\n+                    <Col md={4}>\n+                      <Form.Label htmlFor=\"auth-otp-input\" className=\"small mb-1\">\n+                        {t('app.authOtpLabel')}\n+                      </Form.Label>\n+                      <Form.Control\n+                        id=\"auth-otp-input\"\n+                        data-testid=\"auth-otp-input\"\n+                        value={authOtpInput}\n+                        type=\"text\"\n+                        inputMode=\"numeric\"\n+                        onChange={(event) => setAuthOtpInput(event.target.value)}\n+                        placeholder={authRequiresOtp ? t('app.authOtpRequiredPlaceholder') : t('app.authOtpOptionalPlaceholder')}\n+                        disabled={authLoading}\n+                      />\n+                    </Col>\n+                  </Row>\n+                  <div className=\"d-flex flex-wrap gap-2 mt-3\">\n+                    <Button\n+                      type=\"button\"\n+                      size=\"sm\"\n+                      variant=\"primary\"\n+                      data-testid=\"auth-login\"\n+                      disabled={authLoading}\n+                      onClick={() => void handleLogin()}\n+                    >\n+                      {authLoading ? t('app.authLoggingIn') : t('app.authLogin')}\n+                    </Button>\n+                  </div>\n+                </>\n+              ) : null}\n+              {authUser && !isApiAuthLockedByEnv ? (\n+                <div className=\"d-flex flex-wrap gap-2 mt-2\">\n+                  <Button\n+                    type=\"button\"\n+                    size=\"sm\"\n+                    variant=\"outline-secondary\"\n+                    data-testid=\"auth-logout\"\n+                    disabled={authLoading}\n+                    onClick={() => void handleLogout()}\n+                  >\n+                    {t('app.authLogout')}\n+                  </Button>\n+                </div>\n+              ) : null}\n+              {isApiAuthLockedByEnv ? (\n+                <p className=\"small text-secondary mb-0\">{t('app.authEnvLocked')}</p>\n+              ) : null}\n+              {authStatus ? (\n+                <p\n+                  className={`small mt-2 mb-0 ${authStatus.kind === 'success' ? 'text-success' : 'text-danger'}`}\n+                  data-testid=\"auth-status\"\n+                  role=\"status\"\n+                  aria-live=\"polite\"\n+                >\n+                  {authStatus.message}\n+                </p>\n+              ) : null}\n+              {authUser && mfaFeatureKey ? (\n+                <section className=\"border border-2 border-secondary-subtle rounded p-3 mt-3\" aria-label={t('app.authMfaTitle')}>\n+                  <h4 className=\"h6 mb-2\">{t('app.authMfaTitle')}</h4>\n+                  {!mfaFeatureAvailable ? (\n+                    <p className=\"small text-secondary mb-0\" data-testid=\"auth-mfa-feature-disabled\">\n+                      {t('app.authMfaFeatureUnavailable')}\n+                    </p>\n+                  ) : (\n+                    <>\n+                      <p className=\"small text-secondary mb-2\" data-testid=\"auth-mfa-state\">\n+                        {authUser.mfaEnabled ? t('app.authMfaStateOn') : t('app.authMfaStateOff')}\n+                      </p>\n+                      {mfaFeatureUserCanDisable ? (\n+                        <div className=\"d-flex flex-wrap gap-2 mb-2\">\n+                          <Button\n+                            type=\"button\"\n+                            size=\"sm\"\n+                            variant={mfaFeatureUserEnabled ? 'outline-secondary' : 'outline-primary'}\n+                            data-testid=\"auth-mfa-user-toggle\"\n+                            disabled={authMfaBusy}\n+                            onClick={() => void setUserFeature(!mfaFeatureUserEnabled)}\n+                          >\n+                            {mfaFeatureUserEnabled\n+                              ? t('app.authMfaFeatureOptOut')\n+                              : t('app.authMfaFeatureOptIn')}\n+                          </Button>\n+                        </div>\n+                      ) : null}\n+                      {mfaFeatureUserEnabled ? (\n+                        <>\n+                          {!authUser.mfaEnabled ? (\n+                            <div className=\"d-flex flex-wrap gap-2 mb-2\">\n+                              <Button\n+                                type=\"button\"\n+                                size=\"sm\"\n+                                variant=\"outline-primary\"\n+                                data-testid=\"auth-mfa-setup\"\n+                                disabled={authMfaBusy}\n+                                onClick={() => void startMfaSetup()}\n+                              >\n+                                {t('app.authMfaSetup')}\n+                              </Button>\n+                            </div>\n+                          ) : null}\n+                          {authMfaSetup ? (\n+                            <div className=\"small text-secondary mb-2\" data-testid=\"auth-mfa-setup-material\">\n+                              <div>{t('app.authMfaSecretLabel')}: {authMfaSetup.secret}</div>\n+                              <div>{t('app.authMfaUriLabel')}: {authMfaSetup.otpauthUri}</div>\n+                            </div>\n+                          ) : null}\n+                          <Row className=\"g-2\">\n+                            <Col md={6}>\n+                              <Form.Label htmlFor=\"auth-mfa-otp-action-input\" className=\"small mb-1\">\n+                                {t('app.authOtpLabel')}\n+                              </Form.Label>\n+                              <Form.Control\n+                                id=\"auth-mfa-otp-action-input\"\n+                                data-testid=\"auth-mfa-otp-action-input\"\n+                                value={authMfaOtpAction}\n+                                type=\"text\"\n+                                inputMode=\"numeric\"\n+                                onChange={(event) => setAuthMfaOtpAction(event.target.value)}\n+                                disabled={authMfaBusy}\n+                              />\n+                            </Col>\n+                          </Row>\n+                          <div className=\"d-flex flex-wrap gap-2 mt-2\">\n+                            {!authUser.mfaEnabled ? (\n+                              <Button\n+                                type=\"button\"\n+                                size=\"sm\"\n+                                variant=\"primary\"\n+                                data-testid=\"auth-mfa-enable\"\n+                                disabled={authMfaBusy}\n+                                onClick={() => void enableMfa()}\n+                              >\n+                                {t('app.authMfaEnable')}\n+                              </Button>\n+                            ) : (\n+                              <Button\n+                                type=\"button\"\n+                                size=\"sm\"\n+                                variant=\"outline-danger\"\n+                                data-testid=\"auth-mfa-disable\"\n+                                disabled={authMfaBusy}\n+                                onClick={() => void disableMfa()}\n+                              >\n+                                {t('app.authMfaDisable')}\n+                              </Button>\n+                            )}\n+                          </div>\n+                        </>\n+                      ) : (\n+                        <p className=\"small text-secondary mb-0\" data-testid=\"auth-mfa-user-disabled\">\n+                          {t('app.authMfaFeatureUserDisabled')}\n+                        </p>\n+                      )}\n+                    </>\n+                  )}\n+                  {authMfaStatus ? (\n+                    <p\n+                      className={`small mt-2 mb-0 ${authMfaStatus.kind === 'success' ? 'text-success' : 'text-danger'}`}\n+                      data-testid=\"auth-mfa-status\"\n+                      role=\"status\"\n+                      aria-live=\"polite\"\n+                    >\n+                      {authMfaStatus.message}\n+                    </p>\n+                  ) : null}\n+                </section>\n+              ) : null}\n+            </section>\n             {isApiConfigLockedByEnv ? (\n               <p className=\"small text-secondary mb-3\">{t('app.apiConnectionEnvLocked')}</p>\n             ) : null}\n             <Row className=\"g-2\">\n-              <Col md={6}>\n+              <Col md={12}>\n                 <Form.Label htmlFor=\"api-base-url-input\" className=\"small mb-1\">\n                   {t('app.apiBaseUrlLabel')}\n                 </Form.Label>\n@@ -1149,21 +1803,7 @@ function App() {\n                   value={apiBaseUrlInput}\n                   onChange={(event) => setApiBaseUrlInput(event.target.value)}\n                   placeholder=\"/api/v1\"\n-                  disabled={isApiConfigLockedByEnv}\n-                />\n-              </Col>\n-              <Col md={6}>\n-                <Form.Label htmlFor=\"api-token-input\" className=\"small mb-1\">\n-                  {t('app.apiTokenLabel')}\n-                </Form.Label>\n-                <Form.Control\n-                  id=\"api-token-input\"\n-                  data-testid=\"api-token-input\"\n-                  type=\"password\"\n-                  value={apiTokenInput}\n-                  onChange={(event) => setApiTokenInput(event.target.value)}\n-                  placeholder=\"Bearer token\"\n-                  disabled={isApiConfigLockedByEnv}\n+                  disabled={isApiBaseUrlLockedByEnv}\n                 />\n               </Col>\n             </Row>\n@@ -1174,7 +1814,7 @@ function App() {\n                 variant=\"primary\"\n                 data-testid=\"api-connection-save\"\n                 onClick={saveApiConnectionSettings}\n-                disabled={isApiConfigLockedByEnv}\n+                disabled={isApiBaseUrlLockedByEnv}\n               >\n                 {t('app.apiConnectionSave')}\n               </Button>\n@@ -1193,7 +1833,7 @@ function App() {\n                 variant=\"outline-secondary\"\n                 data-testid=\"api-connection-clear\"\n                 onClick={clearApiConnectionSettings}\n-                disabled={isApiConfigLockedByEnv}\n+                disabled={isApiBaseUrlLockedByEnv}\n               >\n                 {t('app.apiConnectionClear')}\n               </Button>\ndiff --git a/src/api/client.test.ts b/src/api/client.test.ts\nindex 67c6d81..eeaab8b 100644\n--- a/src/api/client.test.ts\n+++ b/src/api/client.test.ts\n@@ -114,6 +114,182 @@ describe('api client', () => {\n     )\n   })\n \n+  it('logs in with credentials and returns bearer payload', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(\n+      new Response(\n+        JSON.stringify({\n+          access_token: 'token-login-1',\n+          token_type: 'Bearer',\n+          client_kind: 'UI_RUST',\n+        }),\n+        { status: 200, headers: { 'content-type': 'application/json' } },\n+      ),\n+    )\n+    const api = createApiClient('/api/v1', fetchMock)\n+\n+    const result = await api.login({\n+      email: 'user@example.com',\n+      password: 'secret',\n+      otp_code: '123456',\n+    })\n+\n+    expect(fetchMock).toHaveBeenCalledWith(\n+      '/api/v1/auth/login',\n+      expect.objectContaining({\n+        method: 'POST',\n+        body: JSON.stringify({\n+          email: 'user@example.com',\n+          password: 'secret',\n+          otp_code: '123456',\n+        }),\n+      }),\n+    )\n+    expect(result.access_token).toBe('token-login-1')\n+  })\n+\n+  it('loads current user and validates email', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(\n+      new Response(\n+        JSON.stringify({\n+          email: 'user@example.com',\n+          display_name: 'User',\n+          mfa_enabled: true,\n+        }),\n+        { status: 200, headers: { 'content-type': 'application/json' } },\n+      ),\n+    )\n+    const api = createApiClient('/api/v1', fetchMock)\n+\n+    const user = await api.getCurrentUser()\n+\n+    expect(fetchMock).toHaveBeenCalledWith('/api/v1/auth/me', expect.any(Object))\n+    expect(user.email).toBe('user@example.com')\n+    expect(user.mfa_enabled).toBe(true)\n+  })\n+\n+  it('throws validation error when current user payload has no email', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(\n+      new Response(JSON.stringify({ display_name: 'User' }), {\n+        status: 200,\n+        headers: { 'content-type': 'application/json' },\n+      }),\n+    )\n+    const api = createApiClient('/api/v1', fetchMock)\n+\n+    await expect(api.getCurrentUser()).rejects.toMatchObject({\n+      status: 502,\n+      payload: { code: 'VALIDATION_FAILED' },\n+    })\n+  })\n+\n+  it('calls logout endpoint with POST', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))\n+    const api = createApiClient('/api/v1', fetchMock)\n+\n+    await api.logout()\n+\n+    expect(fetchMock).toHaveBeenCalledWith(\n+      '/api/v1/auth/logout',\n+      expect.objectContaining({\n+        method: 'POST',\n+      }),\n+    )\n+  })\n+\n+  it('loads user feature state and validates payload shape', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(\n+      new Response(\n+        JSON.stringify({\n+          user_feature_enabled: { 'features.auth.2fa': true },\n+          effective_feature_enabled: { 'features.auth.2fa': true },\n+          feature_governance: [\n+            {\n+              key: 'features.auth.2fa',\n+              user_can_disable: true,\n+              dependencies: [],\n+              disable_escalation: [],\n+              tier: 'OPTIONAL',\n+            },\n+          ],\n+          core_v1_global_features: ['features.core.auth'],\n+        }),\n+        { status: 200, headers: { 'content-type': 'application/json' } },\n+      ),\n+    )\n+    const api = createApiClient('/api/v1', fetchMock)\n+\n+    const features = await api.getUserFeatures()\n+    expect(fetchMock).toHaveBeenCalledWith('/api/v1/auth/me/features', expect.any(Object))\n+    expect(features.effective_feature_enabled['features.auth.2fa']).toBe(true)\n+  })\n+\n+  it('updates user feature preferences with PATCH', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(\n+      new Response(\n+        JSON.stringify({\n+          user_feature_enabled: { 'features.auth.2fa': false },\n+          effective_feature_enabled: { 'features.auth.2fa': false },\n+          feature_governance: [],\n+          core_v1_global_features: ['features.core.auth'],\n+        }),\n+        { status: 200, headers: { 'content-type': 'application/json' } },\n+      ),\n+    )\n+    const api = createApiClient('/api/v1', fetchMock)\n+    await api.updateUserFeatures({\n+      user_feature_enabled: {\n+        'features.auth.2fa': false,\n+      },\n+    })\n+    expect(fetchMock).toHaveBeenCalledWith(\n+      '/api/v1/auth/me/features',\n+      expect.objectContaining({\n+        method: 'PATCH',\n+      }),\n+    )\n+  })\n+\n+  it('starts 2FA setup and validates provisioning payload', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(\n+      new Response(\n+        JSON.stringify({\n+          method: 'TOTP',\n+          issuer: 'Retaia',\n+          account_name: 'user@example.com',\n+          secret: 'SECRET123',\n+          otpauth_uri: 'otpauth://totp/Retaia:user@example.com',\n+        }),\n+        { status: 200, headers: { 'content-type': 'application/json' } },\n+      ),\n+    )\n+    const api = createApiClient('/api/v1', fetchMock)\n+    const setup = await api.setup2fa()\n+    expect(setup.secret).toBe('SECRET123')\n+  })\n+\n+  it('enables and disables 2FA with OTP payload', async () => {\n+    const fetchMock = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))\n+    const api = createApiClient('/api/v1', fetchMock)\n+    await api.enable2fa({ otp_code: '123456' })\n+    await api.disable2fa({ otp_code: '123456' })\n+    expect(fetchMock).toHaveBeenNthCalledWith(\n+      1,\n+      '/api/v1/auth/2fa/enable',\n+      expect.objectContaining({\n+        method: 'POST',\n+        body: JSON.stringify({ otp_code: '123456' }),\n+      }),\n+    )\n+    expect(fetchMock).toHaveBeenNthCalledWith(\n+      2,\n+      '/api/v1/auth/2fa/disable',\n+      expect.objectContaining({\n+        method: 'POST',\n+        body: JSON.stringify({ otp_code: '123456' }),\n+      }),\n+    )\n+  })\n+\n   it('calls purge preview endpoint for one asset', async () => {\n     const fetchMock = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))\n     const api = createApiClient('/api/v1', fetchMock)\ndiff --git a/src/api/client.ts b/src/api/client.ts\nindex 1a4f6e8..db953a6 100644\n--- a/src/api/client.ts\n+++ b/src/api/client.ts\n@@ -27,6 +27,17 @@ type AssetDecisionPayload =\n   paths['/assets/{uuid}/decision']['post']['requestBody']['content']['application/json']\n type AppPolicyResponse =\n   paths['/app/policy']['get']['responses'][200]['content']['application/json']\n+type AuthLoginPayload = components['schemas']['AuthLoginRequest']\n+type AuthLoginResponse = components['schemas']['AuthLoginSuccess']\n+type AuthCurrentUserResponse = components['schemas']['AuthCurrentUser']\n+type UserFeaturesResponse =\n+  paths['/auth/me/features']['get']['responses'][200]['content']['application/json']\n+type UserFeaturesUpdatePayload =\n+  paths['/auth/me/features']['patch']['requestBody']['content']['application/json']\n+type Auth2faSetupResponse =\n+  paths['/auth/2fa/setup']['post']['responses'][200]['content']['application/json']\n+type Auth2faOtpPayload =\n+  paths['/auth/2fa/enable']['post']['requestBody']['content']['application/json']\n \n export type ApiErrorPayload = components['schemas']['ErrorResponse']\n \n@@ -182,6 +193,45 @@ function parseAppPolicyResponse(payload: unknown, path: string) {\n   } as AppPolicyResponse & { server_policy: { feature_flags: Record<string, boolean> } }\n }\n \n+function parseCurrentUserResponse(payload: unknown, path: string) {\n+  if (!isRecord(payload)) {\n+    throw createValidationError(path, 'expected object')\n+  }\n+  if (typeof payload.email !== 'string' || payload.email.length === 0) {\n+    throw createValidationError(path, 'expected non-empty email')\n+  }\n+  return payload as AuthCurrentUserResponse\n+}\n+\n+function parseUserFeaturesResponse(payload: unknown, path: string) {\n+  if (!isRecord(payload)) {\n+    throw createValidationError(path, 'expected object')\n+  }\n+  if (!isRecord(payload.user_feature_enabled)) {\n+    throw createValidationError(path, 'expected user_feature_enabled object')\n+  }\n+  if (!isRecord(payload.effective_feature_enabled)) {\n+    throw createValidationError(path, 'expected effective_feature_enabled object')\n+  }\n+  if (!Array.isArray(payload.feature_governance)) {\n+    throw createValidationError(path, 'expected feature_governance array')\n+  }\n+  return payload as UserFeaturesResponse\n+}\n+\n+function parseAuth2faSetupResponse(payload: unknown, path: string) {\n+  if (!isRecord(payload)) {\n+    throw createValidationError(path, 'expected object')\n+  }\n+  if (typeof payload.secret !== 'string' || payload.secret.length === 0) {\n+    throw createValidationError(path, 'expected non-empty secret')\n+  }\n+  if (typeof payload.otpauth_uri !== 'string' || payload.otpauth_uri.length === 0) {\n+    throw createValidationError(path, 'expected non-empty otpauth_uri')\n+  }\n+  return payload as Auth2faSetupResponse\n+}\n+\n async function parseApiError(response: Response) {\n   try {\n     const payload = (await response.json()) as ApiErrorPayload\n@@ -310,6 +360,55 @@ export function createApiClient(\n       return parseAppPolicyResponse(result, path)\n     },\n \n+    login: (payload: AuthLoginPayload) =>\n+      request<AuthLoginResponse>('/auth/login', {\n+        method: 'POST',\n+        body: JSON.stringify(payload),\n+      }),\n+\n+    getCurrentUser: async () => {\n+      const path = '/auth/me'\n+      const result = await request<unknown>(path)\n+      return parseCurrentUserResponse(result, path)\n+    },\n+\n+    getUserFeatures: async () => {\n+      const path = '/auth/me/features'\n+      const result = await request<unknown>(path)\n+      return parseUserFeaturesResponse(result, path)\n+    },\n+\n+    updateUserFeatures: (payload: UserFeaturesUpdatePayload) =>\n+      request<UserFeaturesResponse>('/auth/me/features', {\n+        method: 'PATCH',\n+        body: JSON.stringify(payload),\n+      }),\n+\n+    logout: () =>\n+      request<void>('/auth/logout', {\n+        method: 'POST',\n+      }),\n+\n+    setup2fa: async () => {\n+      const path = '/auth/2fa/setup'\n+      const result = await request<unknown>(path, {\n+        method: 'POST',\n+      })\n+      return parseAuth2faSetupResponse(result, path)\n+    },\n+\n+    enable2fa: (payload: Auth2faOtpPayload) =>\n+      request<void>('/auth/2fa/enable', {\n+        method: 'POST',\n+        body: JSON.stringify(payload),\n+      }),\n+\n+    disable2fa: (payload: Auth2faOtpPayload) =>\n+      request<void>('/auth/2fa/disable', {\n+        method: 'POST',\n+        body: JSON.stringify(payload),\n+      }),\n+\n     previewMoveBatch: (payload: MovePreviewPayload) =>\n       request<void>('/batches/moves/preview', {\n         method: 'POST',\ndiff --git a/src/i18n/locales/en.ts b/src/i18n/locales/en.ts\nindex 6b136c7..31c3c61 100644\n--- a/src/i18n/locales/en.ts\n+++ b/src/i18n/locales/en.ts\n@@ -9,16 +9,56 @@ export const enTranslation = {\n   'app.fatalErrorRetry': 'Reload',\n   'app.apiConnectionTitle': 'API connection',\n   'app.apiConnectionEnvLocked':\n-    'API config is locked by VITE_API_BASE_URL/VITE_API_TOKEN environment variables.',\n+    'API config is locked by environment variables.',\n   'app.apiBaseUrlLabel': 'API base URL',\n-  'app.apiTokenLabel': 'API token',\n+  'app.authTitle': 'User authentication',\n+  'app.authEmailLabel': 'Email',\n+  'app.authPasswordLabel': 'Password',\n+  'app.authOtpLabel': 'TOTP code',\n+  'app.authOtpOptionalPlaceholder': 'Optional unless 2FA is enabled',\n+  'app.authOtpRequiredPlaceholder': '6-digit TOTP code required',\n+  'app.authLogin': 'Sign in',\n+  'app.authLoggingIn': 'Signing in...',\n+  'app.authLogout': 'Sign out',\n+  'app.authSignedOut': 'No authenticated user.',\n+  'app.authSignedInAs': 'Signed in as {identity}',\n+  'app.authMfaEnabled': '2FA enabled',\n+  'app.authMfaTitle': 'Two-factor authentication',\n+  'app.authMfaFeatureUnavailable': '2FA feature is disabled by global policy.',\n+  'app.authMfaFeatureOptIn': 'Enable 2FA feature for my account',\n+  'app.authMfaFeatureOptOut': 'Disable 2FA feature for my account',\n+  'app.authMfaFeatureEnabled': '2FA feature enabled for your account.',\n+  'app.authMfaFeatureDisabled': '2FA feature disabled for your account.',\n+  'app.authMfaFeatureError': 'Unable to update 2FA feature preference: {message}',\n+  'app.authMfaFeatureUserDisabled': 'Enable the user feature to configure 2FA.',\n+  'app.authMfaStateOn': '2FA status: enabled',\n+  'app.authMfaStateOff': '2FA status: disabled',\n+  'app.authMfaSetup': 'Generate 2FA setup',\n+  'app.authMfaSetupReady': '2FA setup material generated.',\n+  'app.authMfaSetupError': '2FA setup failed: {message}',\n+  'app.authMfaEnable': 'Enable 2FA',\n+  'app.authMfaEnableError': '2FA enable failed: {message}',\n+  'app.authMfaEnabledNow': '2FA is now enabled.',\n+  'app.authMfaDisable': 'Disable 2FA',\n+  'app.authMfaDisableError': '2FA disable failed: {message}',\n+  'app.authMfaDisabledNow': '2FA is now disabled.',\n+  'app.authMfaSecretLabel': 'Secret',\n+  'app.authMfaUriLabel': 'Provisioning URI',\n+  'app.authOtpRequired': 'OTP code is required.',\n+  'app.authLoginSuccess': 'Authentication successful.',\n+  'app.authLogoutSuccess': 'Signed out.',\n+  'app.authMfaRequired': '2FA is required. Enter your TOTP code and retry.',\n+  'app.authMissingCredentials': 'Email and password are required.',\n+  'app.authSessionExpired': 'Session expired. Please sign in again.',\n+  'app.authLoginError': 'Authentication failed: {message}',\n+  'app.authEnvLocked': 'Authentication is managed by VITE_API_TOKEN.',\n   'app.apiConnectionSave': 'Save connection',\n   'app.apiConnectionTest': 'Test connection',\n   'app.apiConnectionClear': 'Clear connection',\n   'app.apiConnectionSaved': 'API configuration saved.',\n   'app.apiConnectionCleared': 'API configuration cleared.',\n   'app.apiConnectionSaveError': 'Unable to persist API configuration.',\n-  'app.apiConnectionAuthError': 'API authentication failed (401/403). Check token.',\n+  'app.apiConnectionAuthError': 'API authentication failed (401/403).',\n   'app.apiConnectionTestOk': 'API connection is valid.',\n   'app.apiConnectionTestError': 'API connection test failed: {message}',\n   'app.policyLoading': 'Loading runtime policy...',\ndiff --git a/src/i18n/locales/fr.ts b/src/i18n/locales/fr.ts\nindex b381304..579e915 100644\n--- a/src/i18n/locales/fr.ts\n+++ b/src/i18n/locales/fr.ts\n@@ -9,16 +9,56 @@ export const frTranslation = {\n   'app.fatalErrorRetry': 'Recharger',\n   'app.apiConnectionTitle': 'Connexion API',\n   'app.apiConnectionEnvLocked':\n-    'Configuration API verrouillée par les variables VITE_API_BASE_URL/VITE_API_TOKEN.',\n+    'Configuration API verrouillée par des variables d’environnement.',\n   'app.apiBaseUrlLabel': 'Base URL API',\n-  'app.apiTokenLabel': 'Token API',\n+  'app.authTitle': 'Authentification utilisateur',\n+  'app.authEmailLabel': 'Email',\n+  'app.authPasswordLabel': 'Mot de passe',\n+  'app.authOtpLabel': 'Code TOTP',\n+  'app.authOtpOptionalPlaceholder': 'Optionnel sauf si 2FA activée',\n+  'app.authOtpRequiredPlaceholder': 'Code TOTP à 6 chiffres requis',\n+  'app.authLogin': 'Se connecter',\n+  'app.authLoggingIn': 'Connexion en cours...',\n+  'app.authLogout': 'Se déconnecter',\n+  'app.authSignedOut': 'Aucun utilisateur authentifié.',\n+  'app.authSignedInAs': 'Connecté en tant que {identity}',\n+  'app.authMfaEnabled': '2FA activée',\n+  'app.authMfaTitle': 'Authentification à deux facteurs',\n+  'app.authMfaFeatureUnavailable': 'La feature 2FA est désactivée par la policy globale.',\n+  'app.authMfaFeatureOptIn': 'Activer la feature 2FA pour mon compte',\n+  'app.authMfaFeatureOptOut': 'Désactiver la feature 2FA pour mon compte',\n+  'app.authMfaFeatureEnabled': 'Feature 2FA activée pour ton compte.',\n+  'app.authMfaFeatureDisabled': 'Feature 2FA désactivée pour ton compte.',\n+  'app.authMfaFeatureError': 'Impossible de mettre à jour la préférence 2FA: {message}',\n+  'app.authMfaFeatureUserDisabled': 'Active la feature utilisateur pour configurer la 2FA.',\n+  'app.authMfaStateOn': 'Statut 2FA: activée',\n+  'app.authMfaStateOff': 'Statut 2FA: désactivée',\n+  'app.authMfaSetup': 'Générer setup 2FA',\n+  'app.authMfaSetupReady': 'Matériel de setup 2FA généré.',\n+  'app.authMfaSetupError': 'Setup 2FA en échec: {message}',\n+  'app.authMfaEnable': 'Activer la 2FA',\n+  'app.authMfaEnableError': 'Activation 2FA en échec: {message}',\n+  'app.authMfaEnabledNow': 'La 2FA est maintenant activée.',\n+  'app.authMfaDisable': 'Désactiver la 2FA',\n+  'app.authMfaDisableError': 'Désactivation 2FA en échec: {message}',\n+  'app.authMfaDisabledNow': 'La 2FA est maintenant désactivée.',\n+  'app.authMfaSecretLabel': 'Secret',\n+  'app.authMfaUriLabel': 'URI provisioning',\n+  'app.authOtpRequired': 'Le code OTP est obligatoire.',\n+  'app.authLoginSuccess': 'Authentification réussie.',\n+  'app.authLogoutSuccess': 'Déconnexion effectuée.',\n+  'app.authMfaRequired': 'La 2FA est requise. Entre le code TOTP et réessaie.',\n+  'app.authMissingCredentials': \"Email et mot de passe obligatoires.\",\n+  'app.authSessionExpired': 'Session expirée. Reconnecte-toi.',\n+  'app.authLoginError': 'Authentification en échec: {message}',\n+  'app.authEnvLocked': 'Authentification pilotée par VITE_API_TOKEN.',\n   'app.apiConnectionSave': 'Enregistrer connexion',\n   'app.apiConnectionTest': 'Tester connexion',\n   'app.apiConnectionClear': 'Vider connexion',\n   'app.apiConnectionSaved': 'Configuration API enregistrée.',\n   'app.apiConnectionCleared': 'Configuration API supprimée.',\n   'app.apiConnectionSaveError': 'Impossible de sauvegarder la configuration API.',\n-  'app.apiConnectionAuthError': \"Authentification API refusée (401/403). Vérifie le token.\",\n+  'app.apiConnectionAuthError': 'Authentification API refusée (401/403).',\n   'app.apiConnectionTestOk': 'Connexion API valide.',\n   'app.apiConnectionTestError': 'Test connexion API en échec: {message}',\n   'app.policyLoading': 'Chargement de la policy runtime...',\n"
test_patch: ''
fail_to_pass: []
pass_to_pass:
- npx vitest run src/App.test.tsx -t "tests API connection with saved base url and token"
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '1302'
  difficulty: hard
  files_changed: '6'
  pr_title: 'feat(auth): gate 2FA by global and user feature state'
  removed_lines: '43'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  Retaia/retaia-ui (#154): feat(auth): gate 2FA by global and user feature state

  Implement interactive authentication for the UI API mode so users can log in, log out, and fetch the current user. Gate all 2FA UI and management by the effective feature state returned from the user features endpoint (global + user state). Only show 2FA controls when the effective feature is enabled and the user has opted in. Provide user-level 2FA toggling and TOTP setup/enable/disable flows. Ensure login remains compatible with accounts without 2FA: require an OTP only when the server indicates MFA is required, and otherwise allow normal login. Keep 2FA management confined to the dedicated 2FA section when enabled.
original_pr_body: |-
  Retaia/retaia-ui (#154): feat(auth): gate 2FA by global and user feature state

  ## Summary
  - implement interactive user auth for UI API mode (login/logout/current user)
  - gate 2FA UI by runtime feature state from /auth/me/features (global + user effective state)
  - add user-level 2FA feature toggle and TOTP setup/enable/disable actions
  - keep OTP non-systematic: prompted on login when MFA_REQUIRED, and managed in dedicated 2FA section only when feature is effectively enabled

  ## Important behavior
  - 2FA controls are not always shown
  - visibility depends on effective_feature_enabled and user preference, loaded from /auth/me/features
  - login remains compatible with accounts without 2FA (no OTP required unless server returns MFA_REQUIRED)

  ## Validation
  - npm run test -- src/api/client.test.ts src/App.test.tsx
  - npm run qa
  - npm run visual:test
  - npm run qa:v1:go-no-go
quality_score: 0.78
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
