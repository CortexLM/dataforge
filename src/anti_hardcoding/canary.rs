//! Canary string generation and contamination detection.
//!
//! Canary strings are unique identifiers embedded in task descriptions that can be used
//! to detect if a model has memorized specific content (contamination detection).

use chrono::Utc;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use uuid::Uuid;

/// Configuration for a canary string that can detect contamination.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CanaryConfig {
    /// Unique identifier for this canary
    pub canary_id: String,
    /// Locations where the canary has been embedded
    pub locations: Vec<String>,
    /// SHA-256 hash of the canary for contamination checking
    pub canary_hash: String,
    /// ISO 8601 timestamp when the canary was generated
    pub generated_at: String,
}

impl CanaryConfig {
    /// Generate a deterministic canary from task_id and seed.
    ///
    /// The canary is generated by combining the task_id and seed to create
    /// a reproducible but unique identifier that can be embedded in content.
    ///
    /// # Arguments
    /// * `task_id` - The unique identifier of the task
    /// * `seed` - A seed value for deterministic generation
    ///
    /// # Returns
    /// A new `CanaryConfig` with the generated canary
    pub fn generate(task_id: &str, seed: u64) -> Self {
        // Create deterministic UUID using UUID v5 (SHA-1 based) with custom namespace
        let namespace = Uuid::NAMESPACE_OID;
        let seed_bytes = seed.to_le_bytes();
        let combined = format!("{}-{}", task_id, hex::encode(&seed_bytes));
        let canary_uuid = Uuid::new_v5(&namespace, combined.as_bytes());
        let canary_id = format!(
            "CANARY-{}",
            canary_uuid.as_hyphenated().to_string().to_uppercase()
        );

        // Generate hash of the canary for verification
        let mut hasher = Sha256::new();
        hasher.update(canary_id.as_bytes());
        let hash_result = hasher.finalize();
        let canary_hash = hex::encode(&hash_result);

        Self {
            canary_id,
            locations: Vec::new(),
            canary_hash,
            generated_at: Utc::now().to_rfc3339(),
        }
    }

    /// Get the hash for contamination checking.
    ///
    /// # Returns
    /// A reference to the canary's SHA-256 hash string
    pub fn hash(&self) -> &str {
        &self.canary_hash
    }
}

/// Embed a canary string into content at a specified location.
///
/// The canary is embedded as a comment-style marker that should not affect
/// the semantic meaning of the content but can be detected in model outputs.
///
/// # Arguments
/// * `content` - The original content to embed the canary in
/// * `canary` - The canary configuration to embed
/// * `location` - A description of where the canary is being embedded
///
/// # Returns
/// The content with the embedded canary string
pub fn embed_canary(content: &str, canary: &CanaryConfig, location: &str) -> String {
    let canary_marker = format!(
        "<!-- {} [loc:{}] -->",
        canary.canary_id,
        location.replace(' ', "_")
    );
    format!("{}\n{}", canary_marker, content)
}

/// Result of contamination detection analysis.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContaminationResult {
    /// Whether contamination was definitively detected
    pub contaminated: bool,
    /// Whether the exact canary string was found
    pub canary_found: bool,
    /// Whether a partial match (substring) was found
    pub partial_match: bool,
    /// Confidence score from 0.0 (no contamination) to 1.0 (definite contamination)
    pub confidence: f64,
}

/// Detect contamination in model output by checking for canary presence.
///
/// Performs multiple levels of analysis:
/// 1. Exact canary string match
/// 2. Canary hash match (in case model outputs hashed form)
/// 3. Partial substring matching
/// 4. Pattern-based detection (UUID format matching)
///
/// # Arguments
/// * `model_output` - The output from the model to analyze
/// * `canary` - The canary configuration to look for
///
/// # Returns
/// A `ContaminationResult` indicating the detection findings
pub fn detect_contamination(model_output: &str, canary: &CanaryConfig) -> ContaminationResult {
    let output_upper = model_output.to_uppercase();
    let canary_id_upper = canary.canary_id.to_uppercase();

    // Check for exact canary match
    let canary_found = output_upper.contains(&canary_id_upper);

    // Check for hash match (model might output the hash)
    let hash_found = model_output.contains(&canary.canary_hash);

    // Check for partial match - extract UUID portion and check
    let partial_match = if let Some(uuid_part) = canary.canary_id.strip_prefix("CANARY-") {
        // Check if any significant portion of the UUID appears
        let uuid_segments: Vec<&str> = uuid_part.split('-').collect();
        uuid_segments
            .iter()
            .any(|segment| segment.len() >= 4 && output_upper.contains(&segment.to_uppercase()))
    } else {
        false
    };

    // Calculate confidence score
    let confidence = calculate_confidence(canary_found, hash_found, partial_match);

    // Determine contamination status
    let contaminated = canary_found || hash_found || confidence > 0.8;

    ContaminationResult {
        contaminated,
        canary_found,
        partial_match,
        confidence,
    }
}

/// Calculate confidence score based on various detection signals.
fn calculate_confidence(canary_found: bool, hash_found: bool, partial_match: bool) -> f64 {
    let mut confidence = 0.0;

    if canary_found {
        // Exact match is definitive
        confidence = 1.0;
    } else if hash_found {
        // Hash match is very strong evidence
        confidence = 0.95;
    } else if partial_match {
        // Partial match provides moderate confidence
        confidence = 0.6;
    }

    confidence
}

/// Helper module for hex encoding (since we use sha2 directly)
mod hex {
    const HEX_CHARS: &[u8; 16] = b"0123456789abcdef";

    pub fn encode(bytes: &[u8]) -> String {
        let mut result = String::with_capacity(bytes.len() * 2);
        for &byte in bytes {
            result.push(HEX_CHARS[(byte >> 4) as usize] as char);
            result.push(HEX_CHARS[(byte & 0x0f) as usize] as char);
        }
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_canary_generation_is_deterministic() {
        let canary1 = CanaryConfig::generate("task-123", 42);
        let canary2 = CanaryConfig::generate("task-123", 42);

        assert_eq!(canary1.canary_id, canary2.canary_id);
        assert_eq!(canary1.canary_hash, canary2.canary_hash);
    }

    #[test]
    fn test_canary_generation_different_seeds() {
        let canary1 = CanaryConfig::generate("task-123", 42);
        let canary2 = CanaryConfig::generate("task-123", 43);

        assert_ne!(canary1.canary_id, canary2.canary_id);
    }

    #[test]
    fn test_canary_generation_different_tasks() {
        let canary1 = CanaryConfig::generate("task-123", 42);
        let canary2 = CanaryConfig::generate("task-456", 42);

        assert_ne!(canary1.canary_id, canary2.canary_id);
    }

    #[test]
    fn test_embed_canary() {
        let canary = CanaryConfig::generate("task-123", 42);
        let content = "Original content here";
        let embedded = embed_canary(content, &canary, "test location");

        assert!(embedded.contains(&canary.canary_id));
        assert!(embedded.contains("Original content here"));
        assert!(embedded.contains("loc:test_location"));
    }

    #[test]
    fn test_detect_contamination_exact_match() {
        let canary = CanaryConfig::generate("task-123", 42);
        let output = format!("Some text {} more text", canary.canary_id);

        let result = detect_contamination(&output, &canary);

        assert!(result.contaminated);
        assert!(result.canary_found);
        assert_eq!(result.confidence, 1.0);
    }

    #[test]
    fn test_detect_contamination_no_match() {
        let canary = CanaryConfig::generate("task-123", 42);
        let output = "This output has no canary in it whatsoever";

        let result = detect_contamination(output, &canary);

        assert!(!result.contaminated);
        assert!(!result.canary_found);
        assert_eq!(result.confidence, 0.0);
    }

    #[test]
    fn test_detect_contamination_hash_match() {
        let canary = CanaryConfig::generate("task-123", 42);
        let output = format!("Output contains hash: {}", canary.canary_hash);

        let result = detect_contamination(&output, &canary);

        assert!(result.contaminated);
        assert!(!result.canary_found);
        assert_eq!(result.confidence, 0.95);
    }
}
