//! Vulnerability Injector Agent for inserting subtle security flaws into code.
//!
//! This agent takes clean, working code and injects realistic security
//! vulnerabilities that are subtle and not immediately obvious. It tracks
//! what was injected for later verification.

use std::sync::Arc;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::code_generator::GeneratedWorkspace;
use super::error::{AgentError, AgentResult};
use super::workspace_ideator::ProgrammingLanguage;
use crate::llm::{GenerationRequest, LlmProvider, Message};

/// System prompt for vulnerability injection.
const VULNERABILITY_INJECTION_SYSTEM_PROMPT: &str = r#"You are a security researcher injecting SUBTLE, REALISTIC vulnerabilities into code for benchmark purposes.

Your goal is to inject security vulnerabilities that:
1. Are REALISTIC - the kind of mistakes real developers make
2. Are SUBTLE - not immediately obvious to someone reading the code
3. Are FUNCTIONAL - the code still works, just insecurely
4. Have NO MARKERS - no comments, no obvious naming, nothing that reveals the vulnerability

VULNERABILITY INJECTION GUIDELINES:

SQL INJECTION:
- Use string formatting/concatenation instead of parameterized queries
- Make it look natural, like a developer who "just wanted to get it working"
- Example: f"SELECT * FROM users WHERE id = {user_id}" instead of parameterized

XSS (Cross-Site Scripting):
- Directly interpolate user input into HTML without escaping
- Skip sanitization in template rendering
- Use innerHTML or equivalent without sanitization

AUTHENTICATION BYPASS:
- Weak comparison operators (== vs === in JS, timing attacks)
- Short-circuit evaluation that can be exploited
- JWT validation that doesn't check signature properly

PATH TRAVERSAL:
- Direct concatenation of user input with file paths
- Insufficient sanitization of "../" sequences
- Not using path normalization functions

RACE CONDITIONS:
- Time-of-check to time-of-use (TOCTOU) vulnerabilities
- Non-atomic file operations
- Unprotected shared state access

INSECURE DESERIALIZATION:
- Using pickle.loads() or yaml.load() without safe loader
- Deserializing untrusted data without validation
- Using eval() on user input

HARDCODED CREDENTIALS:
- API keys in code (make them look like real keys)
- Database passwords in config
- Encryption keys in source

WEAK CRYPTOGRAPHY:
- Using MD5 or SHA1 for passwords
- ECB mode for encryption
- Weak random number generation for security purposes

MEMORY ISSUES (for C/C++/Rust unsafe):
- Buffer overflows through unchecked array access
- Use-after-free scenarios
- Double-free vulnerabilities
- Integer overflow leading to buffer issues

CRITICAL RULES:
1. DO NOT add comments that hint at vulnerabilities
2. DO NOT use obvious variable names like "vulnerable_query" or "unsafe_input"
3. DO NOT add TODO or FIXME comments
4. Make the vulnerable code look like normal, everyday code
5. The vulnerability should require careful analysis to find
6. Preserve code functionality - it should still work correctly in normal use

SUBTLETY TECHNIQUES:
- Bury the vulnerability in larger functions
- Use realistic variable names that don't hint at issues
- Make the insecure path look like an optimization or shortcut
- Add unrelated code around the vulnerability to camouflage it"#;

/// User prompt template for vulnerability injection.
const VULNERABILITY_INJECTION_USER_TEMPLATE: &str = r#"Inject subtle security vulnerabilities into the following code.

Language: {language}
Target Vulnerabilities: {vulnerability_types}

Files to Modify:
{files_content}

Vulnerability Opportunities from Specification:
{vulnerability_opportunities}

Requirements:
1. Inject the specified vulnerability types where they make sense
2. Keep the code functional - it should still work correctly
3. Make vulnerabilities SUBTLE - no obvious markers or comments
4. Return the modified files with injected vulnerabilities

You MUST respond with ONLY valid JSON:
{{
  "modified_files": [
    {{
      "path": "path/to/file",
      "content": "complete modified file content with vulnerabilities injected",
      "original_hash": "for tracking changes"
    }}
  ],
  "injected_vulnerabilities": [
    {{
      "id": "unique-vuln-id",
      "type": "sql_injection|xss|auth_bypass|path_traversal|race_condition|deserialization|hardcoded_credentials|weak_crypto|memory_safety|buffer_overflow|logic_error|missing_validation",
      "file": "path/to/file",
      "line_range": [start_line, end_line],
      "description": "technical description of the vulnerability for verification",
      "exploitation": "how this vulnerability could be exploited",
      "severity": "critical|high|medium|low",
      "cwe_id": "CWE-XXX if applicable"
    }}
  ]
}}"#;

/// Types of vulnerabilities that can be injected.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum VulnerabilityType {
    /// SQL injection via string concatenation.
    SqlInjection,
    /// Cross-site scripting vulnerabilities.
    Xss,
    /// Authentication or authorization bypass.
    AuthBypass,
    /// Directory/path traversal.
    PathTraversal,
    /// Race condition or TOCTOU.
    RaceCondition,
    /// Insecure deserialization.
    Deserialization,
    /// Hardcoded secrets or credentials.
    HardcodedCredentials,
    /// Weak cryptographic practices.
    WeakCrypto,
    /// Memory safety issues (Rust unsafe, C/C++).
    MemorySafety,
    /// Buffer overflow vulnerabilities.
    BufferOverflow,
    /// Logic errors in security checks.
    LogicError,
    /// Missing input validation.
    MissingValidation,
    /// Information disclosure.
    InfoDisclosure,
    /// Command injection.
    CommandInjection,
    /// Server-side request forgery.
    Ssrf,
}

impl VulnerabilityType {
    /// Returns all vulnerability types.
    pub fn all() -> Vec<VulnerabilityType> {
        vec![
            VulnerabilityType::SqlInjection,
            VulnerabilityType::Xss,
            VulnerabilityType::AuthBypass,
            VulnerabilityType::PathTraversal,
            VulnerabilityType::RaceCondition,
            VulnerabilityType::Deserialization,
            VulnerabilityType::HardcodedCredentials,
            VulnerabilityType::WeakCrypto,
            VulnerabilityType::MemorySafety,
            VulnerabilityType::BufferOverflow,
            VulnerabilityType::LogicError,
            VulnerabilityType::MissingValidation,
            VulnerabilityType::InfoDisclosure,
            VulnerabilityType::CommandInjection,
            VulnerabilityType::Ssrf,
        ]
    }

    /// Returns the display name.
    pub fn display_name(&self) -> &'static str {
        match self {
            VulnerabilityType::SqlInjection => "SQL Injection",
            VulnerabilityType::Xss => "Cross-Site Scripting (XSS)",
            VulnerabilityType::AuthBypass => "Authentication Bypass",
            VulnerabilityType::PathTraversal => "Path Traversal",
            VulnerabilityType::RaceCondition => "Race Condition",
            VulnerabilityType::Deserialization => "Insecure Deserialization",
            VulnerabilityType::HardcodedCredentials => "Hardcoded Credentials",
            VulnerabilityType::WeakCrypto => "Weak Cryptography",
            VulnerabilityType::MemorySafety => "Memory Safety",
            VulnerabilityType::BufferOverflow => "Buffer Overflow",
            VulnerabilityType::LogicError => "Logic Error",
            VulnerabilityType::MissingValidation => "Missing Input Validation",
            VulnerabilityType::InfoDisclosure => "Information Disclosure",
            VulnerabilityType::CommandInjection => "Command Injection",
            VulnerabilityType::Ssrf => "Server-Side Request Forgery",
        }
    }

    /// Returns applicable languages for this vulnerability type.
    pub fn applicable_languages(&self) -> Vec<ProgrammingLanguage> {
        match self {
            VulnerabilityType::SqlInjection => vec![
                ProgrammingLanguage::Python,
                ProgrammingLanguage::JavaScript,
                ProgrammingLanguage::TypeScript,
                ProgrammingLanguage::Java,
                ProgrammingLanguage::Go,
            ],
            VulnerabilityType::Xss => vec![
                ProgrammingLanguage::JavaScript,
                ProgrammingLanguage::TypeScript,
                ProgrammingLanguage::Python,
            ],
            VulnerabilityType::MemorySafety | VulnerabilityType::BufferOverflow => vec![
                ProgrammingLanguage::C,
                ProgrammingLanguage::Cpp,
                ProgrammingLanguage::Rust,
            ],
            _ => ProgrammingLanguage::all(),
        }
    }
}

impl std::fmt::Display for VulnerabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_name())
    }
}

/// Severity level for vulnerabilities.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum VulnerabilitySeverity {
    /// Critical severity - immediate exploitation possible.
    Critical,
    /// High severity - significant security impact.
    High,
    /// Medium severity - moderate security impact.
    Medium,
    /// Low severity - minor security impact.
    Low,
}

impl VulnerabilitySeverity {
    /// Returns a numeric score for this severity.
    pub fn score(&self) -> f64 {
        match self {
            VulnerabilitySeverity::Critical => 1.0,
            VulnerabilitySeverity::High => 0.75,
            VulnerabilitySeverity::Medium => 0.5,
            VulnerabilitySeverity::Low => 0.25,
        }
    }
}

/// A tracked injected vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectedVulnerability {
    /// Unique identifier.
    pub id: String,
    /// Type of vulnerability.
    pub vulnerability_type: VulnerabilityType,
    /// File where vulnerability was injected.
    pub file_path: String,
    /// Line range (start, end).
    pub line_range: (usize, usize),
    /// Technical description.
    pub description: String,
    /// How it could be exploited.
    pub exploitation: String,
    /// Severity level.
    pub severity: VulnerabilitySeverity,
    /// CWE identifier if applicable.
    pub cwe_id: Option<String>,
    /// Timestamp when injected.
    pub injected_at: DateTime<Utc>,
}

impl InjectedVulnerability {
    /// Creates a new injected vulnerability record.
    pub fn new(
        vulnerability_type: VulnerabilityType,
        file_path: impl Into<String>,
        line_range: (usize, usize),
        description: impl Into<String>,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            vulnerability_type,
            file_path: file_path.into(),
            line_range,
            description: description.into(),
            exploitation: String::new(),
            severity: VulnerabilitySeverity::Medium,
            cwe_id: None,
            injected_at: Utc::now(),
        }
    }

    /// Sets exploitation description.
    pub fn with_exploitation(mut self, exploitation: impl Into<String>) -> Self {
        self.exploitation = exploitation.into();
        self
    }

    /// Sets severity.
    pub fn with_severity(mut self, severity: VulnerabilitySeverity) -> Self {
        self.severity = severity;
        self
    }

    /// Sets CWE ID.
    pub fn with_cwe_id(mut self, cwe_id: impl Into<String>) -> Self {
        self.cwe_id = Some(cwe_id.into());
        self
    }
}

/// A modified file with vulnerabilities.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerableFile {
    /// File path.
    pub path: String,
    /// Modified content with vulnerabilities.
    pub content: String,
    /// Hash of original content for tracking.
    pub original_hash: String,
}

/// Result of vulnerability injection.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectionResult {
    /// Unique identifier.
    pub id: String,
    /// Source workspace ID.
    pub source_workspace_id: String,
    /// Modified files.
    pub modified_files: Vec<VulnerableFile>,
    /// List of injected vulnerabilities.
    pub vulnerabilities: Vec<InjectedVulnerability>,
    /// Total vulnerability count.
    pub vulnerability_count: usize,
    /// Timestamp.
    pub created_at: DateTime<Utc>,
}

impl InjectionResult {
    /// Creates a new injection result.
    pub fn new(
        source_workspace_id: impl Into<String>,
        modified_files: Vec<VulnerableFile>,
        vulnerabilities: Vec<InjectedVulnerability>,
    ) -> Self {
        let vulnerability_count = vulnerabilities.len();

        Self {
            id: Uuid::new_v4().to_string(),
            source_workspace_id: source_workspace_id.into(),
            modified_files,
            vulnerabilities,
            vulnerability_count,
            created_at: Utc::now(),
        }
    }

    /// Returns vulnerabilities by type.
    pub fn by_type(&self, vuln_type: VulnerabilityType) -> Vec<&InjectedVulnerability> {
        self.vulnerabilities
            .iter()
            .filter(|v| v.vulnerability_type == vuln_type)
            .collect()
    }

    /// Returns vulnerabilities by severity.
    pub fn by_severity(&self, severity: VulnerabilitySeverity) -> Vec<&InjectedVulnerability> {
        self.vulnerabilities
            .iter()
            .filter(|v| v.severity == severity)
            .collect()
    }

    /// Returns vulnerabilities in a specific file.
    pub fn in_file(&self, path: &str) -> Vec<&InjectedVulnerability> {
        self.vulnerabilities
            .iter()
            .filter(|v| v.file_path == path)
            .collect()
    }
}

/// Configuration for the Vulnerability Injector Agent.
#[derive(Debug, Clone)]
pub struct VulnerabilityInjectorConfig {
    /// Temperature for LLM generation.
    pub temperature: f64,
    /// Maximum tokens for response.
    pub max_tokens: u32,
    /// Target vulnerability types to inject.
    pub target_types: Vec<VulnerabilityType>,
    /// Minimum vulnerabilities to inject.
    pub min_vulnerabilities: usize,
    /// Maximum vulnerabilities to inject.
    pub max_vulnerabilities: usize,
}

impl Default for VulnerabilityInjectorConfig {
    fn default() -> Self {
        Self {
            temperature: 0.4,
            max_tokens: 16000,
            target_types: vec![
                VulnerabilityType::SqlInjection,
                VulnerabilityType::Xss,
                VulnerabilityType::AuthBypass,
                VulnerabilityType::PathTraversal,
            ],
            min_vulnerabilities: 2,
            max_vulnerabilities: 5,
        }
    }
}

impl VulnerabilityInjectorConfig {
    /// Creates new configuration.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets temperature.
    pub fn with_temperature(mut self, temperature: f64) -> Self {
        self.temperature = temperature.clamp(0.0, 2.0);
        self
    }

    /// Sets max tokens.
    pub fn with_max_tokens(mut self, max_tokens: u32) -> Self {
        self.max_tokens = max_tokens;
        self
    }

    /// Sets target vulnerability types.
    pub fn with_target_types(mut self, types: Vec<VulnerabilityType>) -> Self {
        self.target_types = types;
        self
    }

    /// Sets vulnerability count range.
    pub fn with_vulnerability_range(mut self, min: usize, max: usize) -> Self {
        self.min_vulnerabilities = min;
        self.max_vulnerabilities = max;
        self
    }
}

/// Vulnerability Injector Agent.
pub struct VulnerabilityInjectorAgent {
    llm_client: Arc<dyn LlmProvider>,
    config: VulnerabilityInjectorConfig,
}

impl std::fmt::Debug for VulnerabilityInjectorAgent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VulnerabilityInjectorAgent")
            .field("config", &self.config)
            .finish_non_exhaustive()
    }
}

impl VulnerabilityInjectorAgent {
    /// Agent name constant.
    pub const AGENT_NAME: &'static str = "vulnerability_injector";

    /// Creates a new vulnerability injector agent.
    pub fn new(llm_client: Arc<dyn LlmProvider>, config: VulnerabilityInjectorConfig) -> Self {
        Self { llm_client, config }
    }

    /// Creates with default configuration.
    pub fn with_defaults(llm_client: Arc<dyn LlmProvider>) -> Self {
        Self::new(llm_client, VulnerabilityInjectorConfig::default())
    }

    /// Injects vulnerabilities into a workspace.
    pub async fn inject_vulnerabilities(
        &self,
        workspace: &GeneratedWorkspace,
        vulnerability_opportunities: &[String],
    ) -> AgentResult<InjectionResult> {
        let mut last_error = None;
        for attempt in 0..3 {
            match self
                .attempt_inject(workspace, vulnerability_opportunities)
                .await
            {
                Ok(result) => return Ok(result),
                Err(e) => {
                    tracing::warn!(
                        attempt = attempt + 1,
                        error = %e,
                        project = %workspace.project_name,
                        "Vulnerability injection failed, retrying..."
                    );
                    last_error = Some(e);
                }
            }
        }
        Err(last_error.expect("should have an error after 3 failed attempts"))
    }

    /// Attempts a single injection.
    async fn attempt_inject(
        &self,
        workspace: &GeneratedWorkspace,
        vulnerability_opportunities: &[String],
    ) -> AgentResult<InjectionResult> {
        let prompt = self.build_prompt(workspace, vulnerability_opportunities);

        let request = GenerationRequest::new(
            "",
            vec![
                Message::system(VULNERABILITY_INJECTION_SYSTEM_PROMPT),
                Message::user(prompt),
            ],
        )
        .with_temperature(self.config.temperature)
        .with_max_tokens(self.config.max_tokens);

        let response = self.llm_client.generate(request).await?;

        let content = response
            .first_content()
            .ok_or_else(|| AgentError::ResponseParseError("Empty LLM response".to_string()))?;

        self.parse_response(content, workspace)
    }

    /// Builds the user prompt.
    fn build_prompt(
        &self,
        workspace: &GeneratedWorkspace,
        vulnerability_opportunities: &[String],
    ) -> String {
        let files_content = workspace
            .files
            .iter()
            .map(|f| format!("--- {} ---\n{}\n", f.path, f.content))
            .collect::<Vec<_>>()
            .join("\n");

        let vuln_types = self
            .config
            .target_types
            .iter()
            .map(|t| t.display_name())
            .collect::<Vec<_>>()
            .join(", ");

        let opportunities = vulnerability_opportunities
            .iter()
            .enumerate()
            .map(|(i, o)| format!("{}. {}", i + 1, o))
            .collect::<Vec<_>>()
            .join("\n");

        VULNERABILITY_INJECTION_USER_TEMPLATE
            .replace("{language}", workspace.language.display_name())
            .replace("{vulnerability_types}", &vuln_types)
            .replace("{files_content}", &files_content)
            .replace("{vulnerability_opportunities}", &opportunities)
    }

    /// Parses the LLM response.
    fn parse_response(
        &self,
        content: &str,
        workspace: &GeneratedWorkspace,
    ) -> AgentResult<InjectionResult> {
        let json_content = self.extract_json(content)?;

        let parsed: InjectionResponse = serde_json::from_str(&json_content)
            .map_err(|e| AgentError::ResponseParseError(format!("Invalid JSON: {}", e)))?;

        let modified_files: Vec<VulnerableFile> = parsed
            .modified_files
            .into_iter()
            .map(|f| VulnerableFile {
                path: f.path,
                content: f.content,
                original_hash: f.original_hash,
            })
            .collect();

        let vulnerabilities: Vec<InjectedVulnerability> = parsed
            .injected_vulnerabilities
            .into_iter()
            .map(|v| {
                let vuln_type = parse_vulnerability_type(&v.vulnerability_type);
                let severity = parse_severity(&v.severity);

                InjectedVulnerability::new(
                    vuln_type,
                    v.file,
                    (v.line_range[0], v.line_range[1]),
                    v.description,
                )
                .with_exploitation(v.exploitation)
                .with_severity(severity)
                .with_cwe_id(v.cwe_id)
            })
            .collect();

        if vulnerabilities.is_empty() {
            return Err(AgentError::GenerationFailed(
                "No vulnerabilities were injected".to_string(),
            ));
        }

        Ok(InjectionResult::new(
            &workspace.id,
            modified_files,
            vulnerabilities,
        ))
    }

    /// Extracts JSON from response.
    fn extract_json(&self, content: &str) -> AgentResult<String> {
        use crate::utils::json_extraction::try_extract_json_from_response;

        let result = try_extract_json_from_response(content);

        match result {
            crate::utils::json_extraction::JsonExtractionResult::Success(json) => Ok(json),
            crate::utils::json_extraction::JsonExtractionResult::Truncated {
                partial_json,
                unclosed_braces,
                unclosed_brackets,
            } => {
                let preview_len = partial_json.len().min(200);
                let preview = &partial_json[..preview_len];
                Err(AgentError::ResponseParseError(format!(
                    "JSON truncated: {} unclosed braces, {} unclosed brackets. Partial: {}...",
                    unclosed_braces, unclosed_brackets, preview
                )))
            }
            crate::utils::json_extraction::JsonExtractionResult::NotFound => {
                let trimmed = content.trim();
                let preview_len = trimmed.len().min(100);
                let preview = &trimmed[..preview_len];
                Err(AgentError::ResponseParseError(format!(
                    "No JSON found in response. Content starts with: '{}'",
                    preview
                )))
            }
        }
    }

    /// Returns the configuration.
    pub fn config(&self) -> &VulnerabilityInjectorConfig {
        &self.config
    }
}

/// Response structure from LLM.
#[derive(Debug, Deserialize)]
struct InjectionResponse {
    modified_files: Vec<ModifiedFileResponse>,
    injected_vulnerabilities: Vec<VulnerabilityResponse>,
}

#[derive(Debug, Deserialize)]
struct ModifiedFileResponse {
    path: String,
    content: String,
    original_hash: String,
}

#[derive(Debug, Deserialize)]
struct VulnerabilityResponse {
    #[serde(default)]
    #[allow(dead_code)]
    id: String,
    #[serde(rename = "type")]
    vulnerability_type: String,
    file: String,
    line_range: Vec<usize>,
    description: String,
    exploitation: String,
    severity: String,
    cwe_id: String,
}

/// Parses a vulnerability type string.
fn parse_vulnerability_type(s: &str) -> VulnerabilityType {
    match s.to_lowercase().replace(['-', '_'], "").as_str() {
        "sqlinjection" => VulnerabilityType::SqlInjection,
        "xss" | "crosssitescripting" => VulnerabilityType::Xss,
        "authbypass" | "authenticationbypass" => VulnerabilityType::AuthBypass,
        "pathtraversal" | "directorytraversal" => VulnerabilityType::PathTraversal,
        "racecondition" => VulnerabilityType::RaceCondition,
        "deserialization" | "insecuredeserialization" => VulnerabilityType::Deserialization,
        "hardcodedcredentials" | "hardcodedsecrets" => VulnerabilityType::HardcodedCredentials,
        "weakcrypto" | "weakcryptography" => VulnerabilityType::WeakCrypto,
        "memorysafety" => VulnerabilityType::MemorySafety,
        "bufferoverflow" => VulnerabilityType::BufferOverflow,
        "logicerror" => VulnerabilityType::LogicError,
        "missingvalidation" | "inputvalidation" => VulnerabilityType::MissingValidation,
        "infodisclosure" | "informationdisclosure" => VulnerabilityType::InfoDisclosure,
        "commandinjection" => VulnerabilityType::CommandInjection,
        "ssrf" | "serversiderequestforgery" => VulnerabilityType::Ssrf,
        _ => VulnerabilityType::LogicError,
    }
}

/// Parses a severity string.
fn parse_severity(s: &str) -> VulnerabilitySeverity {
    match s.to_lowercase().as_str() {
        "critical" => VulnerabilitySeverity::Critical,
        "high" => VulnerabilitySeverity::High,
        "medium" => VulnerabilitySeverity::Medium,
        "low" => VulnerabilitySeverity::Low,
        _ => VulnerabilitySeverity::Medium,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agents::code_generator::GeneratedFile;
    use crate::error::LlmError;
    use crate::llm::{Choice, GenerationResponse as LlmGenResponse, Usage};
    use async_trait::async_trait;
    use std::sync::Mutex;

    struct MockLlmProvider {
        response: Mutex<String>,
    }

    impl MockLlmProvider {
        fn new(response: &str) -> Self {
            Self {
                response: Mutex::new(response.to_string()),
            }
        }
    }

    #[async_trait]
    impl LlmProvider for MockLlmProvider {
        async fn generate(&self, _request: GenerationRequest) -> Result<LlmGenResponse, LlmError> {
            let content = self.response.lock().expect("lock poisoned").clone();
            Ok(LlmGenResponse {
                id: "test-id".to_string(),
                model: "test-model".to_string(),
                choices: vec![Choice {
                    index: 0,
                    message: Message::assistant(content),
                    finish_reason: "stop".to_string(),
                }],
                usage: Usage {
                    prompt_tokens: 100,
                    completion_tokens: 500,
                    total_tokens: 600,
                },
            })
        }
    }

    fn mock_response() -> String {
        r#"{
            "modified_files": [
                {
                    "path": "src/auth.py",
                    "content": "def get_user(user_id):\n    query = f\"SELECT * FROM users WHERE id = {user_id}\"\n    return db.execute(query)\n",
                    "original_hash": "abc123"
                }
            ],
            "injected_vulnerabilities": [
                {
                    "id": "vuln-001",
                    "type": "sql_injection",
                    "file": "src/auth.py",
                    "line_range": [2, 3],
                    "description": "SQL injection via string formatting in user lookup query",
                    "exploitation": "Pass malicious SQL in user_id parameter",
                    "severity": "critical",
                    "cwe_id": "CWE-89"
                }
            ]
        }"#
        .to_string()
    }

    #[test]
    fn test_vulnerability_type_all() {
        let types = VulnerabilityType::all();
        assert_eq!(types.len(), 15);
    }

    #[test]
    fn test_vulnerability_severity_score() {
        assert!((VulnerabilitySeverity::Critical.score() - 1.0).abs() < 0.01);
        assert!((VulnerabilitySeverity::High.score() - 0.75).abs() < 0.01);
        assert!((VulnerabilitySeverity::Medium.score() - 0.5).abs() < 0.01);
        assert!((VulnerabilitySeverity::Low.score() - 0.25).abs() < 0.01);
    }

    #[test]
    fn test_injected_vulnerability_creation() {
        let vuln = InjectedVulnerability::new(
            VulnerabilityType::SqlInjection,
            "src/auth.py",
            (10, 15),
            "SQL injection in query",
        )
        .with_exploitation("Pass malicious SQL")
        .with_severity(VulnerabilitySeverity::Critical)
        .with_cwe_id("CWE-89");

        assert_eq!(vuln.vulnerability_type, VulnerabilityType::SqlInjection);
        assert_eq!(vuln.file_path, "src/auth.py");
        assert_eq!(vuln.line_range, (10, 15));
        assert_eq!(vuln.severity, VulnerabilitySeverity::Critical);
        assert_eq!(vuln.cwe_id, Some("CWE-89".to_string()));
    }

    #[test]
    fn test_injection_result() {
        let vulns = vec![
            InjectedVulnerability::new(
                VulnerabilityType::SqlInjection,
                "file1.py",
                (1, 5),
                "SQL injection",
            ),
            InjectedVulnerability::new(
                VulnerabilityType::Xss,
                "file2.py",
                (10, 15),
                "XSS vulnerability",
            )
            .with_severity(VulnerabilitySeverity::High),
        ];

        let result = InjectionResult::new("workspace-1", vec![], vulns);

        assert_eq!(result.vulnerability_count, 2);
        assert_eq!(result.by_type(VulnerabilityType::SqlInjection).len(), 1);
        assert_eq!(result.by_severity(VulnerabilitySeverity::Medium).len(), 1);
        assert_eq!(result.in_file("file1.py").len(), 1);
    }

    #[test]
    fn test_config_builder() {
        let config = VulnerabilityInjectorConfig::new()
            .with_temperature(0.5)
            .with_max_tokens(8000)
            .with_target_types(vec![VulnerabilityType::SqlInjection])
            .with_vulnerability_range(1, 3);

        assert!((config.temperature - 0.5).abs() < 0.01);
        assert_eq!(config.max_tokens, 8000);
        assert_eq!(config.target_types.len(), 1);
        assert_eq!(config.min_vulnerabilities, 1);
        assert_eq!(config.max_vulnerabilities, 3);
    }

    #[test]
    fn test_parse_vulnerability_type() {
        assert_eq!(
            parse_vulnerability_type("sql_injection"),
            VulnerabilityType::SqlInjection
        );
        assert_eq!(parse_vulnerability_type("XSS"), VulnerabilityType::Xss);
        assert_eq!(
            parse_vulnerability_type("path-traversal"),
            VulnerabilityType::PathTraversal
        );
        assert_eq!(
            parse_vulnerability_type("unknown"),
            VulnerabilityType::LogicError
        );
    }

    #[test]
    fn test_parse_severity() {
        assert_eq!(parse_severity("critical"), VulnerabilitySeverity::Critical);
        assert_eq!(parse_severity("HIGH"), VulnerabilitySeverity::High);
        assert_eq!(parse_severity("unknown"), VulnerabilitySeverity::Medium);
    }

    #[tokio::test]
    async fn test_inject_vulnerabilities() {
        let mock_llm = Arc::new(MockLlmProvider::new(&mock_response()));
        let agent = VulnerabilityInjectorAgent::with_defaults(mock_llm);

        let workspace = GeneratedWorkspace::new(
            "idea-123",
            "test-project",
            ProgrammingLanguage::Python,
            vec![GeneratedFile::new(
                "src/auth.py",
                "def get_user(user_id):\n    return db.query(user_id)\n",
                "Auth module",
            )],
        );

        let result = agent
            .inject_vulnerabilities(&workspace, &["SQL injection in user lookup".to_string()])
            .await
            .expect("should inject vulnerabilities");

        assert_eq!(result.vulnerability_count, 1);
        assert_eq!(
            result.vulnerabilities[0].vulnerability_type,
            VulnerabilityType::SqlInjection
        );
    }
}
