id: tox-dev/filelock-483
repo: tox-dev/filelock
base_commit: 79ca84f47294f5da93284b51b66fde5da763cc84
merge_commit: 57251e9f311caa9098325f21e498fa6f7a1d983e
language: python
difficulty_score: 2
created_at: 2026-02-14T14:35:28.412297724Z
patch: "diff --git a/src/filelock/_api.py b/src/filelock/_api.py\nindex a6adc399..d4f4d1cc 100644\n--- a/src/filelock/_api.py\n+++ b/src/filelock/_api.py\n@@ -14,6 +14,11 @@\n \n from ._error import Timeout\n \n+#: Sentinel indicating that no explicit file permission mode was passed.\n+#: When used, lock files are created with 0o666 (letting umask and default ACLs control the final permissions)\n+#: and fchmod is skipped so that POSIX default ACL inheritance is preserved.\n+_UNSET_FILE_MODE: int = -1\n+\n if TYPE_CHECKING:\n     import sys\n     from types import TracebackType\n@@ -87,7 +92,7 @@ def __call__(  # noqa: PLR0913\n         cls,\n         lock_file: str | os.PathLike[str],\n         timeout: float = -1,\n-        mode: int = 0o644,\n+        mode: int = _UNSET_FILE_MODE,\n         thread_local: bool = True,  # noqa: FBT001, FBT002\n         *,\n         blocking: bool = True,\n@@ -100,7 +105,7 @@ def __call__(  # noqa: PLR0913\n                 params_to_check = {\n                     \"thread_local\": (thread_local, instance.is_thread_local()),\n                     \"timeout\": (timeout, instance.timeout),\n-                    \"mode\": (mode, instance.mode),\n+                    \"mode\": (mode, instance._context.mode),  # noqa: SLF001\n                     \"blocking\": (blocking, instance.blocking),\n                 }\n \n@@ -163,7 +168,7 @@ def __init__(  # noqa: PLR0913\n         self,\n         lock_file: str | os.PathLike[str],\n         timeout: float = -1,\n-        mode: int = 0o644,\n+        mode: int = _UNSET_FILE_MODE,\n         thread_local: bool = True,  # noqa: FBT001, FBT002\n         *,\n         blocking: bool = True,\n@@ -176,7 +181,8 @@ def __init__(  # noqa: PLR0913\n         :param timeout: default timeout when acquiring the lock, in seconds. It will be used as fallback value in\n             the acquire method, if no timeout value (``None``) is given. If you want to disable the timeout, set it\n             to a negative value. A timeout of 0 means that there is exactly one attempt to acquire the file lock.\n-        :param mode: file permissions for the lockfile\n+        :param mode: file permissions for the lockfile. When not specified, the OS controls permissions via umask\n+            and default ACLs, preserving POSIX default ACL inheritance in shared directories.\n         :param thread_local: Whether this object's internal context should be thread local or not. If this is set\n             to ``False`` then the lock will be reentrant across threads.\n         :param blocking: whether the lock should be blocking or not\n@@ -257,7 +263,16 @@ def blocking(self, value: bool) -> None:\n     @property\n     def mode(self) -> int:\n         \"\"\":return: the file permissions for the lockfile\"\"\"\n-        return self._context.mode\n+        return 0o644 if self._context.mode == _UNSET_FILE_MODE else self._context.mode\n+\n+    @property\n+    def has_explicit_mode(self) -> bool:\n+        \"\"\":return: whether the file permissions were explicitly set\"\"\"\n+        return self._context.mode != _UNSET_FILE_MODE\n+\n+    def _open_mode(self) -> int:\n+        \"\"\":return: the mode for os.open() ‚Äî 0o666 when unset (let umask/ACLs decide), else the explicit mode\"\"\"\n+        return 0o666 if self._context.mode == _UNSET_FILE_MODE else self._context.mode\n \n     @abstractmethod\n     def _acquire(self) -> None:\n@@ -415,6 +430,7 @@ def __del__(self) -> None:\n \n \n __all__ = [\n+    \"_UNSET_FILE_MODE\",\n     \"AcquireReturnProxy\",\n     \"BaseFileLock\",\n ]\ndiff --git a/src/filelock/_soft.py b/src/filelock/_soft.py\nindex 035f5cf5..beee316c 100644\n--- a/src/filelock/_soft.py\n+++ b/src/filelock/_soft.py\n@@ -39,7 +39,7 @@ def _acquire(self) -> None:\n         if (o_nofollow := getattr(os, \"O_NOFOLLOW\", None)) is not None:\n             flags |= o_nofollow\n         try:\n-            file_handler = os.open(self.lock_file, flags, self._context.mode)\n+            file_handler = os.open(self.lock_file, flags, self._open_mode())\n         except OSError as exception:  # re-raise unless expected exception\n             if not (\n                 exception.errno == EEXIST  # lock already exist\ndiff --git a/src/filelock/_unix.py b/src/filelock/_unix.py\nindex c35b4b0c..291f2e0a 100644\n--- a/src/filelock/_unix.py\n+++ b/src/filelock/_unix.py\n@@ -37,26 +37,28 @@ def _release(self) -> None:\n     class UnixFileLock(BaseFileLock):\n         \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n \n-        def _acquire(self) -> None:\n+        def _acquire(self) -> None:  # noqa: C901\n             ensure_directory_exists(self.lock_file)\n             open_flags = os.O_RDWR | os.O_TRUNC\n             o_nofollow = getattr(os, \"O_NOFOLLOW\", None)\n             if o_nofollow is not None:\n                 open_flags |= o_nofollow\n             open_flags |= os.O_CREAT\n+            open_mode = self._open_mode()\n             try:\n-                fd = os.open(self.lock_file, open_flags, self._context.mode)\n+                fd = os.open(self.lock_file, open_flags, open_mode)\n             except PermissionError:\n                 # Sticky-bit dirs (e.g. /tmp): O_CREAT fails if the file is owned by another user (#317).\n                 # Fall back to opening the existing file without O_CREAT.\n                 if not Path(self.lock_file).exists():\n                     raise\n                 try:\n-                    fd = os.open(self.lock_file, open_flags & ~os.O_CREAT, self._context.mode)\n+                    fd = os.open(self.lock_file, open_flags & ~os.O_CREAT, open_mode)\n                 except FileNotFoundError:\n                     return\n-            with suppress(PermissionError):  # fchmod fails if the lock file is not owned by this UID\n-                os.fchmod(fd, self._context.mode)\n+            if self.has_explicit_mode:\n+                with suppress(PermissionError):\n+                    os.fchmod(fd, self._context.mode)\n             try:\n                 fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n             except OSError as exception:\ndiff --git a/src/filelock/_windows.py b/src/filelock/_windows.py\nindex c6e423b2..4d9895c0 100644\n--- a/src/filelock/_windows.py\n+++ b/src/filelock/_windows.py\n@@ -63,7 +63,7 @@ def _acquire(self) -> None:\n                 | os.O_TRUNC  # truncate file if not empty\n             )\n             try:\n-                fd = os.open(self.lock_file, flags, self._context.mode)\n+                fd = os.open(self.lock_file, flags, self._open_mode())\n             except OSError as exception:\n                 if exception.errno != EACCES:  # has no access to this lock\n                     raise\ndiff --git a/src/filelock/asyncio.py b/src/filelock/asyncio.py\nindex e2e33203..f77bf812 100644\n--- a/src/filelock/asyncio.py\n+++ b/src/filelock/asyncio.py\n@@ -12,7 +12,7 @@\n from threading import local\n from typing import TYPE_CHECKING, Any, NoReturn, cast\n \n-from ._api import BaseFileLock, FileLockContext, FileLockMeta\n+from ._api import _UNSET_FILE_MODE, BaseFileLock, FileLockContext, FileLockMeta\n from ._error import Timeout\n from ._soft import SoftFileLock\n from ._unix import UnixFileLock\n@@ -74,7 +74,7 @@ def __call__(  # ty: ignore[invalid-method-override]  # noqa: PLR0913\n         cls,  # noqa: N805\n         lock_file: str | os.PathLike[str],\n         timeout: float = -1,\n-        mode: int = 0o644,\n+        mode: int = _UNSET_FILE_MODE,\n         thread_local: bool = False,  # noqa: FBT001, FBT002\n         *,\n         blocking: bool = True,\n@@ -111,7 +111,7 @@ def __init__(  # noqa: PLR0913\n         self,\n         lock_file: str | os.PathLike[str],\n         timeout: float = -1,\n-        mode: int = 0o644,\n+        mode: int = _UNSET_FILE_MODE,\n         thread_local: bool = False,  # noqa: FBT001, FBT002\n         *,\n         blocking: bool = True,\n@@ -127,7 +127,8 @@ def __init__(  # noqa: PLR0913\n         :param timeout: default timeout when acquiring the lock, in seconds. It will be used as fallback value in\n             the acquire method, if no timeout value (``None``) is given. If you want to disable the timeout, set it\n             to a negative value. A timeout of 0 means that there is exactly one attempt to acquire the file lock.\n-        :param mode: file permissions for the lockfile\n+        :param mode: file permissions for the lockfile. When not specified, the OS controls permissions via umask\n+            and default ACLs, preserving POSIX default ACL inheritance in shared directories.\n         :param thread_local: Whether this object's internal context should be thread local or not. If this is set\n             to ``False`` then the lock will be reentrant across threads.\n         :param blocking: whether the lock should be blocking or not\ndiff --git a/tests/test_default_mode.py b/tests/test_default_mode.py\nnew file mode 100644\nindex 00000000..56c27771\n--- /dev/null\n+++ b/tests/test_default_mode.py\n@@ -0,0 +1,139 @@\n+from __future__ import annotations\n+\n+import os\n+import sys\n+from stat import filemode\n+from typing import TYPE_CHECKING\n+\n+import pytest\n+\n+from filelock import FileLock, SoftFileLock\n+from filelock._api import _UNSET_FILE_MODE, BaseFileLock\n+\n+if TYPE_CHECKING:\n+    from pathlib import Path\n+    from unittest.mock import MagicMock\n+\n+\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_default_mode_property_returns_0o644(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock = lock_type(tmp_path / \"a.lock\")\n+    assert lock.mode == 0o644\n+\n+\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_explicit_mode_property_returns_value(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock = lock_type(tmp_path / \"a.lock\", mode=0o600)\n+    assert lock.mode == 0o600\n+\n+\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_has_explicit_mode_false_by_default(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock = lock_type(tmp_path / \"a.lock\")\n+    assert lock.has_explicit_mode is False\n+\n+\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_has_explicit_mode_true_when_set(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock = lock_type(tmp_path / \"a.lock\", mode=0o644)\n+    assert lock.has_explicit_mode is True\n+\n+\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_open_mode_returns_0o666_when_unset(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock = lock_type(tmp_path / \"a.lock\")\n+    assert lock._open_mode() == 0o666\n+\n+\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_open_mode_returns_explicit_value(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock = lock_type(tmp_path / \"a.lock\", mode=0o600)\n+    assert lock._open_mode() == 0o600\n+\n+\n+@pytest.mark.skipif(sys.platform == \"win32\", reason=\"Windows does not apply umask to file permissions\")\n+@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n+def test_default_mode_respects_umask(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock = lock_type(str(lock_path))\n+\n+    initial_umask = os.umask(0o022)\n+    try:\n+        lock.acquire()\n+        assert lock.is_locked\n+\n+        mode = filemode(lock_path.stat().st_mode)\n+        assert mode == \"-rw-r--r--\"\n+    finally:\n+        os.umask(initial_umask)\n+\n+    lock.release()\n+\n+\n+@pytest.mark.skipif(sys.platform == \"win32\", reason=\"fchmod only on Unix\")\n+def test_default_mode_skips_fchmod(tmp_path: Path, mocker: MagicMock) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock = FileLock(str(lock_path))\n+\n+    fchmod_spy = mocker.patch(\"os.fchmod\")\n+    lock.acquire()\n+    assert lock.is_locked\n+    fchmod_spy.assert_not_called()\n+    lock.release()\n+\n+\n+@pytest.mark.skipif(sys.platform == \"win32\", reason=\"fchmod only on Unix\")\n+def test_explicit_mode_calls_fchmod(tmp_path: Path, mocker: MagicMock) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock = FileLock(str(lock_path), mode=0o644)\n+\n+    fchmod_spy = mocker.spy(os, \"fchmod\")\n+    lock.acquire()\n+    assert lock.is_locked\n+    fchmod_spy.assert_called_once()\n+    assert fchmod_spy.call_args[0][1] == 0o644\n+    lock.release()\n+\n+\n+@pytest.mark.skipif(sys.platform == \"win32\", reason=\"fchmod only on Unix\")\n+def test_explicit_mode_overrides_umask(tmp_path: Path) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock = FileLock(str(lock_path), mode=0o666)\n+\n+    initial_umask = os.umask(0o022)\n+    try:\n+        lock.acquire()\n+        assert lock.is_locked\n+\n+        mode = filemode(lock_path.stat().st_mode)\n+        assert mode == \"-rw-rw-rw-\"\n+    finally:\n+        os.umask(initial_umask)\n+\n+    lock.release()\n+\n+\n+def test_singleton_default_mode_matches(tmp_path: Path) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock_1 = FileLock(str(lock_path), is_singleton=True)\n+    lock_2 = FileLock(str(lock_path), is_singleton=True)\n+    assert lock_1 is lock_2\n+\n+\n+def test_singleton_explicit_mode_matches(tmp_path: Path) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock_1 = FileLock(str(lock_path), mode=0o600, is_singleton=True)\n+    lock_2 = FileLock(str(lock_path), mode=0o600, is_singleton=True)\n+    assert lock_1 is lock_2\n+\n+\n+def test_singleton_default_vs_explicit_mode_differ(tmp_path: Path) -> None:\n+    lock_path = tmp_path / \"a.lock\"\n+    lock = FileLock(str(lock_path), is_singleton=True)\n+    with pytest.raises(ValueError, match=\"mode\"):\n+        FileLock(str(lock_path), mode=0o644, is_singleton=True)\n+    del lock\n+\n+\n+def test_unset_file_mode_sentinel_value() -> None:\n+    assert _UNSET_FILE_MODE == -1\n"
test_patch: ''
fail_to_pass:
- |-
  cat <<'PY' > /tmp/test_default_mode.py
  import os
  from filelock import SoftFileLock

  def test_default_mode_uses_open_mode(tmp_path, monkeypatch):
      lock_path = tmp_path / "a.lock"
      captured = {}
      real_open = os.open

      def open_capture(path, flags, mode=0o777, *, dir_fd=None):
          captured["mode"] = mode
          return real_open(path, flags, mode) if dir_fd is None else real_open(path, flags, mode, dir_fd=dir_fd)

      monkeypatch.setattr(os, "open", open_capture)
      lock = SoftFileLock(str(lock_path))
      lock.acquire()
      lock.release()
      assert captured["mode"] == 0o666
  PY
  /tmp/venv/bin/python -m pytest -q /tmp/test_default_mode.py
pass_to_pass:
- /tmp/venv/bin/python -m pytest -q tests/test_filelock.py::test_lock_mode_soft
- /tmp/venv/bin/python -m pytest -q tests/test_read_write_unit.py::test_lock_context_manager
install_config:
  install: pip install -e .
  python: '3.11'
  test_cmd: pytest
meta:
  added_lines: '174'
  difficulty: medium
  files_changed: '6'
  pr_title: '‚ú® feat(mode): respect POSIX default ACL inheritance'
  removed_lines: '16'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  tox-dev/filelock (#483): ‚ú® feat(mode): respect POSIX default ACL inheritance

  Ensure lock file creation respects POSIX default ACL inheritance. When callers do not specify a file mode, allow the OS (umask and default ACLs) to determine final permissions instead of forcing a fixed mode. Preserve existing behavior when a mode is explicitly provided, so permissions are enforced deterministically in that case. Maintain backward compatibility in exposed mode reporting while changing only the observable behavior for environments with default ACLs.
original_pr_body: |-
  tox-dev/filelock (#483): ‚ú® feat(mode): respect POSIX default ACL inheritance

  When directories have default ACLs configured via `setfacl -d`, newly created files should inherit those permissions.
  However, filelock's hardcoded `mode=0o644` passed to `os.open()` combined with an unconditional `os.fchmod()` call
  were preventing this ‚Äî the explicit mode overrides the OS permission machinery, stripping default ACL entries
  entirely. This is a significant pain point in multi-user shared environments (e.g. HuggingFace `.cache` directories)
  where one user's lock file becomes inaccessible to others, requiring manual deletion. üîê

  The fix introduces a sentinel default for the `mode` parameter. When no explicit mode is passed, lock files are now
  created with `0o666` (the standard "let the OS decide" value) and `fchmod()` is skipped, allowing both umask and
  default ACLs to control the final permissions naturally. When `mode` is explicitly set by the caller, the existing
  behavior is fully preserved ‚Äî the mode is passed to `os.open()` and enforced via `fchmod()`. ‚ú® This distinction is
  tracked internally via a `_UNSET_FILE_MODE` sentinel so the `.mode` property still returns `0o644` for backward
  compatibility.

  For users without ACLs and a standard umask (`0o022`), file permissions are identical to before: `0o666 & ~0o022 =
  0o644`. The only observable change is for users who have default ACLs configured ‚Äî which is exactly the population
  that needs this fix. Users in security-sensitive environments who want deterministic permissions can explicitly pass
  `mode=0o644` to opt into the previous behavior. This approach avoids the thread-safety concerns from #204 since we
  never manipulate `umask` ‚Äî we simply stop overriding the kernel's decision.

  Closes #378

  See also: https://man7.org/linux/man-pages/man5/acl.5.html (POSIX ACL semantics ‚Äî "OBJECT CREATION AND DEFAULT ACLs"
  section covers how `open()` mode interacts with inherited ACL entries)
quality_score: 0.55
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
