id: omegat-org/segmentation-migrator-32
repo: omegat-org/segmentation-migrator
base_commit: 40243b45bab9324b27b59cc077b0caca8c958eea
merge_commit: f34435124d34611146d539e06966f6f56b594eab
language: java
difficulty_score: 2
created_at: 2026-02-14T14:37:34.695980290Z
patch: "diff --git a/src/main/java/org/omegat/core/segmentation/LanguageCodes.java b/src/main/java/org/omegat/core/segmentation/LanguageCodes.java\nindex a1c00d6..e3e848f 100644\n--- a/src/main/java/org/omegat/core/segmentation/LanguageCodes.java\n+++ b/src/main/java/org/omegat/core/segmentation/LanguageCodes.java\n@@ -66,6 +66,17 @@ private LanguageCodes(Locale locale) {\n         bundle = ResourceBundle.getBundle(BASENAME, locale);\n     }\n \n+    public String getStandardNameFromMapRule(MapRule mr) {\n+        String language = getLanguageCodeByPattern(mr.getPattern());\n+        if (language == null) {\n+            language = getLanguageCodeByName(mr.getLanguage());\n+        }\n+        if (language == null) {\n+            language = mr.getLanguage();\n+        }\n+        return language;\n+    }\n+\n     // Codes of \"languagerulename\".\n     static final String CATALAN_CODE = \"Catalan\";\n     static final String CZECH_CODE = \"Czech\";\ndiff --git a/src/main/java/org/omegat/core/segmentation/SRX.java b/src/main/java/org/omegat/core/segmentation/SRX.java\nindex 775e8bc..5a6e422 100644\n--- a/src/main/java/org/omegat/core/segmentation/SRX.java\n+++ b/src/main/java/org/omegat/core/segmentation/SRX.java\n@@ -28,174 +28,22 @@\n \n package org.omegat.core.segmentation;\n \n-import com.fasterxml.jackson.annotation.JsonInclude;\n-import com.fasterxml.jackson.databind.DatabindException;\n-import com.fasterxml.jackson.databind.MapperFeature;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n-import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n-import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n-import com.fasterxml.jackson.module.jakarta.xmlbind.JakartaXmlBindAnnotationModule;\n-import gen.core.segmentation.Languagemap;\n-import gen.core.segmentation.Languagerule;\n-import gen.core.segmentation.ObjectFactory;\n-import gen.core.segmentation.Srx;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.xml.stream.XMLInputFactory;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.io.Serial;\n import java.io.Serializable;\n-import java.net.URI;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n \n /**\n  * The class with all the segmentation data possible -- rules, languages, etc.\n- * It loads and saves its data from/to the SRX file.\n- * <p>\n- * When creating an SRX object with the default constructor, you get an empty\n- * SRX without any rules. Please do not use default constructor, unless you\n- * know what you are doing.\n  *\n  * @author Maxym Mykhalchuk\n  * @author Thomas Cordonnier\n  */\n public class SRX implements Serializable {\n \n+    @Serial\n     private static final long serialVersionUID = 2182125877925944613L;\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(SRX.class);\n-\n-    public static final String CONF_SENTSEG = \"segmentation.conf\";\n-    public static final String SRX_SENTSEG = \"segmentation.srx\";\n-    private static final XmlMapper mapper;\n-\n-    static {\n-        final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n-        xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n-        xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n-        xmlInputFactory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE);\n-        XmlFactory xmlFactory = new XmlFactory(xmlInputFactory);\n-        mapper = XmlMapper.builder(xmlFactory)\n-                .defaultUseWrapper(false)\n-                .enable(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)\n-                .enable(SerializationFeature.INDENT_OUTPUT)\n-                .enable(ToXmlGenerator.Feature.WRITE_XML_DECLARATION)\n-                .defaultPropertyInclusion(JsonInclude.Value.construct(JsonInclude.Include.NON_EMPTY,\n-                        JsonInclude.Include.NON_EMPTY))\n-                .addModule(new JakartaXmlBindAnnotationModule())\n-                .build();\n-    }\n-\n-    /**\n-     * Saves segmentation rules into specified directory.\n-     *\n-     * @param srx\n-     *            OmegaT object to be written; if null, means that we want to\n-     *            delete the file\n-     * @param outDir\n-     *            where to put the file. The file name is forced to\n-     *            {@link #SRX_SENTSEG} and will be in standard SRX format.\n-     */\n-    public static void saveToSrx(SRX srx, File outDir) throws IOException {\n-        File outFile = new File(outDir, SRX_SENTSEG);\n-\n-        ObjectFactory factory = new ObjectFactory();\n-        Srx jaxbObject = factory.createSrx();\n-        jaxbObject.setVersion(\"2.0\");\n-        jaxbObject.setHeader(factory.createHeader());\n-        jaxbObject.getHeader().setSegmentsubflows(srx.segmentSubflows ? \"yes\" : \"no\");\n-        jaxbObject.getHeader().setCascade(srx.cascade ? \"yes\" : \"no\");\n-        jaxbObject.setBody(factory.createBody());\n-        jaxbObject.getBody().setMaprules(factory.createMaprules());\n-        jaxbObject.getBody().setLanguagerules(factory.createLanguagerules());\n-        for (MapRule mr : srx.getMappingRules()) {\n-            Languagemap map = new Languagemap();\n-            String pattern = mr.getPattern();\n-            // we use standard name\n-            String language = LanguageCodes.getInstance().getLanguageCodeByPattern(pattern);\n-            if (language == null) {\n-                language = LanguageCodes.getInstance().getLanguageCodeByName(mr.getLanguage());\n-            }\n-            if (language == null) {\n-                language = mr.getLanguage();\n-            }\n-            map.setLanguagerulename(language);\n-            map.setLanguagepattern(pattern);\n-            jaxbObject.getBody().getMaprules().getLanguagemap().add(map);\n-            Languagerule lr = new Languagerule();\n-            lr.setLanguagerulename(language);\n-            jaxbObject.getBody().getLanguagerules().getLanguagerule().add(lr);\n-            for (Rule rule : mr.getRules()) {\n-                gen.core.segmentation.Rule jaxbRule = factory.createRule();\n-                lr.getRule().add(jaxbRule);\n-                jaxbRule.setBreak(rule.isBreakRule() ? \"yes\" : \"no\");\n-                if (rule.getBeforebreak() != null) {\n-                    jaxbRule.setBeforebreak(factory.createBeforebreak());\n-                    jaxbRule.getBeforebreak().setContent(rule.getBeforebreak());\n-                }\n-                if (rule.getAfterbreak() != null) {\n-                    jaxbRule.setAfterbreak(factory.createAfterbreak());\n-                    jaxbRule.getAfterbreak().setContent(rule.getAfterbreak());\n-                }\n-            }\n-        }\n-\n-        try (FileOutputStream fos = new FileOutputStream(outFile)) {\n-            mapper.writerWithDefaultPrettyPrinter().writeValue(fos, jaxbObject);\n-        } catch (DatabindException e) {\n-            throw new IOException(e);\n-        }\n-    }\n-\n-    static SRX loadSrxFile(URI rulesUri) {\n-        try (InputStream inputStream = Files.newInputStream(Paths.get(rulesUri))) {\n-            return loadSrxInputStream(inputStream);\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error loading segmentation rules from file: \" + rulesUri, e);\n-        }\n-        return null;\n-    }\n-\n-    private static SRX loadSrxInputStream(InputStream io) throws IOException {\n-        Srx srx = mapper.readValue(io, Srx.class);\n-        final Map<String, List<Rule>> mapping = new HashMap<>();\n-        List<Languagerule> languageRuleList = srx.getBody().getLanguagerules().getLanguagerule();\n-        for (Languagerule languagerule : languageRuleList) {\n-            mapping.put(languagerule.getLanguagerulename(),\n-                    languagerule.getRule().stream().map(Rule::new).toList());\n-        }\n-        SRX res = new SRX();\n-        res.setSegmentSubflows(!\"no\".equalsIgnoreCase(srx.getHeader().getSegmentsubflows()));\n-        res.setCascade(!\"no\".equalsIgnoreCase(srx.getHeader().getCascade()));\n-        res.setVersion(srx.getVersion());\n-        res.setMappingRules(srx.getBody().getMaprules().getLanguagemap().stream()\n-                .map(languagemap -> new MapRule(languagemap, mapping.get(languagemap.getLanguagerulename())))\n-                .toList());\n-        return res;\n-    }\n-\n-    public static SRX getDefault() {\n-        SRX srx = null;\n-        try {\n-            srx = loadSrxInputStream(SRX.class.getResourceAsStream(\"defaultRules.srx\"));\n-            srx.includeEndingTags = true;\n-            srx.segmentSubflows = true;\n-        } catch (IOException e) {\n-            LOGGER.error(\"Unrecoverable error occurred!\", e);\n-            System.exit(1);\n-        }\n-        return srx;\n-    }\n-\n     /**\n      * Holds value of property cascade: true, unless we read an SRX where it was\n      * set to false.\n@@ -370,6 +218,7 @@ public int hashCode() {\n         result = prime * result + (includeStartingTags ? 1231 : 1237);\n         result = prime * result + ((mappingRules == null) ? 0 : mappingRules.hashCode());\n         result = prime * result + (segmentSubflows ? 1231 : 1237);\n+        result = prime * result + (cascade ? 1231 : 1237);\n         result = prime * result + ((version == null) ? 0 : version.hashCode());\n         return result;\n     }\n@@ -405,6 +254,9 @@ public boolean equals(Object obj) {\n         if (segmentSubflows != other.segmentSubflows) {\n             return false;\n         }\n+        if (cascade != other.cascade) {\n+            return false;\n+        }\n         if (version == null) {\n             if (other.version != null) {\n                 return false;\ndiff --git a/src/main/java/org/omegat/core/segmentation/SegmentationConfMigrator.java b/src/main/java/org/omegat/core/segmentation/SegmentationConfMigrator.java\nindex 31031e5..d08f9e5 100644\n--- a/src/main/java/org/omegat/core/segmentation/SegmentationConfMigrator.java\n+++ b/src/main/java/org/omegat/core/segmentation/SegmentationConfMigrator.java\n@@ -1,6 +1,7 @@\n package org.omegat.core.segmentation;\n \n import org.jspecify.annotations.Nullable;\n+import org.omegat.util.SRXUtils;\n import org.omegat.util.ValidationResult;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -26,8 +27,8 @@ public class SegmentationConfMigrator {\n \n     public static void main(String[] args) {\n         String targetDir = \".\";\n-        Path confFilePath = Paths.get(targetDir).resolve(SRX.CONF_SENTSEG);\n-        Path srxFilePath = Paths.get(targetDir).resolve(SRX.SRX_SENTSEG);\n+        Path confFilePath = Paths.get(targetDir).resolve(SRXUtils.CONF_SENTSEG);\n+        Path srxFilePath = Paths.get(targetDir).resolve(SRXUtils.SRX_SENTSEG);\n         ValidationResult validationResult = checkConfigFile(confFilePath);\n         if (!validationResult.isValid()) {\n             LOGGER.error(validationResult.getErrorMessage());\n@@ -42,7 +43,7 @@ public static void main(String[] args) {\n \n     static ValidationResult checkConfigFile(Path configPath) {\n         if (!configPath.toFile().exists()) {\n-            return ValidationResult.failure(\"File \" + SRX.CONF_SENTSEG + \" is not found!\");\n+            return ValidationResult.failure(\"File \" + SRXUtils.CONF_SENTSEG + \" is not found!\");\n         }\n         SegmentationConfValidator validator = new SegmentationConfValidator(configPath);\n         return validator.validate();\n@@ -55,7 +56,7 @@ static ValidationResult checkConfigFile(Path configPath) {\n             }\n             File srxParent = srxFilePath.getParent().toFile();\n             SRX srx = loadConfFile(configPath.toFile());\n-            SRX.saveToSrx(srx, srxParent);\n+            SRXUtils.saveToSrx(srx, srxParent);\n             return srx;\n         } catch (Exception e) {\n             LOGGER.error(\"Error occurred during conversion!\", e);\ndiff --git a/src/main/java/org/omegat/util/SRXUtils.java b/src/main/java/org/omegat/util/SRXUtils.java\nnew file mode 100644\nindex 0000000..5524533\n--- /dev/null\n+++ b/src/main/java/org/omegat/util/SRXUtils.java\n@@ -0,0 +1,185 @@\n+/*\n+ * OmegaT - Computer Assisted Translation (CAT) tool\n+ *          with fuzzy matching, translation memory, keyword search,\n+ *          glossaries, and translation leveraging into updated projects.\n+ *\n+ * Copyright (C) 2000-2006 Keith Godfrey and Maxym Mykhalchuk\n+ *               2008 Alex Buloichik\n+ *               2018 Thomas Cordonnier\n+ *               2025-2026 Hiroshi MIura\n+ *               Home page: https://www.omegat.org/\n+ *               Support center: https://omegat.org/support\n+ *\n+ * This file is part of OmegaT.\n+ *\n+ * OmegaT is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * OmegaT is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package org.omegat.util;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.DatabindException;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+import com.fasterxml.jackson.module.jakarta.xmlbind.JakartaXmlBindAnnotationModule;\n+import gen.core.segmentation.Languagemap;\n+import gen.core.segmentation.Languagerule;\n+import gen.core.segmentation.ObjectFactory;\n+import gen.core.segmentation.Srx;\n+import org.jspecify.annotations.Nullable;\n+import org.omegat.core.segmentation.LanguageCodes;\n+import org.omegat.core.segmentation.MapRule;\n+import org.omegat.core.segmentation.Rule;\n+import org.omegat.core.segmentation.SRX;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLInputFactory;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Utility class for SRX segmentation rules.\n+ *\n+ * @author Maxym Mykhalchuk\n+ * @author Thomas Cordonnier\n+ * @author Hiroshi Miura\n+ */\n+public class SRXUtils {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SRXUtils.class);\n+\n+    public static final String CONF_SENTSEG = \"segmentation.conf\";\n+    public static final String SRX_SENTSEG = \"segmentation.srx\";\n+    private static final XmlMapper mapper;\n+\n+    static {\n+        final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n+        xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n+        xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n+        xmlInputFactory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE);\n+        XmlFactory xmlFactory = new XmlFactory(xmlInputFactory);\n+        mapper = XmlMapper.builder(xmlFactory)\n+                .defaultUseWrapper(false)\n+                .enable(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .enable(ToXmlGenerator.Feature.WRITE_XML_DECLARATION)\n+                .defaultPropertyInclusion(JsonInclude.Value.construct(JsonInclude.Include.NON_EMPTY,\n+                        JsonInclude.Include.NON_EMPTY))\n+                .addModule(new JakartaXmlBindAnnotationModule())\n+                .build();\n+    }\n+\n+    public static SRX getDefault() throws IOException {\n+        SRX srx = loadSrxInputStream(Objects.requireNonNull(\n+                SRXUtils.class.getResourceAsStream(\"/org/omegat/core/segmentation/defaultRules.srx\")));\n+        srx.setIncludeEndingTags(true);\n+        srx.setSegmentSubflows(true);\n+        return srx;\n+    }\n+\n+    /**\n+     * Saves segmentation rules into specified directory.\n+     *\n+     * @param srx\n+     *            OmegaT object to be written; if null, means that we want to\n+     *            delete the file\n+     * @param outDir\n+     *            where to put the file. The file name is forced to\n+     *            {@link #SRX_SENTSEG} and will be in standard SRX format.\n+     */\n+    public static void saveToSrx(SRX srx, File outDir) throws IOException {\n+        File outFile = new File(outDir, SRX_SENTSEG);\n+\n+        ObjectFactory factory = new ObjectFactory();\n+        Srx jaxbObject = factory.createSrx();\n+        jaxbObject.setVersion(\"2.0\");\n+        jaxbObject.setHeader(factory.createHeader());\n+        jaxbObject.getHeader().setSegmentsubflows(srx.isSegmentSubflows() ? \"yes\" : \"no\");\n+        jaxbObject.getHeader().setCascade(srx.isCascade() ? \"yes\" : \"no\");\n+        jaxbObject.setBody(factory.createBody());\n+        jaxbObject.getBody().setMaprules(factory.createMaprules());\n+        jaxbObject.getBody().setLanguagerules(factory.createLanguagerules());\n+        for (MapRule mr : srx.getMappingRules()) {\n+            Languagemap map = new Languagemap();\n+            String pattern = mr.getPattern();\n+            // we use standard name\n+            String language = LanguageCodes.getInstance().getStandardNameFromMapRule(mr);\n+            map.setLanguagerulename(language);\n+            map.setLanguagepattern(pattern);\n+            jaxbObject.getBody().getMaprules().getLanguagemap().add(map);\n+            Languagerule lr = new Languagerule();\n+            lr.setLanguagerulename(language);\n+            jaxbObject.getBody().getLanguagerules().getLanguagerule().add(lr);\n+            for (Rule rule : mr.getRules()) {\n+                gen.core.segmentation.Rule jaxbRule = factory.createRule();\n+                lr.getRule().add(jaxbRule);\n+                jaxbRule.setBreak(rule.isBreakRule() ? \"yes\" : \"no\");\n+                if (rule.getBeforebreak() != null) {\n+                    jaxbRule.setBeforebreak(factory.createBeforebreak());\n+                    jaxbRule.getBeforebreak().setContent(rule.getBeforebreak());\n+                }\n+                if (rule.getAfterbreak() != null) {\n+                    jaxbRule.setAfterbreak(factory.createAfterbreak());\n+                    jaxbRule.getAfterbreak().setContent(rule.getAfterbreak());\n+                }\n+            }\n+        }\n+\n+        try (FileOutputStream fos = new FileOutputStream(outFile)) {\n+            mapper.writerWithDefaultPrettyPrinter().writeValue(fos, jaxbObject);\n+        } catch (DatabindException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    public static @Nullable SRX loadSrxFile(URI rulesUri) {\n+        try (InputStream inputStream = Files.newInputStream(Paths.get(rulesUri))) {\n+            return loadSrxInputStream(inputStream);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error loading segmentation rules from file: \" + rulesUri, e);\n+        }\n+        return null;\n+    }\n+\n+    static SRX loadSrxInputStream(InputStream io) throws IOException {\n+        Srx srx = mapper.readValue(io, Srx.class);\n+        final Map<String, List<Rule>> mapping = new HashMap<>();\n+        List<Languagerule> languageRuleList = srx.getBody().getLanguagerules().getLanguagerule();\n+        for (Languagerule languagerule : languageRuleList) {\n+            mapping.put(languagerule.getLanguagerulename(),\n+                    languagerule.getRule().stream().map(Rule::new).toList());\n+        }\n+        SRX res = new SRX();\n+        res.setSegmentSubflows(!\"no\".equalsIgnoreCase(srx.getHeader().getSegmentsubflows()));\n+        res.setCascade(!\"no\".equalsIgnoreCase(srx.getHeader().getCascade()));\n+        res.setVersion(srx.getVersion());\n+        res.setMappingRules(srx.getBody().getMaprules().getLanguagemap().stream()\n+                .map(languagemap -> new MapRule(languagemap, mapping.get(languagemap.getLanguagerulename())))\n+                .toList());\n+        return res;\n+    }\n+}\ndiff --git a/src/test/java/org/omegat/core/segmentation/SegmentationConfMigratorTest.java b/src/test/java/org/omegat/core/segmentation/SegmentationConfMigratorTest.java\nindex d48af6d..7c33251 100644\n--- a/src/test/java/org/omegat/core/segmentation/SegmentationConfMigratorTest.java\n+++ b/src/test/java/org/omegat/core/segmentation/SegmentationConfMigratorTest.java\n@@ -30,6 +30,7 @@\n import org.junit.experimental.runners.Enclosed;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n+import org.omegat.util.SRXUtils;\n import org.omegat.util.ValidationResult;\n \n import java.io.File;\n@@ -107,7 +108,7 @@ public static void testSrxMigration(File segmentConf, File configDir) {\n         // load from srx file\n         assertTrue(segmentSrx.exists());\n         assertTrue(segmentSrx.isFile());\n-        SRX srx1 = SRX.loadSrxFile(segmentSrx.toURI());\n+        SRX srx1 = SRXUtils.loadSrxFile(segmentSrx.toURI());\n         assertNotNull(srx1);\n         mapRuleList = srx1.getMappingRules();\n         assertNotNull(mapRuleList);\ndiff --git a/src/test/java/org/omegat/util/SRXUtilsTest.java b/src/test/java/org/omegat/util/SRXUtilsTest.java\nnew file mode 100644\nindex 0000000..051a141\n--- /dev/null\n+++ b/src/test/java/org/omegat/util/SRXUtilsTest.java\n@@ -0,0 +1,92 @@\n+/*\n+ OmegaT - Computer Assisted Translation (CAT) tool\n+          with fuzzy matching, translation memory, keyword search,\n+          glossaries, and translation leveraging into updated projects.\n+\n+ Copyright (C) 2026 Hiroshi Miura\n+               Home page: https://www.omegat.org/\n+               Support center: https://omegat.org/support\n+\n+ This file is part of OmegaT.\n+\n+ OmegaT is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation, either version 3 of the License, or\n+ (at your option) any later version.\n+\n+ OmegaT is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+package org.omegat.util;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.omegat.core.segmentation.SRX;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Unit tests for the {@link SRXUtils#getDefault()} method.\n+ * This method loads the default segmentation rules and configures the SRX object accordingly.\n+ */\n+public class SRXUtilsTest {\n+\n+    /**\n+     * Test that the {@link SRXUtils#getDefault()} method successfully loads the default SRX object.\n+     */\n+    @Test\n+    public void testGetDefaultLoadsSRXSuccessfully() throws IOException {\n+        SRX srx = SRXUtils.getDefault();\n+        Assert.assertNotNull(\"The SRX object should not be null.\", srx);\n+    }\n+\n+    /**\n+     * Test that the {@link SRXUtils#getDefault()} method sets includeEndingTags to true.\n+     */\n+    @Test\n+    public void testGetDefaultIncludeEndingTagsIsTrue() throws IOException {\n+        SRX srx = SRXUtils.getDefault();\n+        Assert.assertTrue(\"The includeEndingTags property should be true.\", srx.isIncludeEndingTags());\n+    }\n+\n+    /**\n+     * Test that the {@link SRXUtils#getDefault()} method sets segmentSubflows to true.\n+     */\n+    @Test\n+    public void testGetDefaultSegmentSubflowsIsTrue() throws IOException {\n+        SRX srx = SRXUtils.getDefault();\n+        Assert.assertTrue(\"The segmentSubflows property should be true.\", srx.isSegmentSubflows());\n+    }\n+\n+    /**\n+     * Test that the {@link SRXUtils#getDefault()} method returns an SRX object with a non-null and non-empty version string.\n+     */\n+    @Test\n+    public void testGetDefaultVersion() throws IOException {\n+        SRX srx = SRXUtils.getDefault();\n+        Assert.assertEquals(\"The SRX version should be 2.0.\", \"2.0\", srx.getVersion());\n+    }\n+\n+    /**\n+     * Test that the {@link SRXUtils#getDefault()} method returns an SRX object with non-null mapping rules.\n+     */\n+    @Test\n+    public void testGetDefaultMappingRulesIsNotNull() throws IOException {\n+        SRX srx = SRXUtils.getDefault();\n+        Assert.assertNotNull(\"The mapping rules should not be null.\", srx.getMappingRules());\n+    }\n+\n+    /**\n+     * Test that the {@link SRXUtils#getDefault()} method returns an SRX object with mapping rules containing at least one rule.\n+     */\n+    @Test\n+    public void testGetDefaultMappingRulesHas18() throws IOException {\n+        SRX srx = SRXUtils.getDefault();\n+        Assert.assertEquals(\"The mapping rules should contain at least one rule.\", 18, srx.getMappingRules().size());\n+    }\n+}\n\\ No newline at end of file\n"
test_patch: ''
fail_to_pass: []
pass_to_pass: []
install_config:
  install: ./mvnw -q -DskipTests package
  java: '21'
  test_cmd: ./mvnw test
meta:
  added_lines: '301'
  difficulty: medium
  files_changed: '6'
  pr_title: 'feat: extract SRX utility methods to new `SRXUtils` class, add XML serialization and deserialization tests'
  removed_lines: '159'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  omegat-org/segmentation-migrator (#32): feat: extract SRX utility methods to new `SRXUtils` class, add XML serialization and deserialization tests

  Extract reusable SRX-related utility behavior into a dedicated utility class and ensure SRX XML serialization and deserialization are covered by automated tests. The library should correctly read and write SRX XML, and the new utility access should not change external behavior.
original_pr_body: |-
  omegat-org/segmentation-migrator (#32): feat: extract SRX utility methods to new `SRXUtils` class, add XML serialization and deserialization tests

  (no description)
quality_score: 0.55
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
