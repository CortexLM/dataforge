id: markuplint/markuplint-3177
repo: markuplint/markuplint
base_commit: 5e20e76166113807b21a6cf8fe33fca599ad72e0
merge_commit: 525218c48db48b0a7198ccc45c65eeb8e1f24058
language: typescript
difficulty_score: 3
created_at: 2026-02-14T12:49:57.857612313Z
patch: "diff --git a/config.schema.json b/config.schema.json\nindex a28900203a..ffc6a8e30a 100644\n--- a/config.schema.json\n+++ b/config.schema.json\n@@ -133,21 +133,10 @@\n \t\t\t}\n \t\t},\n \t\t\"specs\": {\n-\t\t\t\"oneOf\": [\n-\t\t\t\t{\n-\t\t\t\t\t\"type\": \"object\",\n-\t\t\t\t\t\"additionalProperties\": {\n-\t\t\t\t\t\t\"type\": \"string\"\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\t\t\t\t{\n-\t\t\t\t\t\"description\": \"This format is deprecated\",\n-\t\t\t\t\t\"type\": \"array\",\n-\t\t\t\t\t\"items\": {\n-\t\t\t\t\t\t\"type\": \"string\"\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t]\n+\t\t\t\"type\": \"object\",\n+\t\t\t\"additionalProperties\": {\n+\t\t\t\t\"type\": \"string\"\n+\t\t\t}\n \t\t},\n \t\t\"nodeRules\": {\n \t\t\t\"type\": \"array\",\ndiff --git a/docs/migration/v4-v5/config.ja.md b/docs/migration/v4-v5/config.ja.md\nindex a6f6a521ad..90a38666ea 100644\n--- a/docs/migration/v4-v5/config.ja.md\n+++ b/docs/migration/v4-v5/config.ja.md\n@@ -12,6 +12,9 @@\n | 新しい `ruleCommonSettings` 設定プロパティ | 設定ファイル |\n | ARIA バージョンの解決優先度の変更 | `ariaVersion` / `version` オプションを使用するルール |\n | ARIA 1.3 サポートの追加 | `ariaVersion` / `version` オプションを使用するルール |\n+| ルールの配列値が連結から上書きに変更 | `extends` で配列ルール値を使用する設定ファイル |\n+| ルール options が deep merge から shallow merge に変更 | `extends` でネストされた options を使用する設定ファイル |\n+| Pretender の `data` 配列が上書きから追加に変更 | `extends` で pretenders を使用する設定ファイル |\n \n ## `ruleCommonSettings`\n \n@@ -104,6 +107,72 @@ const ariaVersion =\n \n `document.ruleCommonSettings` は、ルールの `verify()` コールバックに渡される `MLDocument` インスタンスで利用可能です。\n \n+## マージ動作の変更\n+\n+v5 ではマージアルゴリズムが変更されました。これらの変更は `extends` を使用して設定を結合する際に影響します。\n+\n+### ルールの配列値: 連結から上書きに変更\n+\n+**v4:** 2つの設定をマージする際、配列のルール値は連結されていました。\n+\n+```json\n+// ベース設定\n+{ \"rules\": { \"allowed-tags\": [\"div\", \"span\"] } }\n+// オーバーライド設定\n+{ \"rules\": { \"allowed-tags\": [\"section\", \"article\"] } }\n+// v4 の結果: [\"div\", \"span\", \"section\", \"article\"]\n+```\n+\n+**v5:** 配列のルール値は上書きされます（右辺優先）。ESLint や Biome と一貫した動作です。\n+\n+```json\n+// v5 の結果: [\"section\", \"article\"]\n+```\n+\n+**移行方法:** 配列の連結に依存していた場合は、単一の設定内で手動で値を統合してください:\n+\n+```json\n+{ \"rules\": { \"allowed-tags\": [\"div\", \"span\", \"section\", \"article\"] } }\n+```\n+\n+### ルール options: Deep Merge から Shallow Merge に変更\n+\n+**v4:** ルール options は `deepmerge` ライブラリを使用して deep merge されていました。\n+\n+```json\n+// ベース設定\n+{ \"rules\": { \"my-rule\": { \"options\": { \"nested\": { \"a\": 1, \"b\": 2 } } } } }\n+// オーバーライド設定\n+{ \"rules\": { \"my-rule\": { \"options\": { \"nested\": { \"b\": 3 } } } } }\n+// v4 の結果 options: { \"nested\": { \"a\": 1, \"b\": 3 } }\n+```\n+\n+**v5:** ルール options は shallow merge（`{...a, ...b}`）を使用します。ネストされたオブジェクトは完全に置き換えられます。\n+\n+```json\n+// v5 の結果 options: { \"nested\": { \"b\": 3 } }\n+```\n+\n+**移行方法:** ネストされたオプションオブジェクトの deep merge に依存していた場合は、オーバーライド側で完全なオブジェクトを指定してください:\n+\n+```json\n+{ \"rules\": { \"my-rule\": { \"options\": { \"nested\": { \"a\": 1, \"b\": 3 } } } } }\n+```\n+\n+### Pretender `data` 配列: 上書きから追加に変更\n+\n+**v4:** Pretender の `data` 配列は上書きされていました（右辺優先）。\n+\n+**v5:** Pretender の `data` 配列は追加（連結）されるようになりました。`files` と `imports` は引き続き上書きされます。\n+\n+| プロパティ | v4 の動作 | v5 の動作 |\n+| ---------- | --------- | --------- |\n+| `files`    | 上書き    | 上書き    |\n+| `imports`  | 上書き    | 上書き    |\n+| `data`     | 上書き    | 追加      |\n+\n+**移行方法:** これは一般的に非破壊的な改善です。pretender データを完全に置き換える必要がある場合は、`extends` を使用せず、単一の設定ですべての pretenders を定義してください。\n+\n ## ARIA 1.3 サポート\n \n v5 では `ariaVersion` の有効な値として `\"1.3\"` が追加されました。デフォルトは `\"1.2\"` のままなので、既存の設定への影響はありません。ARIA 1.3 では `generic` ロールの透過性や `image`/`img` ロールの同義語など、重要な動作変更が導入されています。詳細は [ARIA 移行ガイド](./aria.ja.md)を参照してください。\ndiff --git a/docs/migration/v4-v5/config.md b/docs/migration/v4-v5/config.md\nindex a8b38b338a..301910680b 100644\n--- a/docs/migration/v4-v5/config.md\n+++ b/docs/migration/v4-v5/config.md\n@@ -12,6 +12,9 @@\n | New `ruleCommonSettings` config property | Config files |\n | ARIA version resolution priority changed | Rules using `ariaVersion` / `version` option |\n | ARIA 1.3 support added | Rules using `ariaVersion` / `version` option |\n+| Rule array values now override instead of concatenate | Config files using `extends` with array rule values |\n+| Rule options now use shallow merge instead of deep merge | Config files using `extends` with nested option objects |\n+| Pretender `data` arrays now append instead of override | Config files using `extends` with pretenders |\n \n ## `ruleCommonSettings`\n \n@@ -104,6 +107,72 @@ const ariaVersion =\n \n `document.ruleCommonSettings` is available on the `MLDocument` instance passed to rule `verify()` callbacks.\n \n+## Merge Behavior Changes\n+\n+The merge algorithm has changed in v5. These changes affect how configurations are combined when using `extends`.\n+\n+### Rule Array Values: Override Instead of Concatenate\n+\n+**v4:** Array rule values were concatenated when merging two configs.\n+\n+```json\n+// base config\n+{ \"rules\": { \"allowed-tags\": [\"div\", \"span\"] } }\n+// override config\n+{ \"rules\": { \"allowed-tags\": [\"section\", \"article\"] } }\n+// v4 result: [\"div\", \"span\", \"section\", \"article\"]\n+```\n+\n+**v5:** Array rule values are overridden (right-side wins), consistent with ESLint and Biome.\n+\n+```json\n+// v5 result: [\"section\", \"article\"]\n+```\n+\n+**Migration:** If you relied on array concatenation, manually combine the values into a single config:\n+\n+```json\n+{ \"rules\": { \"allowed-tags\": [\"div\", \"span\", \"section\", \"article\"] } }\n+```\n+\n+### Rule Options: Shallow Merge Instead of Deep Merge\n+\n+**v4:** Rule options were deep-merged using the `deepmerge` library.\n+\n+```json\n+// base config\n+{ \"rules\": { \"my-rule\": { \"options\": { \"nested\": { \"a\": 1, \"b\": 2 } } } } }\n+// override config\n+{ \"rules\": { \"my-rule\": { \"options\": { \"nested\": { \"b\": 3 } } } } }\n+// v4 result options: { \"nested\": { \"a\": 1, \"b\": 3 } }\n+```\n+\n+**v5:** Rule options use shallow merge (`{...a, ...b}`). Nested objects are replaced entirely.\n+\n+```json\n+// v5 result options: { \"nested\": { \"b\": 3 } }\n+```\n+\n+**Migration:** If you relied on deep merge for nested option objects, provide the full object in the override:\n+\n+```json\n+{ \"rules\": { \"my-rule\": { \"options\": { \"nested\": { \"a\": 1, \"b\": 3 } } } } }\n+```\n+\n+### Pretender `data` Arrays: Append Instead of Override\n+\n+**v4:** Pretender `data` arrays were overridden (right-side wins).\n+\n+**v5:** Pretender `data` arrays are appended (concatenated), while `files` and `imports` continue to be overridden.\n+\n+| Property  | v4 Behavior | v5 Behavior |\n+| --------- | ----------- | ----------- |\n+| `files`   | Override    | Override    |\n+| `imports` | Override    | Override    |\n+| `data`    | Override    | Append      |\n+\n+**Migration:** This is generally a non-breaking improvement. If you need to replace pretender data entirely, avoid using `extends` and define all pretenders in a single config.\n+\n ## ARIA 1.3 Support\n \n v5 adds `\"1.3\"` as a valid value for `ariaVersion`. The default remains `\"1.2\"`, so existing configs are unaffected. ARIA 1.3 introduces significant behavioral changes such as `generic` role transparency and the `image`/`img` role synonym. See the [ARIA migration guide](./aria.md) for full details.\ndiff --git a/packages/@markuplint/file-resolver/test/fixtures/002/.markuplintrc.json b/packages/@markuplint/file-resolver/test/fixtures/002/.markuplintrc.json\nindex d6a816af88..381cfd12f2 100644\n--- a/packages/@markuplint/file-resolver/test/fixtures/002/.markuplintrc.json\n+++ b/packages/@markuplint/file-resolver/test/fixtures/002/.markuplintrc.json\n@@ -24,7 +24,7 @@\n \t\t},\n \t\t\"rule__custom-setting-with-detail-option\": {\n \t\t\t\"value\": \"VALUE\",\n-\t\t\t\"option\": {\n+\t\t\t\"options\": {\n \t\t\t\t\"OPTIONAL_PROP\": \"OPTIONAL_VALUE\"\n \t\t\t}\n \t\t},\ndiff --git a/packages/@markuplint/file-resolver/test/fixtures/003/.markuplintrc b/packages/@markuplint/file-resolver/test/fixtures/003/.markuplintrc\nindex ac2cb68c69..8d116fb755 100644\n--- a/packages/@markuplint/file-resolver/test/fixtures/003/.markuplintrc\n+++ b/packages/@markuplint/file-resolver/test/fixtures/003/.markuplintrc\n@@ -13,7 +13,7 @@\n \t\t},\n \t\t\"rule__custom-setting-with-detail-option\": {\n \t\t\t\"value\": \"VALUE\",\n-\t\t\t\"option\": {\n+\t\t\t\"options\": {\n \t\t\t\t\"OPTIONAL_PROP\": \"CHANGED_OPTIONAL_VALUE\"\n \t\t\t}\n \t\t},\ndiff --git a/packages/@markuplint/ml-config/ARCHITECTURE.ja.md b/packages/@markuplint/ml-config/ARCHITECTURE.ja.md\nindex cda4861820..67824c0454 100644\n--- a/packages/@markuplint/ml-config/ARCHITECTURE.ja.md\n+++ b/packages/@markuplint/ml-config/ARCHITECTURE.ja.md\n@@ -124,21 +124,21 @@ flowchart TD\n \n ### プロパティ別マージ戦略テーブル\n \n-| プロパティ       | 戦略                    | ヘルパー関数                                         | 詳細                                          |\n-| ---------------- | ----------------------- | ---------------------------------------------------- | --------------------------------------------- |\n-| `plugins`        | 結合+重複排除+正規化    | `concatArray(uniquely=true, comparePropName='name')` | 同名プラグインは settings を deep merge       |\n-| `parser`         | オブジェクト deep merge | `mergeObject()`                                      | 右辺優先、deepmerge ライブラリ使用            |\n-| `parserOptions`  | オブジェクト deep merge | `mergeObject()`                                      | 同上                                          |\n-| `specs`          | オブジェクト deep merge | `mergeObject()`                                      | 同上                                          |\n-| `excludeFiles`   | 結合+重複排除           | `concatArray(uniquely=true)`                         | 単純な値の重複排除                            |\n-| `severity`       | オブジェクト deep merge | `mergeObject()`                                      | parser と同様                                 |\n-| `pretenders`     | 形式変換+deep merge     | `mergePretenders()`                                  | 配列を PretenderDetails に変換後にマージ      |\n-| `rules`          | ルール別マージ          | `mergeRules()` → `mergeRule()`                       | **最も複雑 -- 次節で詳述**                    |\n-| `nodeRules`      | 結合（重複排除なし）    | `concatArray()`                                      | 両配列を単純連結                              |\n-| `childNodeRules` | 結合（重複排除なし）    | `concatArray()`                                      | nodeRules と同様                              |\n-| `overrideMode`   | 右辺優先                | `b.overrideMode ?? a.overrideMode`                   | 単純な優先順位                                |\n-| `overrides`      | キー別再帰マージ        | `mergeOverrides()`                                   | 各キーに対して `mergeConfig()` を再帰呼び出し |\n-| `extends`        | 結合→削除               | `concatArray()`                                      | マージ後に結果から削除                        |\n+| プロパティ       | 戦略                       | ヘルパー関数                                         | 詳細                                          |\n+| ---------------- | -------------------------- | ---------------------------------------------------- | --------------------------------------------- |\n+| `plugins`        | 結合+重複排除+正規化       | `concatArray(uniquely=true, comparePropName='name')` | 同名プラグインは settings を shallow merge    |\n+| `parser`         | オブジェクト shallow merge | `mergeObject()`                                      | `{...a, ...b}` で右辺優先                     |\n+| `parserOptions`  | オブジェクト shallow merge | `mergeObject()`                                      | 同上                                          |\n+| `specs`          | オブジェクト shallow merge | `mergeObject()`                                      | 同上                                          |\n+| `excludeFiles`   | 結合+重複排除              | `concatArray(uniquely=true)`                         | 単純な値の重複排除                            |\n+| `severity`       | オブジェクト shallow merge | `mergeObject()`                                      | parser と同様                                 |\n+| `pretenders`     | セマンティックマージ       | `mergePretenders()`                                  | files/imports: 上書き、data: 追加             |\n+| `rules`          | ルール別マージ             | `mergeRules()` → `mergeRule()`                       | **最も複雑 -- 次節で詳述**                    |\n+| `nodeRules`      | 結合（重複排除なし）       | `concatArray()`                                      | 両配列を単純連結                              |\n+| `childNodeRules` | 結合（重複排除なし）       | `concatArray()`                                      | nodeRules と同様                              |\n+| `overrideMode`   | 右辺優先                   | `b.overrideMode ?? a.overrideMode`                   | 単純な優先順位                                |\n+| `overrides`      | キー別再帰マージ           | `mergeOverrides()`                                   | 各キーに対して `mergeConfig()` を再帰呼び出し |\n+| `extends`        | 結合→削除                  | `concatArray()`                                      | マージ後に結果から削除                        |\n \n ### mergeRule() -- ルールマージの詳細\n \n@@ -146,7 +146,7 @@ flowchart TD\n mergeRule(a: Nullable<AnyRule>, b: AnyRule): AnyRule\n ```\n \n-最も複雑なマージロジックを処理する関数です。両方の入力はまず `optimizeRule()` で正規化されます（非推奨の `option` から `options` への移行を含む）。\n+最も複雑なマージロジックを処理する関数です。両方の入力はまず `optimizeRule()` で正規化されます。\n \n ```mermaid\n flowchart TD\n@@ -159,18 +159,16 @@ flowchart TD\n     ChkBUndef -->|Yes| RetA[\"return a\"]\n     ChkBUndef -->|No| ChkBVal{\"b は Value?\\n(primitive/null/array)\"}\n     ChkBVal -->|Yes| ChkAVal{\"a は Value?\"}\n-    ChkAVal -->|Yes| ChkBothArr{\"両方とも配列?\"}\n-    ChkBothArr -->|Yes| RetConcat[\"return [...a, ...b]\\n(連結)\"]\n-    ChkBothArr -->|No| RetBVal[\"return b\\n(右辺優先)\"]\n-    ChkAVal -->|No| MergeValObj[\"a の severity/reason を保持\\nvalue を置換\\n(配列は連結)\"]\n+    ChkAVal -->|Yes| RetBVal[\"return b\\n(右辺優先、\\n配列も上書き)\"]\n+    ChkAVal -->|No| MergeValObj[\"a の severity/reason を保持\\nvalue を b で上書き\"]\n     ChkBVal -->|No| MergeObj[\"severity: b ?? a\\nvalue: b ?? a\\noptions: mergeObject(a, b)\\nreason: b ?? a\"]\n ```\n \n **重要な設計判断:**\n \n 1. **`false` は絶対無効化** -- override が `false`（または `{value: false}`）なら、base が何であっても結果は常に `false`\n-2. **配列値は連結** -- `[\"a\",\"b\"]` + `[\"c\",\"d\"]` は `[\"a\",\"b\",\"c\",\"d\"]` になり、extends チェーンでルールを段階的に追加可能\n-3. **options は deep merge** -- severity、value、reason は右辺優先だが、options のみ `mergeObject()`（deepmerge ライブラリによる deep merge）を使用\n+2. **配列値は上書き** -- `[\"a\",\"b\"]` + `[\"c\",\"d\"]` は `[\"c\",\"d\"]` になる（右辺優先）。ESLint や Biome と一貫した動作\n+3. **options は shallow merge** -- severity、value、reason は右辺優先だが、options のみ `mergeObject()`（`{...a, ...b}` による shallow merge）を使用\n \n ### ヘルパー関数\n \n@@ -180,12 +178,12 @@ flowchart TD\n \n - `uniquely=false` -- 単純な連結、重複排除なし\n - `uniquely=true`、`comparePropName` なし -- 完全一致で重複排除\n-- `uniquely=true`、`comparePropName` あり -- 指定プロパティ名で重複排除。同名オブジェクトは `mergeObject()` でマージ（例: プラグインの settings）\n+- `uniquely=true`、`comparePropName` あり -- 指定プロパティ名で重複排除。同名オブジェクトはオブジェクトスプレッドで shallow merge（例: プラグインの settings）\n - 空の結果には `undefined` を返す\n \n #### mergeObject(a, b)\n \n-`deepmerge` ライブラリを使用した再帰的な deep merge。右辺の値が優先。結果から undefined プロパティを除去。\n+`{...a, ...b}` による shallow merge。トップレベルで右辺の値が優先。結果から undefined プロパティを除去。\n \n #### mergeOverrides(a, b)\n \n@@ -193,7 +191,7 @@ flowchart TD\n \n #### mergePretenders(a, b)\n \n-配列形式の pretenders を正規化形式 `PretenderDetails`（`{data: [...]}`）に変換してから `mergeObject()` で deep merge。\n+配列形式の pretenders を正規化形式 `PretenderDetails`（`{data: [...]}`）に変換してからセマンティックマージ: `files`/`imports` は上書き（右辺優先）、`data` は追加（連結）。\n \n ## テンプレートレンダリングシステム\n \n@@ -217,11 +215,11 @@ Mustache テンプレート文字列を提供されたデータでレンダリ\n \n ## ユーティリティ関数\n \n-| 関数                  | 目的                                                                                                     |\n-| --------------------- | -------------------------------------------------------------------------------------------------------- |\n-| `cleanOptions()`      | 非推奨の `option` フィールドを `options` に正規化し、標準フィールドを抽出して undefined プロパティを除去 |\n-| `isRuleConfigValue()` | 型ガード: プリミティブ、`null`、配列（= `RuleConfig` オブジェクトではない）に対して `true` を返す        |\n-| `deleteUndefProp()`   | プレーンオブジェクトから `undefined` 値のプロパティをすべて in-place で削除                              |\n+| 関数                  | 目的                                                                                              |\n+| --------------------- | ------------------------------------------------------------------------------------------------- |\n+| `cleanOptions()`      | 標準フィールド（`severity`、`value`、`options`、`reason`）を抽出して undefined プロパティを除去   |\n+| `isRuleConfigValue()` | 型ガード: プリミティブ、`null`、配列（= `RuleConfig` オブジェクトではない）に対して `true` を返す |\n+| `deleteUndefProp()`   | プレーンオブジェクトから `undefined` 値のプロパティをすべて in-place で削除                       |\n \n ## 主要ソースファイル\n \n@@ -239,7 +237,6 @@ Mustache テンプレート文字列を提供されたデータでレンダリ\n | `@markuplint/ml-ast`   | `ParserOptions` 型（型のみ）                        |\n | `@markuplint/selector` | `RegexSelector` 型（再エクスポート）                |\n | `@markuplint/shared`   | `Nullable` ユーティリティ型                         |\n-| `deepmerge`            | `mergeObject()` の deep merge 実装                  |\n | `is-plain-object`      | `deleteUndefProp()` でのプレーンオブジェクト判定    |\n | `mustache`             | `provideValue()` のテンプレートレンダリングエンジン |\n | `type-fest`            | `Writable` ユーティリティ型                         |\n@@ -277,6 +274,41 @@ flowchart LR\n - **`@markuplint/ml-core`** -- マージ済みの `OptimizedConfig` を受け取り、パース済みドキュメントにルールを適用\n - **`@markuplint/rules`** -- `Rule<T,O>` と `RuleConfig<T,O>` 型を使用してルール実装を定義\n \n+## 設計判断\n+\n+### Flat Config を採用しない理由\n+\n+ESLint の Flat Config アプローチを評価した結果、markuplint には不適と判断しました:\n+\n+- **ESLint 自体が 2025年3月に Flat Config へ `extends` を再追加** -- 純粋な Flat アプローチは JavaScript ツールでも不十分だった\n+- **markuplint は JSON ベース** -- Flat Config は JavaScript を前提とする。HTML/マークアップ開発者（主要ユーザー層）にとって、JSON のスキーマ検証と言語非依存性は大きなメリット\n+- **markuplint の `nodeRules`/`childNodeRules` は CSS セレクタベース** -- Flat Config のファイルパターンモデルに対応する仕組みがない\n+- **ESLint v9 への移行はコミュニティに大きな痛みを与えた** -- 段階的な移行には自動化ツールと数年のエコシステム適応が必要だった\n+\n+**結論:** JSON ベースの `extends` マージ戦略の改善が markuplint にとって最適なアプローチ。\n+\n+### マージ戦略の原則\n+\n+配列の扱いには論理的な区別があります:\n+\n+| 配列の種類                     | 例                                     | マージ動作 | 根拠                   |\n+| ------------------------------ | -------------------------------------- | ---------- | ---------------------- |\n+| **トップレベルのコレクション** | `plugins`, `excludeFiles`, `nodeRules` | 累積       | 独立したアイテムの集合 |\n+| **ルール値**                   | `[\"allowed-tag-1\", \"allowed-tag-2\"]`   | 上書き     | 1つのルールの設定値    |\n+\n+これは ESLint と Biome の動作と一貫しており、ルール値はより具体的な設定で常に上書きされます。\n+\n+### Deep Merge ではなく Shallow Merge\n+\n+| ツール     | ルール options のマージ       | 根拠                                                                       |\n+| ---------- | ----------------------------- | -------------------------------------------------------------------------- |\n+| ESLint     | 完全リプレース                | 最もシンプルだが驚きがある                                                 |\n+| Biome      | Deep merge（Merge trait経由） | 完全な柔軟性、高い複雑性                                                   |\n+| markuplint | **Shallow merge**             | 中間地点: トップレベルのキーはマージ、ネストされたオブジェクトはリプレース |\n+\n+`deepmerge` ライブラリを削除し、シンプルなオブジェクトスプレッド（`{...a, ...b}`）に置き換えました。markuplint の設定でマージされるすべてのオブジェクト（parser、specs、parserOptions、severity、プラグイン設定、ルールオプション）はフラットなキーバリューマップであるため、これで十分です。\n+\n ## ドキュメントマップ\n \n+- [マイグレーションガイド](../../docs/migration/v4-v5/config.ja.md) -- メジャーバージョン間の破壊的変更\n - [メンテナンスガイド](docs/maintenance.ja.md) -- コマンド、レシピ、トラブルシューティング\ndiff --git a/packages/@markuplint/ml-config/ARCHITECTURE.md b/packages/@markuplint/ml-config/ARCHITECTURE.md\nindex 9963dc9bf9..3614403bf5 100644\n--- a/packages/@markuplint/ml-config/ARCHITECTURE.md\n+++ b/packages/@markuplint/ml-config/ARCHITECTURE.md\n@@ -124,21 +124,21 @@ flowchart TD\n \n ### Per-Property Merge Strategy Table\n \n-| Property         | Strategy                         | Helper Function                                      | Details                                           |\n-| ---------------- | -------------------------------- | ---------------------------------------------------- | ------------------------------------------------- |\n-| `plugins`        | Concat + deduplicate + normalize | `concatArray(uniquely=true, comparePropName='name')` | Same-name plugins have their settings deep-merged |\n-| `parser`         | Object deep merge                | `mergeObject()`                                      | Right-side wins, uses deepmerge library           |\n-| `parserOptions`  | Object deep merge                | `mergeObject()`                                      | Same as above                                     |\n-| `specs`          | Object deep merge                | `mergeObject()`                                      | Same as above                                     |\n-| `excludeFiles`   | Concat + deduplicate             | `concatArray(uniquely=true)`                         | Simple value deduplication                        |\n-| `severity`       | Object deep merge                | `mergeObject()`                                      | Same as parser                                    |\n-| `pretenders`     | Format conversion + deep merge   | `mergePretenders()`                                  | Array converted to PretenderDetails, then merged  |\n-| `rules`          | Per-rule merge                   | `mergeRules()` then `mergeRule()`                    | **Most complex -- see next section**              |\n-| `nodeRules`      | Concat (no deduplicate)          | `concatArray()`                                      | Both arrays simply concatenated                   |\n-| `childNodeRules` | Concat (no deduplicate)          | `concatArray()`                                      | Same as nodeRules                                 |\n-| `overrideMode`   | Right-side wins                  | `b.overrideMode ?? a.overrideMode`                   | Simple precedence                                 |\n-| `overrides`      | Per-key recursive merge          | `mergeOverrides()`                                   | Calls `mergeConfig()` recursively for each key    |\n-| `extends`        | Concat then delete               | `concatArray()`                                      | Removed from result after merge                   |\n+| Property         | Strategy                         | Helper Function                                      | Details                                              |\n+| ---------------- | -------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |\n+| `plugins`        | Concat + deduplicate + normalize | `concatArray(uniquely=true, comparePropName='name')` | Same-name plugins have their settings shallow-merged |\n+| `parser`         | Object shallow merge             | `mergeObject()`                                      | Right-side wins via `{...a, ...b}`                   |\n+| `parserOptions`  | Object shallow merge             | `mergeObject()`                                      | Same as above                                        |\n+| `specs`          | Object shallow merge             | `mergeObject()`                                      | Same as above                                        |\n+| `excludeFiles`   | Concat + deduplicate             | `concatArray(uniquely=true)`                         | Simple value deduplication                           |\n+| `severity`       | Object shallow merge             | `mergeObject()`                                      | Same as parser                                       |\n+| `pretenders`     | Semantic merge                   | `mergePretenders()`                                  | files/imports: override, data: append                |\n+| `rules`          | Per-rule merge                   | `mergeRules()` then `mergeRule()`                    | **Most complex -- see next section**                 |\n+| `nodeRules`      | Concat (no deduplicate)          | `concatArray()`                                      | Both arrays simply concatenated                      |\n+| `childNodeRules` | Concat (no deduplicate)          | `concatArray()`                                      | Same as nodeRules                                    |\n+| `overrideMode`   | Right-side wins                  | `b.overrideMode ?? a.overrideMode`                   | Simple precedence                                    |\n+| `overrides`      | Per-key recursive merge          | `mergeOverrides()`                                   | Calls `mergeConfig()` recursively for each key       |\n+| `extends`        | Concat then delete               | `concatArray()`                                      | Removed from result after merge                      |\n \n ### mergeRule() -- Rule Merge Details\n \n@@ -146,7 +146,7 @@ flowchart TD\n mergeRule(a: Nullable<AnyRule>, b: AnyRule): AnyRule\n ```\n \n-This function handles the most complex merge logic. Both inputs are first normalized via `optimizeRule()` (which handles the deprecated `option` to `options` migration).\n+This function handles the most complex merge logic. Both inputs are first normalized via `optimizeRule()`.\n \n ```mermaid\n flowchart TD\n@@ -159,18 +159,16 @@ flowchart TD\n     ChkBUndef -->|Yes| RetA[\"return a\"]\n     ChkBUndef -->|No| ChkBVal{\"b is Value?\\n(primitive/null/array)\"}\n     ChkBVal -->|Yes| ChkAVal{\"a is Value?\"}\n-    ChkAVal -->|Yes| ChkBothArr{\"Both arrays?\"}\n-    ChkBothArr -->|Yes| RetConcat[\"return [...a, ...b]\\n(concatenate)\"]\n-    ChkBothArr -->|No| RetBVal[\"return b\\n(right-side wins)\"]\n-    ChkAVal -->|No| MergeValObj[\"Keep a's severity/reason\\nReplace value\\n(arrays concatenated)\"]\n+    ChkAVal -->|Yes| RetBVal[\"return b\\n(right-side wins,\\narrays override)\"]\n+    ChkAVal -->|No| MergeValObj[\"Keep a's severity/reason\\nOverride value with b\"]\n     ChkBVal -->|No| MergeObj[\"severity: b ?? a\\nvalue: b ?? a\\noptions: mergeObject(a, b)\\nreason: b ?? a\"]\n ```\n \n **Key Design Decisions:**\n \n 1. **`false` is absolute disable** -- If the override is `false` (or `{value: false}`), the result is always `false`, regardless of what the base config says\n-2. **Array values are concatenated** -- `[\"a\",\"b\"]` + `[\"c\",\"d\"]` results in `[\"a\",\"b\",\"c\",\"d\"]`, enabling incremental rule additions across extends chains\n-3. **options uses deep merge** -- While severity, value, and reason use right-side-wins precedence, options alone uses `mergeObject()` (deep merge via deepmerge library)\n+2. **Array values override** -- `[\"a\",\"b\"]` + `[\"c\",\"d\"]` results in `[\"c\",\"d\"]` (right-side wins), consistent with ESLint and Biome behavior\n+3. **options uses shallow merge** -- While severity, value, and reason use right-side-wins precedence, options uses `mergeObject()` (shallow merge via `{...a, ...b}`)\n \n ### Helper Functions\n \n@@ -180,12 +178,12 @@ Concatenates two arrays with optional deduplication:\n \n - `uniquely=false` -- Simple concatenation, no deduplication\n - `uniquely=true`, no `comparePropName` -- Exact-match deduplication\n-- `uniquely=true`, with `comparePropName` -- Deduplicates by the specified property name; when two objects share the same name, they are merged via `mergeObject()` (e.g., plugin settings)\n+- `uniquely=true`, with `comparePropName` -- Deduplicates by the specified property name; when two objects share the same name, they are shallow-merged via object spread (e.g., plugin settings)\n - Returns `undefined` for empty results\n \n #### mergeObject(a, b)\n \n-Deep merges two objects using the `deepmerge` library. Right-side values take precedence. Removes undefined properties from the result.\n+Shallow merges two objects via `{...a, ...b}`. Right-side values take precedence at the top level. Removes undefined properties from the result.\n \n #### mergeOverrides(a, b)\n \n@@ -193,7 +191,7 @@ Collects the union of all keys from both override records. For each key, calls `\n \n #### mergePretenders(a, b)\n \n-Converts array-form pretenders to the normalized `PretenderDetails` form (`{data: [...]}`) before deep merging with `mergeObject()`.\n+Converts array-form pretenders to the normalized `PretenderDetails` form (`{data: [...]}`) then applies semantic merge: `files`/`imports` are overridden (right-side wins), `data` is appended (concatenated).\n \n ## Template Rendering System\n \n@@ -217,11 +215,11 @@ This function is used by `nodeRules` and `childNodeRules` with `regexSelector`,\n \n ## Utility Functions\n \n-| Function              | Purpose                                                                                                   |\n-| --------------------- | --------------------------------------------------------------------------------------------------------- |\n-| `cleanOptions()`      | Normalizes deprecated `option` field to `options`, extracts standard fields, removes undefined properties |\n-| `isRuleConfigValue()` | Type guard: returns `true` for primitives, `null`, and arrays (i.e., not a `RuleConfig` object)           |\n-| `deleteUndefProp()`   | Removes all properties with `undefined` values from a plain object in-place                               |\n+| Function              | Purpose                                                                                           |\n+| --------------------- | ------------------------------------------------------------------------------------------------- |\n+| `cleanOptions()`      | Extracts standard fields (`severity`, `value`, `options`, `reason`), removes undefined properties |\n+| `isRuleConfigValue()` | Type guard: returns `true` for primitives, `null`, and arrays (i.e., not a `RuleConfig` object)   |\n+| `deleteUndefProp()`   | Removes all properties with `undefined` values from a plain object in-place                       |\n \n ## Key Source Files\n \n@@ -234,15 +232,14 @@ This function is used by `nodeRules` and `childNodeRules` with `regexSelector`,\n \n ## External Dependencies\n \n-| Dependency             | Purpose                                           |\n-| ---------------------- | ------------------------------------------------- |\n-| `@markuplint/ml-ast`   | `ParserOptions` type (type-only)                  |\n-| `@markuplint/selector` | `RegexSelector` type (re-exported)                |\n-| `@markuplint/shared`   | `Nullable` utility type                           |\n-| `deepmerge`            | Deep merge implementation used by `mergeObject()` |\n-| `is-plain-object`      | Plain object detection in `deleteUndefProp()`     |\n-| `mustache`             | Template rendering engine for `provideValue()`    |\n-| `type-fest`            | `Writable` utility type                           |\n+| Dependency             | Purpose                                        |\n+| ---------------------- | ---------------------------------------------- |\n+| `@markuplint/ml-ast`   | `ParserOptions` type (type-only)               |\n+| `@markuplint/selector` | `RegexSelector` type (re-exported)             |\n+| `@markuplint/shared`   | `Nullable` utility type                        |\n+| `is-plain-object`      | Plain object detection in `deleteUndefProp()`  |\n+| `mustache`             | Template rendering engine for `provideValue()` |\n+| `type-fest`            | `Writable` utility type                        |\n \n ## Integration Points\n \n@@ -277,6 +274,41 @@ flowchart LR\n - **`@markuplint/ml-core`** -- Receives the merged `OptimizedConfig` and applies rules to the parsed document\n - **`@markuplint/rules`** -- Uses `Rule<T,O>` and `RuleConfig<T,O>` types to define rule implementations\n \n+## Design Decisions\n+\n+### Why Not Flat Config?\n+\n+ESLint's Flat Config approach was evaluated and rejected for markuplint:\n+\n+- **ESLint itself re-added `extends` to Flat Config in March 2025** -- The pure flat approach proved insufficient even for JavaScript tooling\n+- **markuplint is JSON-based** -- Flat Config assumes JavaScript. HTML/markup developers (the primary audience) benefit from JSON's schema validation and language-agnostic editing\n+- **markuplint's `nodeRules`/`childNodeRules` are CSS-selector-based** -- These have no equivalent in Flat Config's file-pattern model\n+- **ESLint v9 migration caused significant community pain** -- The gradual transition required automated migration tools and years of ecosystem adaptation\n+\n+**Conclusion:** Improving the JSON-based `extends` merge strategy is the optimal approach for markuplint.\n+\n+### Merge Strategy Principles\n+\n+There is a logical distinction between how arrays are handled:\n+\n+| Array Type                | Examples                               | Merge Behavior | Rationale                              |\n+| ------------------------- | -------------------------------------- | -------------- | -------------------------------------- |\n+| **Top-level collections** | `plugins`, `excludeFiles`, `nodeRules` | Accumulate     | Independent items forming a collection |\n+| **Rule values**           | `[\"allowed-tag-1\", \"allowed-tag-2\"]`   | Override       | A single rule's configuration value    |\n+\n+This aligns with ESLint and Biome, where rule values are always overridden by the more specific config.\n+\n+### Shallow Merge over Deep Merge\n+\n+| Tool       | Rule options merge           | Rationale                                                             |\n+| ---------- | ---------------------------- | --------------------------------------------------------------------- |\n+| ESLint     | Complete replacement         | Simplest, but can be surprising                                       |\n+| Biome      | Deep merge (via Merge trait) | Full flexibility, higher complexity                                   |\n+| markuplint | **Shallow merge**            | Middle ground: top-level keys are merged, nested objects are replaced |\n+\n+The `deepmerge` library was removed in favor of simple object spread (`{...a, ...b}`). This is sufficient because all merged objects in markuplint config (parser, specs, parserOptions, severity, plugin settings, rule options) are flat key-value maps.\n+\n ## Documentation Map\n \n+- [Migration Guide](../../docs/migration/v4-v5/config.md) -- Breaking changes between major versions\n - [Maintenance Guide](docs/maintenance.md) -- Commands, recipes, and troubleshooting\ndiff --git a/packages/@markuplint/ml-config/SKILL.md b/packages/@markuplint/ml-config/SKILL.md\nindex 876e93efee..4ac66f64af 100644\n--- a/packages/@markuplint/ml-config/SKILL.md\n+++ b/packages/@markuplint/ml-config/SKILL.md\n@@ -49,7 +49,7 @@ Add a new property to the Config type and implement its merge strategy. Follow r\n \n 1. Read `src/merge-config.ts`\n 2. Add the merge logic inside `mergeConfig()`, choosing the appropriate strategy:\n-   - `mergeObject()` for object deep merge\n+   - `mergeObject()` for object shallow merge\n    - `concatArray()` for array concatenation\n    - `b.prop ?? a.prop` for simple right-side precedence\n 3. If the property needs format conversion (like plugins or pretenders), implement a conversion helper\n@@ -94,8 +94,8 @@ Modify the rule merge logic in `mergeRule()`. Follow recipe #3 in `docs/maintena\n \n 1. Make changes to `mergeRule()`, paying attention to:\n    - The `false` absolute disable behavior\n-   - Array concatenation for value arrays\n-   - Deep merge for options via `mergeObject()`\n+   - Array values override (right-side wins)\n+   - Shallow merge for options via `mergeObject()`\n    - Right-side precedence for severity, value, reason\n \n ### Step 3: Verify\ndiff --git a/packages/@markuplint/ml-config/docs/maintenance.ja.md b/packages/@markuplint/ml-config/docs/maintenance.ja.md\nindex fea44e3cc2..6b90c11cee 100644\n--- a/packages/@markuplint/ml-config/docs/maintenance.ja.md\n+++ b/packages/@markuplint/ml-config/docs/maintenance.ja.md\n@@ -61,7 +61,7 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n    - トップレベル専用（`$schema`、`extends` のように）なら、`NoInherit` ユニオン型にプロパティ名を追加\n    - ファイルパターンごとにオーバーライド可能にする場合はそのまま（`Omit<Config, NoInherit>` 経由で `Config` から継承）\n 5. `src/merge-config.ts` を読み、`mergeConfig()` 関数の config オブジェクト内にマージロジックを追加:\n-   - オブジェクト deep merge: `newProp: mergeObject(a.newProp, b.newProp)`\n+   - オブジェクト shallow merge: `newProp: mergeObject(a.newProp, b.newProp)`\n    - 配列結合: `newProp: concatArray(a.newProp, b.newProp)`\n    - 配列結合+重複排除: `newProp: concatArray(a.newProp, b.newProp, true)`\n    - 単純な右辺優先: `newProp: b.newProp ?? a.newProp`（スプレッドで処理されるが、明示的な方が分かりやすい）\n@@ -74,7 +74,7 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n 1. `src/merge-config.ts` を読み、`mergeConfig()` 関数内のプロパティを確認\n 2. 現在の戦略を特定（`ARCHITECTURE.md` の戦略テーブルを参照）\n 3. マージ呼び出しを置換。利用可能な戦略:\n-   - `mergeObject(a.prop, b.prop)` -- 右辺優先の deep merge\n+   - `mergeObject(a.prop, b.prop)` -- 右辺優先の shallow merge\n    - `concatArray(a.prop, b.prop)` -- 単純な配列結合\n    - `concatArray(a.prop, b.prop, true)` -- 重複排除付き結合\n    - `concatArray(a.prop, b.prop, true, 'name')` -- 名前付きプロパティで重複排除、同名オブジェクトをマージ\n@@ -88,15 +88,15 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n \n 1. `src/merge-config.ts` を読み、`mergeRule()` 関数を確認\n 2. 現在のフローを理解:\n-   - `optimizeRule()` が両方の入力を正規化（非推奨の `option` -> `options` を処理）\n+   - `optimizeRule()` が両方の入力を正規化\n    - `false` チェック: override が `false` または `{value: false}` なら常に `false` を返す\n    - `undefined` チェック: 片方がない場合はもう片方を返す\n-   - 値型チェック: override が直接値（primitive/null/array）なら置換または連結\n-   - オブジェクト型マージ: severity/value/reason は右辺優先、options は deep merge\n+   - 値型チェック: override が直接値（primitive/null/array）ならベース値を上書き\n+   - オブジェクト型マージ: severity/value/reason は右辺優先、options は shallow merge\n 3. 変更を加える際、主要な不変条件を保持:\n    - `false` は常に絶対無効化になる必要がある\n-   - 配列値は連結される（置換ではない）\n-   - `options` は `mergeObject()` による deep merge が必要\n+   - 配列値は上書き（右辺優先）であり、連結ではない\n+   - `options` は `mergeObject()` による shallow merge が必要\n 4. `src/merge-config.spec.ts` の既存テストが通ることを確認\n 5. 変更後の動作に対する新しいテストケースを追加\n 6. ビルド: `yarn build --scope @markuplint/ml-config`\n@@ -107,10 +107,10 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n 1. `src/types.ts` を読み、`Pretender`、`PretenderDetails`、`OriginalNode` を確認\n 2. 適切な型に新しいフィールドを追加\n 3. `src/merge-config.ts` を読み、`mergePretenders()` を確認:\n-   - 配列形式を `{data: [...]}` に変換（`convertPretenersToDetails()`）\n-   - `mergeObject()` で deep merge\n-   - `PretenderDetails` の新しいフィールドは自動的に deep merge される\n-   - `Pretender`（`data` 配列内）の新しいフィールドは deepmerge の配列マージで処理\n+   - 配列形式を `{data: [...]}` に変換（`toPretenderDetails()`）\n+   - `files`/`imports` は上書き（右辺優先）\n+   - `data` 配列は連結（追加）\n+   - `PretenderDetails` の新しいフィールドは `mergePretenders()` 内で明示的に処理が必要\n 4. `src/merge-config.spec.ts` にテストケースを追加\n 5. ビルド: `yarn build --scope @markuplint/ml-config`\n 6. テスト: `yarn test --scope @markuplint/ml-config`\n@@ -145,20 +145,18 @@ yarn test --scope @markuplint/ml-config\n 2. 両方の入力に値がある場合にヘルパー関数が `undefined` を返していないか検証\n 3. `concatArray()` は空配列に対して `undefined` を返す -- 入力が空でないことを確認\n \n-### ルール値が上書きではなく連結される\n+### ルール値が予期しない上書きになる\n \n-**症状:** ルールの配列値が上書きされずに増え続ける。\n+**症状:** ルールの配列値がベースの値を保持せず、完全に置き換えられる。\n \n-**原因:** `mergeRule()` はベースとオーバーライドの両方が配列の場合、設計上連結する。\n+**原因:** `mergeRule()` は設計上、配列値を上書きする（右辺優先）。これは ESLint や Biome と一貫した動作。\n \n-**解決策:** 配列値を完全に上書きするには、override 側でオブジェクト形式を使用:\n+**解決策:** これは期待される動作です。両方の値が必要な場合は、単一の設定で手動で配列を統合:\n \n ```json\n-{ \"value\": [\"new\", \"values\"], \"options\": {} }\n+{ \"value\": [\"base-tag-1\", \"base-tag-2\", \"new-tag-1\"], \"options\": {} }\n ```\n \n-これにより連結ではなく値が完全に置換される。\n-\n ### プラグインの settings がマージされない\n \n **症状:** 同名プラグインの2つの設定で、片方の settings しか反映されない。\ndiff --git a/packages/@markuplint/ml-config/docs/maintenance.md b/packages/@markuplint/ml-config/docs/maintenance.md\nindex 4e5b265f9c..75bb5df56a 100644\n--- a/packages/@markuplint/ml-config/docs/maintenance.md\n+++ b/packages/@markuplint/ml-config/docs/maintenance.md\n@@ -61,7 +61,7 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n    - If it should be top-level only (like `$schema`, `extends`), add the property name to the `NoInherit` union type\n    - If it should be overridable per file pattern, leave it as-is (it inherits from `Config` via `Omit<Config, NoInherit>`)\n 5. Read `src/merge-config.ts` and add the merge logic inside the `mergeConfig()` function's config object:\n-   - For object deep merge: `newProp: mergeObject(a.newProp, b.newProp)`\n+   - For object shallow merge: `newProp: mergeObject(a.newProp, b.newProp)`\n    - For array concatenation: `newProp: concatArray(a.newProp, b.newProp)`\n    - For array with deduplication: `newProp: concatArray(a.newProp, b.newProp, true)`\n    - For simple right-side precedence: `newProp: b.newProp ?? a.newProp` (handled by the spread, but explicit is clearer)\n@@ -74,7 +74,7 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n 1. Read `src/merge-config.ts` and locate the property in the `mergeConfig()` function\n 2. Identify the current strategy (see the strategy table in `ARCHITECTURE.md`)\n 3. Replace the merge call. Available strategies:\n-   - `mergeObject(a.prop, b.prop)` -- Deep merge with right-side precedence\n+   - `mergeObject(a.prop, b.prop)` -- Shallow merge with right-side precedence\n    - `concatArray(a.prop, b.prop)` -- Simple array concatenation\n    - `concatArray(a.prop, b.prop, true)` -- Concat with deduplication\n    - `concatArray(a.prop, b.prop, true, 'name')` -- Concat with deduplication by named property, merging same-name objects\n@@ -88,15 +88,15 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n \n 1. Read `src/merge-config.ts` and locate the `mergeRule()` function\n 2. Understand the current flow:\n-   - `optimizeRule()` normalizes both inputs (handles deprecated `option` -> `options`)\n+   - `optimizeRule()` normalizes both inputs\n    - `false` check: override `false` or `{value: false}` always returns `false`\n    - `undefined` checks: missing side returns the other side\n-   - Value type check: if override is a direct value (primitive/null/array), it replaces or concatenates\n-   - Object type merge: severity/value/reason use right-side precedence, options use deep merge\n+   - Value type check: if override is a direct value (primitive/null/array), it replaces the base value\n+   - Object type merge: severity/value/reason use right-side precedence, options use shallow merge\n 3. Make changes, preserving the key invariants:\n    - `false` must always result in absolute disable\n-   - Array values must be concatenated (not replaced)\n-   - `options` must use deep merge via `mergeObject()`\n+   - Array values must override (right-side wins), not concatenate\n+   - `options` must use shallow merge via `mergeObject()`\n 4. Verify existing tests pass in `src/merge-config.spec.ts`\n 5. Add new test cases for the modified behavior\n 6. Build: `yarn build --scope @markuplint/ml-config`\n@@ -107,10 +107,10 @@ expect(exchangeValueOnRule({ value: '{{ var }}' }, { var: 'x' })).toStrictEqual(\n 1. Read `src/types.ts` and locate `Pretender`, `PretenderDetails`, and `OriginalNode`\n 2. Add new fields to the appropriate type\n 3. Read `src/merge-config.ts` and check `mergePretenders()`:\n-   - It converts array form to `{data: [...]}` via `convertPretenersToDetails()`\n-   - Then deep merges with `mergeObject()`\n-   - New fields on `PretenderDetails` are automatically deep merged\n-   - New fields on `Pretender` (inside `data` array) are handled by deepmerge's array merge\n+   - It converts array form to `{data: [...]}` via `toPretenderDetails()`\n+   - `files`/`imports` are overridden (right-side wins)\n+   - `data` arrays are concatenated (appended)\n+   - New fields on `PretenderDetails` need explicit handling in `mergePretenders()`\n 4. Add test cases in `src/merge-config.spec.ts`\n 5. Build: `yarn build --scope @markuplint/ml-config`\n 6. Test: `yarn test --scope @markuplint/ml-config`\n@@ -145,20 +145,18 @@ yarn test --scope @markuplint/ml-config\n 2. Verify the helper function does not return `undefined` when both inputs have values\n 3. `concatArray()` returns `undefined` for empty arrays -- ensure the inputs are not empty\n \n-### Rule values are concatenated instead of replaced\n+### Rule values unexpectedly replaced\n \n-**Symptom:** A rule's array value keeps growing instead of being overwritten.\n+**Symptom:** A rule's array value is replaced entirely instead of keeping both base and override values.\n \n-**Cause:** `mergeRule()` concatenates array values by design when both base and override are arrays.\n+**Cause:** `mergeRule()` overrides array values by design (right-side wins). This is consistent with ESLint and Biome behavior.\n \n-**Solution:** To completely replace an array value, use the object form in the override:\n+**Solution:** This is the expected behavior. If you need both sets of values, manually combine the arrays in a single config:\n \n ```json\n-{ \"value\": [\"new\", \"values\"], \"options\": {} }\n+{ \"value\": [\"base-tag-1\", \"base-tag-2\", \"new-tag-1\"], \"options\": {} }\n ```\n \n-This replaces the value entirely instead of concatenating.\n-\n ### Plugin settings are not merged\n \n **Symptom:** Two configs with the same plugin name result in settings from only one side.\ndiff --git a/packages/@markuplint/ml-config/package.json b/packages/@markuplint/ml-config/package.json\nindex db21261e7d..f642731bcd 100644\n--- a/packages/@markuplint/ml-config/package.json\n+++ b/packages/@markuplint/ml-config/package.json\n@@ -32,7 +32,6 @@\n \t\t\"@markuplint/selector\": \"4.7.8\",\n \t\t\"@markuplint/shared\": \"4.4.13\",\n \t\t\"@types/mustache\": \"4.2.6\",\n-\t\t\"deepmerge\": \"4.3.1\",\n \t\t\"is-plain-object\": \"5.0.0\",\n \t\t\"mustache\": \"4.2.0\",\n \t\t\"type-fest\": \"5.4.4\"\ndiff --git a/packages/@markuplint/ml-config/src/merge-config.md b/packages/@markuplint/ml-config/src/merge-config.md\nindex db57b4926c..ece3458e31 100644\n--- a/packages/@markuplint/ml-config/src/merge-config.md\n+++ b/packages/@markuplint/ml-config/src/merge-config.md\n@@ -1,31 +1,43 @@\n ## Merge Props\n \n-| Options                                                                       | Type                   | Merging                      | Path Absolutize |\n-| ----------------------------------------------------------------------------- | ---------------------- | ---------------------------- | --------------- |\n-| [ruleCommonSettings](https://markuplint.dev/configuration#ruleCommonSettings) | Object                 | Merge                        | ✓               |\n-| [plugins](https://markuplint.dev/configuration#plugins)                       | Array                  | Add uniquely                 | ✓               |\n-| [parser](https://markuplint.dev/configuration#parser)                         | Object                 | Merge                        | ✓               |\n-| [parserOptions](https://markuplint.dev/configuration#parserOptions)           | Object                 | Merge                        | ✓               |\n-| [specs](https://markuplint.dev/configuration#specs)                           | Object(v2) / Array(v1) | Merge(v2) / Add uniquely(v1) | -               |\n-| [extends](https://markuplint.dev/configuration#extends)                       | Array                  | Delete after merged          | ✓               |\n-| [excludeFiles](https://markuplint.dev/configuration#excludeFiles)             | Array                  | Add uniquely                 | ✓               |\n-| [rules](https://markuplint.dev/configuration#rules)                           | Object                 | †1                           | -               |\n-| [nodeRules](https://markuplint.dev/configuration#nodeRules)                   | Array                  | Add                          | -               |\n-| [childNodeRules](https://markuplint.dev/configuration#childNodeRules)         | Array                  | Add                          | -               |\n+| Options                                                                       | Type   | Merging             | Path Absolutize |\n+| ----------------------------------------------------------------------------- | ------ | ------------------- | --------------- |\n+| [ruleCommonSettings](https://markuplint.dev/configuration#ruleCommonSettings) | Object | Shallow Merge       | ✓               |\n+| [plugins](https://markuplint.dev/configuration#plugins)                       | Array  | Add uniquely        | ✓               |\n+| [parser](https://markuplint.dev/configuration#parser)                         | Object | Shallow Merge       | ✓               |\n+| [parserOptions](https://markuplint.dev/configuration#parserOptions)           | Object | Shallow Merge       | ✓               |\n+| [specs](https://markuplint.dev/configuration#specs)                           | Object | Shallow Merge       | -               |\n+| [extends](https://markuplint.dev/configuration#extends)                       | Array  | Delete after merged | ✓               |\n+| [excludeFiles](https://markuplint.dev/configuration#excludeFiles)             | Array  | Add uniquely        | ✓               |\n+| [rules](https://markuplint.dev/configuration#rules)                           | Object | †1                  | -               |\n+| [nodeRules](https://markuplint.dev/configuration#nodeRules)                   | Array  | Add                 | -               |\n+| [childNodeRules](https://markuplint.dev/configuration#childNodeRules)         | Array  | Add                 | -               |\n+| [severity](https://markuplint.dev/configuration#severity)                     | Object | Shallow Merge       | -               |\n+| [pretenders](https://markuplint.dev/configuration#pretenders)                 | Object | †3                  | -               |\n+| [overrideMode](https://markuplint.dev/configuration#overrideMode)             | String | Overwrite           | -               |\n+| [overrides](https://markuplint.dev/configuration#overrides)                   | Object | Per-key merge       | -               |\n \n ## †1 Merge Rules\n \n-| Value Type                | Merging          |\n-| ------------------------- | ---------------- |\n-| String / Number / Boolean | Merge(Overwrite) |\n-| Array                     | Add              |\n-| Object                    | †2               |\n+| Value Type                | Merging   |\n+| ------------------------- | --------- |\n+| String / Number / Boolean | Overwrite |\n+| Array                     | Overwrite |\n+| Object                    | †2        |\n \n ## †2 Merge Rule Details\n \n-| options  | Type   | Merging                                        |\n-| -------- | ------ | ---------------------------------------------- |\n-| value    | †1     | †1                                             |\n-| severity | Enum   | Merge(Overwrite)                               |\n-| option   | Object | Deep Merge(**An array is replaced, no added**) |\n-| reason   | String | Merge(Overwrite)                               |\n+| Property | Type   | Merging       |\n+| -------- | ------ | ------------- |\n+| value    | †1     | †1            |\n+| severity | Enum   | Overwrite     |\n+| options  | Object | Shallow Merge |\n+| reason   | String | Overwrite     |\n+\n+## †3 Merge Pretenders\n+\n+| Property | Type  | Merging   |\n+| -------- | ----- | --------- |\n+| files    | Array | Overwrite |\n+| imports  | Array | Overwrite |\n+| data     | Array | Add       |\ndiff --git a/packages/@markuplint/ml-config/src/merge-config.spec.ts b/packages/@markuplint/ml-config/src/merge-config.spec.ts\nindex 34f7382bbc..3777b8f670 100644\n--- a/packages/@markuplint/ml-config/src/merge-config.spec.ts\n+++ b/packages/@markuplint/ml-config/src/merge-config.spec.ts\n@@ -7,6 +7,128 @@ describe('mergeConfig', () => {\n \t\texpect(mergeConfig({}, {})).toStrictEqual({});\n \t});\n \n+\ttest('extends is preserved when b is not provided', () => {\n+\t\tconst result = mergeConfig({ extends: 'base.json' });\n+\t\texpect(result).toHaveProperty('extends');\n+\t});\n+\n+\ttest('extends is deleted when b is provided', () => {\n+\t\tconst result = mergeConfig({ extends: 'a.json' }, { extends: 'b.json' });\n+\t\texpect(result).not.toHaveProperty('extends');\n+\t});\n+\n+\ttest('ruleCommonSettings shallow merge', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{ ruleCommonSettings: { ariaVersion: '1.2' } },\n+\t\t\t\t// @ts-ignore -- test with partial config\n+\t\t\t\t{ ruleCommonSettings: { ariaVersion: '1.3' } },\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\t// @ts-ignore\n+\t\t\truleCommonSettings: { ariaVersion: '1.3' },\n+\t\t});\n+\t});\n+\n+\ttest('excludeFiles concatenation with deduplication', () => {\n+\t\texpect(mergeConfig({ excludeFiles: ['a.css'] }, { excludeFiles: ['a.css', 'b.js'] })).toStrictEqual({\n+\t\t\texcludeFiles: ['a.css', 'b.js'],\n+\t\t});\n+\t});\n+\n+\ttest('nodeRules concatenation', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{ nodeRules: [{ selector: '.a', rules: { rule1: true } }] },\n+\t\t\t\t{ nodeRules: [{ selector: '.b', rules: { rule2: true } }] },\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tnodeRules: [\n+\t\t\t\t{ selector: '.a', rules: { rule1: true } },\n+\t\t\t\t{ selector: '.b', rules: { rule2: true } },\n+\t\t\t],\n+\t\t});\n+\t});\n+\n+\ttest('childNodeRules concatenation', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{ childNodeRules: [{ selector: '.a', rules: { rule1: true } }] },\n+\t\t\t\t{ childNodeRules: [{ selector: '.b', rules: { rule2: true } }] },\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tchildNodeRules: [\n+\t\t\t\t{ selector: '.a', rules: { rule1: true } },\n+\t\t\t\t{ selector: '.b', rules: { rule2: true } },\n+\t\t\t],\n+\t\t});\n+\t});\n+\n+\ttest('overrideMode right-side wins', () => {\n+\t\texpect(mergeConfig({ overrideMode: 'merge' }, { overrideMode: 'reset' })).toStrictEqual({\n+\t\t\toverrideMode: 'reset',\n+\t\t});\n+\t});\n+\n+\ttest('overrideMode falls back to a', () => {\n+\t\texpect(mergeConfig({ overrideMode: 'merge' }, {})).toStrictEqual({\n+\t\t\toverrideMode: 'merge',\n+\t\t});\n+\t});\n+\n+\ttest('overrides with disjoint keys', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{ overrides: { a: { rules: { rule1: true } } } },\n+\t\t\t\t{ overrides: { b: { rules: { rule2: true } } } },\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\toverrides: {\n+\t\t\t\ta: { rules: { rule1: true } },\n+\t\t\t\tb: { rules: { rule2: true } },\n+\t\t\t},\n+\t\t});\n+\t});\n+\n+\ttest('rules preserved when only a has rules', () => {\n+\t\texpect(mergeConfig({ rules: { rule1: true } }, {})).toStrictEqual({\n+\t\t\trules: { rule1: true },\n+\t\t});\n+\t});\n+\n+\ttest('rules preserved when only b has rules', () => {\n+\t\texpect(mergeConfig({}, { rules: { rule1: true } })).toStrictEqual({\n+\t\t\trules: { rule1: true },\n+\t\t});\n+\t});\n+\n+\ttest('severity shallow merge', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t// @ts-ignore -- test with partial config\n+\t\t\t\t{ severity: { parseError: 'error' } },\n+\t\t\t\t// @ts-ignore\n+\t\t\t\t{ severity: { parseError: 'warning' } },\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\t// @ts-ignore\n+\t\t\tseverity: { parseError: 'warning' },\n+\t\t});\n+\t});\n+\n+\ttest('parserOptions merge', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{ parserOptions: { ignoreFrontMatter: true } },\n+\t\t\t\t// @ts-ignore -- test with partial config\n+\t\t\t\t{ parserOptions: { authoredElementContent: 'flow' } },\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\t// @ts-ignore\n+\t\t\tparserOptions: { ignoreFrontMatter: true, authoredElementContent: 'flow' },\n+\t\t});\n+\t});\n+\n \ttest('plugins + plugins', () => {\n \t\texpect(\n \t\t\tmergeConfig(\n@@ -57,7 +179,6 @@ describe('mergeConfig', () => {\n \t\t\t\t\tname: 'c',\n \t\t\t\t\tsettings: {\n \t\t\t\t\t\tbar: 'bar2',\n-\t\t\t\t\t\tfoo: 'foo',\n \t\t\t\t\t\tfoo2: 'foo2',\n \t\t\t\t\t},\n \t\t\t\t},\n@@ -150,8 +271,7 @@ describe('mergeConfig', () => {\n \t\t\t\t{\n \t\t\t\t\trules: {\n \t\t\t\t\t\ta: {\n-\t\t\t\t\t\t\t// @ts-ignore\n-\t\t\t\t\t\t\toption: {\n+\t\t\t\t\t\t\toptions: {\n \t\t\t\t\t\t\t\truleA: true,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n@@ -227,6 +347,64 @@ describe('mergeConfig', () => {\n });\n \n describe('mergeRule', () => {\n+\ttest('a is undefined returns b (shorthand)', () => {\n+\t\texpect(mergeRule(undefined, 'always')).toBe('always');\n+\t});\n+\n+\ttest('a is undefined returns b (config object)', () => {\n+\t\texpect(mergeRule(undefined, { value: true, severity: 'error' })).toStrictEqual({\n+\t\t\tvalue: true,\n+\t\t\tseverity: 'error',\n+\t\t});\n+\t});\n+\n+\ttest('a is null returns b', () => {\n+\t\texpect(mergeRule(null, true)).toBe(true);\n+\t});\n+\n+\ttest('{value: false} disables rule absolutely', () => {\n+\t\texpect(mergeRule({ value: true, severity: 'error' }, { value: false })).toBe(false);\n+\t});\n+\n+\ttest('reason is overridden by b', () => {\n+\t\texpect(mergeRule({ value: true, reason: 'old' }, { value: true, reason: 'new' })).toStrictEqual({\n+\t\t\tvalue: true,\n+\t\t\treason: 'new',\n+\t\t});\n+\t});\n+\n+\ttest('reason is preserved from a when b has no reason', () => {\n+\t\texpect(mergeRule({ value: true, reason: 'base' }, { severity: 'warning' })).toStrictEqual({\n+\t\t\tvalue: true,\n+\t\t\tseverity: 'warning',\n+\t\t\treason: 'base',\n+\t\t});\n+\t});\n+\n+\ttest('full config merge with all fields', () => {\n+\t\texpect(\n+\t\t\tmergeRule(\n+\t\t\t\t{\n+\t\t\t\t\tseverity: 'warning',\n+\t\t\t\t\tvalue: 'always',\n+\t\t\t\t\toptions: { a: 1, b: 2 },\n+\t\t\t\t\treason: 'base reason',\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tseverity: 'error',\n+\t\t\t\t\tvalue: 'never',\n+\t\t\t\t\toptions: { b: 3, c: 4 },\n+\t\t\t\t\treason: 'override reason',\n+\t\t\t\t},\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tseverity: 'error',\n+\t\t\tvalue: 'never',\n+\t\t\toptions: { a: 1, b: 3, c: 4 },\n+\t\t\treason: 'override reason',\n+\t\t});\n+\t});\n+\n \ttest('{value} + shorthand', () => {\n \t\texpect(\n \t\t\tmergeRule(\n@@ -313,9 +491,126 @@ describe('mergeRule', () => {\n \t\t\toptions: {},\n \t\t});\n \t});\n+\n+\ttest('array value overrides instead of concatenating', () => {\n+\t\texpect(mergeRule(['a', 'b'], ['c', 'd'])).toStrictEqual(['c', 'd']);\n+\t});\n+\n+\ttest('array value overrides when base is config object', () => {\n+\t\texpect(\n+\t\t\tmergeRule(\n+\t\t\t\t{\n+\t\t\t\t\tvalue: ['a', 'b'],\n+\t\t\t\t\tseverity: 'warning',\n+\t\t\t\t},\n+\t\t\t\t['c', 'd'],\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tvalue: ['c', 'd'],\n+\t\t\tseverity: 'warning',\n+\t\t});\n+\t});\n+\n+\ttest('shorthand value overrides config object value', () => {\n+\t\texpect(\n+\t\t\tmergeRule(\n+\t\t\t\t{\n+\t\t\t\t\tvalue: 'always',\n+\t\t\t\t\tseverity: 'error',\n+\t\t\t\t},\n+\t\t\t\t'never',\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tvalue: 'never',\n+\t\t\tseverity: 'error',\n+\t\t});\n+\t});\n+\n+\ttest('{options} shallow merged', () => {\n+\t\texpect(\n+\t\t\tmergeRule(\n+\t\t\t\t{\n+\t\t\t\t\toptions: {\n+\t\t\t\t\t\ta: 1,\n+\t\t\t\t\t\tb: 2,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\toptions: {\n+\t\t\t\t\t\tb: 3,\n+\t\t\t\t\t\tc: 4,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\toptions: {\n+\t\t\t\ta: 1,\n+\t\t\t\tb: 3,\n+\t\t\t\tc: 4,\n+\t\t\t},\n+\t\t});\n+\t});\n });\n \n-describe('Preteners', () => {\n+describe('Pretenders', () => {\n+\ttest('both undefined returns no pretenders', () => {\n+\t\tconst result = mergeConfig({}, {});\n+\t\texpect(result).not.toHaveProperty('pretenders');\n+\t});\n+\n+\ttest('imports is overridden by b', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{\n+\t\t\t\t\tpretenders: {\n+\t\t\t\t\t\timports: ['a'],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tpretenders: {\n+\t\t\t\t\t\timports: ['b'],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tpretenders: {\n+\t\t\t\timports: ['b'],\n+\t\t\t},\n+\t\t});\n+\t});\n+\n+\ttest('data from one side only', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{\n+\t\t\t\t\tpretenders: {\n+\t\t\t\t\t\tfiles: ['x'],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tpretenders: {\n+\t\t\t\t\t\tdata: [\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tselector: 'Comp',\n+\t\t\t\t\t\t\t\tas: 'div',\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tpretenders: {\n+\t\t\t\tfiles: ['x'],\n+\t\t\t\tdata: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tselector: 'Comp',\n+\t\t\t\t\t\tas: 'div',\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t},\n+\t\t});\n+\t});\n+\n \ttest('test', () => {\n \t\texpect(\n \t\t\tmergeConfig(\n@@ -373,7 +668,7 @@ describe('Preteners', () => {\n \t\t});\n \t});\n \n-\ttest('test', () => {\n+\ttest('data is appended, files is overridden', () => {\n \t\texpect(\n \t\t\tmergeConfig(\n \t\t\t\t{\n@@ -412,4 +707,37 @@ describe('Preteners', () => {\n \t\t\t},\n \t\t});\n \t});\n+\n+\ttest('files override', () => {\n+\t\texpect(\n+\t\t\tmergeConfig(\n+\t\t\t\t{\n+\t\t\t\t\tpretenders: {\n+\t\t\t\t\t\tfiles: ['./base-pretenders.json'],\n+\t\t\t\t\t\tdata: [\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tselector: 'BaseComponent',\n+\t\t\t\t\t\t\t\tas: 'span',\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tpretenders: {\n+\t\t\t\t\t\tfiles: ['./override-pretenders.json'],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t),\n+\t\t).toStrictEqual({\n+\t\t\tpretenders: {\n+\t\t\t\tfiles: ['./override-pretenders.json'],\n+\t\t\t\tdata: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tselector: 'BaseComponent',\n+\t\t\t\t\t\tas: 'span',\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t},\n+\t\t});\n+\t});\n });\ndiff --git a/packages/@markuplint/ml-config/src/merge-config.ts b/packages/@markuplint/ml-config/src/merge-config.ts\nindex a46c79d956..6d04c5519a 100644\n--- a/packages/@markuplint/ml-config/src/merge-config.ts\n+++ b/packages/@markuplint/ml-config/src/merge-config.ts\n@@ -1,7 +1,6 @@\n import type {\n \tConfig,\n \tAnyRule,\n-\tAnyRuleV2,\n \tRules,\n \tOptimizedConfig,\n \tOverrideConfig,\n@@ -12,17 +11,16 @@ import type {\n import type { Nullable } from '@markuplint/shared';\n import type { Writable } from 'type-fest';\n \n-import deepmerge from 'deepmerge';\n-\n import { deleteUndefProp, cleanOptions, isRuleConfigValue } from './utils.js';\n \n /**\n- * Deep-merges two markuplint configurations into an optimized result.\n+ * Merges two markuplint configurations into an optimized result.\n  *\n  * Plugins, arrays, and rules are merged with specific strategies:\n- * - Plugins are concatenated and deduplicated by name\n+ * - Plugins are concatenated and deduplicated by name (settings shallow-merged)\n  * - Arrays (excludeFiles, nodeRules, childNodeRules) are concatenated\n  * - Rules are merged per-key with right-side precedence\n+ * - Objects (parser, specs, etc.) are shallow-merged\n  * - The `extends` property is removed from the result when `b` is provided\n  *\n  * @param a - The base configuration\n@@ -73,14 +71,15 @@ export function mergeConfig(a: Config, b?: Config): OptimizedConfig {\n  * Merges two rule configurations with right-side precedence.\n  *\n  * If `b` is `false`, the rule is unconditionally disabled.\n- * If `b` is a direct value, it replaces or extends `a`.\n- * If both are full config objects, their properties are merged.\n+ * If `b` is a direct value (including arrays), it overrides `a`.\n+ * If both are full config objects, their properties are merged\n+ * (severity/value/reason: right-side wins, options: shallow-merged).\n  *\n  * @param a - The base rule configuration (may be `null` or `undefined`)\n  * @param b - The rule configuration to merge on top\n  * @returns The merged rule configuration\n  */\n-export function mergeRule(a: Nullable<AnyRule | AnyRuleV2>, b: AnyRule | AnyRuleV2): AnyRule {\n+export function mergeRule(a: Nullable<AnyRule>, b: AnyRule): AnyRule {\n \tconst oA = optimizeRule(a);\n \tconst oB = optimizeRule(b);\n \n@@ -101,13 +100,9 @@ export function mergeRule(a: Nullable<AnyRule | AnyRuleV2>, b: AnyRule | AnyRule\n \n \tif (isRuleConfigValue(oB)) {\n \t\tif (isRuleConfigValue(oA)) {\n-\t\t\tif (Array.isArray(oA) && Array.isArray(oB)) {\n-\t\t\t\treturn [...oA, ...oB];\n-\t\t\t}\n \t\t\treturn oB;\n \t\t}\n-\t\tconst value = Array.isArray(oA.value) && Array.isArray(oB) ? [...oA.value, ...oB] : oB;\n-\t\tconst res = cleanOptions({ ...oA, value });\n+\t\tconst res = cleanOptions({ ...oA, value: oB });\n \t\tdeleteUndefProp(res);\n \t\treturn res;\n \t}\n@@ -133,14 +128,28 @@ function mergePretenders(\n \tif (!a && !b) {\n \t\treturn;\n \t}\n-\tconst aDetails = a ? convertPretenersToDetails(a) : undefined;\n-\tconst bDetails = b ? convertPretenersToDetails(b) : undefined;\n-\tconst details = mergeObject(aDetails, bDetails) ?? {};\n+\tconst aDetails = a ? toPretenderDetails(a) : undefined;\n+\tconst bDetails = b ? toPretenderDetails(b) : undefined;\n+\n+\tif (!aDetails) {\n+\t\treturn bDetails;\n+\t}\n+\tif (!bDetails) {\n+\t\treturn aDetails;\n+\t}\n+\n+\t// files/imports: override (right-side wins)\n+\t// data: append (concatenate)\n+\tconst details: PretenderDetails = {\n+\t\tfiles: bDetails.files ?? aDetails.files,\n+\t\timports: bDetails.imports ?? aDetails.imports,\n+\t\tdata: concatArray(aDetails.data, bDetails.data),\n+\t};\n \tdeleteUndefProp(details);\n \treturn details;\n }\n \n-function convertPretenersToDetails(pretenders: readonly Pretender[] | PretenderDetails): PretenderDetails {\n+function toPretenderDetails(pretenders: readonly Pretender[] | PretenderDetails): PretenderDetails {\n \tif (isReadonlyArray(pretenders)) {\n \t\treturn {\n \t\t\tdata: pretenders,\n@@ -185,12 +194,12 @@ function mergeObject<T>(a: Nullable<T>, b: Nullable<T>): T | undefined {\n \tif (b == null) {\n \t\treturn a ?? undefined;\n \t}\n-\tconst res = deepmerge<T>(a, b);\n+\tconst res = { ...a, ...b } as T;\n \tdeleteUndefProp(res);\n \treturn res;\n }\n \n-function concatArray<T extends any>(\n+function concatArray<T>(\n \ta: Nullable<readonly T[]>,\n \tb: Nullable<readonly T[]>,\n \tuniquely = false,\n@@ -228,13 +237,7 @@ function concatArray<T extends any>(\n \t\t}\n \n \t\tconst existed = newArray[existedIndex];\n-\t\tconst merged = mergeObject(existed, item);\n-\t\tif (!merged) {\n-\t\t\tnewArray.push(item);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tnewArray.splice(existedIndex, 1, merged);\n+\t\tnewArray.splice(existedIndex, 1, { ...existed, ...item });\n \t}\n \n \t// eslint-disable-next-line unicorn/no-array-for-each\n@@ -287,7 +290,7 @@ function optimizeRules(rules: Rules) {\n \treturn res;\n }\n \n-function optimizeRule(rule: Nullable<AnyRule | AnyRuleV2>): AnyRule | undefined {\n+function optimizeRule(rule: Nullable<AnyRule>): AnyRule | undefined {\n \tif (rule === undefined) {\n \t\treturn;\n \t}\ndiff --git a/packages/@markuplint/ml-config/src/types.ts b/packages/@markuplint/ml-config/src/types.ts\nindex 98ae3ab540..53b8822669 100644\n--- a/packages/@markuplint/ml-config/src/types.ts\n+++ b/packages/@markuplint/ml-config/src/types.ts\n@@ -114,6 +114,10 @@ export type SeverityOptions = {\n \treadonly parseError?: Severity | 'off' | boolean;\n };\n \n+/**\n+ * Normalized form of pretender configuration used after merging.\n+ * Contains optional file references, import paths, and inline pretender data.\n+ */\n export type PretenderDetails = {\n \t/**\n \t * @experimental\n@@ -135,6 +139,11 @@ export type PretenderFileData = {\n \treadonly data: readonly Pretender[];\n };\n \n+/**\n+ * Defines a mapping from a custom element (matched by CSS selector) to a standard\n+ * HTML element for linting purposes, allowing rules to treat custom components\n+ * as if they were native elements.\n+ */\n export type Pretender = {\n \t/**\n \t * Target node selectors\n@@ -319,24 +328,11 @@ export interface PretenderScanOptions {\n  */\n export type Rule<T extends RuleConfigValue, O extends PlainData = undefined> = RuleConfig<T, O> | Readonly<T> | boolean;\n \n-/**\n- * @deprecated\n- */\n-export type RuleV2<T extends RuleConfigValue, O extends PlainData = undefined> =\n-\t| RuleConfigV2<T, O>\n-\t| Readonly<T>\n-\t| boolean;\n-\n /**\n  * A rule setting with any value and option types.\n  */\n export type AnyRule = Rule<RuleConfigValue, PlainData>;\n \n-/**\n- * @deprecated\n- */\n-export type AnyRuleV2 = RuleV2<RuleConfigValue, PlainData>;\n-\n /**\n  * A dictionary mapping rule names to their configurations.\n  */\n@@ -361,23 +357,6 @@ export type RuleConfig<T extends RuleConfigValue, O extends PlainData = undefine\n \treadonly reason?: string;\n };\n \n-/**\n- * @deprecated\n- */\n-export type RuleConfigV2<T extends RuleConfigValue, O extends PlainData = undefined> = {\n-\treadonly severity?: Severity;\n-\treadonly value?: Readonly<T>;\n-\treadonly reason?: string;\n-\n-\t/**\n-\t * Old property\n-\t *\n-\t * @deprecated\n-\t * @see {this.options}\n-\t */\n-\treadonly option?: Readonly<O>;\n-};\n-\n /**\n  * The severity level of a lint violation.\n  */\ndiff --git a/packages/@markuplint/ml-config/src/utils.spec.ts b/packages/@markuplint/ml-config/src/utils.spec.ts\nindex 477f99e3b4..25e0606571 100644\n--- a/packages/@markuplint/ml-config/src/utils.spec.ts\n+++ b/packages/@markuplint/ml-config/src/utils.spec.ts\n@@ -1,6 +1,6 @@\n-import { test, expect } from 'vitest';\n+import { describe, test, expect } from 'vitest';\n \n-import { exchangeValueOnRule, provideValue } from './utils.js';\n+import { cleanOptions, deleteUndefProp, exchangeValueOnRule, isRuleConfigValue, provideValue } from './utils.js';\n \n test('provideValue', () => {\n \texpect(\n@@ -22,6 +22,73 @@ test('provideValue', () => {\n \t).toBe('No variable');\n });\n \n+describe('isRuleConfigValue', () => {\n+\ttest('string is true', () => {\n+\t\texpect(isRuleConfigValue('always')).toBe(true);\n+\t});\n+\n+\ttest('number is true', () => {\n+\t\texpect(isRuleConfigValue(42)).toBe(true);\n+\t});\n+\n+\ttest('boolean is true', () => {\n+\t\texpect(isRuleConfigValue(true)).toBe(true);\n+\t\texpect(isRuleConfigValue(false)).toBe(true);\n+\t});\n+\n+\ttest('null is true', () => {\n+\t\texpect(isRuleConfigValue(null)).toBe(true);\n+\t});\n+\n+\ttest('array is true', () => {\n+\t\texpect(isRuleConfigValue(['a', 'b'])).toBe(true);\n+\t});\n+\n+\ttest('object is false', () => {\n+\t\texpect(isRuleConfigValue({})).toBe(false);\n+\t});\n+\n+\ttest('undefined is false', () => {\n+\t\t// eslint-disable-next-line unicorn/no-useless-undefined\n+\t\texpect(isRuleConfigValue(undefined)).toBe(false);\n+\t});\n+});\n+\n+describe('deleteUndefProp', () => {\n+\ttest('removes undefined properties', () => {\n+\t\tconst obj: Record<string, unknown> = { a: 1, b: undefined, c: 'hello' };\n+\t\tdeleteUndefProp(obj);\n+\t\texpect(obj).toStrictEqual({ a: 1, c: 'hello' });\n+\t});\n+\n+\ttest('does nothing for non-plain-objects', () => {\n+\t\tconst arr = [1, undefined, 3];\n+\t\tdeleteUndefProp(arr);\n+\t\texpect(arr).toStrictEqual([1, undefined, 3]);\n+\n+\t\tconst str = 'hello';\n+\t\tdeleteUndefProp(str);\n+\t\texpect(str).toBe('hello');\n+\t});\n+});\n+\n+describe('cleanOptions', () => {\n+\ttest('removes undefined fields', () => {\n+\t\texpect(cleanOptions({ severity: 'error', value: true })).toStrictEqual({\n+\t\t\tseverity: 'error',\n+\t\t\tvalue: true,\n+\t\t});\n+\t});\n+\n+\ttest('keeps only standard fields', () => {\n+\t\t// @ts-ignore -- extra fields for testing\n+\t\texpect(cleanOptions({ severity: 'error', value: true, extraField: 'ignored' })).toStrictEqual({\n+\t\t\tseverity: 'error',\n+\t\t\tvalue: true,\n+\t\t});\n+\t});\n+});\n+\n test('exchangeValueOnRule', () => {\n \texpect(\n \t\texchangeValueOnRule('The name is {{ dataName }}', {\n@@ -69,7 +136,7 @@ test('exchangeValueOnRule', () => {\n \t\texchangeValueOnRule(\n \t\t\t{\n \t\t\t\tvalue: 'The name is {{ dataName }}',\n-\t\t\t\toption: {\n+\t\t\t\toptions: {\n \t\t\t\t\tpropA: 'The name is {{ dataName }}',\n \t\t\t\t\tpropB: ['The name is {{ dataName }}'],\n \t\t\t\t\tpropC: {\n@@ -119,3 +186,30 @@ test('exchangeValueOnRule', () => {\n \t\t},\n \t});\n });\n+\n+describe('exchangeValueOnRule edge cases', () => {\n+\ttest('boolean value is returned as-is', () => {\n+\t\texpect(exchangeValueOnRule(true, { dataName: 'hoge' })).toBe(true);\n+\t});\n+\n+\ttest('number value is returned as-is', () => {\n+\t\texpect(exchangeValueOnRule(42, { dataName: 'hoge' })).toBe(42);\n+\t});\n+\n+\ttest('null value returns null', () => {\n+\t\texpect(exchangeValueOnRule(null, { dataName: 'hoge' })).toBeNull();\n+\t});\n+\n+\ttest('reason becomes undefined when template rendering fails', () => {\n+\t\tconst result = exchangeValueOnRule(\n+\t\t\t{\n+\t\t\t\tvalue: 'static',\n+\t\t\t\treason: '{{ missingVar }}',\n+\t\t\t},\n+\t\t\t{ dataName: 'hoge' },\n+\t\t);\n+\t\texpect(result).toStrictEqual({\n+\t\t\tvalue: 'static',\n+\t\t});\n+\t});\n+});\ndiff --git a/packages/@markuplint/ml-config/src/utils.ts b/packages/@markuplint/ml-config/src/utils.ts\nindex d5e2763d2c..5d319fdcc7 100644\n--- a/packages/@markuplint/ml-config/src/utils.ts\n+++ b/packages/@markuplint/ml-config/src/utils.ts\n@@ -1,12 +1,4 @@\n-import type {\n-\tAnyRule,\n-\tAnyRuleV2,\n-\tPlainData,\n-\tPrimitiveScalar,\n-\tRuleConfig,\n-\tRuleConfigV2,\n-\tRuleConfigValue,\n-} from './types.js';\n+import type { AnyRule, PlainData, PrimitiveScalar, RuleConfig, RuleConfigValue } from './types.js';\n \n // @ts-ignore\n import { isPlainObject } from 'is-plain-object';\n@@ -45,10 +37,7 @@ export function provideValue(template: string, data: Readonly<Record<string, str\n  * @param data - Key-value pairs for template variable replacement\n  * @returns The rule with all template strings rendered, or `undefined` if rendering fails\n  */\n-export function exchangeValueOnRule(\n-\trule: AnyRule | AnyRuleV2,\n-\tdata: Readonly<Record<string, string>>,\n-): AnyRule | undefined {\n+export function exchangeValueOnRule(rule: AnyRule, data: Readonly<Record<string, string>>): AnyRule | undefined {\n \tif (isRuleConfigValue(rule)) {\n \t\treturn exchangeValue(rule, data);\n \t}\n@@ -59,7 +48,7 @@ export function exchangeValueOnRule(\n \t\t\tvalue: exchangeValue(result.value, data),\n \t\t};\n \t}\n-\tconst options = extractOptions(result);\n+\tconst options = result.options;\n \tif (options != null && options !== '' && options !== 0) {\n \t\tconst newOptions = exchangeOption(options, data);\n \t\tresult = {\n@@ -85,18 +74,15 @@ export function exchangeValueOnRule(\n /**\n  * Normalizes a rule configuration by extracting the standard fields\n  * (`severity`, `value`, `options`, `reason`) and removing `undefined` properties.\n- * Also handles the deprecated `option` field by mapping it to `options`.\n  *\n  * @param rule - The rule configuration to normalize\n  * @returns A clean rule configuration with only defined properties\n  */\n-export function cleanOptions(\n-\trule: RuleConfig<RuleConfigValue, PlainData> | RuleConfigV2<RuleConfigValue, PlainData>,\n-): RuleConfig<RuleConfigValue, PlainData> {\n+export function cleanOptions(rule: RuleConfig<RuleConfigValue, PlainData>): RuleConfig<RuleConfigValue, PlainData> {\n \tconst res = {\n \t\tseverity: rule.severity,\n \t\tvalue: rule.value,\n-\t\toptions: extractOptions(rule),\n+\t\toptions: rule.options,\n \t\treason: rule.reason,\n \t};\n \tdeleteUndefProp(res);\n@@ -141,21 +127,6 @@ export function deleteUndefProp(obj: any) {\n \t}\n }\n \n-/**\n- * Return options from `options` or `option`\n- *\n- * @param rule\n- * @returns\n- */\n-function extractOptions(rule: RuleConfig<RuleConfigValue, PlainData> | RuleConfigV2<RuleConfigValue, PlainData>) {\n-\tif ('options' in rule && rule.options != null) {\n-\t\treturn rule.options;\n-\t}\n-\tif ('option' in rule && rule.option != null) {\n-\t\treturn rule.option;\n-\t}\n-}\n-\n function exchangeValue(rule: RuleConfigValue, data: Readonly<Record<string, string>>): RuleConfigValue | undefined {\n \tif (rule == null) {\n \t\treturn rule;\ndiff --git a/yarn.lock b/yarn.lock\nindex eebdd7ef20..ae749cce08 100644\n--- a/yarn.lock\n+++ b/yarn.lock\n@@ -2712,7 +2712,6 @@ __metadata:\n     \"@markuplint/selector\": \"npm:4.7.8\"\n     \"@markuplint/shared\": \"npm:4.4.13\"\n     \"@types/mustache\": \"npm:4.2.6\"\n-    deepmerge: \"npm:4.3.1\"\n     is-plain-object: \"npm:5.0.0\"\n     mustache: \"npm:4.2.0\"\n     type-fest: \"npm:5.4.4\"\n@@ -7615,13 +7614,6 @@ __metadata:\n   languageName: node\n   linkType: hard\n \n-\"deepmerge@npm:4.3.1\":\n-  version: 4.3.1\n-  resolution: \"deepmerge@npm:4.3.1\"\n-  checksum: 10c0/e53481aaf1aa2c4082b5342be6b6d8ad9dfe387bc92ce197a66dea08bd4265904a087e75e464f14d1347cf2ac8afe1e4c16b266e0561cc5df29382d3c5f80044\n-  languageName: node\n-  linkType: hard\n-\n \"default-browser-id@npm:^5.0.0\":\n   version: 5.0.0\n   resolution: \"default-browser-id@npm:5.0.0\"\n"
test_patch: ''
fail_to_pass: []
pass_to_pass:
- yarn vitest run packages/@markuplint/ml-config/src/merge-config.spec.ts
- yarn vitest run packages/@markuplint/ml-config/src/utils.spec.ts
- yarn vitest run packages/@markuplint/ml-spec/src/utils/schema-to-spec.spec.ts
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '822'
  difficulty: hard
  files_changed: '18'
  pr_title: 'refactor(ml-config)!: simplify merge algorithm for v5'
  removed_lines: '257'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  markuplint/markuplint (#3177): refactor(ml-config)!: simplify merge algorithm for v5

  ## Summary

  - Replace `deepmerge` with shallow merge (`{...a, ...b}`) for all object merging
  - Change rule array values from concatenation to override (right-side wins), consistent with ESLint/Biome
  - Change pretenders `data` merge from override to append, `files`/`imports` remain override
  - Remove deprecated `option` (singular) field support and `RuleV2`/`RuleConfigV2`/`AnyRuleV2` types
  - Remove array support for `specs` config field
  - Simplify `concatArray` helper
  - Add comprehensive test coverage (62 tests, up from 28)
  - Update all documentation (ARCHITECTURE, maintenance guide, SKILL, merge-config spec)
  - Add v4→v5 migration guide sections for merge behavior changes
  - Fix `file-resolver` test fixtures using deprecated `option` field

  ## BREAKING CHANGES

  - Rule array values now override instead of concatenate when merging configs
  - Rule options use shallow merge instead of deep merge
  - Pretender `data` arrays now append instead of override
  - Deprecated `option` (singular) field on `RuleConfig` is no longer supported — use `options` (plural)
  - Deprecated `RuleV2`, `RuleConfigV2`, `AnyRuleV2` types removed
  - `specs` config field no longer accepts array form

  ## Test plan

  - [x] `yarn lint` — 1383 files, 0 issues
  - [x] `yarn build` — 37 projects all pass
  - [x] `yarn test` — 1511 passed (1 flaky CLI timeout, unrelated)
  - [x] `npx vitest run packages/@markuplint/ml-config/` — 62 tests pass
  - [x] `npx vitest run packages/@markuplint/file-resolver/` — 24 tests pass

  🤖 Generated with [Claude Code](https://claude.com/claude-code)
quality_score: 0.8
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
