id: sigil-dev/sigil-15
repo: sigil-dev/sigil
base_commit: 0494473b38c10df4a6308632219c9dd7bc7e2319
merge_commit: f68ee73d0f301e655749234bb780a40b392ee9c2
language: go
difficulty_score: 3
created_at: 2026-02-14T12:38:03.634086323Z
patch: "diff --git a/cmd/sigil/chat.go b/cmd/sigil/chat.go\nindex 473ad8f..69c8cb8 100644\n--- a/cmd/sigil/chat.go\n+++ b/cmd/sigil/chat.go\n@@ -4,6 +4,7 @@\n package main\n \n import (\n+\t\"encoding/json\"\n \t\"fmt\"\n \t\"strings\"\n \n@@ -21,6 +22,7 @@ func newChatCmd() *cobra.Command {\n \tcmd.Flags().StringP(\"workspace\", \"w\", \"\", \"workspace to chat in\")\n \tcmd.Flags().StringP(\"model\", \"m\", \"\", \"model override\")\n \tcmd.Flags().StringP(\"session\", \"s\", \"\", \"resume existing session by ID\")\n+\tcmd.Flags().String(\"address\", \"127.0.0.1:18789\", \"gateway address\")\n \n \treturn cmd\n }\n@@ -31,12 +33,66 @@ func runChat(cmd *cobra.Command, args []string) error {\n \t\tworkspace = \"default\"\n \t}\n \n-\t// TODO: Connect to gateway SSE endpoint once server is implemented.\n-\tif len(args) > 0 {\n-\t\t_, err := fmt.Fprintf(cmd.OutOrStdout(), \"[%s] You: %s\\n\", workspace, strings.Join(args, \" \"))\n+\tif len(args) == 0 {\n+\t\t_, err := fmt.Fprintf(cmd.OutOrStdout(), \"Interactive chat in workspace %q (connect to gateway SSE endpoint)\\n\", workspace)\n \t\treturn err\n \t}\n \n-\t_, err := fmt.Fprintf(cmd.OutOrStdout(), \"Interactive chat in workspace %q (not yet implemented)\\n\", workspace)\n-\treturn err\n+\taddr, _ := cmd.Flags().GetString(\"address\")\n+\tmodel, _ := cmd.Flags().GetString(\"model\")\n+\tsessionID, _ := cmd.Flags().GetString(\"session\")\n+\n+\treturn streamChat(cmd, addr, chatRequest{\n+\t\tContent:     strings.Join(args, \" \"),\n+\t\tWorkspaceID: workspace,\n+\t\tSessionID:   sessionID,\n+\t\tModel:       model,\n+\t})\n+}\n+\n+// chatRequest is the request body sent to the gateway's chat/stream endpoint.\n+type chatRequest struct {\n+\tContent     string `json:\"content\"`\n+\tWorkspaceID string `json:\"workspace_id\"`\n+\tSessionID   string `json:\"session_id,omitempty\"`\n+\tModel       string `json:\"model,omitempty\"`\n+}\n+\n+// streamChat connects to the gateway SSE endpoint, streams text_delta events\n+// to stdout and error events to stderr.\n+func streamChat(cmd *cobra.Command, addr string, req chatRequest) error {\n+\tgw := newGatewayClient(addr)\n+\n+\tevents, err := gw.postSSE(\"/api/v1/chat/stream\", req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tstdout := cmd.OutOrStdout()\n+\tstderr := cmd.ErrOrStderr()\n+\n+\tfor ev := range events {\n+\t\tswitch ev.Event {\n+\t\tcase \"text_delta\":\n+\t\t\tvar delta struct {\n+\t\t\t\tText string `json:\"text\"`\n+\t\t\t}\n+\t\t\tif jsonErr := json.Unmarshal([]byte(ev.Data), &delta); jsonErr == nil {\n+\t\t\t\t_, _ = fmt.Fprint(stdout, delta.Text)\n+\t\t\t}\n+\t\tcase \"error\":\n+\t\t\tvar errData struct {\n+\t\t\t\tMessage string `json:\"message\"`\n+\t\t\t}\n+\t\t\tif jsonErr := json.Unmarshal([]byte(ev.Data), &errData); jsonErr == nil {\n+\t\t\t\t_, _ = fmt.Fprintf(stderr, \"Error: %s\\n\", errData.Message)\n+\t\t\t} else {\n+\t\t\t\t_, _ = fmt.Fprintf(stderr, \"Error: %s\\n\", ev.Data)\n+\t\t\t}\n+\t\tcase \"done\":\n+\t\t\t// Stream complete.\n+\t\t}\n+\t}\n+\n+\treturn nil\n }\ndiff --git a/cmd/sigil/chat_test.go b/cmd/sigil/chat_test.go\nnew file mode 100644\nindex 0000000..6379fdc\n--- /dev/null\n+++ b/cmd/sigil/chat_test.go\n@@ -0,0 +1,201 @@\n+// SPDX-License-Identifier: Apache-2.0\n+// Copyright 2026 Sigil Contributors\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\tsigilerr \"github.com/sigil-dev/sigil/pkg/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestChat_StreamsTextDelta(t *testing.T) {\n+\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.URL.Path != \"/api/v1/chat/stream\" || r.Method != http.MethodPost {\n+\t\t\thttp.NotFound(w, r)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Verify request body.\n+\t\tvar req struct {\n+\t\t\tContent     string `json:\"content\"`\n+\t\t\tWorkspaceID string `json:\"workspace_id\"`\n+\t\t}\n+\t\trequire.NoError(t, json.NewDecoder(r.Body).Decode(&req))\n+\t\tassert.Equal(t, \"hello world\", req.Content)\n+\t\tassert.Equal(t, \"default\", req.WorkspaceID)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n+\t\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n+\t\t_, _ = fmt.Fprint(w, \"event: text_delta\\ndata: {\\\"text\\\":\\\"Hello\\\"}\\n\\n\")\n+\t\t_, _ = fmt.Fprint(w, \"event: text_delta\\ndata: {\\\"text\\\":\\\" world\\\"}\\n\\n\")\n+\t\t_, _ = fmt.Fprint(w, \"event: done\\ndata: {}\\n\\n\")\n+\t}))\n+\tdefer srv.Close()\n+\n+\told := defaultHTTPClient\n+\tdefaultHTTPClient = srv.Client()\n+\tdefer func() { defaultHTTPClient = old }()\n+\n+\taddr := srv.URL[len(\"http://\"):]\n+\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\tstderr := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetErr(stderr)\n+\troot.SetArgs([]string{\"chat\", \"--address\", addr, \"hello\", \"world\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"Hello world\", stdout.String())\n+}\n+\n+func TestChat_ConnectionFailure(t *testing.T) {\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\tstderr := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetErr(stderr)\n+\troot.SetArgs([]string{\"chat\", \"--address\", \"127.0.0.1:1\", \"hello\"})\n+\n+\terr := root.Execute()\n+\trequire.Error(t, err)\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeCLIGatewayNotRunning),\n+\t\t\"expected CodeCLIGatewayNotRunning, got %s\", sigilerr.CodeOf(err))\n+}\n+\n+func TestChat_ErrorEvents(t *testing.T) {\n+\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n+\t\t_, _ = fmt.Fprint(w, \"event: text_delta\\ndata: {\\\"text\\\":\\\"partial\\\"}\\n\\n\")\n+\t\t_, _ = fmt.Fprint(w, \"event: error\\ndata: {\\\"message\\\":\\\"provider timeout\\\"}\\n\\n\")\n+\t\t_, _ = fmt.Fprint(w, \"event: done\\ndata: {}\\n\\n\")\n+\t}))\n+\tdefer srv.Close()\n+\n+\told := defaultHTTPClient\n+\tdefaultHTTPClient = srv.Client()\n+\tdefer func() { defaultHTTPClient = old }()\n+\n+\taddr := srv.URL[len(\"http://\"):]\n+\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\tstderr := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetErr(stderr)\n+\troot.SetArgs([]string{\"chat\", \"--address\", addr, \"hello\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"partial\", stdout.String())\n+\tassert.Contains(t, stderr.String(), \"provider timeout\")\n+}\n+\n+func TestChat_NoArgs_InteractiveStub(t *testing.T) {\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetArgs([]string{\"chat\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\tassert.Contains(t, stdout.String(), \"Interactive chat\")\n+\tassert.Contains(t, stdout.String(), \"default\")\n+}\n+\n+func TestChat_CustomWorkspace(t *testing.T) {\n+\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tvar req struct {\n+\t\t\tWorkspaceID string `json:\"workspace_id\"`\n+\t\t}\n+\t\t_ = json.NewDecoder(r.Body).Decode(&req)\n+\t\tassert.Equal(t, \"myws\", req.WorkspaceID)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n+\t\t_, _ = fmt.Fprint(w, \"event: text_delta\\ndata: {\\\"text\\\":\\\"ok\\\"}\\n\\n\")\n+\t\t_, _ = fmt.Fprint(w, \"event: done\\ndata: {}\\n\\n\")\n+\t}))\n+\tdefer srv.Close()\n+\n+\told := defaultHTTPClient\n+\tdefaultHTTPClient = srv.Client()\n+\tdefer func() { defaultHTTPClient = old }()\n+\n+\taddr := srv.URL[len(\"http://\"):]\n+\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetArgs([]string{\"chat\", \"--address\", addr, \"--workspace\", \"myws\", \"hi\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"ok\", stdout.String())\n+}\n+\n+func TestChat_ModelAndSessionFlags(t *testing.T) {\n+\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tvar req struct {\n+\t\t\tContent     string `json:\"content\"`\n+\t\t\tWorkspaceID string `json:\"workspace_id\"`\n+\t\t\tSessionID   string `json:\"session_id\"`\n+\t\t\tModel       string `json:\"model\"`\n+\t\t}\n+\t\t_ = json.NewDecoder(r.Body).Decode(&req)\n+\t\tassert.Equal(t, \"sess-123\", req.SessionID)\n+\t\tassert.Equal(t, \"claude-4\", req.Model)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n+\t\t_, _ = fmt.Fprint(w, \"event: text_delta\\ndata: {\\\"text\\\":\\\"reply\\\"}\\n\\n\")\n+\t\t_, _ = fmt.Fprint(w, \"event: done\\ndata: {}\\n\\n\")\n+\t}))\n+\tdefer srv.Close()\n+\n+\told := defaultHTTPClient\n+\tdefaultHTTPClient = srv.Client()\n+\tdefer func() { defaultHTTPClient = old }()\n+\n+\taddr := srv.URL[len(\"http://\"):]\n+\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetArgs([]string{\"chat\", \"--address\", addr, \"--model\", \"claude-4\", \"--session\", \"sess-123\", \"test\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"reply\", stdout.String())\n+}\n+\n+func TestChat_ServerError(t *testing.T) {\n+\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n+\t\tw.WriteHeader(http.StatusInternalServerError)\n+\t\t_, _ = w.Write([]byte(\"internal error\"))\n+\t}))\n+\tdefer srv.Close()\n+\n+\told := defaultHTTPClient\n+\tdefaultHTTPClient = srv.Client()\n+\tdefer func() { defaultHTTPClient = old }()\n+\n+\taddr := srv.URL[len(\"http://\"):]\n+\n+\troot := NewRootCmd()\n+\tstdout := new(bytes.Buffer)\n+\troot.SetOut(stdout)\n+\troot.SetArgs([]string{\"chat\", \"--address\", addr, \"hello\"})\n+\n+\terr := root.Execute()\n+\trequire.Error(t, err)\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeCLIRequestFailure),\n+\t\t\"expected CodeCLIRequestFailure, got %s\", sigilerr.CodeOf(err))\n+}\ndiff --git a/cmd/sigil/client.go b/cmd/sigil/client.go\nindex 99a34fb..04426f0 100644\n--- a/cmd/sigil/client.go\n+++ b/cmd/sigil/client.go\n@@ -4,11 +4,14 @@\n package main\n \n import (\n+\t\"bufio\"\n+\t\"bytes\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"io\"\n \t\"net\"\n \t\"net/http\"\n+\t\"strings\"\n \t\"time\"\n \n \tsigilerr \"github.com/sigil-dev/sigil/pkg/errors\"\n@@ -57,6 +60,92 @@ func (c *gatewayClient) getJSON(path string, dest interface{}) error {\n \treturn nil\n }\n \n+// chatStreamEvent is a single SSE event parsed from the chat/stream response.\n+type chatStreamEvent struct {\n+\tEvent string\n+\tData  string\n+}\n+\n+// postSSE sends a POST request and streams SSE events via the returned channel.\n+// The channel is closed when the stream ends. The caller must drain the channel.\n+// Returns an error with CodeCLIGatewayNotRunning on connection refused.\n+func (c *gatewayClient) postSSE(path string, body interface{}) (<-chan chatStreamEvent, error) {\n+\tpayload, err := json.Marshal(body)\n+\tif err != nil {\n+\t\treturn nil, sigilerr.Errorf(sigilerr.CodeCLIRequestFailure, \"marshaling request: %w\", err)\n+\t}\n+\n+\treq, err := http.NewRequest(http.MethodPost, c.baseURL+path, bytes.NewReader(payload))\n+\tif err != nil {\n+\t\treturn nil, sigilerr.Errorf(sigilerr.CodeCLIRequestFailure, \"creating request: %w\", err)\n+\t}\n+\treq.Header.Set(\"Content-Type\", \"application/json\")\n+\treq.Header.Set(\"Accept\", \"text/event-stream\")\n+\n+\t// Use a client without timeout for streaming.\n+\tstreamClient := &http.Client{Transport: c.http.Transport}\n+\tresp, err := streamClient.Do(req)\n+\tif err != nil {\n+\t\tif isDialError(err) {\n+\t\t\treturn nil, sigilerr.New(sigilerr.CodeCLIGatewayNotRunning, \"gateway is not running (connection refused)\")\n+\t\t}\n+\t\treturn nil, sigilerr.Errorf(sigilerr.CodeCLIRequestFailure, \"request failed: %w\", err)\n+\t}\n+\n+\tif resp.StatusCode != http.StatusOK {\n+\t\tdefer func() { _ = resp.Body.Close() }()\n+\t\trespBody, _ := io.ReadAll(resp.Body)\n+\t\treturn nil, sigilerr.Errorf(sigilerr.CodeCLIRequestFailure, \"gateway returned status %d: %s\", resp.StatusCode, string(respBody))\n+\t}\n+\n+\tch := make(chan chatStreamEvent, 16)\n+\tgo func() {\n+\t\tdefer func() { _ = resp.Body.Close() }()\n+\t\tdefer close(ch)\n+\t\tparseSSEStream(resp.Body, ch)\n+\t}()\n+\n+\treturn ch, nil\n+}\n+\n+// parseSSEStream reads an SSE stream and sends parsed events to ch.\n+func parseSSEStream(r io.Reader, ch chan<- chatStreamEvent) {\n+\tscanner := bufio.NewScanner(r)\n+\tvar currentEvent string\n+\tvar dataLines []string\n+\n+\tfor scanner.Scan() {\n+\t\tline := scanner.Text()\n+\n+\t\tif line == \"\" {\n+\t\t\t// Empty line = end of event.\n+\t\t\tif currentEvent != \"\" || len(dataLines) > 0 {\n+\t\t\t\tch <- chatStreamEvent{\n+\t\t\t\t\tEvent: currentEvent,\n+\t\t\t\t\tData:  strings.Join(dataLines, \"\\n\"),\n+\t\t\t\t}\n+\t\t\t\tcurrentEvent = \"\"\n+\t\t\t\tdataLines = nil\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif strings.HasPrefix(line, \"event: \") {\n+\t\t\tcurrentEvent = strings.TrimPrefix(line, \"event: \")\n+\t\t} else if strings.HasPrefix(line, \"data: \") {\n+\t\t\tdataLines = append(dataLines, strings.TrimPrefix(line, \"data: \"))\n+\t\t}\n+\t}\n+\n+\t// Flush any trailing event without final blank line.\n+\tif currentEvent != \"\" || len(dataLines) > 0 {\n+\t\tch <- chatStreamEvent{\n+\t\t\tEvent: currentEvent,\n+\t\t\tData:  strings.Join(dataLines, \"\\n\"),\n+\t\t}\n+\t}\n+}\n+\n // isDialError returns true if err is a net dial error (connection refused, etc.).\n func isDialError(err error) bool {\n \tvar opErr *net.OpError\ndiff --git a/cmd/sigil/doctor.go b/cmd/sigil/doctor.go\nindex 4c0dc34..bc34ce0 100644\n--- a/cmd/sigil/doctor.go\n+++ b/cmd/sigil/doctor.go\n@@ -5,22 +5,33 @@ package main\n \n import (\n \t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n \t\"runtime\"\n \n+\tsigilerr \"github.com/sigil-dev/sigil/pkg/errors\"\n \t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/sys/unix\"\n )\n \n func newDoctorCmd() *cobra.Command {\n-\treturn &cobra.Command{\n+\tcmd := &cobra.Command{\n \t\tUse:   \"doctor\",\n \t\tShort: \"Run diagnostics\",\n \t\tLong:  \"Check binary health, provider API keys, channel connections, disk space, and other system requirements.\",\n \t\tRunE:  runDoctor,\n \t}\n+\n+\tcmd.Flags().String(\"address\", \"127.0.0.1:18789\", \"gateway address to check\")\n+\n+\treturn cmd\n }\n \n func runDoctor(cmd *cobra.Command, _ []string) error {\n \tw := cmd.OutOrStdout()\n+\taddr, _ := cmd.Flags().GetString(\"address\")\n+\tdataDir := resolveDataDir()\n \n \tchecks := []struct {\n \t\tname string\n@@ -28,6 +39,10 @@ func runDoctor(cmd *cobra.Command, _ []string) error {\n \t}{\n \t\t{\"Binary\", checkBinary},\n \t\t{\"Platform\", checkPlatform},\n+\t\t{\"Gateway\", func() string { return checkGateway(addr) }},\n+\t\t{\"Config\", checkConfig},\n+\t\t{\"Plugins\", func() string { return checkPlugins(dataDir) }},\n+\t\t{\"Disk Space\", func() string { return checkDiskSpace(dataDir) }},\n \t}\n \n \tfor _, c := range checks {\n@@ -36,9 +51,17 @@ func runDoctor(cmd *cobra.Command, _ []string) error {\n \t\t}\n \t}\n \n-\t// TODO: Add checks for providers, channels, disk space, Tailscale once subsystems are wired.\n-\t_, err := fmt.Fprintln(w, \"\\nAdditional checks will be available once the gateway is running.\")\n-\treturn err\n+\treturn nil\n+}\n+\n+// resolveDataDir returns the data directory from viper or the default.\n+func resolveDataDir() string {\n+\tdataDir := viper.GetString(\"data_dir\")\n+\tif dataDir != \"\" {\n+\t\treturn dataDir\n+\t}\n+\thome, _ := os.UserHomeDir()\n+\treturn filepath.Join(home, \".sigil\")\n }\n \n func checkBinary() string {\n@@ -48,3 +71,80 @@ func checkBinary() string {\n func checkPlatform() string {\n \treturn fmt.Sprintf(\"%s/%s, Go %s\", runtime.GOOS, runtime.GOARCH, runtime.Version())\n }\n+\n+func checkGateway(addr string) string {\n+\tgw := newGatewayClient(addr)\n+\tvar body struct {\n+\t\tStatus string `json:\"status\"`\n+\t}\n+\tif err := gw.getJSON(\"/api/v1/status\", &body); err != nil {\n+\t\tif sigilerr.HasCode(err, sigilerr.CodeCLIGatewayNotRunning) {\n+\t\t\treturn fmt.Sprintf(\"not running at %s (run 'sigil start')\", addr)\n+\t\t}\n+\t\treturn fmt.Sprintf(\"error: %s\", err)\n+\t}\n+\treturn fmt.Sprintf(\"%s at %s\", body.Status, addr)\n+}\n+\n+func checkConfig() string {\n+\tcfgFile := viper.ConfigFileUsed()\n+\tif cfgFile != \"\" {\n+\t\treturn fmt.Sprintf(\"loaded from %s\", cfgFile)\n+\t}\n+\treturn \"using defaults (no config file found)\"\n+}\n+\n+func checkPlugins(dataDir string) string {\n+\tpluginsDir := filepath.Join(dataDir, \"plugins\")\n+\tentries, err := os.ReadDir(pluginsDir)\n+\tif err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\treturn fmt.Sprintf(\"no plugins directory at %s\", pluginsDir)\n+\t\t}\n+\t\treturn fmt.Sprintf(\"error reading plugins: %s\", err)\n+\t}\n+\n+\tcount := 0\n+\tfor _, e := range entries {\n+\t\tif !e.IsDir() && e.Name()[0] != '.' {\n+\t\t\tcount++\n+\t\t}\n+\t}\n+\n+\tif count == 0 {\n+\t\treturn \"no plugins installed\"\n+\t}\n+\treturn fmt.Sprintf(\"%d plugin(s) found in %s\", count, pluginsDir)\n+}\n+\n+func checkDiskSpace(dataDir string) string {\n+\tpath := dataDir\n+\tif _, err := os.Stat(path); os.IsNotExist(err) {\n+\t\t// Fall back to home directory if data dir doesn't exist yet.\n+\t\tpath, _ = os.UserHomeDir()\n+\t}\n+\n+\tvar stat unix.Statfs_t\n+\tif err := unix.Statfs(path, &stat); err != nil {\n+\t\treturn fmt.Sprintf(\"unable to check: %s\", err)\n+\t}\n+\n+\tavailBytes := stat.Bavail * uint64(stat.Bsize)\n+\treturn formatBytes(availBytes) + \" available\"\n+}\n+\n+// formatBytes formats a byte count as a human-readable string.\n+func formatBytes(b uint64) string {\n+\tconst (\n+\t\tgb = 1024 * 1024 * 1024\n+\t\tmb = 1024 * 1024\n+\t)\n+\tswitch {\n+\tcase b >= gb:\n+\t\treturn fmt.Sprintf(\"%.1f GB\", float64(b)/float64(gb))\n+\tcase b >= mb:\n+\t\treturn fmt.Sprintf(\"%.1f MB\", float64(b)/float64(mb))\n+\tdefault:\n+\t\treturn fmt.Sprintf(\"%d bytes\", b)\n+\t}\n+}\ndiff --git a/cmd/sigil/doctor_test.go b/cmd/sigil/doctor_test.go\nnew file mode 100644\nindex 0000000..8d96bde\n--- /dev/null\n+++ b/cmd/sigil/doctor_test.go\n@@ -0,0 +1,144 @@\n+// SPDX-License-Identifier: Apache-2.0\n+// Copyright 2026 Sigil Contributors\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestDoctor_RunsAllChecks(t *testing.T) {\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\t// Must contain the check names from all implemented checks.\n+\tassert.Contains(t, output, \"Binary:\")\n+\tassert.Contains(t, output, \"Platform:\")\n+\tassert.Contains(t, output, \"Gateway:\")\n+\tassert.Contains(t, output, \"Config:\")\n+\tassert.Contains(t, output, \"Disk Space:\")\n+}\n+\n+func TestDoctor_GatewayRunning(t *testing.T) {\n+\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.URL.Path != \"/api/v1/status\" {\n+\t\t\thttp.NotFound(w, r)\n+\t\t\treturn\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\t_ = json.NewEncoder(w).Encode(map[string]string{\"status\": \"ok\"})\n+\t}))\n+\tdefer srv.Close()\n+\n+\told := defaultHTTPClient\n+\tdefaultHTTPClient = srv.Client()\n+\tdefer func() { defaultHTTPClient = old }()\n+\n+\taddr := srv.URL[len(\"http://\"):]\n+\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\", \"--address\", addr})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\tassert.Contains(t, output, \"Gateway:\")\n+\tassert.Contains(t, output, \"ok\")\n+}\n+\n+func TestDoctor_GatewayNotRunning(t *testing.T) {\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\", \"--address\", \"127.0.0.1:1\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\tassert.Contains(t, output, \"Gateway:\")\n+\tassert.Contains(t, output, \"not running\")\n+}\n+\n+func TestDoctor_PluginsDir(t *testing.T) {\n+\tdir := t.TempDir()\n+\tpluginsDir := filepath.Join(dir, \"plugins\")\n+\trequire.NoError(t, os.MkdirAll(pluginsDir, 0o755))\n+\n+\t// Create a fake plugin file.\n+\trequire.NoError(t, os.WriteFile(filepath.Join(pluginsDir, \"test-plugin\"), []byte(\"x\"), 0o755))\n+\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\", \"--data-dir\", dir, \"--address\", \"127.0.0.1:1\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\tassert.Contains(t, output, \"Plugins:\")\n+\tassert.Contains(t, output, \"1 plugin\")\n+}\n+\n+func TestDoctor_PluginsDirMissing(t *testing.T) {\n+\tdir := t.TempDir()\n+\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\", \"--data-dir\", dir, \"--address\", \"127.0.0.1:1\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\tassert.Contains(t, output, \"Plugins:\")\n+\tassert.Contains(t, output, \"no plugins directory\")\n+}\n+\n+func TestDoctor_DiskSpace(t *testing.T) {\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\tassert.Contains(t, output, \"Disk Space:\")\n+\t// Should show available space in some unit (GB, MB, etc.).\n+\tassert.Regexp(t, `\\d+(\\.\\d+)?\\s*(GB|MB|TB)`, output)\n+}\n+\n+func TestDoctor_ConfigCheck(t *testing.T) {\n+\troot := NewRootCmd()\n+\tbuf := new(bytes.Buffer)\n+\troot.SetOut(buf)\n+\troot.SetArgs([]string{\"doctor\"})\n+\n+\terr := root.Execute()\n+\trequire.NoError(t, err)\n+\n+\toutput := buf.String()\n+\tassert.Contains(t, output, \"Config:\")\n+}\ndiff --git a/cmd/sigil/wire.go b/cmd/sigil/wire.go\nindex f357b46..928db79 100644\n--- a/cmd/sigil/wire.go\n+++ b/cmd/sigil/wire.go\n@@ -88,9 +88,15 @@ func WireGateway(ctx context.Context, cfg *config.Config, dataDir string) (*Gate\n \t}\n \n \t// 6. HTTP server.\n+\tvar tokenValidator server.TokenValidator\n+\tif len(cfg.Auth.Tokens) > 0 {\n+\t\ttokenValidator = newConfigTokenValidator(cfg.Auth.Tokens)\n+\t}\n+\n \tsrv, err := server.New(server.Config{\n-\t\tListenAddr:  cfg.Networking.Listen,\n-\t\tCORSOrigins: nil, // use defaults\n+\t\tListenAddr:     cfg.Networking.Listen,\n+\t\tCORSOrigins:    nil, // use defaults\n+\t\tTokenValidator: tokenValidator,\n \t})\n \tif err != nil {\n \t\t_ = gs.Close()\n@@ -324,3 +330,27 @@ func (a *userServiceAdapter) List(ctx context.Context) ([]server.UserSummary, er\n \t}\n \treturn out, nil\n }\n+\n+// configTokenValidator validates bearer tokens against static config entries.\n+type configTokenValidator struct {\n+\ttokens map[string]*server.AuthenticatedUser\n+}\n+\n+func newConfigTokenValidator(tokens []config.TokenConfig) *configTokenValidator {\n+\tm := make(map[string]*server.AuthenticatedUser, len(tokens))\n+\tfor _, tc := range tokens {\n+\t\tm[tc.Token] = &server.AuthenticatedUser{\n+\t\t\tID:          tc.UserID,\n+\t\t\tName:        tc.Name,\n+\t\t\tPermissions: tc.Permissions,\n+\t\t}\n+\t}\n+\treturn &configTokenValidator{tokens: m}\n+}\n+\n+func (v *configTokenValidator) ValidateToken(_ context.Context, token string) (*server.AuthenticatedUser, error) {\n+\tif user, ok := v.tokens[token]; ok {\n+\t\treturn user, nil\n+\t}\n+\treturn nil, sigilerr.New(sigilerr.CodeServerAuthUnauthorized, \"invalid token\")\n+}\ndiff --git a/docs/decisions/decision-log.md b/docs/decisions/decision-log.md\nindex ac0eb46..2555f3f 100644\n--- a/docs/decisions/decision-log.md\n+++ b/docs/decisions/decision-log.md\n@@ -759,3 +759,23 @@ The interface-first approach means we can adopt either when their Go SDKs stabil\n **Rationale:** The provider creation error path (`wire.go:180-183`) is a defensive guard — all current constructors succeed with non-empty API keys. But future providers may have richer validation. The factory map makes this path testable without changing the public API or over-engineering the function signature. The pattern is local to `cmd/sigil` and doesn't leak into the provider packages.\n \n **Ref:** PR #14 review, `cmd/sigil/wire.go`, `cmd/sigil/wire_test.go`\n+\n+---\n+\n+## D059: Auth Middleware — Bearer Token Validation (Supersedes D049)\n+\n+> **Supersedes D049.** The pass-through stub described in D049 has been replaced with full bearer token validation.\n+\n+**Question:** D049 deferred auth to a security phase, but `sigil-9s6` tracked implementing bearer token validation. Should this be done in the Phase 5 PR or remain a stub?\n+\n+**Options considered:**\n+\n+- Keep stub, defer to dedicated security PR — rejected: the `TokenValidator` interface and middleware are clean, self-contained, and already have comprehensive tests. Deferring adds unnecessary delay.\n+- Full ABAC with capability checks — rejected: still too early. Identity resolution, workspace membership, and capability enforcement remain separate subsystems.\n+- Bearer token validation with dev-mode bypass (chosen) — implements `TokenValidator` interface with config-backed static tokens. Public paths (`/health`, `/openapi.*`) bypass auth. When no tokens are configured, auth is disabled (dev mode).\n+\n+**Decision:** Replace the D049 pass-through stub with bearer token validation via a `TokenValidator` interface. The middleware validates `Authorization: Bearer <token>` headers, returns 401 for missing/invalid tokens and 403 for forbidden access. User context is injected via `UserFromContext`. Dev mode (nil validator) preserves the pass-through behavior for local development.\n+\n+**Rationale:** The `TokenValidator` interface keeps the middleware decoupled from the token storage backend. Config-backed static tokens are sufficient for the current phase. When ABAC is implemented, the interface extends naturally without changing the middleware wiring. The 9 auth tests provide confidence in the security boundary.\n+\n+**Ref:** PR #15, D049, `sigil-9s6`, `internal/server/auth.go`, `internal/server/auth_test.go`\ndiff --git a/internal/config/config.go b/internal/config/config.go\nindex d8ba549..b96ddf3 100644\n--- a/internal/config/config.go\n+++ b/internal/config/config.go\n@@ -16,6 +16,7 @@ import (\n // Config is the top-level Sigil configuration.\n type Config struct {\n \tNetworking NetworkingConfig           `mapstructure:\"networking\"`\n+\tAuth       AuthConfig                 `mapstructure:\"auth\"`\n \tProviders  map[string]ProviderConfig  `mapstructure:\"providers\"`\n \tModels     ModelsConfig               `mapstructure:\"models\"`\n \tSessions   SessionsConfig             `mapstructure:\"sessions\"`\n@@ -23,6 +24,19 @@ type Config struct {\n \tWorkspaces map[string]WorkspaceConfig `mapstructure:\"workspaces\"`\n }\n \n+// AuthConfig controls REST API authentication.\n+type AuthConfig struct {\n+\tTokens []TokenConfig `mapstructure:\"tokens\"`\n+}\n+\n+// TokenConfig maps a bearer token to a user identity.\n+type TokenConfig struct {\n+\tToken       string   `mapstructure:\"token\"`\n+\tUserID      string   `mapstructure:\"user_id\"`\n+\tName        string   `mapstructure:\"name\"`\n+\tPermissions []string `mapstructure:\"permissions\"`\n+}\n+\n // NetworkingConfig controls how Sigil listens for connections.\n type NetworkingConfig struct {\n \tMode   string `mapstructure:\"mode\"`\ndiff --git a/internal/plugin/channel.go b/internal/plugin/channel.go\nindex b06a98d..02b2399 100644\n--- a/internal/plugin/channel.go\n+++ b/internal/plugin/channel.go\n@@ -41,13 +41,16 @@ const (\n \tPairingOpen      PairingMode = \"open\"\n \tPairingClosed    PairingMode = \"closed\"\n \tPairingAllowlist PairingMode = \"allowlist\"\n+\tPairingOnRequest PairingMode = \"pair_on_request\"\n+\tPairingWithCode  PairingMode = \"pair_with_code\"\n )\n \n // ChannelRegistration holds a channel plugin along with its pairing configuration.\n type ChannelRegistration struct {\n-\tPlugin    ChannelPlugin\n-\tMode      PairingMode\n-\tAllowlist []string\n+\tPlugin      ChannelPlugin\n+\tMode        PairingMode\n+\tAllowlist   []string\n+\tPairingCode string // one-time code for pair_with_code mode\n }\n \n // ChannelRouter routes outbound messages and enforces inbound channel\n@@ -124,22 +127,26 @@ func (r *ChannelRouter) AuthorizeInbound(ctx context.Context, channelType, chann\n \tcase PairingOpen:\n \t\treturn nil\n \tcase PairingClosed:\n-\t\treturn sigilerr.New(CodeChannelPairingDenied,\n+\t\treturn sigilerr.New(sigilerr.CodeChannelPairingDenied,\n \t\t\t\"channel is closed\",\n \t\t\tsigilerr.Field(\"channel_type\", channelType),\n \t\t\tsigilerr.Field(\"channel_id\", channelID),\n \t\t)\n \tcase PairingAllowlist:\n \t\tif !slices.Contains(reg.Allowlist, userID) {\n-\t\t\treturn sigilerr.New(CodeChannelPairingDenied,\n+\t\t\treturn sigilerr.New(sigilerr.CodeChannelPairingDenied,\n \t\t\t\t\"user not in channel allowlist\",\n \t\t\t\tsigilerr.Field(\"channel_type\", channelType),\n \t\t\t\tsigilerr.Field(\"channel_id\", channelID),\n \t\t\t\tsigilerr.Field(\"user_id\", userID),\n \t\t\t)\n \t\t}\n+\tcase PairingOnRequest:\n+\t\treturn r.authorizePairOnRequest(ctx, reg, channelType, channelID, userID, workspaceID)\n+\tcase PairingWithCode:\n+\t\treturn r.authorizePairWithCode(ctx, channelType, channelID, userID, workspaceID)\n \tdefault:\n-\t\treturn sigilerr.New(CodeChannelPairingDenied,\n+\t\treturn sigilerr.New(sigilerr.CodeChannelPairingDenied,\n \t\t\t\"unknown pairing mode\",\n \t\t\tsigilerr.Field(\"channel_type\", channelType),\n \t\t\tsigilerr.Field(\"mode\", string(reg.Mode)),\n@@ -149,7 +156,7 @@ func (r *ChannelRouter) AuthorizeInbound(ctx context.Context, channelType, chann\n \t// For non-open modes (allowlist passes above), verify active pairing\n \t// scoped to the specific channel instance and workspace.\n \tif r.pairings == nil {\n-\t\treturn sigilerr.New(CodeChannelPairingRequired,\n+\t\treturn sigilerr.New(sigilerr.CodeChannelPairingRequired,\n \t\t\t\"pairing store not configured\",\n \t\t\tsigilerr.Field(\"channel_type\", channelType),\n \t\t)\n@@ -157,7 +164,7 @@ func (r *ChannelRouter) AuthorizeInbound(ctx context.Context, channelType, chann\n \n \tpairings, err := r.pairings.GetByUser(ctx, userID)\n \tif err != nil {\n-\t\treturn sigilerr.Wrap(err, CodeChannelBackendFailure,\n+\t\treturn sigilerr.Wrap(err, sigilerr.CodeChannelBackendFailure,\n \t\t\t\"pairing lookup failed\",\n \t\t\tsigilerr.Field(\"channel_type\", channelType),\n \t\t\tsigilerr.Field(\"user_id\", userID),\n@@ -171,7 +178,7 @@ func (r *ChannelRouter) AuthorizeInbound(ctx context.Context, channelType, chann\n \t\t}\n \t}\n \n-\treturn sigilerr.New(CodeChannelPairingRequired,\n+\treturn sigilerr.New(sigilerr.CodeChannelPairingRequired,\n \t\t\"no active pairing for channel\",\n \t\tsigilerr.Field(\"channel_type\", channelType),\n \t\tsigilerr.Field(\"channel_id\", channelID),\n@@ -180,6 +187,103 @@ func (r *ChannelRouter) AuthorizeInbound(ctx context.Context, channelType, chann\n \t)\n }\n \n+// authorizePairOnRequest handles the pair_on_request mode. If the user has an\n+// active pairing, access is granted. If a pending pairing exists, the user is\n+// told their request is pending. If no pairing exists, a pending pairing is\n+// auto-created for owner approval.\n+func (r *ChannelRouter) authorizePairOnRequest(ctx context.Context, _ *ChannelRegistration, channelType, channelID, userID, workspaceID string) error {\n+\tif r.pairings == nil {\n+\t\treturn sigilerr.New(sigilerr.CodeChannelPairingRequired,\n+\t\t\t\"pairing store not configured\",\n+\t\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\t)\n+\t}\n+\n+\tpairings, err := r.pairings.GetByUser(ctx, userID)\n+\tif err != nil {\n+\t\treturn sigilerr.Wrap(err, sigilerr.CodeChannelBackendFailure,\n+\t\t\t\"pairing lookup failed\",\n+\t\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\t\tsigilerr.Field(\"user_id\", userID),\n+\t\t)\n+\t}\n+\n+\tfor _, p := range pairings {\n+\t\tif p.ChannelType != channelType || p.ChannelID != channelID || p.WorkspaceID != workspaceID {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p.Status == store.PairingStatusActive {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif p.Status == store.PairingStatusPending {\n+\t\t\treturn sigilerr.New(sigilerr.CodeChannelPairingPending,\n+\t\t\t\t\"pairing request is pending approval\",\n+\t\t\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\t\t\tsigilerr.Field(\"channel_id\", channelID),\n+\t\t\t\tsigilerr.Field(\"user_id\", userID),\n+\t\t\t)\n+\t\t}\n+\t}\n+\n+\t// No existing pairing — create a pending one for owner approval.\n+\tif err := r.pairings.Create(ctx, &store.Pairing{\n+\t\tUserID:      userID,\n+\t\tChannelType: channelType,\n+\t\tChannelID:   channelID,\n+\t\tWorkspaceID: workspaceID,\n+\t\tStatus:      store.PairingStatusPending,\n+\t}); err != nil {\n+\t\treturn sigilerr.Wrap(err, sigilerr.CodeChannelBackendFailure,\n+\t\t\t\"failed to create pending pairing\",\n+\t\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\t\tsigilerr.Field(\"user_id\", userID),\n+\t\t)\n+\t}\n+\n+\treturn sigilerr.New(sigilerr.CodeChannelPairingPending,\n+\t\t\"pairing request sent, awaiting approval\",\n+\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\tsigilerr.Field(\"channel_id\", channelID),\n+\t\tsigilerr.Field(\"user_id\", userID),\n+\t)\n+}\n+\n+// authorizePairWithCode handles the pair_with_code mode. If the user has an\n+// active pairing, access is granted. Otherwise, access is denied — the user\n+// must provide a valid pairing code through a separate endpoint to create an\n+// active pairing first.\n+func (r *ChannelRouter) authorizePairWithCode(ctx context.Context, channelType, channelID, userID, workspaceID string) error {\n+\tif r.pairings == nil {\n+\t\treturn sigilerr.New(sigilerr.CodeChannelPairingRequired,\n+\t\t\t\"pairing store not configured\",\n+\t\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\t)\n+\t}\n+\n+\tpairings, err := r.pairings.GetByUser(ctx, userID)\n+\tif err != nil {\n+\t\treturn sigilerr.Wrap(err, sigilerr.CodeChannelBackendFailure,\n+\t\t\t\"pairing lookup failed\",\n+\t\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\t\tsigilerr.Field(\"user_id\", userID),\n+\t\t)\n+\t}\n+\n+\tfor _, p := range pairings {\n+\t\tif p.ChannelType == channelType && p.ChannelID == channelID &&\n+\t\t\tp.WorkspaceID == workspaceID && p.Status == store.PairingStatusActive {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\treturn sigilerr.New(sigilerr.CodeChannelPairingRequired,\n+\t\t\"pairing code required to access this channel\",\n+\t\tsigilerr.Field(\"channel_type\", channelType),\n+\t\tsigilerr.Field(\"channel_id\", channelID),\n+\t\tsigilerr.Field(\"user_id\", userID),\n+\t)\n+}\n+\n // CheckPairing determines whether a user is allowed to pair with a channel\n // based on the pairing mode and allowlist.\n func CheckPairing(mode PairingMode, userID string, allowlist []string) bool {\n@@ -190,16 +294,11 @@ func CheckPairing(mode PairingMode, userID string, allowlist []string) bool {\n \t\treturn false\n \tcase PairingAllowlist:\n \t\treturn slices.Contains(allowlist, userID)\n+\tcase PairingOnRequest:\n+\t\treturn true // anyone can initiate a pairing request\n+\tcase PairingWithCode:\n+\t\treturn false // requires a code, not auto-pair\n \tdefault:\n \t\treturn false\n \t}\n }\n-\n-// CodeChannelPairingRequired indicates that no active pairing exists for the channel.\n-const CodeChannelPairingRequired sigilerr.Code = \"channel.pairing.required\"\n-\n-// CodeChannelPairingDenied indicates the channel mode denies the user.\n-const CodeChannelPairingDenied sigilerr.Code = \"channel.pairing.denied\"\n-\n-// CodeChannelBackendFailure indicates an infrastructure error during pairing lookup.\n-const CodeChannelBackendFailure sigilerr.Code = \"channel.backend.failure\"\ndiff --git a/internal/plugin/channel_test.go b/internal/plugin/channel_test.go\nindex d675318..95769f2 100644\n--- a/internal/plugin/channel_test.go\n+++ b/internal/plugin/channel_test.go\n@@ -34,10 +34,14 @@ func (m *mockChannelPlugin) Send(_ context.Context, msg plugin.OutboundMessage)\n \n type mockPairingStore struct {\n \tpairings []*store.Pairing\n+\tcreated  []*store.Pairing // track Create() calls\n \terr      error\n }\n \n-func (m *mockPairingStore) Create(context.Context, *store.Pairing) error { return nil }\n+func (m *mockPairingStore) Create(_ context.Context, p *store.Pairing) error {\n+\tm.created = append(m.created, p)\n+\treturn nil\n+}\n func (m *mockPairingStore) GetByChannel(context.Context, string, string) (*store.Pairing, error) {\n \treturn nil, nil\n }\n@@ -158,7 +162,7 @@ func TestAuthorizeInbound_ClosedMode(t *testing.T) {\n \n \terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"any-user\", \"ws-1\")\n \trequire.Error(t, err)\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingDenied))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingDenied))\n }\n \n func TestAuthorizeInbound_AllowlistWithPairing(t *testing.T) {\n@@ -188,12 +192,12 @@ func TestAuthorizeInbound_AllowlistWithPairing(t *testing.T) {\n \t// Bob is allowlisted but has no pairing for chat-1\n \terr = router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"bob\", \"ws-1\")\n \trequire.Error(t, err)\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingRequired))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n \n \t// Stranger is not allowlisted\n \terr = router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"stranger\", \"ws-1\")\n \trequire.Error(t, err)\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingDenied))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingDenied))\n }\n \n func TestAuthorizeInbound_PairingScopedToChannelInstance(t *testing.T) {\n@@ -224,7 +228,7 @@ func TestAuthorizeInbound_PairingScopedToChannelInstance(t *testing.T) {\n \t// Different channel instance: denied (no pairing for chat-2)\n \terr = router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-2\", \"alice\", \"ws-1\")\n \trequire.Error(t, err)\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingRequired))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n }\n \n func TestAuthorizeInbound_PairingBackendFailure(t *testing.T) {\n@@ -238,7 +242,7 @@ func TestAuthorizeInbound_PairingBackendFailure(t *testing.T) {\n \n \terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"alice\", \"ws-1\")\n \trequire.Error(t, err)\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelBackendFailure))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelBackendFailure))\n }\n \n func TestAuthorizeInbound_UnregisteredChannel(t *testing.T) {\n@@ -280,7 +284,7 @@ func TestAuthorizeInbound_InactivePairingDenied(t *testing.T) {\n \n \terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"alice\", \"ws-1\")\n \trequire.Error(t, err, \"inactive pairing should not authorize\")\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingRequired))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n }\n \n func TestAuthorizeInbound_CrossChannelTypePairingDenied(t *testing.T) {\n@@ -306,7 +310,7 @@ func TestAuthorizeInbound_CrossChannelTypePairingDenied(t *testing.T) {\n \n \terr := router.AuthorizeInbound(context.Background(), \"discord\", \"server-1\", \"alice\", \"ws-1\")\n \trequire.Error(t, err, \"telegram pairing should not authorize discord access\")\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingRequired))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n }\n \n func TestAuthorizeInbound_WorkspaceScopedPairingDenied(t *testing.T) {\n@@ -337,5 +341,135 @@ func TestAuthorizeInbound_WorkspaceScopedPairingDenied(t *testing.T) {\n \t// Different workspace: denied\n \terr = router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"alice\", \"ws-2\")\n \trequire.Error(t, err, \"ws-1 pairing should not authorize ws-2 access\")\n-\tassert.True(t, sigilerr.HasCode(err, plugin.CodeChannelPairingRequired))\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n+}\n+\n+// --- pair_on_request and pair_with_code tests ---\n+\n+func TestPairingModes_PairOnRequest(t *testing.T) {\n+\t// CheckPairing should return true for pair_on_request (anyone can initiate a request)\n+\tgot := plugin.CheckPairing(plugin.PairingOnRequest, \"anyone\", nil)\n+\tassert.True(t, got)\n+}\n+\n+func TestPairingModes_PairWithCode(t *testing.T) {\n+\t// CheckPairing should return false for pair_with_code (code-based, not auto-pair)\n+\tgot := plugin.CheckPairing(plugin.PairingWithCode, \"anyone\", nil)\n+\tassert.False(t, got)\n+}\n+\n+func TestAuthorizeInbound_PairOnRequest_NoPairing(t *testing.T) {\n+\t// When no pairing exists, should create a pending pairing and return pending error\n+\tps := &mockPairingStore{pairings: []*store.Pairing{}}\n+\trouter := plugin.NewChannelRouter(ps)\n+\trouter.RegisterWithConfig(\"telegram\", plugin.ChannelRegistration{\n+\t\tPlugin: &mockChannelPlugin{name: \"telegram\"},\n+\t\tMode:   plugin.PairingOnRequest,\n+\t})\n+\n+\terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"new-user\", \"ws-1\")\n+\trequire.Error(t, err)\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingPending))\n+\t// Verify a pending pairing was created\n+\trequire.Len(t, ps.created, 1)\n+\tassert.Equal(t, \"new-user\", ps.created[0].UserID)\n+\tassert.Equal(t, \"telegram\", ps.created[0].ChannelType)\n+\tassert.Equal(t, \"chat-1\", ps.created[0].ChannelID)\n+\tassert.Equal(t, \"ws-1\", ps.created[0].WorkspaceID)\n+\tassert.Equal(t, store.PairingStatusPending, ps.created[0].Status)\n+}\n+\n+func TestAuthorizeInbound_PairOnRequest_PendingPairing(t *testing.T) {\n+\t// When a pending pairing exists, should return pending error without creating another\n+\tps := &mockPairingStore{\n+\t\tpairings: []*store.Pairing{\n+\t\t\t{\n+\t\t\t\tID: \"p-1\", UserID: \"waiting-user\",\n+\t\t\t\tChannelType: \"telegram\", ChannelID: \"chat-1\",\n+\t\t\t\tWorkspaceID: \"ws-1\", Status: store.PairingStatusPending,\n+\t\t\t},\n+\t\t},\n+\t}\n+\trouter := plugin.NewChannelRouter(ps)\n+\trouter.RegisterWithConfig(\"telegram\", plugin.ChannelRegistration{\n+\t\tPlugin: &mockChannelPlugin{name: \"telegram\"},\n+\t\tMode:   plugin.PairingOnRequest,\n+\t})\n+\n+\terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"waiting-user\", \"ws-1\")\n+\trequire.Error(t, err)\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingPending))\n+\t// Should NOT create a duplicate pending pairing\n+\tassert.Empty(t, ps.created)\n+}\n+\n+func TestAuthorizeInbound_PairOnRequest_ActivePairing(t *testing.T) {\n+\t// When an active pairing exists, should allow through\n+\tps := &mockPairingStore{\n+\t\tpairings: []*store.Pairing{\n+\t\t\t{\n+\t\t\t\tID: \"p-1\", UserID: \"approved-user\",\n+\t\t\t\tChannelType: \"telegram\", ChannelID: \"chat-1\",\n+\t\t\t\tWorkspaceID: \"ws-1\", Status: store.PairingStatusActive,\n+\t\t\t},\n+\t\t},\n+\t}\n+\trouter := plugin.NewChannelRouter(ps)\n+\trouter.RegisterWithConfig(\"telegram\", plugin.ChannelRegistration{\n+\t\tPlugin: &mockChannelPlugin{name: \"telegram\"},\n+\t\tMode:   plugin.PairingOnRequest,\n+\t})\n+\n+\terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"approved-user\", \"ws-1\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizeInbound_PairWithCode_NoActivePairing(t *testing.T) {\n+\t// Without an active pairing, should deny with code-required message\n+\tps := &mockPairingStore{pairings: []*store.Pairing{}}\n+\trouter := plugin.NewChannelRouter(ps)\n+\trouter.RegisterWithConfig(\"telegram\", plugin.ChannelRegistration{\n+\t\tPlugin:      &mockChannelPlugin{name: \"telegram\"},\n+\t\tMode:        plugin.PairingWithCode,\n+\t\tPairingCode: \"ABC123\",\n+\t})\n+\n+\terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"new-user\", \"ws-1\")\n+\trequire.Error(t, err)\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n+}\n+\n+func TestAuthorizeInbound_PairWithCode_ActivePairing(t *testing.T) {\n+\t// With an active pairing, should allow through\n+\tps := &mockPairingStore{\n+\t\tpairings: []*store.Pairing{\n+\t\t\t{\n+\t\t\t\tID: \"p-1\", UserID: \"paired-user\",\n+\t\t\t\tChannelType: \"telegram\", ChannelID: \"chat-1\",\n+\t\t\t\tWorkspaceID: \"ws-1\", Status: store.PairingStatusActive,\n+\t\t\t},\n+\t\t},\n+\t}\n+\trouter := plugin.NewChannelRouter(ps)\n+\trouter.RegisterWithConfig(\"telegram\", plugin.ChannelRegistration{\n+\t\tPlugin:      &mockChannelPlugin{name: \"telegram\"},\n+\t\tMode:        plugin.PairingWithCode,\n+\t\tPairingCode: \"ABC123\",\n+\t})\n+\n+\terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"paired-user\", \"ws-1\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizeInbound_PairOnRequest_NoPairingStore(t *testing.T) {\n+\t// pair_on_request with nil pairing store should return pairing required error\n+\trouter := plugin.NewChannelRouter(nil)\n+\trouter.RegisterWithConfig(\"telegram\", plugin.ChannelRegistration{\n+\t\tPlugin: &mockChannelPlugin{name: \"telegram\"},\n+\t\tMode:   plugin.PairingOnRequest,\n+\t})\n+\n+\terr := router.AuthorizeInbound(context.Background(), \"telegram\", \"chat-1\", \"user\", \"ws-1\")\n+\trequire.Error(t, err)\n+\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeChannelPairingRequired))\n }\ndiff --git a/internal/provider/registry.go b/internal/provider/registry.go\nindex a3e8dad..beab9d0 100644\n--- a/internal/provider/registry.go\n+++ b/internal/provider/registry.go\n@@ -5,6 +5,7 @@ package provider\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -12,10 +13,18 @@ import (\n \tsigilerr \"github.com/sigil-dev/sigil/pkg/errors\"\n )\n \n-// Budget defines token budget constraints for a routing request.\n+// Budget defines token and USD budget constraints for a routing request.\n+// The caller (agent loop) is responsible for tracking cumulative spend\n+// and populating these fields; routing only enforces the limits.\n type Budget struct {\n \tMaxSessionTokens  int\n \tUsedSessionTokens int\n+\n+\t// USD budget constraints (0 = unlimited).\n+\tMaxHourUSD  float64\n+\tUsedHourUSD float64\n+\tMaxDayUSD   float64\n+\tUsedDayUSD  float64\n }\n \n // Registry manages provider registration, lookup, and routing with\n@@ -119,6 +128,22 @@ func (r *Registry) RouteWithBudget(ctx context.Context, workspaceID, modelName s\n \t\t)\n \t}\n \n+\t// 1b. Check hourly USD budget.\n+\tif budget != nil && budget.MaxHourUSD > 0 && budget.UsedHourUSD >= budget.MaxHourUSD {\n+\t\treturn nil, \"\", sigilerr.New(\n+\t\t\tsigilerr.CodeProviderBudgetExceeded,\n+\t\t\t\"budget exceeded: hourly USD spend $\"+formatUSD(budget.UsedHourUSD)+\" of $\"+formatUSD(budget.MaxHourUSD)+\" limit\",\n+\t\t)\n+\t}\n+\n+\t// 1c. Check daily USD budget.\n+\tif budget != nil && budget.MaxDayUSD > 0 && budget.UsedDayUSD >= budget.MaxDayUSD {\n+\t\treturn nil, \"\", sigilerr.New(\n+\t\t\tsigilerr.CodeProviderBudgetExceeded,\n+\t\t\t\"budget exceeded: daily USD spend $\"+formatUSD(budget.UsedDayUSD)+\" of $\"+formatUSD(budget.MaxDayUSD)+\" limit\",\n+\t\t)\n+\t}\n+\n \tr.mu.RLock()\n \tdefer r.mu.RUnlock()\n \n@@ -238,6 +263,11 @@ func parseRef(ref string) (providerName, model string) {\n \treturn ref[:idx], ref[idx+1:]\n }\n \n+// formatUSD formats a float64 as a two-decimal USD string (e.g. \"5.00\").\n+func formatUSD(v float64) string {\n+\treturn fmt.Sprintf(\"%.2f\", v)\n+}\n+\n // itoa converts an int to a string without importing strconv.\n func itoa(n int) string {\n \tif n == 0 {\ndiff --git a/internal/provider/registry_test.go b/internal/provider/registry_test.go\nindex 82d3f3d..0d65b57 100644\n--- a/internal/provider/registry_test.go\n+++ b/internal/provider/registry_test.go\n@@ -186,3 +186,225 @@ func TestRegistry_MaxAttempts(t *testing.T) {\n \treg.SetFailover([]string{\"a/model\", \"b/model\", \"c/model\"})\n \tassert.Equal(t, 4, reg.MaxAttempts())\n }\n+\n+func TestRegistry_BudgetEnforcement_HourlyUSD(t *testing.T) {\n+\treg := provider.NewRegistry()\n+\tanthropic := &mockRegistryProvider{name: \"anthropic\", available: true}\n+\treg.Register(\"anthropic\", anthropic)\n+\treg.SetDefault(\"anthropic/claude-sonnet-4-5\")\n+\n+\tctx := context.Background()\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\tbudget  *provider.Budget\n+\t\twantErr bool\n+\t\terrCode sigilerr.Code\n+\t}{\n+\t\t{\n+\t\t\tname: \"hourly budget not exceeded\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxHourUSD:  5.00,\n+\t\t\t\tUsedHourUSD: 3.00,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"hourly budget exactly met\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxHourUSD:  5.00,\n+\t\t\t\tUsedHourUSD: 5.00,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrCode: sigilerr.CodeProviderBudgetExceeded,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"hourly budget exceeded\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxHourUSD:  5.00,\n+\t\t\t\tUsedHourUSD: 7.50,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrCode: sigilerr.CodeProviderBudgetExceeded,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"hourly budget zero means unlimited\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxHourUSD:  0,\n+\t\t\t\tUsedHourUSD: 999.99,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t_, _, err := reg.RouteWithBudget(ctx, \"\", \"\", tt.budget, nil)\n+\t\t\tif tt.wantErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\tassert.True(t, sigilerr.HasCode(err, tt.errCode))\n+\t\t\t\tassert.Contains(t, err.Error(), \"budget\")\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestRegistry_BudgetEnforcement_DailyUSD(t *testing.T) {\n+\treg := provider.NewRegistry()\n+\tanthropic := &mockRegistryProvider{name: \"anthropic\", available: true}\n+\treg.Register(\"anthropic\", anthropic)\n+\treg.SetDefault(\"anthropic/claude-sonnet-4-5\")\n+\n+\tctx := context.Background()\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\tbudget  *provider.Budget\n+\t\twantErr bool\n+\t\terrCode sigilerr.Code\n+\t}{\n+\t\t{\n+\t\t\tname: \"daily budget not exceeded\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxDayUSD:  50.00,\n+\t\t\t\tUsedDayUSD: 25.00,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"daily budget exactly met\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxDayUSD:  50.00,\n+\t\t\t\tUsedDayUSD: 50.00,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrCode: sigilerr.CodeProviderBudgetExceeded,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"daily budget exceeded\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxDayUSD:  50.00,\n+\t\t\t\tUsedDayUSD: 75.00,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrCode: sigilerr.CodeProviderBudgetExceeded,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"daily budget zero means unlimited\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxDayUSD:  0,\n+\t\t\t\tUsedDayUSD: 999.99,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t_, _, err := reg.RouteWithBudget(ctx, \"\", \"\", tt.budget, nil)\n+\t\t\tif tt.wantErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\tassert.True(t, sigilerr.HasCode(err, tt.errCode))\n+\t\t\t\tassert.Contains(t, err.Error(), \"budget\")\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestRegistry_BudgetEnforcement_CombinedLimits(t *testing.T) {\n+\treg := provider.NewRegistry()\n+\tanthropic := &mockRegistryProvider{name: \"anthropic\", available: true}\n+\treg.Register(\"anthropic\", anthropic)\n+\treg.SetDefault(\"anthropic/claude-sonnet-4-5\")\n+\n+\tctx := context.Background()\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\tbudget  *provider.Budget\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"all limits within bounds\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxSessionTokens:  100000,\n+\t\t\t\tUsedSessionTokens: 5000,\n+\t\t\t\tMaxHourUSD:        5.00,\n+\t\t\t\tUsedHourUSD:       1.00,\n+\t\t\t\tMaxDayUSD:         50.00,\n+\t\t\t\tUsedDayUSD:        10.00,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"tokens exceeded but USD ok\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxSessionTokens:  1000,\n+\t\t\t\tUsedSessionTokens: 1500,\n+\t\t\t\tMaxHourUSD:        5.00,\n+\t\t\t\tUsedHourUSD:       1.00,\n+\t\t\t\tMaxDayUSD:         50.00,\n+\t\t\t\tUsedDayUSD:        10.00,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"hourly exceeded but tokens and daily ok\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxSessionTokens:  100000,\n+\t\t\t\tUsedSessionTokens: 5000,\n+\t\t\t\tMaxHourUSD:        5.00,\n+\t\t\t\tUsedHourUSD:       6.00,\n+\t\t\t\tMaxDayUSD:         50.00,\n+\t\t\t\tUsedDayUSD:        10.00,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"daily exceeded but tokens and hourly ok\",\n+\t\t\tbudget: &provider.Budget{\n+\t\t\t\tMaxSessionTokens:  100000,\n+\t\t\t\tUsedSessionTokens: 5000,\n+\t\t\t\tMaxHourUSD:        5.00,\n+\t\t\t\tUsedHourUSD:       1.00,\n+\t\t\t\tMaxDayUSD:         50.00,\n+\t\t\t\tUsedDayUSD:        55.00,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"nil budget always passes\",\n+\t\t\tbudget:  nil,\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t_, _, err := reg.RouteWithBudget(ctx, \"\", \"\", tt.budget, nil)\n+\t\t\tif tt.wantErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\tassert.True(t, sigilerr.HasCode(err, sigilerr.CodeProviderBudgetExceeded))\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestBudget_USDFieldsExist(t *testing.T) {\n+\tb := provider.Budget{\n+\t\tMaxSessionTokens:  100000,\n+\t\tUsedSessionTokens: 0,\n+\t\tMaxHourUSD:        5.00,\n+\t\tUsedHourUSD:       0,\n+\t\tMaxDayUSD:         50.00,\n+\t\tUsedDayUSD:        0,\n+\t}\n+\tassert.Equal(t, 5.00, b.MaxHourUSD)\n+\tassert.Equal(t, 50.00, b.MaxDayUSD)\n+}\ndiff --git a/internal/server/auth.go b/internal/server/auth.go\nindex 1502e93..a5cbc9a 100644\n--- a/internal/server/auth.go\n+++ b/internal/server/auth.go\n@@ -4,21 +4,124 @@\n package server\n \n import (\n+\t\"context\"\n+\t\"encoding/json\"\n \t\"log/slog\"\n \t\"net/http\"\n+\t\"strings\"\n+\n+\tsigilerr \"github.com/sigil-dev/sigil/pkg/errors\"\n )\n \n-// authMiddleware is a stub authentication/ABAC middleware.\n-// It logs incoming requests and passes them through. Full auth enforcement\n-// (token validation, capability checks) will be implemented as part of the\n-// security phase — see sigil-9s6.\n-func authMiddleware(next http.Handler) http.Handler {\n-\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n-\t\tslog.Debug(\"auth stub: passing request through\",\n-\t\t\t\"method\", r.Method,\n-\t\t\t\"path\", r.URL.Path,\n-\t\t\t\"remote\", r.RemoteAddr,\n-\t\t)\n-\t\tnext.ServeHTTP(w, r)\n-\t})\n+// TokenValidator checks bearer tokens and returns the associated user.\n+type TokenValidator interface {\n+\tValidateToken(ctx context.Context, token string) (*AuthenticatedUser, error)\n+}\n+\n+// AuthenticatedUser represents a validated user from a bearer token.\n+type AuthenticatedUser struct {\n+\tID          string\n+\tName        string\n+\tPermissions []string // capability patterns\n+}\n+\n+// contextKey is an unexported type for context keys in this package.\n+type contextKey int\n+\n+const authUserKey contextKey = iota\n+\n+// UserFromContext extracts the authenticated user from the request context.\n+// Returns nil if no user is authenticated (e.g., public endpoints or auth disabled).\n+func UserFromContext(ctx context.Context) *AuthenticatedUser {\n+\tuser, _ := ctx.Value(authUserKey).(*AuthenticatedUser)\n+\treturn user\n+}\n+\n+// defaultPublicPaths are paths that never require authentication.\n+var defaultPublicPaths = []string{\"/health\", \"/openapi.json\", \"/openapi.yaml\"}\n+\n+// authMiddleware returns middleware that enforces bearer-token authentication.\n+// When validator is nil, auth is disabled and all requests pass through (dev mode).\n+func authMiddleware(validator TokenValidator) func(http.Handler) http.Handler {\n+\tif validator == nil {\n+\t\treturn func(next http.Handler) http.Handler {\n+\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\t\t\tslog.Debug(\"auth disabled: passing request through\",\n+\t\t\t\t\t\"method\", r.Method,\n+\t\t\t\t\t\"path\", r.URL.Path,\n+\t\t\t\t)\n+\t\t\t\tnext.ServeHTTP(w, r)\n+\t\t\t})\n+\t\t}\n+\t}\n+\n+\treturn NewAuthMiddleware(validator, defaultPublicPaths)\n+}\n+\n+// NewAuthMiddleware creates an auth middleware function with explicit public paths.\n+// Exported for testing and composition.\n+func NewAuthMiddleware(validator TokenValidator, publicPaths []string) func(http.Handler) http.Handler {\n+\tpublicSet := make(map[string]struct{}, len(publicPaths))\n+\tfor _, p := range publicPaths {\n+\t\tpublicSet[p] = struct{}{}\n+\t}\n+\n+\treturn func(next http.Handler) http.Handler {\n+\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\t\t// Skip auth for public paths.\n+\t\t\tif _, ok := publicSet[r.URL.Path]; ok {\n+\t\t\t\tnext.ServeHTTP(w, r)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Extract Authorization header.\n+\t\t\tauthHeader := r.Header.Get(\"Authorization\")\n+\t\t\tif authHeader == \"\" {\n+\t\t\t\twriteAuthError(w, \"authorization header required\", http.StatusUnauthorized)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Must be \"Bearer <token>\" format.\n+\t\t\tif !strings.HasPrefix(authHeader, \"Bearer \") {\n+\t\t\t\twriteAuthError(w, \"authorization header must use Bearer scheme\", http.StatusUnauthorized)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\ttoken := strings.TrimPrefix(authHeader, \"Bearer \")\n+\t\t\tif token == \"\" {\n+\t\t\t\twriteAuthError(w, \"bearer token must not be empty\", http.StatusUnauthorized)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Validate the token.\n+\t\t\tuser, err := validator.ValidateToken(r.Context(), token)\n+\t\t\tif err != nil {\n+\t\t\t\tslog.Debug(\"token validation failed\",\n+\t\t\t\t\t\"path\", r.URL.Path,\n+\t\t\t\t\t\"error\", err,\n+\t\t\t\t)\n+\t\t\t\tif sigilerr.HasCode(err, sigilerr.CodeServerAuthForbidden) {\n+\t\t\t\t\twriteAuthError(w, \"forbidden\", http.StatusForbidden)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\twriteAuthError(w, \"invalid or expired token\", http.StatusUnauthorized)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Inject user into context.\n+\t\t\tctx := context.WithValue(r.Context(), authUserKey, user)\n+\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n+\t\t})\n+\t}\n+}\n+\n+// authErrorBody is the JSON structure for auth error responses.\n+type authErrorBody struct {\n+\tError string `json:\"error\"`\n+}\n+\n+func writeAuthError(w http.ResponseWriter, msg string, status int) {\n+\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\tw.WriteHeader(status)\n+\t_ = json.NewEncoder(w).Encode(authErrorBody{Error: msg})\n }\ndiff --git a/internal/server/auth_test.go b/internal/server/auth_test.go\nnew file mode 100644\nindex 0000000..d3bb483\n--- /dev/null\n+++ b/internal/server/auth_test.go\n@@ -0,0 +1,247 @@\n+// SPDX-License-Identifier: Apache-2.0\n+// Copyright 2026 Sigil Contributors\n+\n+package server_test\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"github.com/sigil-dev/sigil/internal/server\"\n+\tsigilerr \"github.com/sigil-dev/sigil/pkg/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+// mockTokenValidator is a test double for the TokenValidator interface.\n+type mockTokenValidator struct {\n+\tusers map[string]*server.AuthenticatedUser\n+}\n+\n+func (m *mockTokenValidator) ValidateToken(_ context.Context, token string) (*server.AuthenticatedUser, error) {\n+\tif user, ok := m.users[token]; ok {\n+\t\treturn user, nil\n+\t}\n+\treturn nil, sigilerr.New(sigilerr.CodeServerAuthUnauthorized, \"invalid token\")\n+}\n+\n+// forbiddenTokenValidator always returns CodeServerAuthForbidden (simulates revoked tokens).\n+type forbiddenTokenValidator struct{}\n+\n+func (v *forbiddenTokenValidator) ValidateToken(_ context.Context, _ string) (*server.AuthenticatedUser, error) {\n+\treturn nil, sigilerr.New(sigilerr.CodeServerAuthForbidden, \"token revoked\")\n+}\n+\n+func newValidatorWithToken(token, userID, name string, permissions []string) server.TokenValidator {\n+\treturn &mockTokenValidator{\n+\t\tusers: map[string]*server.AuthenticatedUser{\n+\t\t\ttoken: {\n+\t\t\t\tID:          userID,\n+\t\t\t\tName:        name,\n+\t\t\t\tPermissions: permissions,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func TestAuthMiddleware_PublicEndpointsSkipAuth(t *testing.T) {\n+\tpublicPaths := []string{\"/health\", \"/openapi.json\", \"/openapi.yaml\"}\n+\n+\tfor _, path := range publicPaths {\n+\t\tt.Run(path, func(t *testing.T) {\n+\t\t\tsrv, err := server.New(server.Config{\n+\t\t\t\tListenAddr:     \"127.0.0.1:0\",\n+\t\t\t\tTokenValidator: newValidatorWithToken(\"valid-token\", \"admin\", \"Admin\", []string{\"*\"}),\n+\t\t\t})\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\t// Request WITHOUT auth header to a public endpoint.\n+\t\t\treq := httptest.NewRequest(http.MethodGet, path, nil)\n+\t\t\tw := httptest.NewRecorder()\n+\t\t\tsrv.Handler().ServeHTTP(w, req)\n+\n+\t\t\t// /health returns 200; /openapi.yaml may return 404 if not registered,\n+\t\t\t// but the key assertion is that it does NOT return 401.\n+\t\t\tassert.NotEqual(t, http.StatusUnauthorized, w.Code, \"public path %s should not require auth\", path)\n+\t\t})\n+\t}\n+}\n+\n+func TestAuthMiddleware_MissingAuthHeader_Returns401(t *testing.T) {\n+\tsrv, err := server.New(server.Config{\n+\t\tListenAddr:     \"127.0.0.1:0\",\n+\t\tTokenValidator: newValidatorWithToken(\"valid-token\", \"admin\", \"Admin\", []string{\"*\"}),\n+\t})\n+\trequire.NoError(t, err)\n+\tsrv.RegisterServices(&server.Services{\n+\t\tWorkspaces: &mockWorkspaceService{},\n+\t\tPlugins:    &mockPluginService{},\n+\t\tSessions:   &mockSessionService{},\n+\t\tUsers:      &mockUserService{},\n+\t})\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/workspaces\", nil)\n+\tw := httptest.NewRecorder()\n+\tsrv.Handler().ServeHTTP(w, req)\n+\n+\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n+\tassert.Contains(t, w.Header().Get(\"Content-Type\"), \"application/json\")\n+\n+\tvar resp map[string]string\n+\terr = json.Unmarshal(w.Body.Bytes(), &resp)\n+\trequire.NoError(t, err)\n+\tassert.Contains(t, resp[\"error\"], \"authorization header required\")\n+}\n+\n+func TestAuthMiddleware_InvalidBearerFormat_Returns401(t *testing.T) {\n+\tsrv, err := server.New(server.Config{\n+\t\tListenAddr:     \"127.0.0.1:0\",\n+\t\tTokenValidator: newValidatorWithToken(\"valid-token\", \"admin\", \"Admin\", []string{\"*\"}),\n+\t})\n+\trequire.NoError(t, err)\n+\tsrv.RegisterServices(&server.Services{\n+\t\tWorkspaces: &mockWorkspaceService{},\n+\t\tPlugins:    &mockPluginService{},\n+\t\tSessions:   &mockSessionService{},\n+\t\tUsers:      &mockUserService{},\n+\t})\n+\n+\ttests := []struct {\n+\t\tname  string\n+\t\tvalue string\n+\t}{\n+\t\t{\"no prefix\", \"just-a-token\"},\n+\t\t{\"basic auth\", \"Basic dXNlcjpwYXNz\"},\n+\t\t{\"empty bearer\", \"Bearer \"},\n+\t\t{\"bearer lowercase\", \"bearer valid-token\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/workspaces\", nil)\n+\t\t\treq.Header.Set(\"Authorization\", tt.value)\n+\t\t\tw := httptest.NewRecorder()\n+\t\t\tsrv.Handler().ServeHTTP(w, req)\n+\n+\t\t\tassert.Equal(t, http.StatusUnauthorized, w.Code, \"auth header %q should be rejected\", tt.value)\n+\t\t})\n+\t}\n+}\n+\n+func TestAuthMiddleware_InvalidToken_Returns401(t *testing.T) {\n+\tsrv, err := server.New(server.Config{\n+\t\tListenAddr:     \"127.0.0.1:0\",\n+\t\tTokenValidator: newValidatorWithToken(\"valid-token\", \"admin\", \"Admin\", []string{\"*\"}),\n+\t})\n+\trequire.NoError(t, err)\n+\tsrv.RegisterServices(&server.Services{\n+\t\tWorkspaces: &mockWorkspaceService{},\n+\t\tPlugins:    &mockPluginService{},\n+\t\tSessions:   &mockSessionService{},\n+\t\tUsers:      &mockUserService{},\n+\t})\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/workspaces\", nil)\n+\treq.Header.Set(\"Authorization\", \"Bearer wrong-token\")\n+\tw := httptest.NewRecorder()\n+\tsrv.Handler().ServeHTTP(w, req)\n+\n+\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n+}\n+\n+func TestAuthMiddleware_ValidToken_InjectsUser(t *testing.T) {\n+\tsrv, err := server.New(server.Config{\n+\t\tListenAddr:     \"127.0.0.1:0\",\n+\t\tTokenValidator: newValidatorWithToken(\"sk-test-123\", \"user-1\", \"Sean\", []string{\"*\"}),\n+\t})\n+\trequire.NoError(t, err)\n+\tsrv.RegisterServices(&server.Services{\n+\t\tWorkspaces: &mockWorkspaceService{},\n+\t\tPlugins:    &mockPluginService{},\n+\t\tSessions:   &mockSessionService{},\n+\t\tUsers:      &mockUserService{},\n+\t})\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/workspaces\", nil)\n+\treq.Header.Set(\"Authorization\", \"Bearer sk-test-123\")\n+\tw := httptest.NewRecorder()\n+\tsrv.Handler().ServeHTTP(w, req)\n+\n+\tassert.Equal(t, http.StatusOK, w.Code)\n+}\n+\n+func TestAuthMiddleware_ValidToken_UserInContext(t *testing.T) {\n+\tvalidator := newValidatorWithToken(\"sk-test-123\", \"user-1\", \"Sean\", []string{\"admin:*\"})\n+\n+\t// Build a handler that checks context for the authenticated user.\n+\tvar capturedUser *server.AuthenticatedUser\n+\thandler := http.HandlerFunc(func(_ http.ResponseWriter, r *http.Request) {\n+\t\tcapturedUser = server.UserFromContext(r.Context())\n+\t})\n+\n+\tmw := server.NewAuthMiddleware(validator, []string{})\n+\twrapped := mw(handler)\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n+\treq.Header.Set(\"Authorization\", \"Bearer sk-test-123\")\n+\tw := httptest.NewRecorder()\n+\twrapped.ServeHTTP(w, req)\n+\n+\trequire.NotNil(t, capturedUser, \"user must be injected into context\")\n+\tassert.Equal(t, \"user-1\", capturedUser.ID)\n+\tassert.Equal(t, \"Sean\", capturedUser.Name)\n+\tassert.Equal(t, []string{\"admin:*\"}, capturedUser.Permissions)\n+}\n+\n+func TestAuthMiddleware_Disabled_WhenValidatorNil(t *testing.T) {\n+\tsrv, err := server.New(server.Config{\n+\t\tListenAddr: \"127.0.0.1:0\",\n+\t\t// No TokenValidator — auth disabled.\n+\t})\n+\trequire.NoError(t, err)\n+\tsrv.RegisterServices(&server.Services{\n+\t\tWorkspaces: &mockWorkspaceService{},\n+\t\tPlugins:    &mockPluginService{},\n+\t\tSessions:   &mockSessionService{},\n+\t\tUsers:      &mockUserService{},\n+\t})\n+\n+\t// Request WITHOUT auth header should pass through.\n+\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/workspaces\", nil)\n+\tw := httptest.NewRecorder()\n+\tsrv.Handler().ServeHTTP(w, req)\n+\n+\tassert.Equal(t, http.StatusOK, w.Code)\n+}\n+\n+func TestAuthMiddleware_ForbiddenToken_Returns403(t *testing.T) {\n+\t// A validator that returns CodeServerAuthForbidden (e.g., revoked token).\n+\tforbiddenValidator := &forbiddenTokenValidator{}\n+\tsrv, err := server.New(server.Config{\n+\t\tListenAddr:     \"127.0.0.1:0\",\n+\t\tTokenValidator: forbiddenValidator,\n+\t})\n+\trequire.NoError(t, err)\n+\tsrv.RegisterServices(&server.Services{\n+\t\tWorkspaces: &mockWorkspaceService{},\n+\t\tPlugins:    &mockPluginService{},\n+\t\tSessions:   &mockSessionService{},\n+\t\tUsers:      &mockUserService{},\n+\t})\n+\n+\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/workspaces\", nil)\n+\treq.Header.Set(\"Authorization\", \"Bearer revoked-token\")\n+\tw := httptest.NewRecorder()\n+\tsrv.Handler().ServeHTTP(w, req)\n+\n+\tassert.Equal(t, http.StatusForbidden, w.Code)\n+\tassert.Contains(t, w.Body.String(), \"forbidden\")\n+}\n+\n+func TestUserFromContext_NilWhenNoUser(t *testing.T) {\n+\tuser := server.UserFromContext(context.Background())\n+\tassert.Nil(t, user)\n+}\ndiff --git a/internal/server/server.go b/internal/server/server.go\nindex 37600ee..55f76bd 100644\n--- a/internal/server/server.go\n+++ b/internal/server/server.go\n@@ -20,10 +20,11 @@ import (\n \n // Config holds HTTP server configuration.\n type Config struct {\n-\tListenAddr   string\n-\tCORSOrigins  []string\n-\tReadTimeout  time.Duration\n-\tWriteTimeout time.Duration\n+\tListenAddr     string\n+\tCORSOrigins    []string\n+\tReadTimeout    time.Duration\n+\tWriteTimeout   time.Duration\n+\tTokenValidator TokenValidator // nil = auth disabled (dev mode)\n }\n \n // Server wraps a chi router with huma API and HTTP server.\n@@ -53,7 +54,7 @@ func New(cfg Config) (*Server, error) {\n \tr.Use(middleware.Recoverer)\n \tr.Use(middleware.RealIP)\n \tr.Use(corsMiddleware(cfg.CORSOrigins))\n-\tr.Use(authMiddleware)\n+\tr.Use(authMiddleware(cfg.TokenValidator))\n \n \t// Huma API with OpenAPI spec\n \thumaConfig := huma.DefaultConfig(\"Sigil Gateway\", \"0.1.0\")\ndiff --git a/pkg/errors/errors.go b/pkg/errors/errors.go\nindex 30b4346..b857884 100644\n--- a/pkg/errors/errors.go\n+++ b/pkg/errors/errors.go\n@@ -67,6 +67,7 @@ const (\n \n \tCodeServerRequestInvalid   Code = \"server.request.invalid\"\n \tCodeServerAuthUnauthorized Code = \"server.auth.unauthorized\"\n+\tCodeServerAuthForbidden    Code = \"server.auth.forbidden\"\n \tCodeServerInternalFailure  Code = \"server.internal.failure\"\n \tCodeServerEntityNotFound   Code = \"server.entity.not_found\"\n \tCodeServerConfigInvalid    Code = \"server.config.invalid\"\n@@ -81,6 +82,11 @@ const (\n \tCodeCLIInputInvalid      Code = \"cli.input.invalid\"\n \n \tCodeSecurityCapabilityInvalid Code = \"security.capability.invalid\"\n+\n+\tCodeChannelPairingRequired Code = \"channel.pairing.required\"\n+\tCodeChannelPairingDenied   Code = \"channel.pairing.denied\"\n+\tCodeChannelPairingPending  Code = \"channel.pairing.pending\"\n+\tCodeChannelBackendFailure  Code = \"channel.backend.failure\"\n )\n \n // Field is a structured key/value context attached to an error.\n"
test_patch: ''
fail_to_pass:
- /usr/local/go/bin/go test ./cmd/sigil -v -run TestChat_StreamsTextDelta | grep -q "TestChat_StreamsTextDelta"
pass_to_pass:
- /usr/local/go/bin/go test ./cmd/sigil
- /usr/local/go/bin/go test ./internal/provider -run TestRegistry
install_config:
  go: '1.22'
  install: go mod download
  test_cmd: go test ./...
meta:
  added_lines: '1553'
  difficulty: hard
  files_changed: '16'
  pr_title: 'feat: complete Phase 5 remaining tasks (chat, doctor, auth)'
  removed_lines: '57'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  sigil-dev/sigil (#15): feat: complete Phase 5 remaining tasks (chat, doctor, auth)

  ## Summary

  - **Chat CLI command**: Connects to gateway SSE endpoint, streams text_delta events to stdout, handles errors on stderr. Supports --workspace, --model, --session flags.
  - **Doctor CLI command**: Runs 6 diagnostic checks (binary, platform, gateway status, config, plugins, disk space) with actionable output.
  - **Auth/ABAC middleware**: Bearer token authentication with TokenValidator interface, user context injection, public path bypass (/health, /openapi.*), 401/403 responses. Config-based token validation wired in gateway. Auth disabled when no tokens configured (dev mode).
  - **SSE client infrastructure**: postSSE method and parseSSEStream parser in client.go for CLI-to-gateway streaming.

  Closes sigil-8po, sigil-9s6, sigil-31w. Closes epic sigil-3m0 (Phase 5: Server & API).

  ## Test plan

  - [x] `task test` — 21/21 packages pass, 0 failures
  - [x] `task lint` — 0 issues (Go, Markdown, YAML)
  - [x] Phase 5 gate checklist verified (12/12 items)
  - [x] 7 new chat tests (SSE streaming, connection failure, error events, flags)
  - [x] 8 new doctor tests (all checks, gateway up/down, plugins, disk space)
  - [x] 9 new auth tests (public bypass, 401 cases, 403, valid token, context injection, dev mode)

  🤖 Generated with [Claude Code](https://claude.com/claude-code)
quality_score: 0.78
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
