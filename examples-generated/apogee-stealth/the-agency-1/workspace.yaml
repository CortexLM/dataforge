id: apogee-stealth/the-agency-1
repo: apogee-stealth/the-agency
base_commit: 6a7674303642018e82f6497b9e93b79ac88f0f0a
merge_commit: 3bbc7d3fdb4390307fb99f873cdcd60c4da326e2
language: typescript
difficulty_score: 3
created_at: 2026-02-14T12:38:06.074305612Z
patch: "diff --git a/CLAUDE.md b/CLAUDE.md\nindex ab33858..79f5929 100644\n--- a/CLAUDE.md\n+++ b/CLAUDE.md\n@@ -5,8 +5,9 @@ This is a meta-repo — it manages Claude Code configuration (agents, commands,\n ## What This Repo Contains\n \n - **`src/templates/.claude/agents/`** — Subagent definitions (architect, dev, explorer, pm, reviewer, test-hardener)\n-- **`src/templates/.claude/commands/`** — Slash command definitions (architect, build, pm, review-pr)\n+- **`src/templates/.claude/commands/`** — Slash command definitions (architect, build, pm, prep-pr, review-pr, weekly-summary)\n - **`src/templates/.ai/`** — AI context files (unit test style guide, examples)\n+- **`src/review-plugins/`** — Optional review check plugins (installed via `the-agency install-review-plugins`)\n - **`src/`** — TypeScript source for the CLI sync tool\n - **`dist/`** — Compiled JS output (gitignored, built via `pnpm build`)\n - **`bin/`** — CLI entry point (thin shim into `dist/`)\n@@ -30,9 +31,15 @@ This is a meta-repo — it manages Claude Code configuration (agents, commands,\n - `prepack` script automatically runs tsup before `pnpm pack`/`pnpm publish`\n - Changesets manages versioning: `pnpm changeset` to create a changeset, `pnpm changeset version` to bump\n \n-## The Sync CLI\n+## The CLI\n \n-Consumers install this package and run `the-agency sync` to copy agents, commands, and `.ai/` files into their project. The file manifest lives in `src/manifest.ts` — when adding or removing distributable files, update the manifest.\n+Consumers install this package and use these commands:\n+\n+- `the-agency sync` — Copies agents, commands, and `.ai/` files into the consumer's project\n+- `the-agency sync --pick` — Interactive file selection for sync\n+- `the-agency install-review-plugins` — Interactive multi-select to install optional review check plugins to `.ai/review-checks/`\n+\n+The file manifest lives in `src/manifest.ts` — when adding or removing distributable files, update the manifest.\n \n ## Working on Agents and Commands\n \ndiff --git a/README.md b/README.md\nindex 11f0bdf..8a08d45 100644\n--- a/README.md\n+++ b/README.md\n@@ -16,6 +16,9 @@ npx the-agency sync\n \n # Choose which files to sync\n npx the-agency sync --pick\n+\n+# Install optional review check plugins\n+npx the-agency install-review-plugins\n ```\n \n Files are copied to `.claude/agents/`, `.claude/commands/`, and `.ai/` in the target project. If destination files already exist, you'll be prompted before overwriting.\n@@ -39,12 +42,14 @@ Autonomous subagents that run in isolated context windows and communicate throug\n \n Slash commands invoked in Claude Code sessions.\n \n-| Command      | Purpose                                            |\n-| ------------ | -------------------------------------------------- |\n-| `/architect` | Interactive architecture design session            |\n-| `/build`     | Orchestrates the full dev → review → test pipeline |\n-| `/pm`        | Interactive product requirements discovery         |\n-| `/review-pr` | Structured PR review briefing                      |\n+| Command           | Purpose                                            |\n+| ----------------- | -------------------------------------------------- |\n+| `/architect`      | Interactive architecture design session            |\n+| `/build`          | Orchestrates the full dev → review → test pipeline |\n+| `/pm`             | Interactive product requirements discovery         |\n+| `/prep-pr`        | Pre-submission PR prep and draft creation          |\n+| `/review-pr`      | Structured PR review briefing                      |\n+| `/weekly-summary` | Weekly synthesis of merged PRs                     |\n \n ### AI Context (`.ai/`)\n \n@@ -68,6 +73,43 @@ Reference material automatically available to Claude Code.\n \n See `.ai/workflow.md` after syncing for the full workflow guide.\n \n+## Review Checks (`.ai/review-checks/`)\n+\n+The `/review-pr` command supports pluggable tribal knowledge checks. Place markdown files in `.ai/review-checks/` in your repo, and the review command discovers and evaluates them automatically.\n+\n+### Check File Format\n+\n+Each file uses YAML frontmatter with two fields:\n+\n+```markdown\n+---\n+name: Display Name for This Check Group\n+applies_when: Natural language description of when these checks apply\n+---\n+\n+- [ ] **Check name**: What to look for.\n+```\n+\n+- **`name`** — heading used in the review output\n+- **`applies_when`** — evaluated by the LLM against the PR's changed file list. Use plain language (e.g., \"Changed files include `.tsx` files\" or \"Always\").\n+\n+### Pre-packaged Plugins\n+\n+Install review plugins interactively:\n+\n+```bash\n+npx the-agency install-review-plugins\n+```\n+\n+This presents a multi-select of available plugins and copies your selections to `.ai/review-checks/`.\n+\n+| Plugin                | Targets                                             | Checks                                                                                               |\n+| --------------------- | --------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n+| **react-frontend.md** | `.tsx`, `.jsx`, `.css`, `.scss`, `.styled.ts` files | Hard-coded colors, missing `data-cy` attributes, accessibility gaps                                  |\n+| **node-backend.md**   | `.ts` files in backend/service directories          | `console.log` usage, boundary violations, raw SQL, error swallowing                                  |\n+| **general.md**        | All PRs (unconditional)                             | New env vars, dead code, dependency changes, type safety (`any`, `as`, `@ts-ignore`)                 |\n+| **unit-test.md**      | `.test.ts`, `.spec.ts` files                        | Style guide adherence, barrel export testing, test description accuracy, missing `export default {}` |\n+\n ## Project-Specific Configuration\n \n The sync does **not** copy `settings.local.json` or `settings.json` — those are project-specific. See the [Claude Code docs](https://docs.anthropic.com/en/docs/claude-code) for configuring permissions per-project.\ndiff --git a/docs/archive/briefs/pluggable-review-checks.md b/docs/archive/briefs/pluggable-review-checks.md\nnew file mode 100644\nindex 0000000..c4132d7\n--- /dev/null\n+++ b/docs/archive/briefs/pluggable-review-checks.md\n@@ -0,0 +1,129 @@\n+# Product Brief: Pluggable Review Checks\n+\n+You must read the `src/templates/.claude/commands/review-pr.md` file before proceeding.\n+\n+## Problem Statement\n+\n+The `/review-pr` command ships with hardcoded \"Tribal Knowledge Checks\" that are specific to one team's conventions (Kysely queries, `@avol/telemetry`, `data-cy` attributes). For any other team consuming `@apogeelabs/the-agency`, these checks are irrelevant noise — and there's no way to add checks that match their own conventions.\n+\n+Teams need a way to define their own review checks that reflect their codebase's conventions, tech stack, and architectural boundaries.\n+\n+## Target User\n+\n+Engineering teams using `@apogeelabs/the-agency` who run `/review-pr` as part of their code review workflow. Specifically, the team member(s) responsible for defining and maintaining the team's code standards and review conventions.\n+\n+## MVP Scope\n+\n+### 1. Review checks folder convention\n+\n+A new folder at `.ai/review-checks/` in the consumer's repo. The presence of markdown files in this folder activates the Tribal Knowledge Checks section of the `/review-pr` command. No files = no tribal knowledge checks section in the output.\n+\n+### 2. Check file format\n+\n+Each file is a markdown document grouped by domain (e.g., `react-frontend.md`, `node-backend.md`, `api-services.md`). Each file contains:\n+\n+- **YAML frontmatter** with:\n+    - `name` — display name for the check group (e.g., \"React & Frontend\")\n+    - `applies_when` — natural language description of when this check group activates, interpreted by the LLM against the diff's file list. Supports file extensions, path-based targeting, or combinations (e.g., `\".tsx files in apps/web-client/\"`, `\".ts files under services/ directories\"`)\n+- **Markdown body** — the checks themselves, written as a list of things to look for and flag\n+\n+Example:\n+\n+```markdown\n+---\n+name: React & Frontend\n+applies_when: \".tsx, .jsx, .css, .scss, or .styled.ts files are present in the diff\"\n+---\n+\n+- **Hard-coded colors**: Are there hex values, rgb(), or named colors that should use theme variables?\n+- **Missing data-cy attributes**: Do new interactive elements (buttons, inputs, links) have `data-cy` for testing?\n+- **Accessibility gaps**: Missing alt text on images? Click handlers on non-interactive elements (div, span)? Missing aria labels on icon-only buttons?\n+```\n+\n+### 3. Update the `/review-pr` command\n+\n+- Remove all hardcoded tribal knowledge checks from the command prompt (Step 7)\n+- Replace with instructions to discover and load check files from `.ai/review-checks/`\n+- For each check file, evaluate the `applies_when` criteria against the files in the diff\n+- Only include check groups in the output where the criteria match\n+- If no check files exist or no criteria match, omit the Tribal Knowledge Checks section entirely\n+\n+### 4. Pre-packaged review plugins\n+\n+A new folder at `src/templates/.ai/review-plugins/` containing ready-made check files that teams can copy into their `.ai/review-checks/` folder. These are the starting catalog, seeded from the existing hardcoded checks:\n+\n+- `react-frontend.md` — hard-coded colors, missing data-cy, accessibility gaps\n+- `node-backend.md` — console.log usage, boundary violations, raw SQL, error swallowing\n+- `general.md` — new environment variables, test coverage gaps, type safety (`any`, `as`, `@ts-ignore`)\n+\n+These files are **not synced** to consumer repos by `the-agency sync`. They live in the source repo as reference material.\n+\n+### 5. Documentation\n+\n+Update the README to list the available pre-packaged plugins with descriptions, so consumers know what's available to copy into their repo.\n+\n+## Explicitly Out of Scope\n+\n+- **CLI install command** (e.g., `npx the-agency install-review-plugins`) — future enhancement for plugin discovery and installation\n+- **Syncing review-plugins to consumer repos** — consumers browse the README and copy what they need\n+- **Formal glob/regex matching DSL for `applies_when`** — the LLM interprets natural language criteria; no deterministic pattern matching\n+- **Plugin dependencies or ordering** — check files are independent; no composition or inheritance\n+- **Check severity levels** (warning vs. error) — all checks are advisory and equal in weight\n+- **Disabling individual checks within a file** — granularity is at the file level; if you don't want a check, remove it from the file\n+\n+## User Stories\n+\n+- As a team lead, I want to define review checks that match my team's conventions so that tribal knowledge gets enforced consistently during PR review.\n+    - Acceptance Criteria:\n+        - [ ] Markdown files in `.ai/review-checks/` are discovered and loaded by `/review-pr`\n+        - [ ] Each file's `applies_when` criteria is evaluated against the diff's file list\n+        - [ ] Only matching check groups appear in the output\n+        - [ ] Check output uses the `name` from frontmatter as the section heading\n+\n+- As a team lead, I want to target checks by file type and path so that I can apply different standards to different parts of a monorepo.\n+    - Acceptance Criteria:\n+        - [ ] `applies_when` supports file extension targeting (e.g., \".tsx files\")\n+        - [ ] `applies_when` supports path-based targeting (e.g., \"files under services/\")\n+        - [ ] `applies_when` supports combined criteria (e.g., \".ts files in packages/shared/\")\n+        - [ ] Checks for `services/api/` don't fire when only `packages/shared/` files changed\n+\n+- As a reviewer, I want the review output to skip tribal knowledge checks entirely when no check files are configured so that I don't see an empty or irrelevant section.\n+    - Acceptance Criteria:\n+        - [ ] No `.ai/review-checks/` folder = no Tribal Knowledge Checks section in output\n+        - [ ] Empty `.ai/review-checks/` folder = no Tribal Knowledge Checks section in output\n+        - [ ] Check files present but none matching the diff = no Tribal Knowledge Checks section in output\n+\n+- As a new consumer of the-agency, I want to browse available pre-packaged checks so that I can quickly set up review checks without writing everything from scratch.\n+    - Acceptance Criteria:\n+        - [ ] Pre-packaged check files exist in `src/templates/.ai/review-plugins/`\n+        - [ ] README documents available plugins with descriptions\n+        - [ ] Copying a plugin file to `.ai/review-checks/` activates it with no further configuration\n+\n+## Edge Cases & Open Questions\n+\n+1. **Malformed check files**: If a file in `review-checks/` is missing frontmatter or has invalid YAML, the command should skip it and note the issue in output rather than failing entirely.\n+\n+2. **Overlapping criteria**: Multiple check files could match the same diff files (e.g., a `node-backend.md` and an `api-services.md` both matching `.ts` files in `services/`). This is fine — both run, and the reviewer gets both sets of checks. No deduplication needed.\n+\n+3. **Very large number of check files**: Unlikely in practice, but if a team has 20+ check files, the Tribal Knowledge section could dominate the output. No mitigation needed for MVP — trust teams to be reasonable.\n+\n+4. **Non-markdown files in the folder**: Ignore anything that isn't a `.md` file.\n+\n+5. **LLM interpretation of `applies_when`**: Since matching is non-deterministic, edge cases in criteria phrasing could produce inconsistent results. Acceptable trade-off — these are advisory checks, not a CI gate.\n+\n+## Success Metrics\n+\n+- **Adoption**: Consumer repos actually create `.ai/review-checks/` files (observable when supporting consumers)\n+- **Relevance**: Tribal knowledge checks in review output are relevant to the repo's actual conventions (qualitative, gathered from team feedback)\n+- **Reduction in false matches**: Checks don't fire for irrelevant file changes (qualitative)\n+- **Plugin reuse**: Pre-packaged plugins are copied and adapted by consumers rather than written from scratch\n+\n+## Handoff Notes for Architect\n+\n+- The main implementation target is `src/templates/.claude/commands/review-pr.md` — the prompt itself needs to be rewritten to discover and load check files dynamically instead of using hardcoded checks.\n+- The `.ai/review-checks/` folder is in the consumer's repo, not in this package. The command prompt needs to instruct Claude to look for it at runtime.\n+- The `.ai/review-plugins/` folder lives in `src/templates/.ai/review-plugins/` but is NOT added to the sync manifest. It's reference material only.\n+- YAML frontmatter parsing happens at the LLM level — Claude reads the file and interprets the frontmatter. No code-level parsing needed.\n+- The `applies_when` matching is intentionally fuzzy (LLM-interpreted). The architect should write clear prompting to make this as reliable as possible, but it does not need to be deterministic.\n+- The manifest in `src/manifest.ts` should NOT include the `review-plugins/` folder. These files don't sync.\n+- Consider whether the command prompt should include an example of what a well-formed check file looks like, to help the LLM parse them correctly.\ndiff --git a/docs/briefs/pr-review-command.md b/docs/archive/briefs/pr-review-command.md\nsimilarity index 100%\nrename from docs/briefs/pr-review-command.md\nrename to docs/archive/briefs/pr-review-command.md\ndiff --git a/docs/archive/briefs/prep-pr.md b/docs/archive/briefs/prep-pr.md\nnew file mode 100644\nindex 0000000..f6aea51\n--- /dev/null\n+++ b/docs/archive/briefs/prep-pr.md\n@@ -0,0 +1,88 @@\n+# Product Brief: Prep PR Command\n+\n+## Problem Statement\n+\n+Developers want a pre-submission quality gate for pull requests. Before opening a PR, they need to run checks against their changes, generate a meaningful description, and create the PR — all without context-switching between multiple tools and manual steps. Today this requires manually running checks, writing a description from memory, and cobbling together the `gh pr create` invocation. The existing `review-pr` command serves a _reviewer_ after a PR exists; this serves the _author_ before one does.\n+\n+## Target User\n+\n+Any developer using The Agency who is ready to open a pull request and wants to verify their changes and streamline PR creation.\n+\n+## MVP Scope\n+\n+A new slash command `/prep-pr` that:\n+\n+1. **Validates preconditions** — refuses to run if the current branch is `main` (or the repo's default branch) or if a PR already exists for the current branch.\n+2. **Runs review plugin checks** — loads and evaluates the same `.ai/review-checks/*.md` plugin files used by `/review-pr`. Displays results with pass/fail status. Check failures are informational, not blocking.\n+3. **Generates a draft PR title and description** — analyzes the diff against the target branch and produces a summary of what changed and why.\n+4. **Prompts the developer for testing steps** — the developer enters their own testing steps, which get formatted into the PR body.\n+5. **Presents a full PR preview** — title, description, testing steps, and check results are shown together. The developer can review and edit before proceeding.\n+6. **Asks for target branch** — prompts the developer to specify which branch they're targeting.\n+7. **Pushes the branch if needed** — if the branch isn't pushed to the remote (or is behind), offers to push it.\n+8. **Creates a draft PR via GitHub CLI** — always creates the PR as a draft using `gh pr create --draft`.\n+\n+## Explicitly Out of Scope\n+\n+- **Reviewer assignment** — no `--reviewer` flag or team assignment.\n+- **Labels, milestones, or project boards** — no metadata beyond title, body, base branch.\n+- **Ready-for-review PRs** — always creates as draft. No option to toggle.\n+- **Uncommitted change warnings** — if the developer has uncommitted work, that's their problem.\n+- **Updating existing PRs** — if a PR already exists for this branch, the command bails with a message.\n+- **Auto-generated testing steps** — testing steps come from the developer, not from diff analysis.\n+\n+## User Stories\n+\n+- As a developer, I want to run quality checks against my changes before opening a PR so that I catch issues before reviewers do.\n+    - Acceptance Criteria:\n+        - [ ] Review plugin checks from `.ai/review-checks/*.md` are loaded and evaluated against the diff\n+        - [ ] Check results are displayed with clear pass/fail indicators\n+        - [ ] Failed checks do not block PR creation\n+\n+- As a developer, I want an AI-generated PR title and description so that I don't have to write one from scratch.\n+    - Acceptance Criteria:\n+        - [ ] Title is concise and reflects the nature of the changes\n+        - [ ] Description summarizes what changed and why, based on the diff and commit history\n+        - [ ] Both title and description are editable before PR creation\n+\n+- As a developer, I want to add my own testing steps so that reviewers know how to verify my changes.\n+    - Acceptance Criteria:\n+        - [ ] The command prompts the developer for testing steps\n+        - [ ] Testing steps are formatted and included in the PR body\n+\n+- As a developer, I want to preview the complete PR before it's created so that I can catch mistakes.\n+    - Acceptance Criteria:\n+        - [ ] Full preview shows title, description, testing steps, and check results\n+        - [ ] Developer can edit the preview before proceeding\n+\n+- As a developer, I want the command to handle branch pushing so that I don't have to do it separately.\n+    - Acceptance Criteria:\n+        - [ ] If the branch is not pushed, the command offers to push it\n+        - [ ] If the branch is already up to date, this step is skipped\n+\n+- As a developer, I want the PR created as a draft so that I can continue iterating before requesting review.\n+    - Acceptance Criteria:\n+        - [ ] PR is always created with `--draft` flag\n+        - [ ] PR URL is displayed after creation\n+\n+## Edge Cases & Open Questions\n+\n+- **Branch is `main`**: Command refuses to run with a clear message (\"You're on main — create a feature branch first\").\n+- **PR already exists**: Command bails with a message (\"A PR already exists for this branch: [URL]\").\n+- **No review check files exist**: Skip the checks step entirely — no error, no placeholder output.\n+- **No commits ahead of target branch**: Should the command warn that there's nothing to PR? (Recommendation: yes, bail with a message.)\n+- **`gh` CLI not installed or not authenticated**: Fail early with a helpful message.\n+- **Push fails (e.g., force push needed)**: Report the error and stop. Don't offer `--force`.\n+\n+## Success Metrics\n+\n+- Developers use `/prep-pr` as their default way to open PRs in repos using The Agency.\n+- Time from \"ready to PR\" to \"draft PR exists\" is reduced to a single command invocation.\n+- PR descriptions are more consistent and informative than manually written ones.\n+\n+## Handoff Notes for Architect\n+\n+- The review plugin system already exists and is documented in `/review-pr`. The plugin loading logic (discover `.ai/review-checks/*.md`, parse YAML frontmatter, evaluate `applies_when`) should be reusable. Consider whether to extract shared logic or duplicate the relevant prompt instructions.\n+- This is a slash command, so it lives in `src/templates/.claude/commands/prep-pr.md` and needs a manifest entry in `src/manifest.ts`.\n+- The command is conversational — it prompts the developer at multiple points (testing steps, preview editing, target branch, push confirmation). This is intentional and matches the interactive nature of slash commands.\n+- The PR body template should include sections for: Summary (AI-generated), Test Plan (developer-provided), and optionally a collapsed section for check results.\n+- Always use `gh pr create --draft`.\ndiff --git a/docs/archive/briefs/weekly-summary.md b/docs/archive/briefs/weekly-summary.md\nnew file mode 100644\nindex 0000000..edf3168\n--- /dev/null\n+++ b/docs/archive/briefs/weekly-summary.md\n@@ -0,0 +1,73 @@\n+# Product Brief: Weekly Summary Command\n+\n+## Problem Statement\n+\n+Developers lose track of how the codebase has changed when they're not involved in every PR. Whether returning from PTO or just missing a few reviews, there's no quick way to rebuild a mental model of what shifted in the last week. The existing `review-pr` command solves this at the single-PR level — this command solves it at the weekly aggregate level.\n+\n+## Target User\n+\n+Developers on the team who need to catch up on changes they weren't part of.\n+\n+## MVP Scope\n+\n+A Claude Code slash command (`/weekly-summary`) that:\n+\n+- Queries merged PRs from the last 7 rolling days\n+- Collects PR metadata for each: title, body, commit messages, and diffstat (`--stat`)\n+- Synthesizes a thematic summary across all PRs (not per-PR summaries)\n+- Produces two sections:\n+    - **Mental Model Shift** — How the codebase changed, grouped by theme (e.g., \"Auth migrated from sessions to JWT,\" \"15 components moved as part of FSD migration\")\n+    - **Risk Callouts** — Things that could bite you: breaking changes, new patterns that replaced old ones, areas of high churn\n+- Writes output as a markdown file to `docs/reports/weekly-summary-YYYY-MM-DD.md`\n+- No arguments or flags — just run it\n+\n+### Input Strategy\n+\n+Full diffs are off the table for token budget reasons. The model works from:\n+\n+1. PR titles\n+2. PR bodies/descriptions\n+3. Commit messages\n+4. Diffstat (file paths, lines changed, add/remove ratio)\n+\n+This is sufficient for thematic synthesis. As PR descriptions improve (via the `review-pr` command adoption), the quality of weekly summaries will improve with them.\n+\n+## Explicitly Out of Scope\n+\n+- **CTO/devops-oriented views** — architectural drift, operational risk, etc. Desired for the future, not now.\n+- **Configurable time range** — no `--days` flag. Always 7 days for MVP.\n+- **Open/draft PRs** — only merged PRs. The developer wants to know what the codebase _is_, not what it might become.\n+- **Full diff analysis** — token budget constraint. Metadata + diffstat only.\n+- **Per-PR summaries** — the value is in the synthesis, not the itemization.\n+\n+## User Stories\n+\n+- As a developer returning from time away, I want a synthesized summary of the last week's merged changes so that I can quickly rebuild my mental model of the codebase without reading every PR.\n+    - Acceptance Criteria:\n+        - [ ] Command queries merged PRs from the last 7 rolling days\n+        - [ ] Output includes a \"Mental Model Shift\" section grouped by theme\n+        - [ ] Output includes a \"Risk Callouts\" section\n+        - [ ] Output is written to `docs/reports/weekly-summary-YYYY-MM-DD.md`\n+        - [ ] Token input is constrained to PR metadata + diffstat (no full diffs)\n+        - [ ] If no PRs were merged in the last 7 days, the command handles it gracefully (states so, doesn't produce an empty/broken report)\n+\n+## Edge Cases & Open Questions\n+\n+- **Repos with very high PR volume**: A busy repo could have 50+ merged PRs in a week. Even metadata-only, that's a lot of input. May need to test and see if there's a practical upper bound, or if the model handles it fine.\n+- **Repos with zero merged PRs**: Should produce a short file or a message, not an error.\n+- **File naming collisions**: If run twice on the same day, does it overwrite or append a suffix? Overwrite seems fine — it's a regeneration, not a history.\n+- **Cross-repo awareness**: Not relevant for MVP, but worth noting that some teams work across multiple repos. Out of scope.\n+\n+## Success Metrics\n+\n+- Developer can run the command and get a useful summary in under 2 minutes\n+- The summary accurately reflects the themes of that week's changes (spot-check against actual PRs)\n+- Developers voluntarily use it (the real test)\n+\n+## Handoff Notes for Architect\n+\n+- This is a Claude Code slash command, same pattern as `review-pr`. Lives in `src/templates/.claude/commands/`.\n+- The command will need to use `gh` CLI to query merged PRs and `git diff --stat` for diffstats. Both are safe assumptions for the target environment.\n+- The `review-pr` command is a good reference for structure and tone — this is its weekly-scale sibling.\n+- `docs/reports/` is already gitignored, so output files won't clutter the repo.\n+- Token budget is the primary technical constraint. The input strategy (metadata + diffstat, no full diffs) is a product decision, not just a technical one — the synthesized view is more valuable than per-PR detail at this time scale.\ndiff --git a/docs/archive/build-plans/install-review-plugins.md b/docs/archive/build-plans/install-review-plugins.md\nnew file mode 100644\nindex 0000000..16d179d\n--- /dev/null\n+++ b/docs/archive/build-plans/install-review-plugins.md\n@@ -0,0 +1,135 @@\n+# Build Plan: Install Review Plugins Command\n+\n+## Context Source\n+\n+Voice conversation with project owner. No product brief — requirements gathered interactively.\n+\n+## Problem Summary\n+\n+The agency package ships reference review-check files (`src/review-plugins/`) that consumers can use to enhance their PR review process. Currently there's no CLI command to install these — users have to manually copy them. We need a new `the-agency install-review-plugins` command that presents an interactive multi-select of available review plugins and copies the selected ones to `.ai/review-checks/` in the consumer's project.\n+\n+This is deliberately separate from the existing `sync` command. Sync handles the core setup (agents, commands, AI context files); review plugins are optional extras that users pick à la carte.\n+\n+## Technical Approach\n+\n+Add a new standalone module (`src/install-review-plugins.ts`) that follows the same structural patterns as `sync.ts` but is self-contained. It reads from a review plugins manifest, presents a multi-select prompt, handles overwrite confirmation, and copies files to the destination directory. The CLI entry point gets a new `install-review-plugins` command that delegates to this module.\n+\n+The manifest gets a new `reviewPlugins` section using the same `ManifestItem` shape. The review plugins source directory is already in the package but needs to be explicitly included in `package.json`'s `files` array so it ships to consumers.\n+\n+## Key Design Decisions\n+\n+- **Standalone module, not an extension of sync**\n+    - **Why**: Different semantics — sync is \"give me the full setup,\" review plugins are \"let me pick optional extras.\" Keeping them separate avoids muddying the sync abstraction.\n+    - **Trade-off**: Some pattern duplication between `sync.ts` and `install-review-plugins.ts`. Acceptable given the small codebase and the clarity it provides.\n+\n+- **Manifest-based with hand-written descriptions (not frontmatter parsing)**\n+    - **Why**: Consistent with existing manifest pattern. Four files don't justify adding YAML parsing at runtime.\n+    - **Trade-off**: Descriptions could drift from frontmatter. Manageable at this scale.\n+\n+- **Always interactive (multi-select)**\n+    - **Why**: Review plugins are opt-in by nature. A \"copy all\" default doesn't match the use case — users should consciously choose which checks apply to their stack.\n+    - **Trade-off**: No non-interactive/CI mode. Can add `--all` flag later if needed.\n+\n+## Existing Patterns to Follow\n+\n+- `sync.ts` — file copy pattern: build file list → check for existing → overwrite prompt → copy with `mkdir -p`\n+- `manifest.ts` — `ManifestItem` interface for `{ file, description }`\n+- `cli.ts` — command routing pattern (simple if/else on `args[0]`)\n+- `sync.test.ts` — testing pattern: mock `fs/promises` and `prompts`, use `jest.unstable_mockModule`\n+- `prompts` library for interactive selection (already a dependency)\n+\n+## Implementation Tasks\n+\n+### Task 1: Extend Manifest with Review Plugins\n+\n+- **What**: Add a `reviewPlugins` array to the manifest and update the `Manifest` interface.\n+- **Files**: `src/manifest.ts`\n+- **Details**:\n+    - Add `reviewPlugins: ManifestItem[]` to the `Manifest` interface\n+    - Add entries for all four plugins:\n+        - `general.md` — \"General checks: env vars, type safety, dead code, debugging leftovers, breaking changes, binary assets\"\n+        - `node-backend.md` — \"Node.js backend checks: API design, error handling, security, database patterns\"\n+        - `react-frontend.md` — \"React frontend checks: component design, hooks, rendering, accessibility\"\n+        - `unit-test.md` — \"Unit test checks: test quality, coverage, mocking patterns, assertions\"\n+    - Descriptions should be concise since they appear in the multi-select prompt\n+- **Basic Tests**: Existing manifest test (if any) still passes; new entries are present\n+- **Done when**: `manifest.reviewPlugins` has all four entries with accurate descriptions\n+\n+### Task 2: Create Install Review Plugins Module\n+\n+- **What**: New standalone module that handles the interactive install flow.\n+- **Files**: Create `src/install-review-plugins.ts`\n+- **Details**:\n+    - Export `installReviewPlugins()` async function\n+    - Source path: `src/review-plugins/` (relative to package root)\n+    - Destination path: `.ai/review-checks/` (relative to cwd)\n+    - Build choices from `manifest.reviewPlugins` — all selected by default\n+    - Present multi-select prompt via `prompts`\n+    - Check which destination files already exist\n+    - If any exist, show overwrite confirmation prompt\n+    - Copy selected files, creating directories as needed\n+    - Log each copied file and a summary count\n+    - Handle empty selection and cancelled prompts gracefully\n+    - Reuse the `fileExists` helper — import from `sync.ts` or duplicate (it's 5 lines)\n+- **Basic Tests**: Multi-select presented, files copied for selection, overwrite flow works, empty selection exits cleanly\n+- **Done when**: `installReviewPlugins()` copies selected plugin files to `.ai/review-checks/`\n+\n+### Task 3: Wire Up CLI Command\n+\n+- **What**: Add `install-review-plugins` command to the CLI entry point and update help text.\n+- **Files**: `src/cli.ts`\n+- **Details**:\n+    - Add `install-review-plugins` to the command routing\n+    - Import and call `installReviewPlugins()` from the new module\n+    - Update help text to include the new command with a brief description\n+- **Basic Tests**: N/A (CLI wiring is thin; covered by integration/manual testing)\n+- **Done when**: `npx the-agency install-review-plugins` launches the interactive flow\n+\n+### Task 4: Update Package Files\n+\n+- **What**: Ensure review plugin source files are included in the published package.\n+- **Files**: `package.json`\n+- **Details**:\n+    - Add `\"src/review-plugins/\"` to the `files` array\n+    - Verify with `pnpm pack --dry-run` that the review plugin files appear in the tarball\n+- **Basic Tests**: Dry-run pack includes `src/review-plugins/*.md`\n+- **Done when**: `pnpm pack` includes review plugin files\n+\n+### Task 5: Tests for Install Review Plugins\n+\n+- **What**: Unit tests following the same mocking pattern as `sync.test.ts`.\n+- **Files**: Create `src/install-review-plugins.test.ts`\n+- **Details**:\n+    - Mock `fs/promises` (access, mkdir, copyFile) and `prompts`\n+    - Test cases:\n+        - Copies selected files to `.ai/review-checks/`\n+        - Presents multi-select with all plugins\n+        - Prompts for overwrite when destination files exist\n+        - Aborts when user declines overwrite\n+        - Skips overwrite prompt when no conflicts\n+        - Exits cleanly on empty selection\n+        - Exits cleanly on cancelled prompt (undefined)\n+- **Basic Tests**: All the above\n+- **Done when**: All tests pass, coverage mirrors sync test coverage\n+\n+## Technical Risks\n+\n+- **Risk**: `src/review-plugins/` path resolution differs between local dev (symlinks) and installed package\n+    - **Mitigation**: Use the same `packageRoot` pattern as `sync.ts` — `resolve(__dirname, \"..\")` — which resolves correctly in both contexts. Verify with a local `pnpm pack` + install test.\n+    - **Likelihood**: Low (same pattern already works for sync)\n+\n+- **Risk**: New manifest field could break existing sync if not handled carefully\n+    - **Mitigation**: `sync` explicitly references `manifest.agents`, `.commands`, and `.ai` — it doesn't iterate all keys. Adding `reviewPlugins` won't affect it.\n+    - **Likelihood**: Low\n+\n+## Dependencies\n+\n+None new. Uses existing `prompts` package and Node.js built-ins.\n+\n+## Handoff Notes for Developer\n+\n+- The `fileExists` helper in `sync.ts` is already exported. Import it rather than duplicating.\n+- Review plugin files have YAML frontmatter — they're copied as-is, no parsing needed.\n+- The destination `.ai/review-checks/` matches what the `review-pr` command expects to find. Don't change this path without checking that command.\n+- Keep the test file structure parallel to `sync.test.ts` — same mock setup pattern, same describe/it structure. Future maintainers will thank you.\n+- The existing `sync.test.ts` has an `import` for manifest that verifies the manifest shape works at test time. Consider a similar smoke test for the review plugins manifest entries.\ndiff --git a/docs/archive/build-plans/pluggable-review-checks.md b/docs/archive/build-plans/pluggable-review-checks.md\nnew file mode 100644\nindex 0000000..fab47df\n--- /dev/null\n+++ b/docs/archive/build-plans/pluggable-review-checks.md\n@@ -0,0 +1,140 @@\n+# Build Plan: Pluggable Review Checks\n+\n+## Context Source\n+\n+Product brief at `docs/briefs/pluggable-review-checks.md`, plus architecture conversation.\n+\n+## Problem Summary\n+\n+The `/review-pr` command has hardcoded \"Tribal Knowledge Checks\" baked into the prompt — Kysely queries, `@avol/telemetry`, `data-cy` attributes — that only make sense for one team. Any other team consuming `@apogeelabs/the-agency` gets irrelevant noise with no way to customize.\n+\n+This feature makes tribal knowledge checks pluggable. Teams define their own checks as markdown files in `.ai/review-checks/`, and the `/review-pr` command discovers and loads them at runtime. Pre-packaged plugins ship as reference material for teams to copy and adapt.\n+\n+## Technical Approach\n+\n+All changes are prompt-level — no TypeScript code changes, no manifest updates, no new dependencies.\n+\n+The `/review-pr` command prompt (`src/templates/.claude/commands/review-pr.md`) gets two modifications: Step 4 becomes generic (no hardcoded monorepo paths), and Step 7 switches from hardcoded checks to a discovery-and-load sequence that reads markdown files from `.ai/review-checks/` at runtime.\n+\n+Pre-packaged plugin files live in `src/review-plugins/` (outside the `src/templates/` tree, so they're not symlinked or synced). These are reference material — teams browse the README and copy what they need.\n+\n+## Key Design Decisions\n+\n+- **Plugins live in `src/review-plugins/`, not `src/templates/.ai/review-plugins/`**\n+    - **Why**: `src/templates/.ai/` is symlinked into the repo root for dogfooding. Plugins are source material, not configuration — they shouldn't appear in `.ai/` via the symlink. Keeping them in `src/review-plugins/` also sets up cleanly for the future CLI install command.\n+    - **Trade-off**: Slightly unconventional path (not under `templates/`), but the separation is worth it.\n+\n+- **Prescriptive shell commands in the prompt for file discovery**\n+    - **Why**: Explicit `ls` and `cat` commands reduce ambiguity about how Claude should find and read check files. Declarative instructions (\"discover and load\") leave too much room for the LLM to improvise.\n+    - **Trade-off**: More verbose prompt, but more reliable behavior.\n+\n+- **Step 4 made generic — categorize by top-level directory / workspaces**\n+    - **Why**: The hardcoded path categories (`packages/shared/*`, `services/api/*`) are as team-specific as the tribal knowledge checks. Generic categorization works for any repo.\n+    - **Trade-off**: Slightly less structured output for the original team, but they can compensate with check files that reference their specific paths.\n+\n+- **Inline example of check file format in the prompt**\n+    - **Why**: Cheap insurance — helps the LLM parse YAML frontmatter reliably. ~10 lines of prompt for significantly more consistent behavior.\n+    - **Trade-off**: Slightly longer prompt, negligible cost.\n+\n+- **`applies_when` matching is LLM-interpreted, not deterministic**\n+    - **Why**: Per the brief, this is intentionally fuzzy. Natural language criteria (\"`.tsx` files in `apps/web-client/`\") are interpreted by the LLM against the diff's file list. No glob/regex DSL.\n+    - **Trade-off**: Possible inconsistency on edge cases, but these are advisory checks, not CI gates.\n+\n+## Existing Patterns to Follow\n+\n+- Command files are pure markdown, no frontmatter — the check files use frontmatter, but the command file itself does not.\n+- The existing prompt uses explicit bash code blocks for shell commands Claude should run (see Steps 1-3).\n+- The `.ai/` directory convention is already established for AI context files (unit test guides, workflow docs).\n+\n+## Implementation Tasks\n+\n+### Task 1: Create pre-packaged plugin files\n+\n+- **What**: Create three markdown check files in `src/review-plugins/`, seeded from the existing hardcoded checks in Step 7. Each file gets YAML frontmatter (`name`, `applies_when`) and the checks as a markdown body.\n+- **Files**:\n+    - Create `src/review-plugins/react-frontend.md`\n+    - Create `src/review-plugins/node-backend.md`\n+    - Create `src/review-plugins/general.md`\n+- **Details**:\n+    - `react-frontend.md`: `applies_when` targets `.tsx, .jsx, .css, .scss, .styled.ts` files. Checks: hard-coded colors, missing data-cy attributes, accessibility gaps.\n+    - `node-backend.md`: `applies_when` targets `.ts` files in backend/service directories (not test files). Checks: console.log usage, boundary violations, raw SQL, error swallowing. Generalize away from team-specific references — replace \"Kysely\" with \"parameterized queries\" and \"`@avol/telemetry`\" with \"the project's structured logger\".\n+    - `general.md`: `applies_when` is unconditional (always applies). Checks: new environment variables, test coverage gaps, type safety (`any`, `as`, `@ts-ignore`).\n+- **Basic Tests**: Manual — copy a plugin file to `.ai/review-checks/`, run `/review-pr` on a test PR, verify it gets picked up.\n+- **Done when**: Three well-formed plugin files exist in `src/review-plugins/` with correct frontmatter and generalized check content.\n+\n+### Task 2: Rewrite Step 4 of `review-pr.md` — generic file categorization\n+\n+- **What**: Strip the hardcoded monorepo path categories from Step 4. Replace with generic categorization logic.\n+- **Files**:\n+    - Modify `src/templates/.claude/commands/review-pr.md` (Step 4, lines ~56-82)\n+- **Details**:\n+    - Keep the noise file filtering (lock files, dist/build, binaries) — it's universal.\n+    - Remove the hardcoded \"Categorize by area\" block (`packages/shared/*`, `packages/db/*`, etc.).\n+    - Replace with: categorize changed files by top-level directory. If workspace definitions exist (`package.json` workspaces field or `pnpm-workspace.yaml`), use those to inform grouping.\n+    - Remove the \"Identify file types present\" block — this was only needed to drive the hardcoded checks in Step 7. With pluggable checks, `applies_when` handles file-type relevance.\n+- **Basic Tests**: Run `/review-pr` on a PR and verify the file categorization is sensible without the hardcoded paths.\n+- **Done when**: Step 4 contains no team-specific path references and produces reasonable categorization for any repo structure.\n+\n+### Task 3: Replace Step 7 of `review-pr.md` — pluggable check discovery\n+\n+- **What**: Remove the hardcoded tribal knowledge checks. Replace with instructions to discover, load, and evaluate check files from `.ai/review-checks/`.\n+- **Files**:\n+    - Modify `src/templates/.claude/commands/review-pr.md` (Step 7, lines ~148-170, plus output format section)\n+- **Details**:\n+    - New Step 7 flow:\n+        1. List markdown files: `ls .ai/review-checks/*.md 2>/dev/null`\n+        2. If no directory or no `.md` files, skip the entire Tribal Knowledge Checks section (no heading, no placeholder text).\n+        3. If files found, read each file.\n+        4. Parse the YAML frontmatter to extract `name` and `applies_when`. If a file is missing frontmatter or has invalid YAML, skip it and note in output: \"Skipped `{filename}`: missing or invalid frontmatter.\"\n+        5. Evaluate `applies_when` against the list of files from the diff (gathered in Step 3). Use the LLM's interpretation — no deterministic matching.\n+        6. For each check group where `applies_when` matches, include its checks in the output under a heading using `name` from frontmatter.\n+        7. If files exist but none match the diff, skip the Tribal Knowledge Checks section entirely.\n+    - Include an inline example of the expected check file format (frontmatter + body) so the LLM knows exactly what it's parsing.\n+    - Use explicit bash commands: `ls` for discovery, read each file for content.\n+    - Update the output format section: make the Tribal Knowledge Checks heading and content conditional. Add a note that this section only appears when matching check files are found.\n+- **Basic Tests**:\n+    - No `.ai/review-checks/` directory → no Tribal Knowledge Checks section in output\n+    - Empty `.ai/review-checks/` directory → no Tribal Knowledge Checks section in output\n+    - Check file with `applies_when` that matches the diff → checks appear under `name` heading\n+    - Check file with `applies_when` that doesn't match → checks don't appear\n+    - Malformed file (no frontmatter) → skipped with note\n+- **Done when**: Step 7 is fully dynamic — no hardcoded checks remain, and the section appears only when matching check files exist.\n+\n+### Task 4: Update the README\n+\n+- **What**: Document the `.ai/review-checks/` convention and list the available pre-packaged plugins.\n+- **Files**:\n+    - Modify `README.md`\n+- **Details**:\n+    - Add a section explaining the review checks folder convention (`.ai/review-checks/`), the file format (frontmatter + body), and how `applies_when` works.\n+    - List each pre-packaged plugin from `src/review-plugins/` with its name, what it checks, and what file types it targets.\n+    - Include brief instructions: \"Copy any of these files to `.ai/review-checks/` in your repo to activate them.\"\n+    - Keep it concise — this is reference documentation, not a tutorial.\n+- **Basic Tests**: Read the README and verify the plugin descriptions match the actual file contents.\n+- **Done when**: README documents the convention and lists all available plugins with accurate descriptions.\n+\n+## Technical Risks\n+\n+- **Risk**: LLM inconsistently interprets `applies_when` criteria, leading to checks firing (or not firing) unexpectedly.\n+    - **Mitigation**: Use clear, specific language in the pre-packaged plugin `applies_when` fields as examples of good practice. Include the inline example in the prompt to anchor the LLM's parsing. Accept that edge cases will exist — these are advisory, not gates.\n+    - **Likelihood**: Medium (but low impact — worst case is a slightly noisy or slightly incomplete review)\n+\n+- **Risk**: LLM fails to parse YAML frontmatter correctly from the check files.\n+    - **Mitigation**: Include an inline example of the exact format in the Step 7 prompt instructions. Keep the frontmatter minimal (two fields only).\n+    - **Likelihood**: Low\n+\n+- **Risk**: The `ls .ai/review-checks/*.md` command behaves differently across shells or OS environments (e.g., zsh glob no-match errors).\n+    - **Mitigation**: The `2>/dev/null` redirect handles the \"no files\" case. Test on both bash and zsh. If needed, use `find` as a fallback.\n+    - **Likelihood**: Low\n+\n+## Dependencies\n+\n+None. No new packages, services, or APIs.\n+\n+## Handoff Notes for Developer\n+\n+- **The canonical files live in `src/templates/`**. Because of the dogfooding symlinks, editing `src/templates/.claude/commands/review-pr.md` and `.claude/commands/review-pr.md` are the same file. Edit via the `src/templates/` path.\n+- **Don't touch `src/manifest.ts`**. The review-plugins directory is not synced to consumers.\n+- **Generalize the plugin content**. The existing hardcoded checks reference team-specific tools (`@avol/telemetry`, Kysely). The pre-packaged plugins should use generic language (\"structured logger\", \"parameterized queries\") so they're useful to any team.\n+- **The output format section** (at the bottom of `review-pr.md`) needs updating too — it currently shows Tribal Knowledge Checks as a fixed section. Make it conditional with a note.\n+- **For testing**: you can create `.ai/review-checks/` in this repo (it'll actually be `src/templates/.ai/review-checks/` via the symlink) and run `/review-pr` against a real PR to verify the discovery flow works. Clean up after testing — don't commit test check files unless we want them for dogfooding.\ndiff --git a/docs/build-plans/pr-review-command.md b/docs/archive/build-plans/pr-review-command.md\nsimilarity index 100%\nrename from docs/build-plans/pr-review-command.md\nrename to docs/archive/build-plans/pr-review-command.md\ndiff --git a/docs/archive/build-plans/prep-pr.md b/docs/archive/build-plans/prep-pr.md\nnew file mode 100644\nindex 0000000..f7a772c\n--- /dev/null\n+++ b/docs/archive/build-plans/prep-pr.md\n@@ -0,0 +1,163 @@\n+# Build Plan: Prep PR Command\n+\n+## Context Source\n+\n+Product brief at `docs/briefs/prep-pr.md`, plus design conversation with Jim covering plugin evaluation depth, target branch timing, PR body template, and edge case handling.\n+\n+## Problem Summary\n+\n+Developers need a pre-submission quality gate for pull requests. Before opening a PR, they want to run checks against their changes, get an AI-generated description, add testing steps, and create a draft PR — all from a single command. The existing `/review-pr` command serves reviewers after a PR exists; `/prep-pr` serves the author before one does.\n+\n+## Technical Approach\n+\n+This is a single markdown command file (`src/templates/.claude/commands/prep-pr.md`) following the same pattern as existing commands. The command is conversational and interactive — it prompts the developer at multiple points during the flow.\n+\n+The review plugin loading logic is duplicated from `/review-pr` with adjusted evaluation instructions: same discovery and YAML frontmatter parsing, but check evaluation produces pass/fail with brief file/line pointers rather than the full reviewer narrative. This keeps both commands self-contained (important since commands run in isolated contexts) while giving authors enough information to find and fix issues.\n+\n+The command creates draft PRs exclusively via `gh pr create --draft`.\n+\n+## Key Design Decisions\n+\n+- **Duplicate plugin loading instructions (lighter evaluation)**\n+    - **Why**: Commands are self-contained markdown running in isolated contexts — no import mechanism. Author needs actionable pass/fail with file pointers, not reviewer-depth analysis.\n+    - **Trade-off**: Two places to update if plugin format changes. Acceptable for MVP; extraction would require architectural changes to the command system.\n+\n+- **Target branch asked early, defaults to repo default branch**\n+    - **Why**: Need the base branch to generate the diff for analysis. Asking early with a sensible default (repo's default branch) avoids friction for the 90% case while letting the developer override.\n+    - **Trade-off**: Slightly more upfront interaction before the interesting stuff, but cleaner data flow.\n+\n+- **Collapsed check results in PR body**\n+    - **Why**: Check results are useful context for reviewers but shouldn't dominate the PR description. A `<details>` block keeps them accessible without cluttering.\n+    - **Trade-off**: May remove this if it feels noisy in practice. Keeping for MVP to evaluate.\n+\n+- **Bail on no commits ahead with rebase suggestion**\n+    - **Why**: A PR with no diff is meaningless. Suggesting a rebase points the developer toward the likely fix.\n+    - **Trade-off**: None meaningful — this is a clear error case.\n+\n+## Existing Patterns to Follow\n+\n+- Command file structure from `review-pr.md` — step-numbered sections, bash code blocks for commands, conditional flow based on command output\n+- Plugin discovery flow from `review-pr.md` Steps 7.1–7.7 — `ls .ai/review-checks/*.md`, parse YAML frontmatter, evaluate `applies_when`\n+- Manifest entry format from `src/manifest.ts`\n+- Interactive/conversational tone matching existing commands (e.g., `architect.md`, `pm.md`)\n+\n+## Implementation Tasks\n+\n+### Task 1: Create the command file with precondition checks\n+\n+- **What**: Create `src/templates/.claude/commands/prep-pr.md` with Step 1 (precondition validation). This includes checking whether `gh` is installed and authenticated, whether the current branch is `main` (or the repo's default branch), and whether a PR already exists for the current branch. Each failure case produces a clear message and stops execution.\n+- **Files**: `src/templates/.claude/commands/prep-pr.md` (create)\n+- **Implementation notes**:\n+    - Use `gh auth status` to verify `gh` CLI is installed and authenticated\n+    - Use `git branch --show-current` to get current branch\n+    - Use `gh repo view --json defaultBranchRef -q '.defaultBranchRef.name'` to get default branch name\n+    - Use `gh pr list --head <branch> --json number,url` to check for existing PRs\n+    - If on default branch: bail with \"You're on [branch] — create a feature branch first\"\n+    - If PR exists: bail with \"A PR already exists for this branch: [URL]\"\n+- **Done when**: Command file exists with precondition checks that bail correctly for each failure case.\n+\n+### Task 2: Add target branch prompt and diff gathering\n+\n+- **What**: Add Step 2 (target branch selection) and Step 3 (diff gathering). Prompt the developer for target branch, defaulting to the repo's default branch. Then gather the diff and commit log against that base.\n+- **Files**: `src/templates/.claude/commands/prep-pr.md` (modify)\n+- **Implementation notes**:\n+    - Default target branch is the repo's default branch (from Task 1's `gh repo view` query)\n+    - Prompt: \"Target branch? (default: [default branch])\" — developer can accept default or specify another\n+    - Check that there are commits ahead of the target branch. If not, bail with: \"No commits ahead of [target branch]. Nothing to PR. You may need to rebase.\"\n+    - Gather: `git diff --stat <target>...HEAD`, `git diff <target>...HEAD`, `git log --no-merges --oneline <target>..HEAD`\n+- **Done when**: Command prompts for target branch, gathers diff successfully, and bails correctly when no commits ahead.\n+\n+### Task 3: Add review plugin checks\n+\n+- **What**: Add Step 4 (review plugin evaluation). Discover and load `.ai/review-checks/*.md` files, parse YAML frontmatter, evaluate `applies_when` against changed files, and run applicable checks against the diff.\n+- **Files**: `src/templates/.claude/commands/prep-pr.md` (modify)\n+- **Implementation notes**:\n+    - Discovery: `ls .ai/review-checks/*.md 2>/dev/null`\n+    - If no directory or no files, skip silently — no error, no placeholder\n+    - Read each file, parse YAML frontmatter for `name` and `applies_when`\n+    - Skip files with missing/invalid frontmatter (note in output: \"Skipped `{filename}`: missing or invalid frontmatter\")\n+    - Evaluate `applies_when` against changed file list from the diff\n+    - For matching check groups: evaluate each check item against the diff\n+    - Output format: pass/fail per check with brief file/line pointers for failures — enough breadcrumb to find and fix, not a full reviewer narrative\n+    - Store check results for inclusion in PR body later\n+- **Done when**: Plugin checks load, evaluate, and produce actionable pass/fail output with location pointers.\n+\n+### Task 4: Add title/description generation and testing steps prompt\n+\n+- **What**: Add Step 5 (AI-generated title and description) and Step 6 (developer testing steps). Analyze the diff and commit history to generate a PR title and description. Then prompt the developer for testing steps.\n+- **Files**: `src/templates/.claude/commands/prep-pr.md` (modify)\n+- **Implementation notes**:\n+    - Title: concise, reflects the nature of the changes (bug fix, feature, refactor, etc.)\n+    - Description: summarize what changed and why, based on diff and commit messages. Focus on the \"so what\" not a restatement of the diff.\n+    - Prompt developer: \"Enter your testing steps (how should a reviewer verify these changes?):\"\n+    - Developer provides free-form testing steps — these are NOT AI-generated\n+- **Done when**: Command generates title and description from the diff and collects testing steps from the developer.\n+\n+### Task 5: Add PR preview, push, and creation\n+\n+- **What**: Add Step 7 (full preview), Step 8 (push if needed), and Step 9 (draft PR creation). Present the complete PR preview for developer review/editing. Push the branch if not already pushed. Create the draft PR via `gh`.\n+- **Files**: `src/templates/.claude/commands/prep-pr.md` (modify)\n+- **Implementation notes**:\n+    - Preview format shows: title, description, testing steps, and check results (if any)\n+    - Developer can review and request edits to any section before proceeding\n+    - PR body template:\n+\n+        ```\n+        ## Summary\n+        [AI-generated description]\n+\n+        ## Test Plan\n+        [Developer-provided testing steps]\n+\n+        <details>\n+        <summary>Pre-submission Checks</summary>\n+\n+        [Check results — pass/fail with names]\n+\n+        </details>\n+        ```\n+\n+    - If no check results (no plugin files or none matched), omit the `<details>` section entirely\n+    - Check push status: `git rev-parse --abbrev-ref --symbolic-full-name @{u}` — if no upstream or local is ahead, offer to push\n+    - Push with: `git push -u origin <branch>`\n+    - If push fails, report the error and stop. Do NOT offer `--force`.\n+    - Create PR: `gh pr create --draft --base <target> --title \"<title>\" --body \"<body>\"`\n+    - Display the PR URL on success\n+\n+- **Done when**: Command shows preview, handles push, creates draft PR, and displays the URL.\n+\n+### Task 6: Add manifest entry\n+\n+- **What**: Add the new command to the file manifest so it gets distributed by `the-agency sync`.\n+- **Files**: `src/manifest.ts` (modify)\n+- **Implementation notes**:\n+    - Add to the `commands` array: `{ file: \"prep-pr.md\", description: \"Pre-submission PR prep and draft creation\" }`\n+- **Done when**: Manifest includes the new command entry and `pnpm build` succeeds.\n+\n+## Technical Risks\n+\n+- **Risk**: Plugin loading instructions diverge between `prep-pr` and `review-pr` over time\n+    - **Mitigation**: Keep the discovery/loading flow identical; only the evaluation depth differs. Comment in both files referencing the other as the sibling implementation.\n+    - **Likelihood**: Medium (will happen eventually, but is manageable)\n+\n+- **Risk**: `gh` CLI edge cases (not installed, not authenticated, wrong repo)\n+    - **Mitigation**: Fail early in precondition checks with specific, helpful error messages\n+    - **Likelihood**: Low (well-understood failure modes)\n+\n+- **Risk**: Diff too large for context window during title/description generation\n+    - **Mitigation**: Use `git diff --stat` for overview + selective reading of key files rather than dumping the entire diff. The command prompt should instruct analysis of the stat summary and commit log first, then selectively read diffs for the most significant files.\n+    - **Likelihood**: Medium (large PRs exist, but the command already has all context available as a slash command)\n+\n+## Dependencies\n+\n+- `gh` CLI (GitHub CLI) — must be installed and authenticated in the consuming repo\n+- `.ai/review-checks/*.md` — optional, plugin files for tribal knowledge checks (already part of the existing system)\n+\n+## Handoff Notes for Developer\n+\n+- This is a **prompt engineering** task, not a code task. The entire implementation is a single markdown file. Write it like you're writing instructions for a very capable but literal assistant.\n+- Look at `review-pr.md` as your primary reference for style and structure. Match its level of specificity in bash commands and conditional logic.\n+- The command is intentionally conversational. There are multiple points where you pause and wait for developer input. Don't try to make it fully autonomous.\n+- The `<details>` block for check results in the PR body is provisional — we may remove it after seeing it in practice.\n+- ⚠️ Don't forget to cross-reference with `review-pr.md` when writing the plugin discovery/loading section. Same flow, lighter evaluation.\n+- The command should NOT reference `$ARGUMENTS` — unlike `review-pr`, this command takes no arguments. It operates on the current branch.\ndiff --git a/docs/archive/build-plans/weekly-summary.md b/docs/archive/build-plans/weekly-summary.md\nnew file mode 100644\nindex 0000000..65b61b3\n--- /dev/null\n+++ b/docs/archive/build-plans/weekly-summary.md\n@@ -0,0 +1,134 @@\n+# Build Plan: Weekly Summary Command\n+\n+## Context Source\n+\n+Product brief: `docs/briefs/weekly-summary.md`\n+\n+## Problem Summary\n+\n+Developers lose track of how the codebase evolves when they're not reviewing every PR. There's no quick way to rebuild a mental model after a few days away. This command synthesizes the last 7 days of merged PRs into a thematic summary — not a list of PRs, but a narrative of how the codebase shifted — with risk callouts for things that could bite you.\n+\n+## Technical Approach\n+\n+This is a Claude Code slash command (`/weekly-summary`), same structural pattern as the existing `review-pr` command. It lives in `src/templates/.claude/commands/weekly-summary.md` as a prompt file — no application code, no runtime logic, just prompt engineering that drives Claude's behavior when the command is invoked.\n+\n+The command uses the GitHub API (via `gh` CLI) exclusively for data gathering — no local branch assumptions, no `git diff`. This is deliberate: merged branches are often deleted, and the command should work against any repo the user has `gh` access to without needing branches checked out locally. Data flows in three stages: (1) fetch merged PR list with metadata, (2) fetch per-PR file stats for diffstat equivalence, (3) synthesize into thematic output.\n+\n+Output is written to `docs/reports/weekly-summary-YYYY-MM-DD.md`. The `docs/reports/` directory is already gitignored in consumer repos that follow the convention.\n+\n+## Key Design Decisions\n+\n+- **Decision**: API-first data gathering — no local git operations\n+    - **Why**: Merged branches are frequently deleted. The command should work regardless of local branch state.\n+    - **Trade-off**: Requires network access and a valid `gh` auth session. Can't run offline.\n+\n+- **Decision**: No input cap or truncation for MVP\n+    - **Why**: The model should handle the synthesis; premature truncation risks losing signal. Token cost is acceptable for a command run ~weekly.\n+    - **Trade-off**: High-volume repos (50+ PRs/week) may produce large input payloads. We'll monitor and add truncation if costs or quality suffer.\n+\n+- **Decision**: Thematic synthesis, not per-PR summaries\n+    - **Why**: The value is in the aggregate mental model update. Per-PR summaries are just a worse version of reading PR titles.\n+    - **Trade-off**: The prompt must be very explicit about this or the model will default to per-PR itemization.\n+\n+- **Decision**: Overwrite on same-day re-run\n+    - **Why**: It's a regeneration, not a history. Running twice should give you the latest synthesis, not two files.\n+    - **Trade-off**: None meaningful. If someone wanted the earlier version, it wasn't committed anyway (gitignored).\n+\n+## Existing Patterns to Follow\n+\n+- **Command file structure**: Follow `src/templates/.claude/commands/review-pr.md` — step-by-step instructions with bash command blocks, output format specification, and behavioral guidance.\n+- **Manifest registration**: Add entry to `src/manifest.ts` in the `commands` array.\n+- **Output location**: `docs/reports/` directory, matching the convention documented in `CLAUDE.md`.\n+- **Tone and synthesis style**: The \"Mental Model Shift\" narrative voice from `review-pr` is the reference for how this command should read.\n+\n+## Implementation Tasks\n+\n+### Task 1: Create the weekly-summary command prompt\n+\n+- **What**: Create `src/templates/.claude/commands/weekly-summary.md` — the full slash command prompt that drives Claude's behavior when `/weekly-summary` is invoked.\n+- **Files**: Create `src/templates/.claude/commands/weekly-summary.md`\n+- **Structure**:\n+\n+    **Step 1 — Determine date range**: Calculate the date 7 days ago from today. Use this as the cutoff for merged PRs.\n+\n+    **Step 2 — Fetch merged PRs**: Use `gh pr list --state merged --json number,title,body,mergedAt,additions,deletions,changedFiles,commits --limit 100`. Filter results to only PRs where `mergedAt` is within the last 7 days (the `--state merged` flag returns recent merges, but Claude must verify dates since `gh` doesn't have a native date filter on `pr list`).\n+\n+    **Step 3 — Handle zero PRs**: If no PRs match the date range, write a short file to the output path stating no PRs were merged in the last 7 days. Stop.\n+\n+    **Step 4 — Fetch per-PR file stats**: For each merged PR, run `gh api repos/{owner}/{repo}/pulls/{number}/files` to get file-level change stats (filename, additions, deletions, status). This is the diffstat equivalent. Use `gh repo view --json owner,name` (or parse from `gh repo view --json nameWithOwner`) to get the owner/repo values dynamically.\n+\n+    **Step 5 — Synthesize**: With all data assembled, produce the two output sections:\n+    - **Mental Model Shift**: Thematic grouping of how the codebase changed. NOT per-PR summaries. The prompt must aggressively reinforce: \"Group by theme, not by PR. A developer reading this should understand the narrative of what shifted, not get a changelog.\" Examples of good themes: \"Auth migrated from X to Y,\" \"New caching layer introduced,\" \"Test infrastructure overhauled.\"\n+    - **Risk Callouts**: Breaking changes, new patterns replacing old ones, high-churn areas, new dependencies, removed capabilities, things that will surprise someone who wasn't watching.\n+\n+    **Step 6 — Write output**: Write the synthesized markdown to `docs/reports/weekly-summary-YYYY-MM-DD.md` (using today's date). Create `docs/reports/` if it doesn't exist.\n+\n+    **Output format**:\n+\n+    ```\n+    # Weekly Summary: YYYY-MM-DD\n+\n+    **Period**: {start_date} to {end_date}\n+    **PRs merged**: {count}\n+\n+    ---\n+\n+    ## Mental Model Shift\n+\n+    [Thematic narrative sections]\n+\n+    ---\n+\n+    ## Risk Callouts\n+\n+    [Bulleted risk items, or \"No significant risks identified\"]\n+    ```\n+\n+    **Behavioral guidance in the prompt**:\n+    - Think like a teammate giving a hallway briefing, not a release notes generator\n+    - If multiple PRs contribute to the same theme, weave them together — don't enumerate\n+    - Diffstats inform emphasis: high-churn areas get more attention\n+    - File paths in diffstats reveal what _areas_ changed, even when PR descriptions are sparse\n+    - Be honest about uncertainty: if PR descriptions are vague and diffstats are ambiguous, say so\n+    - Never hallucinate changes — only report what the data shows\n+\n+- **Done when**: Command file exists, follows the step-by-step structure of `review-pr.md`, and is a self-contained prompt that Claude Code can execute.\n+\n+### Task 2: Register command in manifest\n+\n+- **What**: Add the `weekly-summary.md` command to the manifest so the sync CLI distributes it.\n+- **Files**: Modify `src/manifest.ts`\n+- **Change**: Add `{ file: \"weekly-summary.md\", description: \"Weekly synthesis of merged PRs\" }` to the `commands` array.\n+- **Done when**: Manifest includes the new entry, `pnpm build` succeeds.\n+\n+## Technical Risks\n+\n+- **Risk**: GitHub API rate limiting on repos with many merged PRs\n+    - **Mitigation**: The per-PR file stats call is the bottleneck (one call per PR). For 50 PRs, that's 50 API calls — well within GitHub's rate limits for authenticated users (5000/hour). Only a concern if someone runs this against a repo with 200+ weekly merges, which is an extreme edge case.\n+    - **Likelihood**: Low\n+\n+- **Risk**: PR descriptions are sparse/empty, leading to thin summaries\n+    - **Mitigation**: The command also ingests commit messages and file-level diffstats. Even with empty PR bodies, the diffstat reveals what areas of the codebase changed, and commit messages often carry useful context. The prompt should instruct the model to lean on diffstats when descriptions are sparse.\n+    - **Likelihood**: Medium (varies wildly by team culture)\n+\n+- **Risk**: Model falls back to per-PR itemization despite thematic prompting\n+    - **Mitigation**: Strong prompt reinforcement with explicit negative examples (\"Do NOT summarize each PR individually\"). Test against real data and iterate on prompt wording.\n+    - **Likelihood**: Medium\n+\n+- **Risk**: `docs/reports/` doesn't exist in consumer repos\n+    - **Mitigation**: Command includes a step to `mkdir -p docs/reports/` before writing. Trivial.\n+    - **Likelihood**: Medium\n+\n+## Dependencies\n+\n+- `gh` CLI — authenticated and available in the user's shell. Same assumption as `review-pr`.\n+- No new packages or external services.\n+\n+## Handoff Notes for Developer\n+\n+- The hardest part of this is the synthesis prompt in Step 5. Expect to iterate on the wording. The first draft will probably produce per-PR summaries despite instructions — tighten the language until it consistently produces thematic output.\n+- Look at `review-pr.md` Step 5 for the \"Mental Model Shift\" voice — this command should read like the same author.\n+- The `gh api` call for per-PR files returns paginated results (30 per page by default). For PRs with many files, you may need `--paginate` or a higher `per_page` param. Add `?per_page=100` to the API URL.\n+- The date filtering happens client-side (in Claude's logic), not in the `gh` query. The `--limit 100` on `gh pr list` should be sufficient for most repos — if a repo merges more than 100 PRs in a week, the oldest ones in the window may get dropped. Acceptable for MVP.\n+- The owner/repo for the API call should be derived dynamically — don't hardcode anything. `gh repo view --json nameWithOwner --jq .nameWithOwner` gives you `owner/repo` in one shot.\n+- Re-running on the same day overwrites. This is intentional.\ndiff --git a/docs/briefs/.gitkeep b/docs/briefs/.gitkeep\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/docs/build-plans/.gitkeep b/docs/build-plans/.gitkeep\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/package.json b/package.json\nindex 3239125..7ac056d 100644\n--- a/package.json\n+++ b/package.json\n@@ -10,6 +10,7 @@\n     \"bin/\",\n     \"dist/\",\n     \"src/templates/\",\n+    \"src/review-plugins/\",\n     \"!src/templates/.claude/settings*.json\"\n   ],\n   \"dependencies\": {\ndiff --git a/src/cli.ts b/src/cli.ts\nindex f164abb..849cbd4 100644\n--- a/src/cli.ts\n+++ b/src/cli.ts\n@@ -1,4 +1,5 @@\n import { sync } from \"./sync.js\";\n+import { installReviewPlugins } from \"./install-review-plugins.js\";\n \n const args = process.argv.slice(2);\n const command = args[0];\n@@ -8,8 +9,9 @@ if (!command || command === \"help\" || command === \"--help\") {\n Usage: the-agency <command> [options]\n \n Commands:\n-  sync          Sync all Claude Code files to the current project\n-  sync --pick   Interactively select which files to sync\n+  sync                    Sync all Claude Code files to the current project\n+  sync --pick             Interactively select which files to sync\n+  install-review-plugins  Install optional review check plugins\n `);\n     process.exit(0);\n }\n@@ -17,6 +19,8 @@ Commands:\n if (command === \"sync\") {\n     const pick = args.includes(\"--pick\");\n     await sync({ pick });\n+} else if (command === \"install-review-plugins\") {\n+    await installReviewPlugins();\n } else {\n     console.error(`Unknown command: ${command}`);\n     process.exit(1);\ndiff --git a/src/install-review-plugins.test.ts b/src/install-review-plugins.test.ts\nnew file mode 100644\nindex 0000000..47bb2af\n--- /dev/null\n+++ b/src/install-review-plugins.test.ts\n@@ -0,0 +1,148 @@\n+import { jest } from \"@jest/globals\";\n+import { join, resolve, dirname } from \"node:path\";\n+import { fileURLToPath } from \"node:url\";\n+\n+const __dirname = dirname(fileURLToPath(import.meta.url));\n+const packageRoot = resolve(__dirname, \"..\");\n+\n+// Mock fs/promises\n+const mockAccess = jest.fn<() => Promise<void>>();\n+const mockMkdir = jest.fn<() => Promise<string | undefined>>();\n+const mockCopyFile = jest.fn<() => Promise<void>>();\n+\n+jest.unstable_mockModule(\"node:fs/promises\", () => ({\n+    access: mockAccess,\n+    mkdir: mockMkdir,\n+    copyFile: mockCopyFile,\n+}));\n+\n+// Mock prompts\n+const mockPrompts = jest.fn<() => Promise<Record<string, unknown>>>();\n+jest.unstable_mockModule(\"prompts\", () => ({\n+    default: mockPrompts,\n+}));\n+\n+// Import after mocks are set up\n+const { installReviewPlugins } = await import(\"./install-review-plugins.js\");\n+const { manifest } = await import(\"./manifest.js\");\n+\n+beforeEach(() => {\n+    jest.clearAllMocks();\n+    mockMkdir.mockResolvedValue(undefined);\n+    mockCopyFile.mockResolvedValue(undefined);\n+});\n+\n+describe(\"installReviewPlugins\", () => {\n+    it(\"presents multi-select with all review plugins\", async () => {\n+        mockPrompts.mockResolvedValue({ selected: [\"general.md\"] });\n+        mockAccess.mockRejectedValue(new Error(\"ENOENT\"));\n+\n+        await installReviewPlugins();\n+\n+        expect(mockPrompts).toHaveBeenCalledWith(\n+            expect.objectContaining({\n+                type: \"multiselect\",\n+                name: \"selected\",\n+                choices: expect.arrayContaining(\n+                    manifest.reviewPlugins.map((plugin) =>\n+                        expect.objectContaining({\n+                            title: plugin.file,\n+                            value: plugin.file,\n+                            selected: true,\n+                        })\n+                    )\n+                ),\n+            })\n+        );\n+    });\n+\n+    it(\"copies selected files to .ai/review-checks/\", async () => {\n+        const selected = [\"general.md\", \"unit-test.md\"];\n+        mockPrompts.mockResolvedValue({ selected });\n+        mockAccess.mockRejectedValue(new Error(\"ENOENT\"));\n+\n+        await installReviewPlugins();\n+\n+        expect(mockCopyFile).toHaveBeenCalledTimes(2);\n+        for (const file of selected) {\n+            expect(mockCopyFile).toHaveBeenCalledWith(\n+                join(packageRoot, \"src/review-plugins\", file),\n+                join(process.cwd(), \".ai/review-checks\", file)\n+            );\n+        }\n+    });\n+\n+    it(\"creates destination directory\", async () => {\n+        mockPrompts.mockResolvedValue({ selected: [\"general.md\"] });\n+        mockAccess.mockRejectedValue(new Error(\"ENOENT\"));\n+\n+        await installReviewPlugins();\n+\n+        expect(mockMkdir).toHaveBeenCalledWith(join(process.cwd(), \".ai/review-checks\"), {\n+            recursive: true,\n+        });\n+    });\n+\n+    it(\"prompts for overwrite when destination files exist\", async () => {\n+        const selected = [\"general.md\", \"unit-test.md\"];\n+        mockPrompts.mockResolvedValueOnce({ selected }).mockResolvedValueOnce({ proceed: true });\n+        mockAccess.mockResolvedValue(undefined); // all files exist\n+\n+        await installReviewPlugins();\n+\n+        expect(mockPrompts).toHaveBeenCalledTimes(2);\n+        expect(mockPrompts).toHaveBeenLastCalledWith(\n+            expect.objectContaining({\n+                type: \"confirm\",\n+                name: \"proceed\",\n+            })\n+        );\n+        expect(mockCopyFile).toHaveBeenCalledTimes(2);\n+    });\n+\n+    it(\"aborts when user declines overwrite\", async () => {\n+        mockPrompts\n+            .mockResolvedValueOnce({ selected: [\"general.md\"] })\n+            .mockResolvedValueOnce({ proceed: false });\n+        mockAccess.mockResolvedValue(undefined);\n+\n+        await installReviewPlugins();\n+\n+        expect(mockCopyFile).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"skips overwrite prompt when no conflicts\", async () => {\n+        mockPrompts.mockResolvedValue({ selected: [\"general.md\"] });\n+        mockAccess.mockRejectedValue(new Error(\"ENOENT\"));\n+\n+        await installReviewPlugins();\n+\n+        // Only the multiselect prompt, no confirm\n+        expect(mockPrompts).toHaveBeenCalledTimes(1);\n+    });\n+\n+    it(\"exits cleanly on empty selection\", async () => {\n+        mockPrompts.mockResolvedValue({ selected: [] });\n+\n+        await installReviewPlugins();\n+\n+        expect(mockCopyFile).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"exits cleanly on cancelled prompt\", async () => {\n+        mockPrompts.mockResolvedValue({ selected: undefined });\n+\n+        await installReviewPlugins();\n+\n+        expect(mockCopyFile).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"manifest has all four review plugin entries\", () => {\n+        expect(manifest.reviewPlugins).toHaveLength(4);\n+        const files = manifest.reviewPlugins.map((p) => p.file);\n+        expect(files).toContain(\"general.md\");\n+        expect(files).toContain(\"node-backend.md\");\n+        expect(files).toContain(\"react-frontend.md\");\n+        expect(files).toContain(\"unit-test.md\");\n+    });\n+});\ndiff --git a/src/install-review-plugins.ts b/src/install-review-plugins.ts\nnew file mode 100644\nindex 0000000..4a46224\n--- /dev/null\n+++ b/src/install-review-plugins.ts\n@@ -0,0 +1,88 @@\n+import { resolve, dirname, join } from \"node:path\";\n+import { fileURLToPath } from \"node:url\";\n+import { copyFile, mkdir } from \"node:fs/promises\";\n+import prompts from \"prompts\";\n+import { manifest } from \"./manifest.js\";\n+import { fileExists } from \"./sync.js\";\n+\n+const __dirname = dirname(fileURLToPath(import.meta.url));\n+const packageRoot = resolve(__dirname, \"..\");\n+\n+/** Where plugin source files live inside the published package. */\n+const srcDir = join(packageRoot, \"src/review-plugins\");\n+\n+/** Destination matches what the `review-pr` command expects to find. */\n+const destDir = \".ai/review-checks\";\n+\n+/**\n+ * Presents an interactive multi-select of available review plugins and\n+ * copies the selected ones into the consumer's project.\n+ *\n+ * This is deliberately separate from `sync` — sync handles core setup\n+ * (agents, commands, AI context), while review plugins are optional\n+ * extras that users pick à la carte.\n+ */\n+export async function installReviewPlugins(): Promise<void> {\n+    const choices = manifest.reviewPlugins.map((plugin) => ({\n+        title: plugin.file,\n+        description: plugin.description,\n+        value: plugin.file,\n+        selected: true,\n+    }));\n+\n+    const { selected } = await prompts({\n+        type: \"multiselect\",\n+        name: \"selected\",\n+        message: \"Select review plugins to install\",\n+        choices,\n+        instructions: false,\n+        hint: \"- Space to toggle, Enter to confirm\",\n+    });\n+\n+    // `prompts` returns undefined when the user hits Ctrl-C\n+    if (!selected || selected.length === 0) {\n+        console.log(\"Nothing selected. Exiting.\");\n+        return;\n+    }\n+\n+    const destBase = join(process.cwd(), destDir);\n+\n+    // Check for conflicts before copying so we can ask once rather than per-file\n+    const existing: string[] = [];\n+    for (const file of selected) {\n+        const dest = join(destBase, file);\n+        if (await fileExists(dest)) {\n+            existing.push(file);\n+        }\n+    }\n+\n+    if (existing.length > 0) {\n+        console.log(`\\nExisting files that will be overwritten:`);\n+        for (const file of existing) {\n+            console.log(`  - ${destDir}/${file}`);\n+        }\n+\n+        const { proceed } = await prompts({\n+            type: \"confirm\",\n+            name: \"proceed\",\n+            message: `Overwrite ${existing.length} existing file(s)?`,\n+            initial: true,\n+        });\n+\n+        if (!proceed) {\n+            console.log(\"Install cancelled.\");\n+            return;\n+        }\n+    }\n+\n+    await mkdir(destBase, { recursive: true });\n+\n+    for (const file of selected) {\n+        const src = join(srcDir, file);\n+        const dest = join(destBase, file);\n+        await copyFile(src, dest);\n+        console.log(`  \\u2713 ${destDir}/${file}`);\n+    }\n+\n+    console.log(`\\nInstalled ${selected.length} review plugin(s).`);\n+}\ndiff --git a/src/manifest.ts b/src/manifest.ts\nindex 6674d3b..0030428 100644\n--- a/src/manifest.ts\n+++ b/src/manifest.ts\n@@ -7,6 +7,7 @@ export interface Manifest {\n     agents: ManifestItem[];\n     commands: ManifestItem[];\n     ai: ManifestItem[];\n+    reviewPlugins: ManifestItem[];\n }\n \n export const manifest: Manifest = {\n@@ -22,11 +23,33 @@ export const manifest: Manifest = {\n         { file: \"architect.md\", description: \"Interactive architecture design sessions\" },\n         { file: \"build.md\", description: \"Build orchestrator pipeline\" },\n         { file: \"pm.md\", description: \"Interactive product requirements discovery\" },\n+        { file: \"prep-pr.md\", description: \"Pre-submission PR prep and draft creation\" },\n         { file: \"review-pr.md\", description: \"Structured PR review briefing\" },\n+        { file: \"weekly-summary.md\", description: \"Weekly synthesis of merged PRs\" },\n     ],\n     ai: [\n         { file: \"UnitTestGeneration.md\", description: \"TypeScript/Jest unit testing style guide\" },\n         { file: \"UnitTestExamples.md\", description: \"Reference examples for the test style guide\" },\n         { file: \"workflow.md\", description: \"Multi-agent development workflow guide\" },\n     ],\n+    reviewPlugins: [\n+        {\n+            file: \"general.md\",\n+            description:\n+                \"General checks: env vars, type safety, dead code, debugging leftovers, breaking changes, binary assets\",\n+        },\n+        {\n+            file: \"node-backend.md\",\n+            description:\n+                \"Node.js backend checks: API design, error handling, security, database patterns\",\n+        },\n+        {\n+            file: \"react-frontend.md\",\n+            description: \"React frontend checks: component design, hooks, rendering, accessibility\",\n+        },\n+        {\n+            file: \"unit-test.md\",\n+            description: \"Unit test checks: test quality, coverage, mocking patterns, assertions\",\n+        },\n+    ],\n };\ndiff --git a/src/review-plugins/general.md b/src/review-plugins/general.md\nnew file mode 100644\nindex 0000000..629e0c6\n--- /dev/null\n+++ b/src/review-plugins/general.md\n@@ -0,0 +1,12 @@\n+---\n+name: General Checks\n+applies_when: Always — applies to all PRs regardless of file types\n+---\n+\n+- [ ] **New environment variables**: Are there new `process.env.*` references that need documentation or deployment configuration?\n+- [ ] **Type safety**: Are there `any` types, type assertions (`as`), or `@ts-ignore` / `@ts-expect-error` comments that bypass TypeScript's type system?\n+- [ ] **Dead code**: Flag new functions, methods, constants, or type definitions that are exported or defined but never referenced by any other code in the diff. Also flag commented-out code blocks and unreachable code after unconditional `return`, `throw`, or `process.exit` statements. If it's not called, imported, or reachable, it shouldn't be merged.\n+- [ ] **Dependency changes**: Flag new packages added to `dependencies` or `devDependencies`. For each new dependency, consider: does the project already have a library that does this? Is a full package warranted or would a few lines of code suffice? Also flag removed packages (is anything still importing them?) and major version bumps (check for breaking changes in the upgrade path).\n+- [ ] **Leftover debugging**: Flag `debugger` statements, `console.debug`, `.only` on test cases (`describe.only`, `it.only`, `test.only`), artificial delays (`sleep()`, `setTimeout` used as a wait hack), and commented-out code that was clearly used during development (e.g., commented-out `console.log`, toggled feature flags, hardcoded user IDs). These are fine locally — not fine in a merge to main.\n+- [ ] **Breaking interface changes**: Flag changes to exported function signatures, type definitions, or shared interfaces that alter the contract — renamed fields, removed parameters, changed return types, narrowed union types. In a monorepo, these can silently break consumers in other packages. Flag when there's no corresponding update to callers visible in the diff, and no migration note or changelog entry.\n+- [ ] **Large binary/asset additions**: Flag images, fonts, PDFs, video files, database dumps, or other binary assets added directly to the repo, especially files over 500KB. These inflate the git history permanently and typically belong in a CDN, object store, or asset pipeline. Small icons and favicons are fine.\ndiff --git a/src/review-plugins/node-backend.md b/src/review-plugins/node-backend.md\nnew file mode 100644\nindex 0000000..cf5f07c\n--- /dev/null\n+++ b/src/review-plugins/node-backend.md\n@@ -0,0 +1,17 @@\n+---\n+name: Node Backend Checks\n+applies_when: Changed files include .ts files in backend or service directories (excluding test files)\n+---\n+\n+- [ ] **Console.log usage**: Is `console.log` used instead of the project's structured logger?\n+- [ ] **Boundary violations**: Is a handler reaching into a repository directly instead of going through a service layer?\n+- [ ] **Raw SQL**: Are there string-concatenated queries instead of parameterized queries via the project's query builder?\n+- [ ] **Error swallowing**: Are errors being caught and silently discarded without logging or re-throwing?\n+- [ ] **Readability at a glance**: Can a developer unfamiliar with this code follow the logic 6 months from now? Flag functions longer than ~40 lines that lack decomposition, deeply nested conditionals (3+ levels), boolean parameters without named constants or descriptive variable assignments, and variable names that are ambiguous or require context to interpret (e.g., `data`, `result`, `temp`, `val`, single-letter names outside of trivial loops).\n+- [ ] **Documentation gaps**: Public functions and methods should have JSDoc comments documenting purpose, parameters, and return values. Non-obvious logic — workarounds, business rules, performance trade-offs, \"this looks wrong but isn't\" patterns — should have inline comments explaining _why_, not _what_. Flag new public functions missing JSDoc and non-trivial logic blocks that would confuse a reader without context.\n+- [ ] **N+1 query patterns**: Flag loops that execute a database call (find, findOne, aggregate, query, get, fetch) per iteration instead of batching. This includes `for` loops, `.forEach`, `.map`, and `for...of` over a collection where each iteration hits the DB. The fix is typically a single bulk query (`$in`, `WHERE IN`, `mget`, pipeline) before the loop, then an in-memory lookup. Also flag `Promise.all` wrapping per-item DB calls — it's parallel but still N round-trips.\n+- [ ] **Unvalidated external input**: Flag request body fields, query parameters, route parameters, and header values used directly in business logic or DB queries without schema validation (e.g., zod, joi, class-validator). Trusting `req.body.email` without parsing it is an injection and type-safety risk. Internal function-to-function calls within the service layer do NOT need validation — only system boundaries (HTTP handlers, queue consumers, webhook receivers).\n+- [ ] **Leaking internals in API responses**: Flag error handlers or response payloads that expose stack traces, raw database error messages, internal collection/table names, internal IDs (like MongoDB `_id` when a public-facing ID exists), or implementation details (library names, file paths). API consumers should get structured error codes and user-safe messages, not a guided tour of your infrastructure.\n+- [ ] **Race conditions in async code**: Flag missing `await` on promises whose result or side effects matter (fire-and-forget is only acceptable for truly independent, failure-tolerant operations like analytics). Flag parallel mutations to shared state (e.g., two `await` calls that both read-then-write the same document without guarding against interleaving). Flag `Promise.all` over operations that have implicit ordering dependencies.\n+- [ ] **Overly broad try/catch**: Flag `try` blocks spanning more than ~15-20 lines or wrapping multiple distinct operations where the `catch` handles all failures identically. Different failure modes (network error, validation error, auth error, DB constraint violation) usually need different responses. If a single `catch(e)` logs and returns a generic 500 for all of them, flag it. Each distinct failure mode should be catchable and handleable separately.\n+- [ ] **Hardcoded magic numbers**: Flag raw numeric literals used for timeouts, retry counts, page sizes, rate limits, cache TTLs, port numbers, or threshold values. These should be named constants or pulled from configuration. `setTimeout(fn, 30000)` is unreadable; `setTimeout(fn, CACHE_TTL_MS)` communicates intent. Exceptions: `0`, `1`, `-1` in obvious arithmetic/index contexts, and HTTP status codes (e.g., `res.status(404)`) are fine.\ndiff --git a/src/review-plugins/react-frontend.md b/src/review-plugins/react-frontend.md\nnew file mode 100644\nindex 0000000..92e6354\n--- /dev/null\n+++ b/src/review-plugins/react-frontend.md\n@@ -0,0 +1,22 @@\n+---\n+name: React & Frontend Checks\n+applies_when: Changed files include .tsx, .jsx, .css, .scss, or .styled.ts files\n+---\n+\n+- [ ] **Hard-coded colors**: Are there hex values, `rgb()`, or named colors that should use theme variables or design tokens?\n+- [ ] **Missing data-cy attributes**: Do new interactive elements (buttons, inputs, links, dropdowns) have `data-cy` attributes for end-to-end testing?\n+- [ ] **Accessibility gaps**: Missing `alt` text on images? Click handlers on non-interactive elements (`div`, `span`) without proper roles? Missing `aria-label` on icon-only buttons?\n+- [ ] **One public component per file**: Each `.tsx` file should export only one React component. If additional helper components exist in the same file, they must NOT be exported and should have a `/** @private */` JSDoc comment above their declaration. Flag any file that exports multiple components, or has unexported components missing the `@private` pragma.\n+- [ ] **No direct component tests**: `.tsx` component files should NOT have corresponding `.test.tsx` or `.spec.tsx` test files. Style-only hooks (e.g., `useStyles`, `useTheme`) also do not need tests UNLESS the hook contains conditional logic that affects code paths beyond styling. Flag any new test file that directly tests a `.tsx` component or a pure-styling hook.\n+- [ ] **BEM class naming**: CSS class names must follow BEM (Block Element Modifier) convention: `.block__element--modifier`. Flag class names that use camelCase, generic names without BEM structure, or inconsistent delimiter usage (e.g., single underscores or hyphens where BEM expects doubles).\n+- [ ] **Rem units over pixels**: Use `rem` for all sizing and spacing values. `px` is acceptable ONLY for media query breakpoints. Flag any `px` usage in properties like `font-size`, `margin`, `padding`, `width`, `height`, `gap`, `border-radius`, etc.\n+- [ ] **Inline styles**: Flag `style={{...}}` props in JSX. Styling should live in stylesheets, styled components, or style hooks — not inline objects. Exceptions: truly dynamic values computed at runtime (e.g., positioning from a calculation) are acceptable, but static visual properties (`color`, `padding`, `fontSize`) are not.\n+- [ ] **Missing `key` on dynamic lists**: Flag `.map()` calls that return JSX without a `key` prop. Also flag usage of array index as `key` on lists that can be reordered, filtered, or have items added/removed — index keys cause subtle re-render bugs in those cases. Stable identifiers (IDs, slugs) are required.\n+- [ ] **Direct DOM manipulation**: Flag usage of `document.querySelector`, `document.getElementById`, `document.createElement`, `.innerHTML`, `.innerText` assignment, or `.appendChild`. React components should use refs (`useRef`) for DOM access and state for DOM updates. Direct DOM manipulation bypasses React's reconciliation and causes stale UI.\n+- [ ] **Inline event handler allocation in lists**: Flag arrow functions defined directly in JSX event props (`onClick={() => handler(id)}`) when they appear inside `.map()` or other list-rendering patterns. These create a new function reference per render per item. Extract to a named handler or use `useCallback`. Single-instance components (not in a loop) are fine.\n+- [ ] **Derived state anti-pattern**: Flag `useState` + `useEffect` pairs where the effect's only job is to compute a value from other state or props and store it back into state. This should be `useMemo` (for expensive computations) or a plain `const` (for cheap ones). The pattern creates unnecessary render cycles and is a common source of stale-state bugs.\n+- [ ] **Hardcoded user-facing strings**: Flag literal text strings rendered in JSX that a user would see on screen — headings, button labels, tooltips, placeholder text, error messages, `aria-label` values. These should use the project's i18n system (e.g., `t('key')`). Do NOT flag non-user-facing strings like prop names, CSS classes, `data-cy` values, log messages, or enum/constant comparisons.\n+- [ ] **Missing error boundaries**: Flag new top-level route components or major feature entry-point components that are not wrapped in an error boundary. An unhandled throw in a component tree without a boundary will unmount the entire app. Leaf components and small utility components do not need their own boundaries.\n+- [ ] **Prop drilling**: Flag props being passed through two or more intermediate components that don't use them — they just forward them deeper. This suggests the value should live in a React context, a state management store, or the component tree should be restructured using composition (children/render props). Name the prop and the pass-through chain in your finding.\n+- [ ] **Non-memoized context values**: Flag React context providers where the `value` prop is an object literal, array literal, or function created inline (e.g., `<Ctx.Provider value={{ user, setUser }}>`). Every render creates a new reference, forcing all consumers to re-render. Wrap the value in `useMemo` (objects/arrays) or `useCallback` (functions).\n+- [ ] **`useEffect` missing cleanup**: Flag `useEffect` hooks that create subscriptions (e.g., `addEventListener`, WebSocket connections, `subscribe()` calls), timers (`setTimeout`, `setInterval`), or `AbortController` instances without returning a cleanup function that tears them down. Also flag `async` operations in effects that set state after completion without checking whether the component is still mounted (missing abort signal or cancelled flag). These are memory leak and state-update-after-unmount bugs.\ndiff --git a/src/review-plugins/unit-test.md b/src/review-plugins/unit-test.md\nnew file mode 100644\nindex 0000000..1b9cc42\n--- /dev/null\n+++ b/src/review-plugins/unit-test.md\n@@ -0,0 +1,10 @@\n+---\n+name: Unit Test Checks\n+applies_when: Changed files include .test.ts or .spec.ts files\n+---\n+\n+- [ ] **Style guide adherence**: Test files must follow the conventions in `.ai/UnitTestGeneration.md`. Key rules to verify: method under test is executed in `beforeEach()` with assertions only in `it()` blocks (Critical Rule #1), mock behavior is configured in `beforeEach`/`beforeAll` and never at module level (Critical Rule #2), callbacks are invoked via `mockImplementation` and never via `mock.calls[N][M]()` (Critical Rule #3). Also check for coverage-driven test planning (every branch in the source has a corresponding test scenario) and superfluous test prevention (no duplicate scenarios exercising the same code path with different literal values). Note: the guide's suggestion to use \"fun\" test data is optional — straightforward data is equally acceptable.\n+- [ ] **No testing pure style hooks**: Do not test hooks that simply export a memoized style object or return static style values (e.g., `useStyles`, `useTheme` wrappers that just return a `useMemo` around a style object). If the hook contains conditional logic, branching, or computation that determines _which_ styles to return based on props/state, it should be tested. The distinction: does the hook have code paths a reviewer would want coverage on, or is it just a memoized constant?\n+- [ ] **No testing barrel exports**: Flag any new test file that tests an `index.ts` barrel export file (a file whose only purpose is re-exporting from other modules). These files have zero logic and zero branches — testing them adds maintenance cost with no coverage value.\n+- [ ] **Test descriptions match assertions**: Flag `describe`/`it` blocks where the text description doesn't match what the `expect` statements actually verify. For example, `it(\"should return the user\")` followed by `expect(mockLogger.warn).toHaveBeenCalled()` is a mismatch — the description claims one behavior but the assertion checks something unrelated. Descriptions should accurately predict what the assertions verify.\n+- [ ] **Missing `export default {}`**: Every test file must include `export default {};` near the top of the file (after any eslint pragma comments). This prevents global scope collision between test files. Flag any new or modified test file missing this export — the resulting failures are cryptic and hard to trace back to this cause.\ndiff --git a/src/sync.test.ts b/src/sync.test.ts\nindex 9e9f0fb..dc1621b 100644\n--- a/src/sync.test.ts\n+++ b/src/sync.test.ts\n@@ -62,8 +62,9 @@ describe(\"getFilesToSync\", () => {\n     });\n \n     it(\"handles the full manifest\", () => {\n-        const files = getFilesToSync({ ...manifest });\n-        const totalItems = manifest.agents.length + manifest.commands.length + manifest.ai.length;\n+        const { agents, commands, ai } = manifest;\n+        const files = getFilesToSync({ agents, commands, ai });\n+        const totalItems = agents.length + commands.length + ai.length;\n         expect(files).toHaveLength(totalItems);\n     });\n });\ndiff --git a/src/sync.ts b/src/sync.ts\nindex 208e7d1..603578d 100644\n--- a/src/sync.ts\n+++ b/src/sync.ts\n@@ -24,6 +24,11 @@ const categoryConfig: Record<string, CategoryConfig> = {\n     ai: { src: \"src/templates/.ai\", dest: \".ai\" },\n };\n \n+/**\n+ * Resolves manifest categories into concrete source/destination file paths.\n+ * Only categories present in `categoryConfig` are valid — passing unknown\n+ * categories (e.g. `reviewPlugins`) will throw at runtime.\n+ */\n export function getFilesToSync(categories: Record<string, ManifestItem[]>): SyncFile[] {\n     const files: SyncFile[] = [];\n     for (const [category, items] of Object.entries(categories)) {\n@@ -39,6 +44,10 @@ export function getFilesToSync(categories: Record<string, ManifestItem[]>): Sync\n     return files;\n }\n \n+/**\n+ * Checks whether a file exists at the given path.\n+ * Uses `fs.access` rather than `stat` to avoid TOCTOU overhead we don't need.\n+ */\n export async function fileExists(path: string): Promise<boolean> {\n     try {\n         await access(path);\n@@ -48,11 +57,25 @@ export async function fileExists(path: string): Promise<boolean> {\n     }\n }\n \n+/**\n+ * Copies agent, command, and AI context files from the package into the\n+ * consumer's project. In pick mode, presents an interactive multi-select;\n+ * otherwise syncs everything.\n+ *\n+ * Review plugins are deliberately excluded — they have their own install\n+ * flow via `install-review-plugins` since they're opt-in extras, not\n+ * core setup.\n+ */\n export async function sync({ pick = false } = {}): Promise<void> {\n     let selectedCategories: Record<string, ManifestItem[]>;\n \n     if (pick) {\n-        const choices = Object.entries(manifest).flatMap(([category, items]) =>\n+        // Filter to categories that have a known source/dest mapping.\n+        // This keeps non-sync manifest sections (e.g. reviewPlugins) out of the prompt.\n+        const syncableCategories = Object.entries(manifest).filter(\n+            ([category]) => category in categoryConfig\n+        );\n+        const choices = syncableCategories.flatMap(([category, items]) =>\n             items.map((item: ManifestItem) => ({\n                 title: `${categoryConfig[category].dest}/${item.file}`,\n                 description: item.description,\n@@ -81,7 +104,10 @@ export async function sync({ pick = false } = {}): Promise<void> {\n             selectedCategories[category].push(item);\n         }\n     } else {\n-        selectedCategories = { ...manifest };\n+        // Explicitly destructure only syncable categories to avoid pulling in\n+        // manifest sections that don't belong in sync (e.g. reviewPlugins).\n+        const { agents, commands, ai } = manifest;\n+        selectedCategories = { agents, commands, ai };\n     }\n \n     const files = getFilesToSync(selectedCategories);\ndiff --git a/src/templates/.claude/agents/dev.md b/src/templates/.claude/agents/dev.md\nindex 010ff4b..0a76fa8 100644\n--- a/src/templates/.claude/agents/dev.md\n+++ b/src/templates/.claude/agents/dev.md\n@@ -19,10 +19,15 @@ If a file exists at `docs/reports/review-fixes-[feature-name].md`, you are in a\n \n - Follow the build plan. If you disagree with something, flag it in your report before deviating.\n - Write code that reads well six months from now.\n-- Write happy-path tests alongside your implementation as specified in the build plan.\n+- Write happy-path tests alongside your implementation as specified in the build plan. Follow the testing conventions in `.ai/UnitTestGeneration.md` — read it before writing any tests.\n - Comments explain WHY, not WHAT.\n - Don't over-abstract. If something is used once, it doesn't need to be a utility function.\n \n+## What You Do NOT Test\n+\n+- **React components (.tsx files)**: Do not write unit tests for `.tsx` files. Component testing is handled separately.\n+- **Barrel exports (index.ts re-exports)**: Do not write tests for files that just re-export from other modules. There's no logic to test.\n+\n ## Code Standards\n \n - Follow existing patterns in the codebase. Consistency beats personal preference.\ndiff --git a/src/templates/.claude/agents/test-hardener.md b/src/templates/.claude/agents/test-hardener.md\nindex 0eab042..b4a8da0 100644\n--- a/src/templates/.claude/agents/test-hardener.md\n+++ b/src/templates/.claude/agents/test-hardener.md\n@@ -14,8 +14,14 @@ You are NOT rewriting the developer's tests. You're adding edge cases, failure m\n 1. Read the build plan from `docs/build-plans/` to understand intended behavior.\n 2. If a product brief exists in `docs/briefs/`, read it — especially the edge cases section.\n 3. If a review report exists in `docs/reports/review-report-*.md`, read it for flagged concerns.\n-4. Read the implementation code.\n-5. Read the existing tests. Understand what's covered. Do NOT modify existing tests.\n+4. **Read `.ai/UnitTestGeneration.md`** — this is your testing style guide. Follow it.\n+5. Read the implementation code.\n+6. Read the existing tests. Understand what's covered. Do NOT modify existing tests.\n+\n+## What You Do NOT Test\n+\n+- **React components (.tsx files)**: Do not write unit tests for `.tsx` files. Component testing is handled separately.\n+- **Barrel exports (index.ts re-exports)**: Do not write tests for files that just re-export from other modules. There's no logic to test.\n \n ## Your Approach\n \n@@ -64,8 +70,9 @@ Think like someone trying to break this code. Thoroughly, not maliciously.\n 1. Audit existing tests. Catalog what's covered.\n 2. Identify gaps by category.\n 3. Prioritize: likely to happen OR catastrophic if it does.\n-4. Write tests. Follow the existing test framework and patterns exactly.\n-5. Write your report.\n+4. **Read `.ai/UnitTestGeneration.md`** and follow its conventions exactly. Pay special attention to the **Superfluous Test Prevention** and **Coverage-Driven Test Planning** sections — you are especially prone to writing redundant tests that exercise the same branch with different values.\n+5. Write tests. Follow the existing test framework and patterns exactly.\n+6. Write your report.\n \n ## Output\n \n@@ -117,5 +124,6 @@ You also know 100% coverage is a vanity metric. You test what prevents real bugs\n \n - Match the existing test framework and patterns. Don't introduce new test libraries.\n - Test behavior, not implementation details. If internals get refactored, your tests should still pass.\n-- Do NOT modify the developer's existing tests. Add new test files or blocks only.\n+- **Add your tests to the existing `*.test.ts` file** for each module. Do NOT create separate `*.hardened.test.ts` files. Add new `describe` blocks alongside the developer's existing tests.\n+- Do NOT modify the developer's existing tests. Add new describe/it blocks only.\n - If the existing test structure is a mess, note it but don't reorganize. That's a separate task.\ndiff --git a/src/templates/.claude/commands/build.md b/src/templates/.claude/commands/build.md\nindex 7e85705..59926eb 100644\n--- a/src/templates/.claude/commands/build.md\n+++ b/src/templates/.claude/commands/build.md\n@@ -31,9 +31,7 @@ Delegate to the **dev** subagent. Tell it:\n - To write its report to `docs/reports/dev-report-[feature-name].md`\n - If a file exists at `docs/reports/review-fixes-[feature-name].md`, it's a FIX LOOP — fix only those issues\n \n-**After the dev agent completes**: Read `docs/reports/dev-report-[feature-name].md`. Summarize for the user what was built and note any deviations from the plan.\n-\n-Ask the user: **\"Dev phase complete. Proceed to code review?\"**\n+**After the dev agent completes**: Read `docs/reports/dev-report-[feature-name].md`. Summarize for the user what was built and note any deviations from the plan. Then proceed directly to Phase 2.\n \n ## Phase 2: Code Review\n \n@@ -55,13 +53,11 @@ Delegate to the **reviewer** subagent. Tell it:\n \n ### If verdict is 🟡 PASS WITH FIXES:\n \n-Report the should-fix items to the user. Ask: **\"Review passed with suggestions. Fix these before testing, or proceed to test hardening?\"**\n-\n-If the user wants fixes, create the fixes file and loop back to Phase 1.\n+Report the should-fix items to the user for awareness, then proceed directly to Phase 3. The should-fix items can be addressed after test hardening.\n \n ### If verdict is ✅ PASS:\n \n-Proceed to Phase 3.\n+Proceed directly to Phase 3.\n \n ## Phase 3: Test Hardening\n \n@@ -120,6 +116,6 @@ When all phases pass, produce a final summary:\n \n 1. **Delegate to subagents.** Do NOT try to simulate a persona by changing your own behavior. Use the actual subagents so they get isolated context.\n 2. **Subagents communicate ONLY through files.** Build plans, reports, and the codebase itself. Never pass conversation context.\n-3. **Always pause for user confirmation between phases.** The user is the decision-maker.\n+3. **Proceed automatically between phases.** Do not ask the user for permission to continue. Report what happened and move on. The user can interrupt if needed.\n 4. **Cap fix loops at 2 per phase.** If it's still failing, the human needs to look at it.\n 5. **Report what happened, not what the agent said.** Read the output files and summarize.\ndiff --git a/src/templates/.claude/commands/prep-pr.md b/src/templates/.claude/commands/prep-pr.md\nnew file mode 100644\nindex 0000000..e0d14db\n--- /dev/null\n+++ b/src/templates/.claude/commands/prep-pr.md\n@@ -0,0 +1,256 @@\n+# Prep PR Command\n+\n+You are a PR preparation assistant. Your job is to help the developer run pre-submission checks, generate a PR title and description, collect testing steps, and create a draft pull request — all from the current branch.\n+\n+This command takes no arguments. It operates on the currently checked-out branch.\n+\n+<!-- Sibling command: review-pr.md uses the same plugin discovery/loading flow but with deeper evaluation. If the plugin format changes, update both files. -->\n+\n+## Step 1: Validate Preconditions\n+\n+Run these checks in order. Stop at the first failure.\n+\n+### 1.1: Verify `gh` CLI\n+\n+```bash\n+gh auth status\n+```\n+\n+**If this fails**, stop and output:\n+\n+> **GitHub CLI is not installed or not authenticated.**\n+>\n+> Install it from https://cli.github.com/ and run `gh auth login` to authenticate.\n+\n+### 1.2: Check current branch\n+\n+```bash\n+git branch --show-current\n+```\n+\n+Get the repo's default branch:\n+\n+```bash\n+gh repo view --json defaultBranchRef -q '.defaultBranchRef.name'\n+```\n+\n+**If the current branch matches the default branch**, stop and output:\n+\n+> **You're on `{branch}` — create a feature branch first.**\n+\n+### 1.3: Check for existing PR\n+\n+```bash\n+gh pr list --head $(git branch --show-current) --json number,url\n+```\n+\n+**If this returns a PR**, stop and output:\n+\n+> **A PR already exists for this branch:** {url}\n+\n+## Step 2: Target Branch\n+\n+Ask the developer:\n+\n+> **Target branch?** (default: `{default branch from Step 1.2}`)\n+\n+The developer can accept the default or specify another branch. Use whatever they provide (or the default) as `$TARGET` for all subsequent steps.\n+\n+## Step 3: Gather Diff\n+\n+Check that there are commits ahead of the target branch:\n+\n+```bash\n+git log --oneline $TARGET..HEAD\n+```\n+\n+**If no commits are returned**, stop and output:\n+\n+> **No commits ahead of `{$TARGET}`. Nothing to PR.** You may need to rebase.\n+\n+Gather the change data:\n+\n+```bash\n+# File list with change stats\n+git diff --stat $TARGET...HEAD\n+\n+# Full diff\n+git diff $TARGET...HEAD\n+\n+# Commit log (excluding merges)\n+git log --no-merges --oneline $TARGET..HEAD\n+```\n+\n+## Step 4: Review Plugin Checks\n+\n+Review plugin checks are loaded dynamically from `.ai/review-checks/`. Each check file is a markdown file with YAML frontmatter.\n+\n+<!-- This is the same discovery/loading flow as review-pr.md, but with lighter evaluation: pass/fail with brief file/line pointers rather than full reviewer narrative. -->\n+\n+**Expected check file format:**\n+\n+```markdown\n+---\n+name: Example Check Group\n+applies_when: Changed files include .ts files in src/\n+---\n+\n+- [ ] **Check name**: Description of what to look for.\n+- [ ] **Another check**: Description of what to look for.\n+```\n+\n+**Discovery and evaluation flow:**\n+\n+1. List available check files:\n+\n+```bash\n+ls .ai/review-checks/*.md 2>/dev/null\n+```\n+\n+2. **If the directory does not exist or contains no `.md` files**, skip the entire review plugin checks section silently — no error, no placeholder text. Proceed to Step 5.\n+\n+3. **If files are found**, read each one:\n+\n+```bash\n+cat .ai/review-checks/*.md\n+```\n+\n+4. For each file, parse the YAML frontmatter to extract `name` and `applies_when`. If a file is missing frontmatter or has invalid/unparseable YAML, skip it and note: \"Skipped `{filename}`: missing or invalid frontmatter.\"\n+\n+5. Evaluate each file's `applies_when` value against the list of changed files from the diff (gathered in Step 3). Use your judgment — `applies_when` is natural language, not a glob pattern. Match generously but sensibly.\n+\n+6. For each check group where `applies_when` matches, evaluate each check item against the diff. Output format: **pass/fail per check with brief file/line pointers for failures** — enough breadcrumb to find and fix the issue, not a full review narrative.\n+\n+7. If files exist but **none** of their `applies_when` criteria match the diff, skip the check results silently.\n+\n+Store the check results — they'll be included in the PR body later.\n+\n+Display the check results to the developer as you go so they can see what passed and what needs attention.\n+\n+## Step 5: Generate Title and Description\n+\n+Analyze the diff and commit history gathered in Step 3. Generate:\n+\n+- **Title**: Concise, reflects the nature of the changes (bug fix, feature, refactor, etc.). Keep it under 70 characters.\n+- **Description**: Summarize what changed and why. Focus on the \"so what\" — not a restatement of the diff. Draw from commit messages and the actual code changes.\n+\n+For large diffs, prioritize analyzing `git diff --stat` and the commit log, then selectively read diffs for the most significant files rather than trying to process the entire diff.\n+\n+## Step 6: Collect Testing Steps\n+\n+Ask the developer:\n+\n+> **Testing steps — how should a reviewer verify these changes?**\n+\n+The developer provides their own testing steps as free-form text. These are NOT AI-generated. Wait for their input before proceeding.\n+\n+## Step 7: Present Full Preview\n+\n+Show the developer the complete PR preview:\n+\n+```\n+## PR Preview\n+\n+**Title:** {generated title}\n+\n+---\n+\n+## Summary\n+\n+{generated description}\n+\n+## Test Plan\n+\n+{developer-provided testing steps}\n+```\n+\n+If check results exist from Step 4, also show:\n+\n+```\n+<details>\n+<summary>Pre-submission Checks</summary>\n+\n+{check results — pass/fail with names}\n+\n+</details>\n+```\n+\n+Then ask:\n+\n+> **Review the preview above.** Want to edit anything (title, description, testing steps), or good to go?\n+\n+Let the developer make edits. Iterate until they're satisfied.\n+\n+## Step 8: Push Branch\n+\n+Check whether the branch has an upstream and is up to date:\n+\n+```bash\n+git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null\n+```\n+\n+**If no upstream exists**, or if the local branch is ahead of the remote:\n+\n+```bash\n+git status -sb\n+```\n+\n+Ask:\n+\n+> **Branch needs to be pushed to the remote. Push now?**\n+\n+If the developer confirms, push:\n+\n+```bash\n+git push -u origin $(git branch --show-current)\n+```\n+\n+**If the push fails**, report the error and stop. Do NOT offer `--force`.\n+\n+**If the branch is already up to date with the remote**, skip this step silently.\n+\n+## Step 9: Create Draft PR\n+\n+Assemble the PR body:\n+\n+```\n+## Summary\n+\n+{description}\n+\n+## Test Plan\n+\n+{testing steps}\n+```\n+\n+If check results exist from Step 4, append:\n+\n+```\n+<details>\n+<summary>Pre-submission Checks</summary>\n+\n+{check results — pass/fail with names}\n+\n+</details>\n+```\n+\n+If no check results (no plugin files found or none matched), omit the `<details>` section entirely.\n+\n+Create the draft PR:\n+\n+```bash\n+gh pr create --draft --base $TARGET --title \"{title}\" --body \"{body}\"\n+```\n+\n+**If this succeeds**, display:\n+\n+> **Draft PR created:** {URL}\n+\n+**If this fails**, report the error and stop.\n+\n+## Important Notes\n+\n+- This command is conversational. There are multiple points where you pause and wait for developer input (Step 2, Step 6, Step 7, Step 8). Don't try to rush through without their responses.\n+- Check failures are informational, not blocking. The developer can still create the PR even if checks fail.\n+- Always create the PR as a draft. No option to toggle this.\n+- If the developer wants to bail at any point, respect that. Don't push them to continue.\ndiff --git a/src/templates/.claude/commands/review-pr.md b/src/templates/.claude/commands/review-pr.md\nindex d8c281e..e2dd797 100644\n--- a/src/templates/.claude/commands/review-pr.md\n+++ b/src/templates/.claude/commands/review-pr.md\n@@ -62,23 +62,9 @@ Before analysis, categorize the changed files:\n - `*.min.js`, `*.min.css`, `dist/*`, `build/*` → \"generated/bundled files\"\n - Binary files (images, fonts, etc.) → \"binary file added/modified/deleted\"\n \n-**Categorize by area** (for this monorepo):\n+**Categorize by area:**\n \n-- `packages/shared/*` → shared package\n-- `packages/db/*` → database package\n-- `packages/core/*` → core business logic\n-- `packages/telemetry/*` → telemetry package\n-- `services/api/*` → API service\n-- `tests/*` → test files\n-- `.claude/*` → Claude Code configuration\n-- Other paths → categorize by top-level directory\n-\n-**Identify file types present** (for tribal knowledge checks):\n-\n-- React/frontend: `*.tsx`, `*.jsx`, `*.css`, `*.scss`, `*.styled.ts`\n-- Backend: `*.ts` in `packages/*` or `services/*` (excluding test files)\n-- Test files: `*.test.ts`, `*.spec.ts`, `*.integration.test.ts`\n-- Config: `*.json`, `*.yaml`, `*.yml`, `*.env*`\n+Group changed files by top-level directory. If the repo uses workspaces (check for a `workspaces` field in `package.json` or the presence of `pnpm-workspace.yaml`), use the workspace definitions to inform grouping. Otherwise, fall back to top-level directory names.\n \n ## Step 5: Analyze Changes\n \n@@ -147,26 +133,43 @@ Scan for and report:\n \n ## Step 7: Tribal Knowledge Checks\n \n-Run checks based on which file types are present in the diff. Only report checks that are relevant to the files actually changed:\n+Tribal knowledge checks are loaded dynamically from `.ai/review-checks/`. Each check file is a markdown file with YAML frontmatter.\n+\n+**Expected check file format:**\n+\n+```markdown\n+---\n+name: Example Check Group\n+applies_when: Changed files include .ts files in src/\n+---\n+\n+- [ ] **Check name**: Description of what to look for.\n+- [ ] **Another check**: Description of what to look for.\n+```\n \n-### If React/CSS/style files are present:\n+**Discovery and evaluation flow:**\n \n-- [ ] **Hard-coded colors**: Are there hex values, rgb(), or named colors that should use theme variables?\n-- [ ] **Missing data-cy attributes**: Do new interactive elements (buttons, inputs, links) have `data-cy` for testing?\n-- [ ] **Accessibility gaps**: Missing alt text on images? Click handlers on non-interactive elements (div, span)? Missing aria labels on icon-only buttons?\n+1. List available check files:\n+\n+```bash\n+ls .ai/review-checks/*.md 2>/dev/null\n+```\n+\n+2. **If the directory does not exist or contains no `.md` files**, skip the entire Tribal Knowledge Checks section — produce no heading and no placeholder text.\n+\n+3. **If files are found**, read each one:\n+\n+```bash\n+cat .ai/review-checks/*.md\n+```\n \n-### If backend files are present:\n+4. For each file, parse the YAML frontmatter to extract `name` and `applies_when`. If a file is missing frontmatter or has invalid/unparseable YAML, skip it and note in the output: \"Skipped `{filename}`: missing or invalid frontmatter.\"\n \n-- [ ] **Console.log usage**: Is `console.log` used instead of the structured logger from `@avol/telemetry`?\n-- [ ] **Boundary violations**: Is a handler reaching into a repository directly instead of going through a service?\n-- [ ] **Raw SQL**: Are there string-concatenated queries instead of parameterized Kysely queries?\n-- [ ] **Error handling**: Are errors being caught and swallowed without logging or re-throwing?\n+5. Evaluate each file's `applies_when` value against the list of changed files from the diff (gathered in Step 3). Use your judgment — `applies_when` is natural language, not a glob pattern. Match generously but sensibly.\n \n-### Always check:\n+6. For each check group where `applies_when` matches, include its checks in the output under a heading using the `name` from frontmatter. Evaluate each check against the actual diff.\n \n-- [ ] **New environment variables**: Are there new `process.env.*` references that DevOps needs to know about?\n-- [ ] **Test coverage**: Do new code paths have corresponding test files? Are there new functions/methods without tests?\n-- [ ] **Type safety**: Are there `any` types, type assertions (`as`), or `@ts-ignore` comments that bypass TypeScript?\n+7. If files exist but **none** of their `applies_when` criteria match the diff, skip the Tribal Knowledge Checks section entirely.\n \n ## Step 8: Testing Recommendations\n \n@@ -241,9 +244,9 @@ Each block contains:\n \n ## Tribal Knowledge Checks\n \n-[Based on file types present, report findings. Only include checks relevant to the file types in this PR.]\n+[Only include this section if matching check files were found in .ai/review-checks/. If no check files exist or none matched the diff, omit this entire section including the heading.]\n \n-### [Check category]\n+### [name from check file frontmatter]\n \n - [x] [Check passed or N/A]\n - [ ] **[Check failed]**: [Specific finding with file:line references]\ndiff --git a/src/templates/.claude/commands/weekly-summary.md b/src/templates/.claude/commands/weekly-summary.md\nnew file mode 100644\nindex 0000000..3a8e2cf\n--- /dev/null\n+++ b/src/templates/.claude/commands/weekly-summary.md\n@@ -0,0 +1,148 @@\n+# Weekly Summary Command\n+\n+You are a codebase narrator. Your job is to synthesize the last 7 days of merged pull requests into a thematic briefing that updates a developer's mental model of how the codebase shifted — not a changelog, not a list of PRs, but a narrative of what changed and why it matters.\n+\n+## Step 1: Determine Date Range\n+\n+Calculate the date 7 days ago from today. This is your cutoff — only PRs merged on or after this date are included.\n+\n+```bash\n+# Get today's date and the date 7 days ago (macOS and Linux compatible)\n+date -u +%Y-%m-%d 2>/dev/null || date -u -I\n+```\n+\n+Store these as `start_date` (7 days ago) and `end_date` (today) for use in the output header.\n+\n+## Step 2: Fetch Merged PRs\n+\n+```bash\n+gh pr list --state merged --json number,title,body,mergedAt,additions,deletions,changedFiles,commits --limit 100\n+```\n+\n+Filter the results to only PRs where `mergedAt` falls within the last 7 days. The `--limit 100` returns recent merges, but `gh` doesn't natively filter by date — you must verify each PR's `mergedAt` timestamp against your cutoff.\n+\n+## Step 3: Handle Zero PRs\n+\n+If no PRs were merged in the last 7 days, create the output directory and write a short report:\n+\n+```bash\n+mkdir -p docs/reports\n+```\n+\n+Write to `docs/reports/weekly-summary-YYYY-MM-DD.md` (using today's date):\n+\n+```markdown\n+# Weekly Summary: YYYY-MM-DD\n+\n+**Period**: {start_date} to {end_date}\n+**PRs merged**: 0\n+\n+---\n+\n+No pull requests were merged during this period. Nothing to report.\n+```\n+\n+**Stop here.** Do not proceed to subsequent steps.\n+\n+## Step 4: Fetch Per-PR File Stats\n+\n+First, get the repo's owner and name dynamically:\n+\n+```bash\n+gh repo view --json nameWithOwner --jq .nameWithOwner\n+```\n+\n+Then, for each merged PR in your filtered set, fetch file-level change stats:\n+\n+```bash\n+gh api repos/{owner}/{repo}/pulls/{number}/files?per_page=100\n+```\n+\n+This returns per-file additions, deletions, filename, and status (added/modified/removed/renamed). This is your diffstat equivalent — it tells you _what areas_ of the codebase each PR touched, which is often more informative than the PR description itself.\n+\n+⚠️ For PRs that touch more than 100 files, append `--paginate` to get the full list.\n+\n+## Step 5: Synthesize\n+\n+With all PR metadata and file-level stats assembled, produce the output. The output has two sections: **Mental Model Shift** and **Risk Callouts**.\n+\n+### Mental Model Shift\n+\n+This is the core of the report. Group changes **by theme, not by PR**.\n+\n+**Do NOT summarize each PR individually.** Do NOT produce a bulleted list of PR titles. Do NOT write \"PR #42 did X, PR #43 did Y.\" A developer reading this should understand the _narrative_ of what shifted — as if a teammate is giving them a hallway briefing after a week away.\n+\n+Good themes look like:\n+\n+- \"Auth migrated from session cookies to JWT\"\n+- \"New caching layer introduced across API endpoints\"\n+- \"Test infrastructure overhauled — Jest replaced with Vitest\"\n+- \"Data model restructured — users and accounts split into separate tables\"\n+- \"Build pipeline rewritten around Turborepo\"\n+\n+Bad output looks like:\n+\n+- \"PR #42: Updated auth module\"\n+- \"PR #43: Added caching to user endpoint\"\n+- \"PR #44: Fixed test runner\"\n+\n+If multiple PRs contribute to the same theme, **weave them together** into a single narrative section. The PR numbers are supporting evidence, not the organizing principle.\n+\n+**Use diffstats to inform emphasis.** High-churn areas (lots of files changed, lots of additions/deletions) deserve more attention in the narrative. A PR that touches 50 files across 3 packages is more architecturally significant than one that fixes a typo.\n+\n+**Use file paths to reveal what changed.** Even when PR descriptions are sparse or absent, the file paths in the diffstat tell you which areas of the codebase were affected. A cluster of changes in `src/auth/` tells a story even without a word of description.\n+\n+**Be honest about uncertainty.** If PR descriptions are vague and the diffstats are ambiguous, say so. \"Several PRs touched the payments module but descriptions were sparse — worth checking with the team on what shifted\" is better than fabricating a narrative.\n+\n+**Never hallucinate changes.** Only report what the data shows. If a file wasn't in any diffstat, don't claim it was changed.\n+\n+### Risk Callouts\n+\n+Flag anything that could bite a developer who wasn't watching. These are things worth knowing about _before_ they surprise you in a code review, a deploy, or a debugging session:\n+\n+- **Breaking changes** — public API modifications, interface changes, removed exports\n+- **New patterns replacing old ones** — if a PR introduces a new way of doing X, anyone still doing it the old way will diverge\n+- **High-churn areas** — parts of the codebase with heavy modification across multiple PRs (potential merge conflict zones)\n+- **New dependencies** — added packages, especially heavy or opinionated ones\n+- **Removed capabilities** — deleted features, deprecated endpoints, dropped support\n+- **Things that will surprise you** — behavioral changes, default value shifts, renamed concepts\n+\n+If there are genuinely no risks, say \"No significant risks identified\" — don't manufacture concern.\n+\n+## Step 6: Write Output\n+\n+```bash\n+mkdir -p docs/reports\n+```\n+\n+Write the synthesized report to `docs/reports/weekly-summary-YYYY-MM-DD.md` (using today's date). If a file already exists at that path, overwrite it — re-running on the same day is a regeneration, not a duplicate.\n+\n+## Output Format\n+\n+```markdown\n+# Weekly Summary: YYYY-MM-DD\n+\n+**Period**: {start_date} to {end_date}\n+**PRs merged**: {count}\n+\n+---\n+\n+## Mental Model Shift\n+\n+[Thematic narrative sections. Each section has a descriptive heading and a prose explanation of how the codebase shifted in that area. PR numbers referenced inline as supporting evidence, not as the organizing structure.]\n+\n+---\n+\n+## Risk Callouts\n+\n+[Bulleted risk items with enough context to understand the concern, or \"No significant risks identified.\"]\n+```\n+\n+## Behavioral Guidance\n+\n+- **Think like a teammate giving a hallway briefing**, not a release notes generator. The reader was away for a week and wants to rebuild their mental model in 5 minutes.\n+- **Group by theme, not by PR.** This is the most important instruction. If you catch yourself writing \"PR #N:\" at the start of a bullet, you've already failed. Restructure around themes.\n+- **Diffstats are your best friend.** PR titles can be misleading. PR descriptions can be empty. But file paths and change volumes don't lie. Lean on them.\n+- **Be concise.** This is a briefing, not a novel. Each thematic section should be a tight paragraph or two — enough to update the reader's mental model, not enough to replace reading the actual PRs.\n+- **Be honest.** Uncertainty is fine. \"Not sure what this was about\" beats a confident hallucination every time.\n+- **Prioritize signal.** Not every PR deserves mention. A typo fix or a lockfile update doesn't need a thematic narrative. Focus on changes that actually shift how a developer thinks about the codebase.\ndiff --git a/src/templates/.claude/settings.local.json b/src/templates/.claude/settings.local.json\nindex c758c5a..b3f227b 100644\n--- a/src/templates/.claude/settings.local.json\n+++ b/src/templates/.claude/settings.local.json\n@@ -31,7 +31,9 @@\n             \"Bash(chmod *)\",\n             \"Bash(cat *)\",\n             \"Bash(head *)\",\n-            \"Bash(tail *)\"\n+            \"Bash(tail *)\",\n+            \"Bash(pnpm build:*)\",\n+            \"mcp__voicemode__converse\"\n         ],\n         \"deny\": [\n             \"Bash(rm -rf /*)\",\ndiff --git a/tsup.config.ts b/tsup.config.ts\nindex 244c629..7868178 100644\n--- a/tsup.config.ts\n+++ b/tsup.config.ts\n@@ -1,7 +1,7 @@\n import { defineConfig } from \"tsup\";\n \n export default defineConfig({\n-    entry: [\"src/cli.ts\", \"src/sync.ts\", \"src/manifest.ts\"],\n+    entry: [\"src/cli.ts\", \"src/sync.ts\", \"src/manifest.ts\", \"src/install-review-plugins.ts\"],\n     format: [\"esm\"],\n     target: \"node22\",\n     outDir: \"dist\",\n"
test_patch: ''
fail_to_pass:
- node --experimental-vm-modules node_modules/jest/bin/jest.js --config '{"preset":"ts-jest/presets/default-esm","testEnvironment":"node","extensionsToTreatAsEsm":[".ts"],"moduleNameMapper":{"^(\\.{1,2}/.*)\\.js$":"$1"},"transform":{"^.+\\.ts$":["ts-jest",{"useESM":true}]}}' --runTestsByPath src/cli.test.ts
pass_to_pass:
- node --experimental-vm-modules node_modules/jest/bin/jest.js --config '{"preset":"ts-jest/presets/default-esm","testEnvironment":"node","extensionsToTreatAsEsm":[".ts"],"moduleNameMapper":{"^(\\.{1,2}/.*)\\.js$":"$1"},"transform":{"^.+\\.ts$":["ts-jest",{"useESM":true}]}}' --runTestsByPath src/sync.test.ts
install_config:
  install: npm install
  node: '20'
  test_cmd: npm test
meta:
  added_lines: '1744'
  difficulty: hard
  files_changed: '32'
  pr_title: DEV-3134 Add prep-pr, weekly-summary commands; pluggable review checks
  removed_lines: '63'
  source: gh-archive-pr
  test_generation: agentic
prompt: |-
  apogee-stealth/the-agency (#1): DEV-3134 Add prep-pr, weekly-summary commands; pluggable review checks

  ## Summary

  Adds two new slash commands and a pluggable review check system:

  - **`/prep-pr`** — Walks through pre-submission checks, generates a PR title/description, collects testing steps, and creates a draft PR via `gh`. Supports review plugin checks when installed.
  - **`/weekly-summary`** — Synthesizes the last 7 days of merged PRs into a thematic narrative briefing (not a changelog), written to `docs/reports/`.
  - **Pluggable review checks** — `/review-pr` and `/prep-pr` now discover check files dynamically from `.ai/review-checks/` instead of using hardcoded tribal knowledge checks. Ships with 4 pre-packaged plugins (general, node-backend, react-frontend, unit-test).
  - **`install-review-plugins` CLI command** — Interactive multi-select to install review plugins into a consumer project.
  - **`/build` now auto-proceeds** between phases instead of pausing for user confirmation at each gate.
  - **Agent refinements** — Dev and test-hardener agents now reference `.ai/UnitTestGeneration.md`, exclude `.tsx` and barrel export testing, and test-hardener adds to existing test files instead of creating separate ones.

  ## Test Plan

  Install these new commands (and the review plugins) in your target repo and take them for a test drive.
quality_score: 0.78
quality_passed: true
docker_passed: false
workspace_path: null
status: ready
